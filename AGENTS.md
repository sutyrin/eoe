# TODO (общий список)

Если пользователь просит "выполнить следующую задачу", агент начинает с первого пункта ниже и идет по порядку.

- [ ] реализовать механику бесконечной генерации уровня (препятствия, дорога) в Steppy Scroller.
- [ ] добавить условия проигрыша (столкновения с препятствиями) и систему набора очков (Score).
- [ ] заменить SVG-заглушки на качественные пиксель-арт ассеты.
- [ ] настроить GitHub Actions для автоматического запуска smoke-тестов после деплоя.

# Недавно сделанное (архив)

- [x] стабилизировать E2E тесты для Devvit: решено использовать head mode (HEADLESS=0) для обхода анти-бот защиты Reddit.
- [x] создать MVP для отладки MCP-подхода на Steppy Scroller:
  - сделать общий модуль `/packages/game-api` с типами, ядром `window.__GAME__`, адаптером `window.__MCP__`, dev-логгером,
  - подключить в `games/steppy-scroller`, зарегистрировать начальное состояние,
  - реализовать 2–3 действия и синхронизировать UI с `state.actions`,
  - написать минимум тестов (unit/api/e2e) и проверить deploy на Vercel.
- [x] заинцептить в новом стеке заглушку для steppy scroller и полностью катнуть его на vercel. В том числе, после катки сходить на итоговый url в vercel и прокликать smoke test через mcp.
- [x] глубоко проанализировать ответы на вопросы и продолжить анализировать и доплонять agents. 
- [x] спроектировать конкретную структуру разработки в соответствии с требованиями к mcp game api и пирамиде тестов.
- [x] зафиксировать текущий стек (js/ts, vite, phaser, сборщик, выкладка на vercel и т.п.) и расписать инструкции по работе для агента.

## Анализ и уточнения (канонизация принципов)

Ниже фиксируем минимально-каноничный старт, который можно расширять по мере разработки. Цель — чтобы любой агент
мог быстро запустить игру, проверить состояние через game api и понять, где что лежит.

### Каноничный минимальный game api (первый приближенный вариант)

Базовый API живет в общем слое репозитория и доступен каждой игре из подкаталога. Реализация — в браузере
через `window.__GAME__`, без отдельного HTTP-сервера. MCP — лишь интерфейс к нему (`window.__MCP__`).
Это минимальный набор, который покрывает текущие требования
к тестам и итерациям разработки.

- `window.__GAME__.getState()` — текущее состояние игры, всегда включает:
  - `version` (строка) — версия схемы состояния.
  - `status` (строка) — `ready` | `running` | `ended`.
  - `tick` (число) — счетчик изменений состояния.
  - `player` (объект) — минимум позиция/идентификатор игрока.
  - `actions` (массив) — доступные действия, минимум `id`, `label`, `enabled`.
  - `meta` (объект) — игра/уровень/seed, если применимо.
- `window.__GAME__.getActions()` — список доступных действий (может совпадать с `state.actions`).
- `window.__GAME__.act(actionId, payload?)` — выполнить действие, возвращает обновленный state.

Правила:
- Все поля в `state` должны быть сериализуемыми и стабильными между вызовами.
- Любой клик в UI соответствует `actionId` из state.
- Нельзя допускать расхождения state между UI и API (при любом действии).

Это минимальный «канон». Он может расширяться, но новые поля и методы должны быть обратно совместимы
с уже выпущенными играми. Для старых игр допустимо оставить их на старой версии схемы.

### Где живет game api

API реализуется как общий модуль в корне репозитория (общий слой), но каждый игровой подкаталог должен иметь
тонкую обертку, чтобы запуск из подкаталога работал без ручных правок путей.
Рекомендуемый интерфейс для агентов и тестов — `window.__MCP__` (адаптер к `window.__GAME__`).

### Тестовая пирамида (практически)

- 60–80% — юнит-тесты JS/TS (логика, утилиты, генераторы).
- 15–30% — game api тесты (сценарии хода/состояния).
- 5–10% — e2e UI (видимость UI/игрока/кнопок/интеракция + сверка через API).

Минимальный smoke-набор:
- `GET /mcp/state` возвращает валидный объект (обязательные поля выше).
- Выполнить 1–2 действия и убедиться, что изменился `tick` и состояние игрока/доступных действий.

### Шаблон игры и совместимость

Стратегия совместимости: старые игры «фризятся» и не обязаны подтягивать новые общие пакеты.
Чтобы новые игры могли использовать новые версии компонентов, допускаем два режима:

- режим A: общий пакет в `/packages/*` и игры фиксируют версию (monorepo + версионирование),
- режим B: «вендоринг» — копирование версии компонентов в конкретную игру.

По умолчанию выбираем режим A, а режим B — для фиксации старых игр. Обратное портирование в старые игры не
обязательно.

### Экран, перф, логирование

- Ориентация: портрет, мобильный фуллскрин, нижняя зона для контроля.
- Производительность: FPS 30+ и минимальный бандл; избегать тяжелых ассетов.
- Логи: единый формат console-логов, готовность к последующему дублированию на эндпоинт.

### Правила для агентов

- Любое новое решение по API/структуре фиксировать в этом файле.
- При добавлении фичи — сначала сделать минимальный сценарий через game api, потом UI.
- Для изменений UI обязательно проверять консистентность state через API.
- После каждого коммита обязательно делать `git push`.

## Devvit (минимальные инструкции)

- Каждая игра — отдельное Devvit‑приложение в подкаталоге `devvit/<game-name>/`.
- Создание нового Devvit‑приложения (`devvit new`) требует действия пользователя в браузере; это нормально, нужно просить пользователя сделать это.
- Деплой: `npm run build` → `devvit upload --bump patch` → `devvit install r/softwart <app>@<version>`.
- Тестовый сабреддит: `/r/softwart`.
- Playwright (браузерный тест, требуется логин):
  1) `cd devvit/steppy-scroller/steppy-scroller`
  2) Один раз: `npm run pw:login` → вручную залогиниться в Reddit → Enter (сохранит `playwright/.auth/reddit.json`).
  3) Запуск: `DEVVIT_POST_URL="<post url>" HEADLESS=0 npm run pw:devvit:e2e`.
  Скрипт кликает по центру поста, находит splash iframe, жмет Start и скринит результат в `test-results/devvit/`.
  Для ручной отладки: `DEVTOOLS=1 npm run pw:devvit:e2e` (окно браузера + devtools).

## Devvit (итоги и практика)

В Devvit WebView нельзя встраивать внешние игры через iframe из‑за CSP. Поэтому для реального деплоя игру
нужно собирать прямо в `devvit/<game>/` и отдавать как WebView ассеты из `dist/client`.
Phaser переносится напрямую: `game.html` + `game.ts` + `game.css`, без внешнего хостинга.

Состояние хранится на стороне Devvit backend в Redis через `@devvit/web/server` и доступно по `postId + userId`.
С сервера читаем state только при старте (`/api/init`), а дальше работаем локально; клики меняют state мгновенно,
а сохранение идет в фоне (`/api/save`). Это устраняет гонки и прыжки: ответ сервера не должен перетирать локальное
состояние во время игры.

Создание нового Devvit приложения требует участия пользователя в браузере при `devvit new`. После этого
рекомендуемый путь: собрать ассеты, `devvit upload`, установить в `/r/softwart`, создать пост из меню.
Проверка в браузере вручную: открыть пост → кликнуть по карточке поста (открывает splash) → нажать Start
→ открывается игра (WebView).

## Структура разработки (черновик)

Цель: единая монорепа с общими модулями и шаблоном игры. Структура минимальна, но поддерживает MCP Game API и
пирамиду тестов.

### Корень репозитория

```
/packages/
  game-api/          # общий MCP Game API: адаптеры, типы, тестовые утилиты
  game-core/         # общий слой логики (state, reducers, random, helpers)
  ui-shared/         # общие UI-компоненты и темы (минимально, при необходимости)
/games/
  steppy-scroller/   # игра (см. шаблон ниже)
  phaser3-test/
  kaboom-test/
/docs/               # общая документация (гайд для агентов, шаблоны)
```

Правило: любая игра должна работать из своего подкаталога без ручной подстройки путей.

### Шаблон структуры для каждой игры

```
/games/<game-name>/
  index.html
  src/
    main.ts          # точка входа
    game/            # логика/сцены/состояние
    mcp/             # glue-код для MCP Game API (эндпоинты, адаптеры)
    ui/              # UI-слой и отображение состояния
  assets/            # спрайты/шрифты/звуки
  tests/
    unit/            # юнит-тесты
    api/             # сценарии через MCP Game API
    e2e/             # минимальные UI проверки
  README.md          # краткий гайд по запуску и тестам
```

### Размещение MCP Game API

- Общая реализация: `/packages/game-api`.
- В каждой игре: тонкий адаптер в `src/mcp/`, который регистрирует `state`, `actions`, `act`.
- API-тесты опираются на общий раннер из `game-api` и сценарии из `tests/api`.

### Тесты и отладка MCP (через браузер)

- Интеграция через `window.__MCP__`.
- Playwright использует `page.evaluate()` для доступа к API.
- Допускаются логи `console.log("[mcp]", ...)` для отладки, но это не основной интерфейс.

### Локальная разработка и Mock API

При запуске `npm run dev` (Vite) используется локальный **Mock API** (middleware в `vite.config.ts`), который
эмулирует бэкенд `/api/state`. Он хранит состояние в памяти (in-memory), поэтому:
- Состояние сохраняется между перезагрузками страницы (пока работает dev-сервер).
- Это позволяет прогонять полноценные сценарии (включая сохранение прогресса) локально.
- `src/main.ts` имеет фоллбек: если API недоступен или возвращает ошибку, игра работает в оффлайн-режиме (сбрасывается при перезагрузке).

### E2E smoke (Playwright)

Локально (поднимается dev‑сервер с in-memory Mock API для `/api/state`):
```
cd games/steppy-scroller
npm run test:e2e
```

Vercel smoke (без локального сервера):
```
cd games/steppy-scroller
E2E_BASE_URL="https://steppy-scroller.vercel.app" npm run test:e2e
```

Отладка:
```
PWDEBUG=1 npm run test:e2e
```

Ожидания тестов: `window.__MCP__` доступен, есть `#controls .action`, и есть `#game-root canvas`.

### Каноничные URL (обновлять при деплое)

- Steppy Scroller (Vercel, prod): `https://steppy-scroller.vercel.app` (проверено 2025-12-21)

### Как избегать ошибок (чек‑лист)

- Всегда фиксируй финальные URL деплоя в этом файле (см. секцию выше) и обновляй дату.
- Перед Vercel e2e проверь, что URL отвечает `200` и это нужный билд (минимум через `curl -I`).
- В Playwright используй новый контекст (по умолчанию так и есть) — состояние должно стартовать с «чистого» browserId.
- Не выводи токены/секреты из `.env` в stdout команд.
- Для изменений UI сверяй `state.actions` с кнопками, и прогоняй минимум один MCP‑сценарий.

### Где искать логи Codex CLI

- `~/.codex/sessions/YYYY/MM/DD/*.jsonl` — покомандные логи диалогов и tool‑calls.
- `~/.codex/history.jsonl` — общая история.
- `~/.codex/log/codex-tui.log` — TUI‑лог.

### Token usage (Codex CLI)

- Док: `docs/codex-token-usage.md`
- Скрипт: `scripts/codex_token_usage.py --date YYYY-MM-DD` (см. `--mode request`)

### Тестовая пирамида на уровне структуры

- `tests/unit` — максимальное покрытие утилит и логики.
- `tests/api` — сценарии ходов, проверка state и действий (основной функциональный слой).
- `tests/e2e` — минимальные UI проверки: рендер, клики, сверка state через API.

### Совместимость и развитие

- Новые общие модули развиваются в `/packages/*`.
- Старые игры могут фиксировать версии (или вендорить) и не обязаны обновляться.

## Текущий стек (зафиксировано)

- Язык: TypeScript для новых игр, JavaScript допустим для прототипов.
- Рендер/игровой фреймворк: Phaser 3 (держимся Phaser 3; переход на Phaser 4 — только по отдельному решению/задаче).
- Сборка: Vite.
- Тесты: Vitest (unit + api), Playwright (e2e UI).
- Пакетный менеджер: npm (по умолчанию).
- Деплой: Vercel, размещение каждой игры по пути `/games/<game-name>/`.


## Инструменты и скрипты

### Быстрое создание скриншота (Steppy Scroller)

Для создания скриншота игры в вертикальном мобильном формате (как настроено в `playwright.config.ts`) используется специальный скрипт. Он автоматически запускает локальный dev-сервер (если нужно) и сохраняет результат.

Команда:
```bash
cd games/steppy-scroller
npm run screenshot
```

Результат сохраняется в `games/steppy-scroller/screenshots/` с именем `game-screenshot-<timestamp>.png`.
Этот метод полезен для визуальной сверки верстки агентами или генерации отчетов.

# Общие сведения

В этом репозитории разрабатывается серия маленьких онлайн-игр по общим технологиям.

В качестве основного фреймворка используем Phaser 3.

Каждая игра помещается в отдельном подкаталоге, в index.html, так, чтобы при заливке 
всего репозитория на vercel по соотв. пути можно было открыть каждую игру и играть в неё полноценно.

# Особенности разработки

Разработка ведётся силами ИИ-агентов, которые документируют свою деятельность в
этом файле, а также других, при необходимости (можно в подкаталогах). Агенты
могут быть разных марок, но пользуются общими правилами.

В максимальной степени используется короткий цикл разработки, где агент
запускает код и сам исследует поведение игры. Для этого он обращается к
запущенной игре по специальному game api, где считывает текущее состояние игры
а также может выполнять любые игровые действия, допустимые для игрока. Также
есть интерфейс для игрока (обычный, браузерный, визуальный), который агент
видит через mcp. В нем тоже можно производить те же самые игровые действия.
Основное тестиование (можно считать его тестом среднего уровня) происходит
через game api, и некоторое количество тестов (назовем их e2e) делаются через
UI, чтобы удостоверить корректность работы интерфейсного слоя для игрока. 

Стиль gameplay подобран так, чтобы агенту было удобно его разрабатывать в этой
парадигме. Т.е., от игрока (и от агента) не требуется быстро считвыать
состояние и быстро реагировать. Т.е., игра пошаговая. И в то же время,
idle-анимации и фоновые эффекты украшают картинку в то время, как пользователь
смотрит на нее и думает, что сделать дальше. Также допускается появление
подсказок, если ползьователь слишком долго залип и ничего не делает (они
помогают ему продвинуться по игре, по туториалу и т.п.).

Разрабатывая серию этих игр, мы накапливаем подходы, модули, библиотеки, куски
кода, переиспользуя их между играми и нарабатывая шаблоны и принципы. Эти общие
материалы хранятся в этом репозитории и тщательно отдокументрованы. 

В основном проектируем под полноэкранный опыт на мобильном устройстве, игра
большим пальцем одной или двух рук. Т.е., контролы внизу экрана.

# Игры

## Steppy Scroller

В основе - вертикальное изображение по типу лабиринта, вид сверху, уютный
пиксельный стиль, квадратная сетка. Главный герой находится внизу экрана,
пользователь видит его следующие возможные шаги, и нажимает большим пальцем на
один из возможных выборов. Область выбора - достаточно большая и очевидная,
чтобы было легко нажать. Пусть это будет коридор-лабиринт из 4-6 столбцов,
чтобы при каждом шаге пользовтеля он сдвигался на 1 ряд вниз (т.е., игрок на 1
ряд вверх). Что-то вроде тетриса, где движение вверх неизбежно, а по горзонтали
можно и нужно вдумчиво выбирать. Простой красивый стиль, природа, мультяшность.
Нижняя часть экрана посвящена движению и управлению, верхняя содержит будущее,
цель игры + неоходимые пояснения и подсказки. Внимание движется от низа к
верху, точнее, прицеливаясь в верхнее, мы влияем на нижнее, в цикле переключая
внимание.

## kaboom test

Пробник для фреймворка kaboom, завершён

## phaser3 test

Пробник для phaser3, завершён.
