# TODO (общий список)

Если пользователь просит "выполнить следующую задачу", агент начинает с первого пункта ниже и идет по порядку.

- [x] глубоко проанализировать ответы на вопросы и продолжить анализировать и доплонять agents. 
- [x] спроектировать конкретную структуру разработки в соответствии с требованиями к mcp game api и пирамиде тестов.
- [x] зафиксировать текущий стек (js/ts, vite, phaser, сборщик, выкладка на vercel и т.п.) и расписать инструкции по работе для агента.
- [ ] заинцептить в новом стеке заглушку для steppy scroller и полностью катнуть его на vercel. В том числе, после катки сходить на итоговый url в vercel и прокликать smoke test через mcp.
- [ ] создать MVP для отладки MCP-подхода на Steppy Scroller:
  - сделать общий модуль `/packages/game-api` с типами, адаптером `window.__MCP__`, dev-логгером,
  - подключить в `games/steppy-scroller`, зарегистрировать начальное состояние,
  - реализовать 2–3 действия и синхронизировать UI с `state.actions`,
  - написать минимум тестов (unit/api/e2e) и проверить deploy на Vercel.

# Недавно сделанное (архив)

## Вопросы к принципам и текущему файлу

1) Какой формат mcp game api считается "каноничным" для этого репозитория: эндпоинты, схема состояния, обязательные поля?

не знаю, нужно с чего-то начать и потом улучшать по мере конкретной необходимости при разработке 

2) Где должен жить game api: в каждой игре отдельно, или общий слой/библиотека в корне?

давай общий. но все должно работать из подкаталогов. не знаю.

3) Какие минимальные smoke-тесты считаются обязательными через game api?

начальное состояние считывается и корректное, 1-2 действия можно произвести и они отражаются в состоянии

4) Какие e2e через UI нужны обязательно, и какие можно отложить?

UI отображатеся, игрок виден, следующие действия видны. при клике на одно из действий состояние изменяется и отображается. можно сочетать прокликивание через UI и параллельную проверку состояния через game api. Всё должно быть консистентно. 

5) Как выглядит "пирамида тестов" для этих игр в терминах пропорций и инструментов?

много юнит-тестов для js, основные тесты игровой логики на game api, немного e2e. 

6) Нужен ли общий шаблон структуры каталогов для каждой игры (assets/src/tests и т.п.)?

да, такой шаблон мы должны разрабатывать и улучшать от игры к игре.

7) Нужны ли единые требования по размеру экрана/ориентации и адаптиву?

Да, экран вертикальный, мобильный.

8) Есть ли требования к логированию, телеметрии, трекингу ошибок?

да, единое логгирование, пока что только на js console. с прицелом, что потом его продублируем на удалённый ендпоинт.

9) Какая целевая производительность на мобильных (fps/размер бандла)?

fps 30+, бандл минимально взозможный. 

10) Планируется ли монорепа с общими пакетами или простая структура без сборки?

монорепа с общими модулями и компонентами. но я не знаю, что делать с обратной совместимостью. когда новые игры убегут вперед, убежит и развитие компонентов. может, их копировать из игры в игру? чтобы сохранить собираемость всех старых игр. обратное портирование - это ненужная активность, лучше фризить и двигаться дальше.

## Анализ и уточнения (канонизация принципов)

Ниже фиксируем минимально-каноничный старт, который можно расширять по мере разработки. Цель — чтобы любой агент
мог быстро запустить игру, проверить состояние через game api и понять, где что лежит.

### Каноничный минимальный game api (первый приближенный вариант)

Базовый API живет в общем слое репозитория и доступен каждой игре из подкаталога. Реализация — в браузере
через `window.__MCP__`, без отдельного HTTP-сервера. Это минимальный набор, который покрывает текущие требования
к тестам и итерациям разработки.

- `window.__MCP__.getState()` — текущее состояние игры, всегда включает:
  - `version` (строка) — версия схемы состояния.
  - `status` (строка) — `ready` | `running` | `ended`.
  - `tick` (число) — счетчик изменений состояния.
  - `player` (объект) — минимум позиция/идентификатор игрока.
  - `actions` (массив) — доступные действия, минимум `id`, `label`, `enabled`.
  - `meta` (объект) — игра/уровень/seed, если применимо.
- `window.__MCP__.getActions()` — список доступных действий (может совпадать с `state.actions`).
- `window.__MCP__.act(actionId, payload?)` — выполнить действие, возвращает обновленный state.

Правила:
- Все поля в `state` должны быть сериализуемыми и стабильными между вызовами.
- Любой клик в UI соответствует `actionId` из state.
- Нельзя допускать расхождения state между UI и API (при любом действии).

Это минимальный «канон». Он может расширяться, но новые поля и методы должны быть обратно совместимы
с уже выпущенными играми. Для старых игр допустимо оставить их на старой версии схемы.

### Где живет game api

API реализуется как общий модуль в корне репозитория (общий слой), но каждый игровой подкаталог должен иметь
тонкую обертку, чтобы запуск из подкаталога работал без ручных правок путей.
Рекомендуемый интерфейс для агентов и тестов — `window.__MCP__`.

### Тестовая пирамида (практически)

- 60–80% — юнит-тесты JS/TS (логика, утилиты, генераторы).
- 15–30% — game api тесты (сценарии хода/состояния).
- 5–10% — e2e UI (видимость UI/игрока/кнопок/интеракция + сверка через API).

Минимальный smoke-набор:
- `GET /mcp/state` возвращает валидный объект (обязательные поля выше).
- Выполнить 1–2 действия и убедиться, что изменился `tick` и состояние игрока/доступных действий.

### Шаблон игры и совместимость

Стратегия совместимости: старые игры «фризятся» и не обязаны подтягивать новые общие пакеты.
Чтобы новые игры могли использовать новые версии компонентов, допускаем два режима:

- режим A: общий пакет в `/packages/*` и игры фиксируют версию (monorepo + версионирование),
- режим B: «вендоринг» — копирование версии компонентов в конкретную игру.

По умолчанию выбираем режим A, а режим B — для фиксации старых игр. Обратное портирование в старые игры не
обязательно.

### Экран, перф, логирование

- Ориентация: портрет, мобильный фуллскрин, нижняя зона для контроля.
- Производительность: FPS 30+ и минимальный бандл; избегать тяжелых ассетов.
- Логи: единый формат console-логов, готовность к последующему дублированию на эндпоинт.

### Правила для агентов

- Любое новое решение по API/структуре фиксировать в этом файле.
- При добавлении фичи — сначала сделать минимальный сценарий через game api, потом UI.
- Для изменений UI обязательно проверять консистентность state через API.

## Структура разработки (черновик)

Цель: единая монорепа с общими модулями и шаблоном игры. Структура минимальна, но поддерживает MCP Game API и
пирамиду тестов.

### Корень репозитория

```
/packages/
  game-api/          # общий MCP Game API: адаптеры, типы, тестовые утилиты
  game-core/         # общий слой логики (state, reducers, random, helpers)
  ui-shared/         # общие UI-компоненты и темы (минимально, при необходимости)
/games/
  steppy-scroller/   # игра (см. шаблон ниже)
  phaser3-test/
  kaboom-test/
/docs/               # общая документация (гайд для агентов, шаблоны)
```

Правило: любая игра должна работать из своего подкаталога без ручной подстройки путей.

### Шаблон структуры для каждой игры

```
/games/<game-name>/
  index.html
  src/
    main.ts          # точка входа
    game/            # логика/сцены/состояние
    mcp/             # glue-код для MCP Game API (эндпоинты, адаптеры)
    ui/              # UI-слой и отображение состояния
  assets/            # спрайты/шрифты/звуки
  tests/
    unit/            # юнит-тесты
    api/             # сценарии через MCP Game API
    e2e/             # минимальные UI проверки
  README.md          # краткий гайд по запуску и тестам
```

### Размещение MCP Game API

- Общая реализация: `/packages/game-api`.
- В каждой игре: тонкий адаптер в `src/mcp/`, который регистрирует `state`, `actions`, `act`.
- API-тесты опираются на общий раннер из `game-api` и сценарии из `tests/api`.

### Тесты и отладка MCP (через браузер)

- Интеграция через `window.__MCP__`.
- Playwright использует `page.evaluate()` для доступа к API.
- Допускаются логи `console.log("[mcp]", ...)` для отладки, но это не основной интерфейс.

### Тестовая пирамида на уровне структуры

- `tests/unit` — максимальное покрытие утилит и логики.
- `tests/api` — сценарии ходов, проверка state и действий (основной функциональный слой).
- `tests/e2e` — минимальные UI проверки: рендер, клики, сверка state через API.

### Совместимость и развитие

- Новые общие модули развиваются в `/packages/*`.
- Старые игры могут фиксировать версии (или вендорить) и не обязаны обновляться.

## Текущий стек (зафиксировано)

- Язык: TypeScript для новых игр, JavaScript допустим для прототипов.
- Рендер/игровой фреймворк: Phaser 3.
- Сборка: Vite.
- Тесты: Vitest (unit + api), Playwright (e2e UI).
- Пакетный менеджер: npm (по умолчанию).
- Деплой: Vercel, размещение каждой игры по пути `/games/<game-name>/`.

## Инструкции для агента (рабочий процесс)

1) Создать/обновить игру в `/games/<game-name>/` по шаблону структуры.
2) Сначала реализовать логику и MCP Game API, затем UI-слой.
3) Написать:
   - `tests/unit` для логики,
   - `tests/api` для сценариев через MCP,
   - `tests/e2e` для минимальных UI-проверок.
4) Проверки:
   - `npm run dev` — локальная разработка,
   - `npm run test:unit`, `npm run test:api`, `npm run test:e2e`,
   - `npm run build` — сборка перед деплоем.
5) Деплой на Vercel с корня репозитория; проверять, что игра доступна по
   `/<game-name>/` и тестировать smoke-сценарии через MCP.


# Общие сведения

В этом репозитории разрабатывается серия маленьких онлайн-игр по общим технологиям.

В качестве основного фреймворка используем phaser js.

Каждая игра помещается в отдельном подкаталоге, в index.html, так, чтобы при заливке 
всего репозитория на vercel по соотв. пути можно было открыть каждую игру и играть в неё полноценно.

# Особенности разработки

Разработка ведётся силами ИИ-агентов, которые документируют свою деятельность в этом файле, а также других, при необходимости (можно в подкаталогах). Агенты могут быть разных марок, но пользуются общими правилами.

В максимальной степени используется короткий цикл разработки, где агент запускает код и сам исследует поведение
игры. Для этого он обращается к запущенной игре по специальному game api, где считывает текущее состояние игры 
а также может выполнять любые игровые действия, допустимые для игрока. Также есть интерфейс для игрока (обычный, 
браузерный, визуальный), который агент видит через mcp. В нем тоже можно производить те же самые игровые действия.
Основное тестиование (можно считать его тестом среднего уровня) происходит через game api, и некоторое количество
тестов (назовем их e2e) делаются через UI, чтобы удостоверить корректность работы интерфейсного слоя для игрока. 

Стиль gameplay подобран так, чтобы агенту было удобно его разрабатывать в этой парадигме. Т.е., от игрока (и от агента) не требуется быстро считвыать состояние и быстро реагировать. Т.е., игра пошаговая. И в то же время, idle-анимации
и фоновые эффекты украшают картинку в то время, как пользователь смотрит на нее и думает, что сделать дальше. Также допускается появление подсказок, если ползьователь слишком долго залип и ничего не делает (они помогают ему продвинуться 
по игре, по туториалу и т.п.).

Разрабатывая серию этих игр, мы накапливаем подходы, модули, библиотеки, куски кода, переиспользуя их между играми и нарабатывая шаблоны и принципы. Эти общие материалы хранятся в этом репозитории и тщательно отдокументрованы. 

В основном проектируем под полноэкранный опыт на мобильном устройстве, игра большим пальцем одной или двух рук. Т.е., контролы внизу экрана.

# Игры

## Steppy Scroller

В основе - вертикальное изображение по типу лабиринта, вид сверху, уютный пиксельный стиль, квадратная сетка. Главный герой находится внизу экрана, пользователь видит его следующие возможные шаги, и нажимает большим пальцем на один из возможных выборов. Область выбора - достаточно большая и очевидная, чтобы было легко нажать. Пусть это будет коридор-лабиринт из 4-6 столбцов, чтобы при каждом шаге пользовтеля он сдвигался на 1 ряд вниз (т.е., игрок на 1 ряд вверх). Что-то вроде тетриса, где движение вверх неизбежно, а по горзонтали можно и нужно вдумчиво выбирать. Простой красивый стиль, природа, мультяшность. Нижняя часть экрана посвящена движению и управлению, верхняя содержит будущее, цель игры + неоходимые пояснения и подсказки. Внимание движется от низа к верху, точнее, прицеливаясь в верхнее, мы влияем на нижнее, в цикле переключая внимание.

## kaboom test

Пробник для фреймворка kaboom, завершён

## phaser3 test

Пробник для phaser3, завершён.
