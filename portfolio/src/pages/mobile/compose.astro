---
import MobileLayout from '../../layouts/MobileLayout.astro';
import CompositionCanvas from '../../components/CompositionCanvas.astro';
import AtomPickerSheet from '../../components/AtomPickerSheet.astro';
import NodeDetailSheet from '../../components/NodeDetailSheet.astro';
import CompositionToolbar from '../../components/CompositionToolbar.astro';
import PreviewControls from '../../components/PreviewControls.astro';
---

<MobileLayout title="Compose" showBack={true} backHref="/mobile/compositions">
  <CompositionToolbar />
  <PreviewControls />

  <div style="margin: -16px; margin-top: -16px;">
    <CompositionCanvas />
  </div>

  <!-- FAB button to add atoms -->
  <button id="add-atom-fab" class="compose-fab" title="Add atom">+</button>

  <!-- Atom picker bottom sheet -->
  <AtomPickerSheet />

  <!-- Node detail bottom sheet -->
  <NodeDetailSheet />
</MobileLayout>

<script>
  import {
    saveComposition,
    getComposition,
    addAtomToComposition,
    buildNodes,
    buildEdges,
    loadAtomsMap,
    updateNodePositions,
    removeAtomFromComposition,
    deleteComposition,
  } from '../../scripts/composition-store';
  import { createRoute, deleteRoute } from '../../scripts/routing-engine';
  import {
    createEmptyComposition,
    MAX_ATOMS_PER_COMPOSITION,
  } from '../../scripts/composition-types';
  import { getAtom } from '../../scripts/db';
  import type { Node, Edge } from 'reactflow';
  import { UndoRedoManager } from '../../scripts/undo-redo';
  import { scheduleAutosave, cancelAutosave } from '../../scripts/composition-autosave';
  import {
    createSnapshotFromComposition,
    saveSnapshot,
    formatSnapshotSize,
    getSnapshotSize,
    getSnapshot,
    buildNodesFromSnapshot,
    buildAtomsMapFromSnapshot,
  } from '../../scripts/composition-snapshot';
  import type { CompositionSnapshot } from '../../scripts/composition-types';
  import { PreviewEngine } from '../../scripts/preview-engine';
  import type { PreviewState } from '../../scripts/composition-types';

  let currentComposition = createEmptyComposition('Untitled Composition');
  let currentSnapshot: CompositionSnapshot | null = null;  // If viewing a snapshot
  let atomsMap = new Map();
  const history = new UndoRedoManager();
  let previewEngine: PreviewEngine | null = null;  // Phase 6: preview engine

  // Helper: commit a change to history and schedule autosave
  function commitChange(composition: typeof currentComposition) {
    currentComposition = composition;
    history.push(composition);
    scheduleAutosave(composition);
    updateHistoryButtons();
  }

  // Update toolbar undo/redo button states
  function updateHistoryButtons() {
    window.dispatchEvent(new CustomEvent('eoe:history-changed', {
      detail: history.stats(),
    }));
  }

  // Load composition from URL parameter or create new
  async function initComposition() {
    atomsMap = await loadAtomsMap();

    const params = new URLSearchParams(window.location.search);
    const compId = params.get('id');
    const snapshotId = params.get('snapshot');

    // Check if loading a snapshot
    if (snapshotId) {
      const snapshot = await getSnapshot(snapshotId);
      if (snapshot) {
        currentSnapshot = snapshot;
        // Build synthetic atoms map from snapshot inline code
        atomsMap = buildAtomsMapFromSnapshot(snapshot);

        // Convert snapshot to composition format for canvas rendering
        currentComposition = {
          id: snapshot.compositionId,
          name: snapshot.name,
          createdAt: snapshot.createdAt,
          updatedAt: snapshot.createdAt,
          atoms: snapshot.atoms.map(a => ({
            nodeId: a.nodeId,
            atomSlug: a.atomSlug,
            position: a.position,
            paramOverrides: a.paramOverrides,
          })),
          routes: snapshot.routes,
          viewport: snapshot.viewport,
          synced: snapshot.synced,
          playbackMode: snapshot.playbackMode,
        };

        // Snapshots are read-only - no history
        history.clear();
        updateHistoryButtons();

        // Set toolbar composition name
        window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
          detail: { name: currentComposition.name }
        }));

        await refreshCanvas();
        return;
      }
    }

    // Check if loading a draft composition
    if (compId) {
      const loaded = await getComposition(compId);
      if (loaded) {
        currentComposition = loaded;

        // Initialize history with loaded composition
        history.clear();
        history.push(currentComposition);
        updateHistoryButtons();

        // Set toolbar composition name
        window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
          detail: { name: currentComposition.name }
        }));

        await refreshCanvas();
        return;
      }
    }

    // New composition - initialize history with empty state
    history.clear();
    history.push(currentComposition);
    updateHistoryButtons();

    // Set toolbar composition name
    window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
      detail: { name: currentComposition.name }
    }));

    updateFabState();
  }

  // Refresh React Flow canvas from composition data
  async function refreshCanvas() {
    const nodes = await buildNodes(currentComposition, atomsMap);
    const edges = buildEdges(currentComposition);

    // Update React canvas via global setters (from CompositionCanvas)
    if ((window as any).__canvasSetNodes) {
      (window as any).__canvasSetNodes(nodes);
    }
    if ((window as any).__canvasSetEdges) {
      (window as any).__canvasSetEdges(edges);
    }
    updateFabState();
  }

  // FAB button: open atom picker
  const fab = document.getElementById('add-atom-fab')!;
  fab.addEventListener('click', () => {
    const atLimit = currentComposition.atoms.length >= MAX_ATOMS_PER_COMPOSITION;
    window.dispatchEvent(new CustomEvent('eoe:open-atom-picker', {
      detail: { atLimit }
    }));
  });

  // Handle atom selection from picker
  window.addEventListener('eoe:add-atom', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const { atomSlug } = customEvent.detail;
    const atomMeta = atomsMap.get(atomSlug);
    if (!atomMeta) {
      console.warn('[compose] Atom not found in cache:', atomSlug);
      return;
    }

    const updated = addAtomToComposition(currentComposition, atomSlug, atomMeta);
    if (!updated) {
      // Limit reached
      showToast('Maximum 5 atoms reached');
      return;
    }

    commitChange(updated);
    await refreshCanvas();

    showToast(`Added ${atomMeta.title}`);
  });

  // Handle atom removal from node detail sheet
  window.addEventListener('eoe:remove-atom', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const { nodeId } = customEvent.detail;

    const updated = removeAtomFromComposition(currentComposition, nodeId);
    commitChange(updated);
    await refreshCanvas();

    showToast('Atom removed');
  });

  // Handle route creation
  window.addEventListener('eoe:create-route', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const { sourceNodeId, sourceParam, targetNodeId, targetParam } = customEvent.detail;

    const updated = createRoute(
      currentComposition,
      sourceNodeId,
      sourceParam,
      targetNodeId,
      targetParam
    );
    commitChange(updated);
    await refreshCanvas();

    showToast('Route created');
  });

  // Handle route deletion
  window.addEventListener('eoe:delete-route', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const { routeId } = customEvent.detail;

    const updated = deleteRoute(currentComposition, routeId);
    commitChange(updated);
    await refreshCanvas();

    showToast('Route deleted');
  });

  // Undo
  window.addEventListener('eoe:undo', async () => {
    const prev = history.undo();
    if (prev) {
      currentComposition = prev;
      scheduleAutosave(prev);
      await refreshCanvas();
      updateHistoryButtons();
      showToast('Undone');
    }
  });

  // Redo
  window.addEventListener('eoe:redo', async () => {
    const next = history.redo();
    if (next) {
      currentComposition = next;
      scheduleAutosave(next);
      await refreshCanvas();
      updateHistoryButtons();
      showToast('Redone');
    }
  });

  // Rename composition
  window.addEventListener('eoe:rename-composition', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const updated = {
      ...currentComposition,
      name: customEvent.detail.name,
      updatedAt: new Date().toISOString(),
    };
    commitChange(updated);

    window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
      detail: { name: customEvent.detail.name }
    }));

    showToast('Composition renamed');
  });

  // Delete composition
  window.addEventListener('eoe:delete-composition', async () => {
    await deleteComposition(currentComposition.id);
    cancelAutosave();
    window.location.href = '/mobile/compositions';
  });

  // Save snapshot
  window.addEventListener('eoe:save-snapshot', async () => {
    try {
      // Create snapshot with inline atom code
      const snapshot = await createSnapshotFromComposition(currentComposition, atomsMap);
      await saveSnapshot(snapshot);

      const size = formatSnapshotSize(getSnapshotSize(snapshot));
      showToast(`Snapshot saved (${size})`);
    } catch (err) {
      console.error('[compose] Failed to save snapshot:', err);
      showToast('Failed to save snapshot');
    }
  });

  // Update FAB state (disable at limit)
  function updateFabState() {
    const atLimit = currentComposition.atoms.length >= MAX_ATOMS_PER_COMPOSITION;
    fab.classList.toggle('disabled', atLimit);
  }

  // Toast notification helper
  function showToast(message: string) {
    const toast = document.getElementById('canvas-toast');
    if (toast) {
      toast.textContent = message;
      toast.classList.add('visible');
      setTimeout(() => toast.classList.remove('visible'), 2000);
    }
  }

  // Listen for node position changes from React Flow
  // The canvas dispatches this when nodes are dragged
  window.addEventListener('eoe:nodes-changed', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const nodes = customEvent.detail?.nodes;
    if (nodes && currentComposition) {
      const updated = updateNodePositions(currentComposition, nodes);
      // Commit on drag stop (debounced autosave handles the actual save)
      commitChange(updated);
    }
  });

  // Phase 6: Preview engine integration

  // Play preview
  window.addEventListener('preview-play', async () => {
    try {
      if (!previewEngine) {
        previewEngine = new PreviewEngine(currentComposition);
        await previewEngine.init();

        // Listen for state changes
        previewEngine.addEventListener('state-change', ((e: CustomEvent<PreviewState>) => {
          window.dispatchEvent(new CustomEvent('preview-state-changed', { detail: e.detail }));
        }) as EventListener);

        // Listen for route active events (for canvas highlighting)
        previewEngine.addEventListener('route-active', ((e: CustomEvent<string[]>) => {
          window.dispatchEvent(new CustomEvent('preview-routes-active', { detail: e.detail }));
        }) as EventListener);

        // Listen for sequential-next-ready
        previewEngine.addEventListener('sequential-next-ready', ((e: CustomEvent<boolean>) => {
          window.dispatchEvent(new CustomEvent('preview-next-ready', { detail: e.detail }));
        }) as EventListener);

        // Listen for glitch warnings
        previewEngine.addEventListener('glitch-warning', ((e: CustomEvent) => {
          window.dispatchEvent(new CustomEvent('preview-glitch', { detail: e.detail }));
        }) as EventListener);
      }

      await previewEngine.play();
    } catch (err) {
      console.error('[preview] Failed to start:', err);
      showToast('Preview failed to start');
    }
  });

  // Pause preview
  window.addEventListener('preview-pause', () => {
    if (previewEngine) {
      previewEngine.pause();
    }
  });

  // Stop preview
  window.addEventListener('preview-stop', async () => {
    if (previewEngine) {
      await previewEngine.stop();
      previewEngine.cleanup();
      previewEngine = null;
    }
  });

  // Next atom in sequential mode
  window.addEventListener('preview-next', async () => {
    if (previewEngine) {
      await previewEngine.startNext();
    }
  });

  // Playback mode change
  window.addEventListener('preview-mode-change', async ((e: CustomEvent<'simultaneous' | 'sequential'>) => {
    const updated = {
      ...currentComposition,
      playbackMode: e.detail,
      updatedAt: new Date().toISOString(),
    };
    commitChange(updated);

    // If preview is running, restart with new mode
    if (previewEngine && previewEngine.getState() !== 'stopped') {
      await previewEngine.stop();
      previewEngine.cleanup();
      previewEngine = null;

      window.dispatchEvent(new CustomEvent('preview-play'));
    }
  }) as EventListener);

  // Restart after glitch
  window.addEventListener('preview-restart', async () => {
    if (previewEngine) {
      await previewEngine.stop();
      previewEngine.cleanup();
      previewEngine = null;
    }
    window.dispatchEvent(new CustomEvent('preview-play'));
  });

  // Initialize
  initComposition();
</script>

<style>
  :global(.mobile-main) {
    padding: 0 !important;
    max-width: none !important;
  }
</style>
