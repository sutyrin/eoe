---
import MobileLayout from '../../layouts/MobileLayout.astro';
import CompositionCanvas from '../../components/CompositionCanvas.astro';
import AtomPickerSheet from '../../components/AtomPickerSheet.astro';
import NodeDetailSheet from '../../components/NodeDetailSheet.astro';
import CompositionToolbar from '../../components/CompositionToolbar.astro';
---

<MobileLayout title="Compose" showBack={true} backHref="/mobile/compositions">
  <CompositionToolbar />

  <div style="margin: -16px; margin-top: -16px;">
    <CompositionCanvas />
  </div>

  <!-- FAB button to add atoms -->
  <button id="add-atom-fab" class="compose-fab" title="Add atom">+</button>

  <!-- Atom picker bottom sheet -->
  <AtomPickerSheet />

  <!-- Node detail bottom sheet -->
  <NodeDetailSheet />
</MobileLayout>

<script>
  import {
    saveComposition,
    getComposition,
    addAtomToComposition,
    buildNodes,
    buildEdges,
    loadAtomsMap,
    updateNodePositions,
    removeAtomFromComposition,
    deleteComposition,
  } from '../../scripts/composition-store';
  import { createRoute, deleteRoute } from '../../scripts/routing-engine';
  import {
    createEmptyComposition,
    MAX_ATOMS_PER_COMPOSITION,
  } from '../../scripts/composition-types';
  import { getAtom } from '../../scripts/db';
  import type { Node, Edge } from 'reactflow';
  import { UndoRedoManager } from '../../scripts/undo-redo';
  import { scheduleAutosave, cancelAutosave } from '../../scripts/composition-autosave';
  import {
    createSnapshotFromComposition,
    saveSnapshot,
    formatSnapshotSize,
    getSnapshotSize,
  } from '../../scripts/composition-snapshot';

  let currentComposition = createEmptyComposition('Untitled Composition');
  let atomsMap = new Map();
  const history = new UndoRedoManager();

  // Helper: commit a change to history and schedule autosave
  function commitChange(composition: typeof currentComposition) {
    currentComposition = composition;
    history.push(composition);
    scheduleAutosave(composition);
    updateHistoryButtons();
  }

  // Update toolbar undo/redo button states
  function updateHistoryButtons() {
    window.dispatchEvent(new CustomEvent('eoe:history-changed', {
      detail: history.stats(),
    }));
  }

  // Load composition from URL parameter or create new
  async function initComposition() {
    atomsMap = await loadAtomsMap();

    const params = new URLSearchParams(window.location.search);
    const compId = params.get('id');

    if (compId) {
      const loaded = await getComposition(compId);
      if (loaded) {
        currentComposition = loaded;

        // Initialize history with loaded composition
        history.clear();
        history.push(currentComposition);
        updateHistoryButtons();

        // Set toolbar composition name
        window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
          detail: { name: currentComposition.name }
        }));

        await refreshCanvas();
        return;
      }
    }

    // New composition - initialize history with empty state
    history.clear();
    history.push(currentComposition);
    updateHistoryButtons();

    // Set toolbar composition name
    window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
      detail: { name: currentComposition.name }
    }));

    updateFabState();
  }

  // Refresh React Flow canvas from composition data
  async function refreshCanvas() {
    const nodes = await buildNodes(currentComposition, atomsMap);
    const edges = buildEdges(currentComposition);

    // Update React canvas via global setters (from CompositionCanvas)
    if ((window as any).__canvasSetNodes) {
      (window as any).__canvasSetNodes(nodes);
    }
    if ((window as any).__canvasSetEdges) {
      (window as any).__canvasSetEdges(edges);
    }
    updateFabState();
  }

  // FAB button: open atom picker
  const fab = document.getElementById('add-atom-fab')!;
  fab.addEventListener('click', () => {
    const atLimit = currentComposition.atoms.length >= MAX_ATOMS_PER_COMPOSITION;
    window.dispatchEvent(new CustomEvent('eoe:open-atom-picker', {
      detail: { atLimit }
    }));
  });

  // Handle atom selection from picker
  window.addEventListener('eoe:add-atom', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const { atomSlug } = customEvent.detail;
    const atomMeta = atomsMap.get(atomSlug);
    if (!atomMeta) {
      console.warn('[compose] Atom not found in cache:', atomSlug);
      return;
    }

    const updated = addAtomToComposition(currentComposition, atomSlug, atomMeta);
    if (!updated) {
      // Limit reached
      showToast('Maximum 5 atoms reached');
      return;
    }

    commitChange(updated);
    await refreshCanvas();

    showToast(`Added ${atomMeta.title}`);
  });

  // Handle atom removal from node detail sheet
  window.addEventListener('eoe:remove-atom', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const { nodeId } = customEvent.detail;

    const updated = removeAtomFromComposition(currentComposition, nodeId);
    commitChange(updated);
    await refreshCanvas();

    showToast('Atom removed');
  });

  // Handle route creation
  window.addEventListener('eoe:create-route', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const { sourceNodeId, sourceParam, targetNodeId, targetParam } = customEvent.detail;

    const updated = createRoute(
      currentComposition,
      sourceNodeId,
      sourceParam,
      targetNodeId,
      targetParam
    );
    commitChange(updated);
    await refreshCanvas();

    showToast('Route created');
  });

  // Handle route deletion
  window.addEventListener('eoe:delete-route', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const { routeId } = customEvent.detail;

    const updated = deleteRoute(currentComposition, routeId);
    commitChange(updated);
    await refreshCanvas();

    showToast('Route deleted');
  });

  // Undo
  window.addEventListener('eoe:undo', async () => {
    const prev = history.undo();
    if (prev) {
      currentComposition = prev;
      scheduleAutosave(prev);
      await refreshCanvas();
      updateHistoryButtons();
      showToast('Undone');
    }
  });

  // Redo
  window.addEventListener('eoe:redo', async () => {
    const next = history.redo();
    if (next) {
      currentComposition = next;
      scheduleAutosave(next);
      await refreshCanvas();
      updateHistoryButtons();
      showToast('Redone');
    }
  });

  // Rename composition
  window.addEventListener('eoe:rename-composition', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const updated = {
      ...currentComposition,
      name: customEvent.detail.name,
      updatedAt: new Date().toISOString(),
    };
    commitChange(updated);

    window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
      detail: { name: customEvent.detail.name }
    }));

    showToast('Composition renamed');
  });

  // Delete composition
  window.addEventListener('eoe:delete-composition', async () => {
    await deleteComposition(currentComposition.id);
    cancelAutosave();
    window.location.href = '/mobile/compositions';
  });

  // Save snapshot
  window.addEventListener('eoe:save-snapshot', async () => {
    try {
      // Create snapshot with inline atom code
      const snapshot = await createSnapshotFromComposition(currentComposition, atomsMap);
      await saveSnapshot(snapshot);

      const size = formatSnapshotSize(getSnapshotSize(snapshot));
      showToast(`Snapshot saved (${size})`);
    } catch (err) {
      console.error('[compose] Failed to save snapshot:', err);
      showToast('Failed to save snapshot');
    }
  });

  // Update FAB state (disable at limit)
  function updateFabState() {
    const atLimit = currentComposition.atoms.length >= MAX_ATOMS_PER_COMPOSITION;
    fab.classList.toggle('disabled', atLimit);
  }

  // Toast notification helper
  function showToast(message: string) {
    const toast = document.getElementById('canvas-toast');
    if (toast) {
      toast.textContent = message;
      toast.classList.add('visible');
      setTimeout(() => toast.classList.remove('visible'), 2000);
    }
  }

  // Listen for node position changes from React Flow
  // The canvas dispatches this when nodes are dragged
  window.addEventListener('eoe:nodes-changed', async (e: Event) => {
    const customEvent = e as CustomEvent;
    const nodes = customEvent.detail?.nodes;
    if (nodes && currentComposition) {
      const updated = updateNodePositions(currentComposition, nodes);
      // Commit on drag stop (debounced autosave handles the actual save)
      commitChange(updated);
    }
  });

  // Initialize
  initComposition();
</script>

<style>
  :global(.mobile-main) {
    padding: 0 !important;
    max-width: none !important;
  }
</style>
