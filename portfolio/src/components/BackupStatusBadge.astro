---
/**
 * BackupStatusBadge: Persistent badge in app header showing backup status.
 *
 * States:
 * - synced (green checkmark): All items backed up
 * - pending (orange dot with count): N items not yet backed up
 * - backing-up (blue spinner): Backup in progress
 * - error (red exclamation): Last backup failed
 *
 * Tapping the badge navigates to /mobile/backup management page.
 */
---

<a href="/mobile/backup" id="backup-badge" class="backup-badge" title="Backup status">
  <span id="badge-icon" class="badge-icon badge-icon-synced">
    <!-- Synced: checkmark -->
    <svg id="icon-synced" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" style="display: none;">
      <path d="M11.5 3.5l-6 6L2.5 6.5" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <!-- Pending: count -->
    <span id="icon-pending" class="badge-count" style="display: none;">0</span>
    <!-- Backing up: spinner -->
    <span id="icon-backing-up" class="badge-spinner" style="display: none;"></span>
    <!-- Error: exclamation -->
    <span id="icon-error" style="display: none;">!</span>
  </span>
</a>

<script>
  type BadgeState = 'synced' | 'pending' | 'backing-up' | 'error';

  const badge = document.getElementById('backup-badge')!;
  const iconSynced = document.getElementById('icon-synced')!;
  const iconPending = document.getElementById('icon-pending')!;
  const iconBackingUp = document.getElementById('icon-backing-up')!;
  const iconError = document.getElementById('icon-error')!;
  const badgeIcon = document.getElementById('badge-icon')!;

  function updateBadge(state: BadgeState, count = 0) {
    // Hide all icons
    iconSynced.style.display = 'none';
    iconPending.style.display = 'none';
    iconBackingUp.style.display = 'none';
    iconError.style.display = 'none';

    // Remove all state classes
    badgeIcon.className = 'badge-icon';

    switch (state) {
      case 'synced':
        iconSynced.style.display = 'block';
        badgeIcon.classList.add('badge-icon-synced');
        break;
      case 'pending':
        iconPending.style.display = 'inline';
        iconPending.textContent = String(count);
        badgeIcon.classList.add('badge-icon-pending');
        break;
      case 'backing-up':
        iconBackingUp.style.display = 'inline-block';
        badgeIcon.classList.add('badge-icon-active');
        break;
      case 'error':
        iconError.style.display = 'inline';
        badgeIcon.classList.add('badge-icon-error');
        break;
    }
  }

  // Listen for backup status events
  window.addEventListener('eoe:backup-status', ((e: CustomEvent) => {
    const { status } = e.detail;
    switch (status) {
      case 'idle':
        // Check for pending items
        checkPendingCount();
        break;
      case 'backing-up':
        updateBadge('backing-up');
        break;
      case 'success':
        updateBadge('synced');
        // Recheck after a moment (items may have changed)
        setTimeout(checkPendingCount, 5000);
        break;
      case 'error':
        updateBadge('error');
        break;
    }
  }) as EventListener);

  // Check pending count on load and periodically
  async function checkPendingCount() {
    try {
      const { getUnsyncedCount } = await import('../scripts/composition-store');
      const compCount = await getUnsyncedCount();

      let snapCount = 0;
      try {
        const { getUnsyncedSnapshots } = await import('../scripts/db');
        const unsynced = await getUnsyncedSnapshots();
        snapCount = unsynced.length;
      } catch { /* ok */ }

      const total = compCount + snapCount;
      if (total > 0) {
        updateBadge('pending', total);
      } else {
        updateBadge('synced');
      }
    } catch {
      // Default to synced if we can't check
      updateBadge('synced');
    }
  }

  // Initial check
  setTimeout(checkPendingCount, 1500);
  // Periodic check every 60 seconds
  setInterval(checkPendingCount, 60000);
</script>

<style>
  .backup-badge {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    text-decoration: none;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.15s;
  }

  .backup-badge:active {
    background: rgba(255, 255, 255, 0.1);
  }

  .badge-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    font-size: 10px;
    font-weight: 700;
    line-height: 1;
  }

  .badge-icon-synced {
    color: #6bff6b;
  }

  .badge-icon-pending {
    background: #ffb56b;
    color: #0a0a0a;
  }

  .badge-icon-active {
    color: #6bb5ff;
  }

  .badge-icon-error {
    background: #ff6b6b;
    color: #fff;
  }

  .badge-count {
    font-size: 10px;
    font-weight: 700;
  }

  .badge-spinner {
    width: 12px;
    height: 12px;
    border: 2px solid rgba(107, 181, 255, 0.3);
    border-top-color: #6bb5ff;
    border-radius: 50%;
    animation: badge-spin 0.8s linear infinite;
  }

  @keyframes badge-spin {
    to { transform: rotate(360deg); }
  }
</style>
