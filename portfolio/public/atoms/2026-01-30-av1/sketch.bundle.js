const _PI = Math.PI;
const VERSION = "2.2.0";
const P2D = "p2d";
const P2DHDR = "p2d-hdr";
const WEBGL = "webgl";
const WEBGL2 = "webgl2";
const WEBGPU = "webgpu";
const ARROW = "default";
const SIMPLE = "simple";
const FULL = "full";
const CROSS = "crosshair";
const HAND = "pointer";
const MOVE = "move";
const TEXT = "text";
const WAIT = "wait";
const HALF_PI = _PI / 2;
const PI = _PI;
const QUARTER_PI = _PI / 4;
const TAU = _PI * 2;
const TWO_PI = _PI * 2;
const DEG_TO_RAD = _PI / 180;
const RAD_TO_DEG = 180 / _PI;
const CORNER = "corner";
const CORNERS = "corners";
const RADIUS = "radius";
const RIGHT = "right";
const LEFT = "left";
const CENTER = "center";
const TOP = "top";
const BOTTOM = "bottom";
const BASELINE = "alphabetic";
const POINTS = 0;
const LINES = 1;
const LINE_STRIP = 3;
const LINE_LOOP = 2;
const TRIANGLES = 4;
const TRIANGLE_FAN = 6;
const TRIANGLE_STRIP = 5;
const QUADS = "quads";
const QUAD_STRIP = "quad_strip";
const TESS = "tess";
const EMPTY_PATH = 7;
const PATH = 8;
const CLOSE = "close";
const OPEN = "open";
const CHORD = "chord";
const PIE = "pie";
const PROJECT = "square";
const SQUARE = "butt";
const ROUND = "round";
const BEVEL = "bevel";
const MITER = "miter";
const AUTO = "auto";
const ALT = "Alt";
const BACKSPACE = "Backspace";
const CONTROL = "Control";
const DELETE = "Delete";
const DOWN_ARROW = "ArrowDown";
const ENTER = "Enter";
const ESCAPE = "Escape";
const LEFT_ARROW = "ArrowLeft";
const OPTION = "Alt";
const RETURN = "Enter";
const RIGHT_ARROW = "ArrowRight";
const SHIFT = "Shift";
const TAB = "Tab";
const UP_ARROW = "ArrowUp";
const BLEND = "source-over";
const REMOVE = "destination-out";
const ADD = "lighter";
const DARKEST = "darken";
const LIGHTEST = "lighten";
const DIFFERENCE = "difference";
const SUBTRACT = "subtract";
const EXCLUSION = "exclusion";
const MULTIPLY = "multiply";
const SCREEN = "screen";
const REPLACE = "copy";
const OVERLAY = "overlay";
const HARD_LIGHT = "hard-light";
const SOFT_LIGHT = "soft-light";
const DODGE = "color-dodge";
const BURN = "color-burn";
const THRESHOLD = "threshold";
const GRAY = "gray";
const OPAQUE = "opaque";
const INVERT = "invert";
const POSTERIZE = "posterize";
const DILATE = "dilate";
const ERODE = "erode";
const BLUR = "blur";
const NORMAL = "normal";
const ITALIC = "italic";
const BOLD = "bold";
const BOLDITALIC = "bold italic";
const CHAR = "CHAR";
const WORD = "WORD";
const _DEFAULT_TEXT_FILL = "#000000";
const _DEFAULT_LEADMULT = 1.25;
const _CTX_MIDDLE = "middle";
const LINEAR = "linear";
const QUADRATIC = "quadratic";
const BEZIER = "bezier";
const CURVE = "curve";
const STROKE = "stroke";
const FILL = "fill";
const TEXTURE = "texture";
const IMMEDIATE = "immediate";
const IMAGE = "image";
const LINEAR_MIPMAP = "linear_mipmap";
const NEAREST = "nearest";
const REPEAT = "repeat";
const CLAMP = "clamp";
const MIRROR = "mirror";
const FLAT = "flat";
const SMOOTH = "smooth";
const LANDSCAPE = "landscape";
const PORTRAIT = "portrait";
const _DEFAULT_STROKE = "#000000";
const _DEFAULT_FILL = "#FFFFFF";
const GRID = "grid";
const AXES = "axes";
const LABEL = "label";
const FALLBACK = "fallback";
const CONTAIN = "contain";
const COVER = "cover";
const UNSIGNED_BYTE = "unsigned-byte";
const UNSIGNED_INT = "unsigned-int";
const FLOAT = "float";
const HALF_FLOAT = "half-float";
const INCLUDE = /* @__PURE__ */ Symbol("include");
const EXCLUDE = /* @__PURE__ */ Symbol("exclude");
const JOIN = /* @__PURE__ */ Symbol("join");
var constants = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ADD,
  ALT,
  ARROW,
  AUTO,
  AXES,
  BACKSPACE,
  BASELINE,
  BEVEL,
  BEZIER,
  BLEND,
  BLUR,
  BOLD,
  BOLDITALIC,
  BOTTOM,
  BURN,
  CENTER,
  CHAR,
  CHORD,
  CLAMP,
  CLOSE,
  CONTAIN,
  CONTROL,
  CORNER,
  CORNERS,
  COVER,
  CROSS,
  CURVE,
  DARKEST,
  DEG_TO_RAD,
  DELETE,
  DIFFERENCE,
  DILATE,
  DODGE,
  DOWN_ARROW,
  EMPTY_PATH,
  ENTER,
  ERODE,
  ESCAPE,
  EXCLUDE,
  EXCLUSION,
  FALLBACK,
  FILL,
  FLAT,
  FLOAT,
  FULL,
  GRAY,
  GRID,
  HALF_FLOAT,
  HALF_PI,
  HAND,
  HARD_LIGHT,
  IMAGE,
  IMMEDIATE,
  INCLUDE,
  INVERT,
  ITALIC,
  JOIN,
  LABEL,
  LANDSCAPE,
  LEFT,
  LEFT_ARROW,
  LIGHTEST,
  LINEAR,
  LINEAR_MIPMAP,
  LINES,
  LINE_LOOP,
  LINE_STRIP,
  MIRROR,
  MITER,
  MOVE,
  MULTIPLY,
  NEAREST,
  NORMAL,
  OPAQUE,
  OPEN,
  OPTION,
  OVERLAY,
  P2D,
  P2DHDR,
  PATH,
  PI,
  PIE,
  POINTS,
  PORTRAIT,
  POSTERIZE,
  PROJECT,
  QUADRATIC,
  QUADS,
  QUAD_STRIP,
  QUARTER_PI,
  RADIUS,
  RAD_TO_DEG,
  REMOVE,
  REPEAT,
  REPLACE,
  RETURN,
  RIGHT,
  RIGHT_ARROW,
  ROUND,
  SCREEN,
  SHIFT,
  SIMPLE,
  SMOOTH,
  SOFT_LIGHT,
  SQUARE,
  STROKE,
  SUBTRACT,
  TAB,
  TAU,
  TESS,
  TEXT,
  TEXTURE,
  THRESHOLD,
  TOP,
  TRIANGLES,
  TRIANGLE_FAN,
  TRIANGLE_STRIP,
  TWO_PI,
  UNSIGNED_BYTE,
  UNSIGNED_INT,
  UP_ARROW,
  VERSION,
  WAIT,
  WEBGL,
  WEBGL2,
  WEBGPU,
  WORD,
  _CTX_MIDDLE,
  _DEFAULT_FILL,
  _DEFAULT_LEADMULT,
  _DEFAULT_STROKE,
  _DEFAULT_TEXT_FILL
});
function transform$1(p53, fn2) {
  fn2.applyMatrix = function(...args) {
    let isTypedArray = args[0] instanceof Object.getPrototypeOf(Uint8Array);
    if (Array.isArray(args[0]) || isTypedArray) {
      this._renderer.applyMatrix(...args[0]);
    } else {
      this._renderer.applyMatrix(...args);
    }
    return this;
  };
  fn2.resetMatrix = function() {
    this._renderer.resetMatrix();
    return this;
  };
  fn2.rotate = function(angle, axis) {
    this._renderer.rotate(this._toRadians(angle), axis);
    return this;
  };
  fn2.rotateX = function(angle) {
    this._assert3d("rotateX");
    this._renderer.rotateX(this._toRadians(angle));
    return this;
  };
  fn2.rotateY = function(angle) {
    this._assert3d("rotateY");
    this._renderer.rotateY(this._toRadians(angle));
    return this;
  };
  fn2.rotateZ = function(angle) {
    this._assert3d("rotateZ");
    this._renderer.rotateZ(this._toRadians(angle));
    return this;
  };
  fn2.scale = function(x, y, z) {
    if (x instanceof p53.Vector) {
      const v = x;
      x = v.x;
      y = v.y;
      z = v.z;
    } else if (Array.isArray(x)) {
      const rg = x;
      x = rg[0];
      y = rg[1];
      z = rg[2] || 1;
    }
    if (isNaN(y)) {
      y = z = x;
    } else if (isNaN(z)) {
      z = 1;
    }
    this._renderer.scale(x, y, z);
    return this;
  };
  fn2.shearX = function(angle) {
    const rad = this._toRadians(angle);
    this._renderer.applyMatrix(1, 0, Math.tan(rad), 1, 0, 0);
    return this;
  };
  fn2.shearY = function(angle) {
    const rad = this._toRadians(angle);
    this._renderer.applyMatrix(1, Math.tan(rad), 0, 1, 0, 0);
    return this;
  };
  fn2.translate = function(x, y, z) {
    if (this._renderer.isP3D) {
      this._renderer.translate(x, y, z);
    } else {
      this._renderer.translate(x, y);
    }
    return this;
  };
  fn2.push = function() {
    this._renderer.push();
  };
  fn2.pop = function() {
    this._renderer.pop();
  };
}
if (typeof p5 !== "undefined") {
  transform$1(p5, p5.prototype);
}
function structure(p53, fn2) {
  fn2.noLoop = function() {
    this._loop = false;
  };
  fn2.loop = function() {
    if (!this._loop) {
      this._loop = true;
      if (this._setupDone) {
        this._draw();
      }
    }
  };
  fn2.isLooping = function() {
    return this._loop;
  };
  fn2.redraw = async function(n2) {
    if (this._inUserDraw || !this._setupDone) {
      return;
    }
    let numberOfRedraws = parseInt(n2);
    if (isNaN(numberOfRedraws) || numberOfRedraws < 1) {
      numberOfRedraws = 1;
    }
    const context2 = this._isGlobal ? window : this;
    if (typeof context2.draw === "function") {
      if (typeof context2.setup === "undefined") {
        context2.scale(context2._pixelDensity, context2._pixelDensity);
      }
      for (let idxRedraw = 0; idxRedraw < numberOfRedraws; idxRedraw++) {
        context2.resetMatrix();
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._updateAccsOutput();
        }
        if (this._renderer.isP3D) {
          this._renderer._update();
        }
        this.frameCount = context2.frameCount + 1;
        await this._runLifecycleHook("predraw");
        this._inUserDraw = true;
        try {
          await context2.draw();
        } finally {
          this._inUserDraw = false;
        }
        await this._runLifecycleHook("postdraw");
      }
      await this._renderer.finishDraw?.();
    }
  };
}
if (typeof p5 !== "undefined") {
  structure(p5, p5.prototype);
}
function environment$1(p53, fn2, lifecycles) {
  const standardCursors = [ARROW, CROSS, HAND, MOVE, TEXT, WAIT];
  fn2._frameRate = 0;
  fn2._lastFrameTime = window.performance.now();
  fn2._targetFrameRate = 60;
  const _windowPrint = window.print;
  let windowPrintDisabled = false;
  lifecycles.presetup = function() {
    const events2 = [
      "resize"
    ];
    for (const event of events2) {
      window.addEventListener(event, this[`_on${event}`].bind(this), {
        passive: false,
        signal: this._removeSignal
      });
    }
  };
  fn2.print = function(...args) {
    if (!args.length) {
      if (!windowPrintDisabled) {
        _windowPrint();
        if (window.confirm(
          "You just tried to print the webpage. Do you want to prevent this from running again?"
        )) {
          windowPrintDisabled = true;
        }
      }
    } else {
      console.log(...args);
    }
  };
  fn2.frameCount = 0;
  fn2.deltaTime = 0;
  fn2.focused = document.hasFocus();
  fn2.cursor = function(type2, x, y) {
    let cursor = "auto";
    const canvas2 = this._curElement.elt;
    if (standardCursors.includes(type2)) {
      cursor = type2;
    } else if (typeof type2 === "string") {
      let coords = "";
      if (typeof x === "number") {
        y = typeof y === "number" ? y : 0;
        coords = `${Math.max(x, 0)} ${Math.max(y, 0)}`;
      }
      if (type2.substring(0, 7) === "http://" || type2.substring(0, 8) === "https://") {
        cursor = `url(${type2}) ${coords}, auto`;
      } else if (/\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(type2)) {
        cursor = `url(${type2}) ${coords}, auto`;
      } else {
        cursor = type2;
      }
    }
    canvas2.style.cursor = cursor;
  };
  fn2.frameRate = function(fps) {
    if (typeof fps !== "number" || fps < 0) {
      return this._frameRate;
    } else {
      this._targetFrameRate = fps;
      if (fps === 0) {
        this._frameRate = fps;
      }
      return this;
    }
  };
  fn2.getFrameRate = function() {
    return this.frameRate();
  };
  fn2.setFrameRate = function(fps) {
    return this.frameRate(fps);
  };
  fn2.getTargetFrameRate = function() {
    return this._targetFrameRate;
  };
  fn2.noCursor = function() {
    this._curElement.elt.style.cursor = "none";
  };
  fn2.webglVersion = P2D;
  fn2.displayWidth = screen.width;
  fn2.displayHeight = screen.height;
  fn2.windowWidth = 0;
  fn2.windowHeight = 0;
  fn2._onresize = function(e2) {
    this.windowWidth = getWindowWidth();
    this.windowHeight = getWindowHeight();
    let executeDefault;
    if (typeof this._customActions.windowResized === "function") {
      executeDefault = this._customActions.windowResized(e2);
      if (executeDefault !== void 0 && !executeDefault) {
        e2.preventDefault();
      }
    }
  };
  function getWindowWidth() {
    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth || 0;
  }
  function getWindowHeight() {
    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight || 0;
  }
  fn2._updateWindowSize = function() {
    this.windowWidth = getWindowWidth();
    this.windowHeight = getWindowHeight();
  };
  Object.defineProperty(fn2, "width", {
    get() {
      return this._renderer.width;
    }
  });
  Object.defineProperty(fn2, "height", {
    get() {
      return this._renderer.height;
    }
  });
  fn2.fullscreen = function(val) {
    if (typeof val === "undefined") {
      return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
    } else {
      if (val) {
        launchFullscreen(document.documentElement);
      } else {
        exitFullscreen();
      }
    }
  };
  fn2.pixelDensity = function(val) {
    let returnValue;
    if (typeof val === "number") {
      if (val !== this._renderer._pixelDensity) {
        this._renderer._pixelDensity = val;
      }
      returnValue = this;
      this.resizeCanvas(this.width, this.height, true);
    } else {
      returnValue = this._renderer._pixelDensity;
    }
    return returnValue;
  };
  fn2.displayDensity = () => window.devicePixelRatio;
  function launchFullscreen(element2) {
    const enabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
    if (!enabled) {
      throw new Error("Fullscreen not enabled in this browser.");
    }
    if (element2.requestFullscreen) {
      element2.requestFullscreen();
    } else if (element2.mozRequestFullScreen) {
      element2.mozRequestFullScreen();
    } else if (element2.webkitRequestFullscreen) {
      element2.webkitRequestFullscreen();
    } else if (element2.msRequestFullscreen) {
      element2.msRequestFullscreen();
    }
  }
  function exitFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
  fn2.getURL = () => location.href;
  fn2.getURLPath = () => location.pathname.split("/").filter((v) => v !== "");
  fn2.getURLParams = function() {
    const re = /[?&]([^&=]+)(?:[&=])([^&=]+)/gim;
    let m;
    const v = {};
    while ((m = re.exec(location.search)) != null) {
      if (m.index === re.lastIndex) {
        re.lastIndex++;
      }
      v[m[1]] = m[2];
    }
    return v;
  };
  fn2.worldToScreen = function(worldPosition) {
    if (typeof worldPosition === "number") {
      worldPosition = this.createVector(...arguments);
    }
    const matrix2 = this._renderer.getWorldToScreenMatrix();
    const screenPosition = matrix2.multiplyAndNormalizePoint(worldPosition);
    return screenPosition;
  };
  fn2.screenToWorld = function(screenPosition) {
    if (typeof screenPosition === "number") {
      screenPosition = this.createVector(...arguments);
    }
    const matrix2 = this._renderer.getWorldToScreenMatrix();
    if (screenPosition.dimensions === 2) {
      let z = matrix2.mat4[14] / matrix2.mat4[15];
      screenPosition = this.createVector(screenPosition.x, screenPosition.y, z);
    }
    const matrixInverse = matrix2.invert(matrix2);
    const worldPosition = matrixInverse.multiplyAndNormalizePoint(screenPosition);
    return worldPosition;
  };
}
if (typeof p5 !== "undefined") {
  environment$1(p5, p5.prototype);
}
function multiplyMatrices(A, B) {
  let m = A.length;
  if (!Array.isArray(A[0])) {
    A = [A];
  }
  if (!Array.isArray(B[0])) {
    B = B.map((x) => [x]);
  }
  let p2 = B[0].length;
  let B_cols = B[0].map((_23, i) => B.map((x) => x[i]));
  let product = A.map((row) => B_cols.map((col) => {
    let ret = 0;
    if (!Array.isArray(row)) {
      for (let c of col) {
        ret += row * c;
      }
      return ret;
    }
    for (let i = 0; i < row.length; i++) {
      ret += row[i] * (col[i] || 0);
    }
    return ret;
  }));
  if (m === 1) {
    product = product[0];
  }
  if (p2 === 1) {
    return product.map((x) => x[0]);
  }
  return product;
}
function isString$1(str) {
  return type$1(str) === "string";
}
function type$1(o) {
  let str = Object.prototype.toString.call(o);
  return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
}
function serializeNumber(n2, { precision, unit }) {
  if (isNone(n2)) {
    return "none";
  }
  return toPrecision(n2, precision) + (unit ?? "");
}
function isNone(n2) {
  return Number.isNaN(n2) || n2 instanceof Number && n2?.none;
}
function toPrecision(n2, precision) {
  if (n2 === 0) {
    return 0;
  }
  let integer2 = ~~n2;
  let digits = 0;
  if (integer2 && precision) {
    digits = ~~Math.log10(Math.abs(integer2)) + 1;
  }
  const multiplier = 10 ** (precision - digits);
  return Math.floor(n2 * multiplier + 0.5) / multiplier;
}
const angleFactor = {
  deg: 1,
  grad: 0.9,
  rad: 180 / Math.PI,
  turn: 360
};
function parseFunction(str) {
  if (!str) {
    return;
  }
  str = str.trim();
  const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
  const isNumberRegex = /^-?[\d.]+$/;
  const unitValueRegex = /%|deg|g?rad|turn$/;
  const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
  let parts = str.match(isFunctionRegex);
  if (parts) {
    let args = [];
    parts[2].replace(singleArgument, ($0, rawArg) => {
      let match = rawArg.match(unitValueRegex);
      let arg = rawArg;
      if (match) {
        let unit = match[0];
        let unitlessArg = arg.slice(0, -unit.length);
        if (unit === "%") {
          arg = new Number(unitlessArg / 100);
          arg.type = "<percentage>";
        } else {
          arg = new Number(unitlessArg * angleFactor[unit]);
          arg.type = "<angle>";
          arg.unit = unit;
        }
      } else if (isNumberRegex.test(arg)) {
        arg = new Number(arg);
        arg.type = "<number>";
      } else if (arg === "none") {
        arg = new Number(NaN);
        arg.none = true;
      }
      if ($0.startsWith("/")) {
        arg = arg instanceof Number ? arg : new Number(arg);
        arg.alpha = true;
      }
      if (typeof arg === "object" && arg instanceof Number) {
        arg.raw = rawArg;
      }
      args.push(arg);
    });
    return {
      name: parts[1].toLowerCase(),
      rawName: parts[1],
      rawArgs: parts[2],
      // An argument could be (as of css-color-4):
      // a number, percentage, degrees (hue), ident (in color())
      args
    };
  }
}
function last(arr2) {
  return arr2[arr2.length - 1];
}
function interpolate(start2, end, p2) {
  if (isNaN(start2)) {
    return end;
  }
  if (isNaN(end)) {
    return start2;
  }
  return start2 + (end - start2) * p2;
}
function interpolateInv(start2, end, value) {
  return (value - start2) / (end - start2);
}
function mapRange(from, to2, value) {
  return interpolate(to2[0], to2[1], interpolateInv(from[0], from[1], value));
}
function parseCoordGrammar(coordGrammars) {
  return coordGrammars.map((coordGrammar2) => {
    return coordGrammar2.split("|").map((type2) => {
      type2 = type2.trim();
      let range2 = type2.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
      if (range2) {
        let ret = new String(range2[1]);
        ret.range = [+range2[2], +range2[3]];
        return ret;
      }
      return type2;
    });
  });
}
function clamp$1(min, val, max) {
  return Math.max(Math.min(max, val), min);
}
function copySign(to2, from) {
  return Math.sign(to2) === Math.sign(from) ? to2 : -to2;
}
function spow(base2, exp) {
  return copySign(Math.abs(base2) ** exp, base2);
}
function zdiv(n2, d2) {
  return d2 === 0 ? 0 : n2 / d2;
}
function bisectLeft(arr2, value, lo = 0, hi = arr2.length) {
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (arr2[mid] < value) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
}
class Hooks {
  add(name, callback, first) {
    if (typeof arguments[0] != "string") {
      for (var name in arguments[0]) {
        this.add(name, arguments[0][name], arguments[1]);
      }
      return;
    }
    (Array.isArray(name) ? name : [name]).forEach(function(name2) {
      this[name2] = this[name2] || [];
      if (callback) {
        this[name2][first ? "unshift" : "push"](callback);
      }
    }, this);
  }
  run(name, env) {
    this[name] = this[name] || [];
    this[name].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
}
const hooks = new Hooks();
const WHITES = {
  // for compatibility, the four-digit chromaticity-derived ones everyone else uses
  D50: [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585],
  D65: [0.3127 / 0.329, 1, (1 - 0.3127 - 0.329) / 0.329]
};
function getWhite(name) {
  if (Array.isArray(name)) {
    return name;
  }
  return WHITES[name];
}
function adapt$1(W1, W2, XYZ, options2 = {}) {
  W1 = getWhite(W1);
  W2 = getWhite(W2);
  if (!W1 || !W2) {
    throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
  }
  if (W1 === W2) {
    return XYZ;
  }
  let env = { W1, W2, XYZ, options: options2 };
  hooks.run("chromatic-adaptation-start", env);
  if (!env.M) {
    if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
      env.M = [
        [1.0479297925449969, 0.022946870601609652, -0.05019226628920524],
        [0.02962780877005599, 0.9904344267538799, -0.017073799063418826],
        [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]
      ];
    } else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {
      env.M = [
        [0.955473421488075, -0.02309845494876471, 0.06325924320057072],
        [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323],
        [0.012314014864481998, -0.020507649298898964, 1.330365926242124]
      ];
    }
  }
  hooks.run("chromatic-adaptation-end", env);
  if (env.M) {
    return multiplyMatrices(env.M, env.XYZ);
  } else {
    throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
  }
}
const defaults$1 = {
  gamut_mapping: "css",
  precision: 5,
  deltaE: "76",
  // Default deltaE method
  verbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== "test",
  warn: function warn(msg) {
    if (this.verbose) {
      globalThis?.console?.warn?.(msg);
    }
  }
};
const noneTypes = /* @__PURE__ */ new Set(["<number>", "<percentage>", "<angle>"]);
function coerceCoords(space, format, name, coords) {
  let types2 = Object.entries(space.coords).map(([id, coordMeta], i) => {
    let coordGrammar2 = format.coordGrammar[i];
    let arg = coords[i];
    let providedType = arg?.type;
    let type2;
    if (arg.none) {
      type2 = coordGrammar2.find((c) => noneTypes.has(c));
    } else {
      type2 = coordGrammar2.find((c) => c == providedType);
    }
    if (!type2) {
      let coordName = coordMeta.name || id;
      throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
    }
    let fromRange = type2.range;
    if (providedType === "<percentage>") {
      fromRange ||= [0, 1];
    }
    let toRange = coordMeta.range || coordMeta.refRange;
    if (fromRange && toRange) {
      coords[i] = mapRange(fromRange, toRange, coords[i]);
    }
    return type2;
  });
  return types2;
}
function parse$4(str, { meta } = {}) {
  let env = { "str": String(str)?.trim() };
  hooks.run("parse-start", env);
  if (env.color) {
    return env.color;
  }
  env.parsed = parseFunction(env.str);
  if (env.parsed) {
    let name = env.parsed.name;
    if (name === "color") {
      let id = env.parsed.args.shift();
      let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
      let ids = [id, alternateId];
      let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
      for (let space of ColorSpace.all) {
        let colorSpec = space.getFormat("color");
        if (colorSpec) {
          if (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {
            const coords = Object.keys(space.coords).map((_23, i) => env.parsed.args[i] || 0);
            let types2;
            if (colorSpec.coordGrammar) {
              types2 = coerceCoords(space, colorSpec, "color", coords);
            }
            if (meta) {
              Object.assign(meta, { formatId: "color", types: types2 });
            }
            if (colorSpec.id.startsWith("--") && !id.startsWith("--")) {
              defaults$1.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
            }
            if (id.startsWith("--") && !colorSpec.id.startsWith("--")) {
              defaults$1.warn(`${space.name} is a standard space and supported in the CSS spec. Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
            }
            return { spaceId: space.id, coords, alpha };
          }
        }
      }
      let didYouMean = "";
      let registryId = id in ColorSpace.registry ? id : alternateId;
      if (registryId in ColorSpace.registry) {
        let cssId = ColorSpace.registry[registryId].formats?.color?.id;
        if (cssId) {
          didYouMean = `Did you mean color(${cssId})?`;
        }
      }
      throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
    } else {
      for (let space of ColorSpace.all) {
        let format = space.getFormat(name);
        if (format && format.type === "function") {
          let alpha = 1;
          if (format.lastAlpha || last(env.parsed.args).alpha) {
            alpha = env.parsed.args.pop();
          }
          let coords = env.parsed.args;
          let types2;
          if (format.coordGrammar) {
            types2 = coerceCoords(space, format, name, coords);
          }
          if (meta) {
            Object.assign(meta, { formatId: format.name, types: types2 });
          }
          return {
            spaceId: space.id,
            coords,
            alpha
          };
        }
      }
    }
  } else {
    for (let space of ColorSpace.all) {
      for (let formatId in space.formats) {
        let format = space.formats[formatId];
        if (format.type !== "custom") {
          continue;
        }
        if (format.test && !format.test(env.str)) {
          continue;
        }
        let color2 = format.parse(env.str);
        if (color2) {
          color2.alpha ??= 1;
          if (meta) {
            meta.formatId = formatId;
          }
          return color2;
        }
      }
    }
  }
  throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
}
function getColor(color2) {
  if (Array.isArray(color2)) {
    return color2.map(getColor);
  }
  if (!color2) {
    throw new TypeError("Empty color reference");
  }
  if (isString$1(color2)) {
    color2 = parse$4(color2);
  }
  let space = color2.space || color2.spaceId;
  if (!(space instanceof ColorSpace)) {
    color2.space = ColorSpace.get(space);
  }
  if (color2.alpha === void 0) {
    color2.alpha = 1;
  }
  return color2;
}
const ε$3 = 75e-6;
class ColorSpace {
  constructor(options2) {
    this.id = options2.id;
    this.name = options2.name;
    this.base = options2.base ? ColorSpace.get(options2.base) : null;
    this.aliases = options2.aliases;
    if (this.base) {
      this.fromBase = options2.fromBase;
      this.toBase = options2.toBase;
    }
    let coords = options2.coords ?? this.base.coords;
    for (let name in coords) {
      if (!("name" in coords[name])) {
        coords[name].name = name;
      }
    }
    this.coords = coords;
    let white2 = options2.white ?? this.base.white ?? "D65";
    this.white = getWhite(white2);
    this.formats = options2.formats ?? {};
    for (let name in this.formats) {
      let format = this.formats[name];
      format.type ||= "function";
      format.name ||= name;
    }
    if (!this.formats.color?.id) {
      this.formats.color = {
        ...this.formats.color ?? {},
        id: options2.cssId || this.id
      };
    }
    if (options2.gamutSpace) {
      this.gamutSpace = options2.gamutSpace === "self" ? this : ColorSpace.get(options2.gamutSpace);
    } else {
      if (this.isPolar) {
        this.gamutSpace = this.base;
      } else {
        this.gamutSpace = this;
      }
    }
    if (this.gamutSpace.isUnbounded) {
      this.inGamut = (coords2, options3) => {
        return true;
      };
    }
    this.referred = options2.referred;
    Object.defineProperty(this, "path", {
      value: getPath$1(this).reverse(),
      writable: false,
      enumerable: true,
      configurable: true
    });
    hooks.run("colorspace-init-end", this);
  }
  inGamut(coords, { epsilon = ε$3 } = {}) {
    if (!this.equals(this.gamutSpace)) {
      coords = this.to(this.gamutSpace, coords);
      return this.gamutSpace.inGamut(coords, { epsilon });
    }
    let coordMeta = Object.values(this.coords);
    return coords.every((c, i) => {
      let meta = coordMeta[i];
      if (meta.type !== "angle" && meta.range) {
        if (Number.isNaN(c)) {
          return true;
        }
        let [min, max] = meta.range;
        return (min === void 0 || c >= min - epsilon) && (max === void 0 || c <= max + epsilon);
      }
      return true;
    });
  }
  get isUnbounded() {
    return Object.values(this.coords).every((coord) => !("range" in coord));
  }
  get cssId() {
    return this.formats?.color?.id || this.id;
  }
  get isPolar() {
    for (let id in this.coords) {
      if (this.coords[id].type === "angle") {
        return true;
      }
    }
    return false;
  }
  getFormat(format) {
    if (typeof format === "object") {
      format = processFormat(format, this);
      return format;
    }
    let ret;
    if (format === "default") {
      ret = Object.values(this.formats)[0];
    } else {
      ret = this.formats[format];
    }
    if (ret) {
      ret = processFormat(ret, this);
      return ret;
    }
    return null;
  }
  /**
   * Check if this color space is the same as another color space reference.
   * Allows proxying color space objects and comparing color spaces with ids.
   * @param {string | ColorSpace} space ColorSpace object or id to compare to
   * @returns {boolean}
   */
  equals(space) {
    if (!space) {
      return false;
    }
    return this === space || this.id === space || this.id === space.id;
  }
  to(space, coords) {
    if (arguments.length === 1) {
      const color2 = getColor(space);
      [space, coords] = [color2.space, color2.coords];
    }
    space = ColorSpace.get(space);
    if (this.equals(space)) {
      return coords;
    }
    coords = coords.map((c) => Number.isNaN(c) ? 0 : c);
    let myPath = this.path;
    let otherPath = space.path;
    let connectionSpace, connectionSpaceIndex;
    for (let i = 0; i < myPath.length; i++) {
      if (myPath[i].equals(otherPath[i])) {
        connectionSpace = myPath[i];
        connectionSpaceIndex = i;
      } else {
        break;
      }
    }
    if (!connectionSpace) {
      throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
    }
    for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {
      coords = myPath[i].toBase(coords);
    }
    for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {
      coords = otherPath[i].fromBase(coords);
    }
    return coords;
  }
  from(space, coords) {
    if (arguments.length === 1) {
      const color2 = getColor(space);
      [space, coords] = [color2.space, color2.coords];
    }
    space = ColorSpace.get(space);
    return space.to(this, coords);
  }
  toString() {
    return `${this.name} (${this.id})`;
  }
  getMinCoords() {
    let ret = [];
    for (let id in this.coords) {
      let meta = this.coords[id];
      let range2 = meta.range || meta.refRange;
      ret.push(range2?.min ?? 0);
    }
    return ret;
  }
  static registry = {};
  // Returns array of unique color spaces
  static get all() {
    return [...new Set(Object.values(ColorSpace.registry))];
  }
  static register(id, space) {
    if (arguments.length === 1) {
      space = arguments[0];
      id = space.id;
    }
    space = this.get(space);
    if (this.registry[id] && this.registry[id] !== space) {
      throw new Error(`Duplicate color space registration: '${id}'`);
    }
    this.registry[id] = space;
    if (arguments.length === 1 && space.aliases) {
      for (let alias of space.aliases) {
        this.register(alias, space);
      }
    }
    return space;
  }
  /**
   * Lookup ColorSpace object by name
   * @param {ColorSpace | string} name
   */
  static get(space, ...alternatives) {
    if (!space || space instanceof ColorSpace) {
      return space;
    }
    let argType = type$1(space);
    if (argType === "string") {
      let ret = ColorSpace.registry[space.toLowerCase()];
      if (!ret) {
        throw new TypeError(`No color space found with id = "${space}"`);
      }
      return ret;
    }
    if (alternatives.length) {
      return ColorSpace.get(...alternatives);
    }
    throw new TypeError(`${space} is not a valid color space`);
  }
  /**
   * Get metadata about a coordinate of a color space
   *
   * @static
   * @param {Array | string} ref
   * @param {ColorSpace | string} [workingSpace]
   * @return {Object}
   */
  static resolveCoord(ref2, workingSpace) {
    let coordType = type$1(ref2);
    let space, coord;
    if (coordType === "string") {
      if (ref2.includes(".")) {
        [space, coord] = ref2.split(".");
      } else {
        [space, coord] = [, ref2];
      }
    } else if (Array.isArray(ref2)) {
      [space, coord] = ref2;
    } else {
      space = ref2.space;
      coord = ref2.coordId;
    }
    space = ColorSpace.get(space);
    if (!space) {
      space = workingSpace;
    }
    if (!space) {
      throw new TypeError(`Cannot resolve coordinate reference ${ref2}: No color space specified and relative references are not allowed here`);
    }
    coordType = type$1(coord);
    if (coordType === "number" || coordType === "string" && coord >= 0) {
      let meta = Object.entries(space.coords)[coord];
      if (meta) {
        return { space, id: meta[0], index: coord, ...meta[1] };
      }
    }
    space = ColorSpace.get(space);
    let normalizedCoord = coord.toLowerCase();
    let i = 0;
    for (let id in space.coords) {
      let meta = space.coords[id];
      if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {
        return { space, id, index: i, ...meta };
      }
      i++;
    }
    throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
  }
  static DEFAULT_FORMAT = {
    type: "functions",
    name: "color"
  };
}
function getPath$1(space) {
  let ret = [space];
  for (let s = space; s = s.base; ) {
    ret.push(s);
  }
  return ret;
}
function processFormat(format, { coords } = {}) {
  if (format.coords && !format.coordGrammar) {
    format.type ||= "function";
    format.name ||= "color";
    format.coordGrammar = parseCoordGrammar(format.coords);
    let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {
      let outputType = format.coordGrammar[i][0];
      let fromRange = coordMeta.range || coordMeta.refRange;
      let toRange = outputType.range, suffix = "";
      if (outputType == "<percentage>") {
        toRange = [0, 100];
        suffix = "%";
      } else if (outputType == "<angle>") {
        suffix = "deg";
      }
      return { fromRange, toRange, suffix };
    });
    format.serializeCoords = (coords2, precision) => {
      return coords2.map((c, i) => {
        let { fromRange, toRange, suffix } = coordFormats[i];
        if (fromRange && toRange) {
          c = mapRange(fromRange, toRange, c);
        }
        c = serializeNumber(c, { precision, unit: suffix });
        return c;
      });
    };
  }
  return format;
}
const xyz_d65 = new ColorSpace({
  id: "xyz-d65",
  name: "XYZ D65",
  coords: {
    x: { name: "X" },
    y: { name: "Y" },
    z: { name: "Z" }
  },
  white: "D65",
  formats: {
    color: {
      ids: ["xyz-d65", "xyz"]
    }
  },
  aliases: ["xyz"]
});
class RGBColorSpace extends ColorSpace {
  /**
   * Creates a new RGB ColorSpace.
   * If coords are not specified, they will use the default RGB coords.
   * Instead of `fromBase()` and `toBase()` functions,
   * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.
   * @param {*} options - Same options as {@link ColorSpace} plus:
   * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ
   * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ
   */
  constructor(options2) {
    if (!options2.coords) {
      options2.coords = {
        r: {
          range: [0, 1],
          name: "Red"
        },
        g: {
          range: [0, 1],
          name: "Green"
        },
        b: {
          range: [0, 1],
          name: "Blue"
        }
      };
    }
    if (!options2.base) {
      options2.base = xyz_d65;
    }
    if (options2.toXYZ_M && options2.fromXYZ_M) {
      options2.toBase ??= (rgb) => {
        let xyz = multiplyMatrices(options2.toXYZ_M, rgb);
        if (this.white !== this.base.white) {
          xyz = adapt$1(this.white, this.base.white, xyz);
        }
        return xyz;
      };
      options2.fromBase ??= (xyz) => {
        xyz = adapt$1(this.base.white, this.white, xyz);
        return multiplyMatrices(options2.fromXYZ_M, xyz);
      };
    }
    options2.referred ??= "display";
    super(options2);
  }
}
function getAll(color2, space) {
  color2 = getColor(color2);
  if (!space || color2.space.equals(space)) {
    return color2.coords.slice();
  }
  space = ColorSpace.get(space);
  return space.from(color2);
}
function get$1(color2, prop) {
  color2 = getColor(color2);
  let { space, index } = ColorSpace.resolveCoord(prop, color2.space);
  let coords = getAll(color2, space);
  return coords[index];
}
function setAll(color2, space, coords) {
  color2 = getColor(color2);
  space = ColorSpace.get(space);
  color2.coords = space.to(color2.space, coords);
  return color2;
}
setAll.returns = "color";
function set(color2, prop, value) {
  color2 = getColor(color2);
  if (arguments.length === 2 && type$1(arguments[1]) === "object") {
    let object2 = arguments[1];
    for (let p2 in object2) {
      set(color2, p2, object2[p2]);
    }
  } else {
    if (typeof value === "function") {
      value = value(get$1(color2, prop));
    }
    let { space, index } = ColorSpace.resolveCoord(prop, color2.space);
    let coords = getAll(color2, space);
    coords[index] = value;
    setAll(color2, space, coords);
  }
  return color2;
}
set.returns = "color";
const XYZ_D50 = new ColorSpace({
  id: "xyz-d50",
  name: "XYZ D50",
  white: "D50",
  base: xyz_d65,
  fromBase: (coords) => adapt$1(xyz_d65.white, "D50", coords),
  toBase: (coords) => adapt$1("D50", xyz_d65.white, coords)
});
const ε$2 = 216 / 24389;
const ε3 = 24 / 116;
const κ$1 = 24389 / 27;
let white$2 = WHITES.D50;
const Lab = new ColorSpace({
  id: "lab",
  name: "Lab",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    a: {
      refRange: [-125, 125]
    },
    b: {
      refRange: [-125, 125]
    }
  },
  // Assuming XYZ is relative to D50, convert to CIE Lab
  // from CIE standard, which now defines these as a rational fraction
  white: white$2,
  base: XYZ_D50,
  // Convert D50-adapted XYX to Lab
  //  CIE 15.3:2004 section 8.2.1.1
  fromBase(XYZ) {
    let xyz = XYZ.map((value, i) => value / white$2[i]);
    let f = xyz.map((value) => value > ε$2 ? Math.cbrt(value) : (κ$1 * value + 16) / 116);
    return [
      116 * f[1] - 16,
      // L
      500 * (f[0] - f[1]),
      // a
      200 * (f[1] - f[2])
      // b
    ];
  },
  // Convert Lab to D50-adapted XYZ
  // Same result as CIE 15.3:2004 Appendix D although the derivation is different
  // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
  toBase(Lab2) {
    let f = [];
    f[1] = (Lab2[0] + 16) / 116;
    f[0] = Lab2[1] / 500 + f[1];
    f[2] = f[1] - Lab2[2] / 200;
    let xyz = [
      f[0] > ε3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$1,
      Lab2[0] > 8 ? Math.pow((Lab2[0] + 16) / 116, 3) : Lab2[0] / κ$1,
      f[2] > ε3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$1
    ];
    return xyz.map((value, i) => value * white$2[i]);
  },
  formats: {
    "lab": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
function constrain$1(angle) {
  return (angle % 360 + 360) % 360;
}
function adjust(arc, angles) {
  if (arc === "raw") {
    return angles;
  }
  let [a1, a2] = angles.map(constrain$1);
  let angleDiff = a2 - a1;
  if (arc === "increasing") {
    if (angleDiff < 0) {
      a2 += 360;
    }
  } else if (arc === "decreasing") {
    if (angleDiff > 0) {
      a1 += 360;
    }
  } else if (arc === "longer") {
    if (-180 < angleDiff && angleDiff < 180) {
      if (angleDiff > 0) {
        a1 += 360;
      } else {
        a2 += 360;
      }
    }
  } else if (arc === "shorter") {
    if (angleDiff > 180) {
      a1 += 360;
    } else if (angleDiff < -180) {
      a2 += 360;
    }
  }
  return [a1, a2];
}
const LCH$1 = new ColorSpace({
  id: "lch",
  name: "LCH",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    c: {
      refRange: [0, 150],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: Lab,
  fromBase(Lab2) {
    let [L, a, b2] = Lab2;
    let hue;
    const ε2 = 0.02;
    if (Math.abs(a) < ε2 && Math.abs(b2) < ε2) {
      hue = NaN;
    } else {
      hue = Math.atan2(b2, a) * 180 / Math.PI;
    }
    return [
      L,
      // L is still L
      Math.sqrt(a ** 2 + b2 ** 2),
      // Chroma
      constrain$1(hue)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(LCH2) {
    let [Lightness, Chroma, Hue] = LCH2;
    if (Chroma < 0) {
      Chroma = 0;
    }
    if (isNaN(Hue)) {
      Hue = 0;
    }
    return [
      Lightness,
      // L is still L
      Chroma * Math.cos(Hue * Math.PI / 180),
      // a
      Chroma * Math.sin(Hue * Math.PI / 180)
      // b
    ];
  },
  formats: {
    "lch": {
      coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
    }
  }
});
const Gfactor = 25 ** 7;
const π$1 = Math.PI;
const r2d = 180 / π$1;
const d2r$1 = π$1 / 180;
function pow7(x) {
  const x2 = x * x;
  const x7 = x2 * x2 * x2 * x;
  return x7;
}
function deltaE2000(color2, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
  [color2, sample] = getColor([color2, sample]);
  let [L1, a1, b1] = Lab.from(color2);
  let C1 = LCH$1.from(Lab, [L1, a1, b1])[1];
  let [L2, a2, b2] = Lab.from(sample);
  let C2 = LCH$1.from(Lab, [L2, a2, b2])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C2 < 0) {
    C2 = 0;
  }
  let Cbar = (C1 + C2) / 2;
  let C7 = pow7(Cbar);
  let G2 = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
  let adash1 = (1 + G2) * a1;
  let adash2 = (1 + G2) * a2;
  let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
  let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);
  let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
  let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);
  if (h1 < 0) {
    h1 += 2 * π$1;
  }
  if (h2 < 0) {
    h2 += 2 * π$1;
  }
  h1 *= r2d;
  h2 *= r2d;
  let ΔL = L2 - L1;
  let ΔC = Cdash2 - Cdash1;
  let hdiff = h2 - h1;
  let hsum = h1 + h2;
  let habs = Math.abs(hdiff);
  let Δh;
  if (Cdash1 * Cdash2 === 0) {
    Δh = 0;
  } else if (habs <= 180) {
    Δh = hdiff;
  } else if (hdiff > 180) {
    Δh = hdiff - 360;
  } else if (hdiff < -180) {
    Δh = hdiff + 360;
  } else {
    defaults$1.warn("the unthinkable has happened");
  }
  let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);
  let Ldash = (L1 + L2) / 2;
  let Cdash = (Cdash1 + Cdash2) / 2;
  let Cdash7 = pow7(Cdash);
  let hdash;
  if (Cdash1 * Cdash2 === 0) {
    hdash = hsum;
  } else if (habs <= 180) {
    hdash = hsum / 2;
  } else if (hsum < 360) {
    hdash = (hsum + 360) / 2;
  } else {
    hdash = (hsum - 360) / 2;
  }
  let lsq = (Ldash - 50) ** 2;
  let SL = 1 + 0.015 * lsq / Math.sqrt(20 + lsq);
  let SC = 1 + 0.045 * Cdash;
  let T2 = 1;
  T2 -= 0.17 * Math.cos((hdash - 30) * d2r$1);
  T2 += 0.24 * Math.cos(2 * hdash * d2r$1);
  T2 += 0.32 * Math.cos((3 * hdash + 6) * d2r$1);
  T2 -= 0.2 * Math.cos((4 * hdash - 63) * d2r$1);
  let SH = 1 + 0.015 * Cdash * T2;
  let Δθ = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
  let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
  let RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;
  let dE = (ΔL / (kL * SL)) ** 2;
  dE += (ΔC / (kC * SC)) ** 2;
  dE += (ΔH / (kH * SH)) ** 2;
  dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));
  return Math.sqrt(dE);
}
const XYZtoLMS_M$1 = [
  [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
  [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
  [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
];
const LMStoXYZ_M$1 = [
  [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
  [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
  [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
];
const LMStoLab_M = [
  [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
  [1.9779985324311684, -2.42859224204858, 0.450593709617411],
  [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
];
const LabtoLMS_M = [
  [1, 0.3963377773761749, 0.2158037573099136],
  [1, -0.1055613458156586, -0.0638541728258133],
  [1, -0.0894841775298119, -1.2914855480194092]
];
const OKLab = new ColorSpace({
  id: "oklab",
  name: "Oklab",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    a: {
      refRange: [-0.4, 0.4]
    },
    b: {
      refRange: [-0.4, 0.4]
    }
  },
  // Note that XYZ is relative to D65
  white: "D65",
  base: xyz_d65,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);
    let LMSg = LMS.map((val) => Math.cbrt(val));
    return multiplyMatrices(LMStoLab_M, LMSg);
  },
  toBase(OKLab2) {
    let LMSg = multiplyMatrices(LabtoLMS_M, OKLab2);
    let LMS = LMSg.map((val) => val ** 3);
    return multiplyMatrices(LMStoXYZ_M$1, LMS);
  },
  formats: {
    "oklab": {
      coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
function deltaEOK(color2, sample) {
  [color2, sample] = getColor([color2, sample]);
  let [L1, a1, b1] = OKLab.from(color2);
  let [L2, a2, b2] = OKLab.from(sample);
  let ΔL = L1 - L2;
  let Δa = a1 - a2;
  let Δb = b1 - b2;
  return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);
}
const ε$1 = 75e-6;
function inGamut(color2, space, { epsilon = ε$1 } = {}) {
  color2 = getColor(color2);
  if (!space) {
    space = color2.space;
  }
  space = ColorSpace.get(space);
  let coords = color2.coords;
  if (space !== color2.space) {
    coords = space.from(color2);
  }
  return space.inGamut(coords, { epsilon });
}
function clone$1(color2) {
  return {
    space: color2.space,
    coords: color2.coords.slice(),
    alpha: color2.alpha
  };
}
function distance(color1, color2, space = "lab") {
  space = ColorSpace.get(space);
  let coords1 = space.from(color1);
  let coords2 = space.from(color2);
  return Math.sqrt(coords1.reduce((acc, c12, i) => {
    let c22 = coords2[i];
    if (isNaN(c12) || isNaN(c22)) {
      return acc;
    }
    return acc + (c22 - c12) ** 2;
  }, 0));
}
function deltaE76(color2, sample) {
  return distance(color2, sample, "lab");
}
const π = Math.PI;
const d2r = π / 180;
function deltaECMC(color2, sample, { l = 2, c = 1 } = {}) {
  [color2, sample] = getColor([color2, sample]);
  let [L1, a1, b1] = Lab.from(color2);
  let [, C1, H1] = LCH$1.from(Lab, [L1, a1, b1]);
  let [L2, a2, b2] = Lab.from(sample);
  let C2 = LCH$1.from(Lab, [L2, a2, b2])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C2 < 0) {
    C2 = 0;
  }
  let ΔL = L1 - L2;
  let ΔC = C1 - C2;
  let Δa = a1 - a2;
  let Δb = b1 - b2;
  let H2 = Δa ** 2 + Δb ** 2 - ΔC ** 2;
  let SL = 0.511;
  if (L1 >= 16) {
    SL = 0.040975 * L1 / (1 + 0.01765 * L1);
  }
  let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;
  let T2;
  if (Number.isNaN(H1)) {
    H1 = 0;
  }
  if (H1 >= 164 && H1 <= 345) {
    T2 = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));
  } else {
    T2 = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));
  }
  let C4 = Math.pow(C1, 4);
  let F2 = Math.sqrt(C4 / (C4 + 1900));
  let SH = SC * (F2 * T2 + 1 - F2);
  let dE = (ΔL / (l * SL)) ** 2;
  dE += (ΔC / (c * SC)) ** 2;
  dE += H2 / SH ** 2;
  return Math.sqrt(dE);
}
const Yw = 203;
const XYZ_Abs_D65 = new ColorSpace({
  // Absolute CIE XYZ, with a D65 whitepoint,
  // as used in most HDR colorspaces as a starting point.
  // SDR spaces are converted per BT.2048
  // so that diffuse, media white is 203 cd/m²
  id: "xyz-abs-d65",
  cssId: "--xyz-abs-d65",
  name: "Absolute XYZ D65",
  coords: {
    x: {
      refRange: [0, 9504.7],
      name: "Xa"
    },
    y: {
      refRange: [0, 1e4],
      name: "Ya"
    },
    z: {
      refRange: [0, 10888.3],
      name: "Za"
    }
  },
  base: xyz_d65,
  fromBase(XYZ) {
    return XYZ.map((v) => Math.max(v * Yw, 0));
  },
  toBase(AbsXYZ) {
    return AbsXYZ.map((v) => Math.max(v / Yw, 0));
  }
});
const b = 1.15;
const g = 0.66;
const n = 2610 / 2 ** 14;
const ninv = 2 ** 14 / 2610;
const c1$1 = 3424 / 2 ** 12;
const c2$1 = 2413 / 2 ** 7;
const c3$1 = 2392 / 2 ** 7;
const p = 1.7 * 2523 / 2 ** 5;
const pinv = 2 ** 5 / (1.7 * 2523);
const d = -0.56;
const d0 = 16295499532821565e-27;
const XYZtoCone_M = [
  [0.41478972, 0.579999, 0.014648],
  [-0.20151, 1.120649, 0.0531008],
  [-0.0166008, 0.2648, 0.6684799]
];
const ConetoXYZ_M = [
  [1.9242264357876067, -1.0047923125953657, 0.037651404030618],
  [0.35031676209499907, 0.7264811939316552, -0.06538442294808501],
  [-0.09098281098284752, -0.3127282905230739, 1.5227665613052603]
];
const ConetoIab_M = [
  [0.5, 0.5, 0],
  [3.524, -4.066708, 0.542708],
  [0.199076, 1.096799, -1.295875]
];
const IabtoCone_M = [
  [1, 0.1386050432715393, 0.05804731615611886],
  [0.9999999999999999, -0.1386050432715393, -0.05804731615611886],
  [0.9999999999999998, -0.09601924202631895, -0.8118918960560388]
];
const Jzazbz = new ColorSpace({
  id: "jzazbz",
  name: "Jzazbz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    az: {
      refRange: [-0.5, 0.5]
    },
    bz: {
      refRange: [-0.5, 0.5]
    }
  },
  base: XYZ_Abs_D65,
  fromBase(XYZ) {
    let [Xa, Ya, Za] = XYZ;
    let Xm = b * Xa - (b - 1) * Za;
    let Ym = g * Ya - (g - 1) * Xa;
    let LMS = multiplyMatrices(XYZtoCone_M, [Xm, Ym, Za]);
    let PQLMS = LMS.map(function(val) {
      let num = c1$1 + c2$1 * (val / 1e4) ** n;
      let denom = 1 + c3$1 * (val / 1e4) ** n;
      return (num / denom) ** p;
    });
    let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
    let Jz = (1 + d) * Iz / (1 + d * Iz) - d0;
    return [Jz, az, bz];
  },
  toBase(Jzazbz2) {
    let [Jz, az, bz] = Jzazbz2;
    let Iz = (Jz + d0) / (1 + d - d * (Jz + d0));
    let PQLMS = multiplyMatrices(IabtoCone_M, [Iz, az, bz]);
    let LMS = PQLMS.map(function(val) {
      let num = c1$1 - val ** pinv;
      let denom = c3$1 * val ** pinv - c2$1;
      let x = 1e4 * (num / denom) ** ninv;
      return x;
    });
    let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, LMS);
    let Xa = (Xm + (b - 1) * Za) / b;
    let Ya = (Ym + (g - 1) * Xa) / g;
    return [Xa, Ya, Za];
  },
  formats: {
    // https://drafts.csswg.org/css-color-hdr/#Jzazbz
    "color": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
const jzczhz = new ColorSpace({
  id: "jzczhz",
  name: "JzCzHz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    cz: {
      refRange: [0, 1],
      name: "Chroma"
    },
    hz: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: Jzazbz,
  fromBase(jzazbz) {
    let [Jz, az, bz] = jzazbz;
    let hue;
    const ε2 = 2e-4;
    if (Math.abs(az) < ε2 && Math.abs(bz) < ε2) {
      hue = NaN;
    } else {
      hue = Math.atan2(bz, az) * 180 / Math.PI;
    }
    return [
      Jz,
      // Jz is still Jz
      Math.sqrt(az ** 2 + bz ** 2),
      // Chroma
      constrain$1(hue)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(jzczhz2) {
    return [
      jzczhz2[0],
      // Jz is still Jz
      jzczhz2[1] * Math.cos(jzczhz2[2] * Math.PI / 180),
      // az
      jzczhz2[1] * Math.sin(jzczhz2[2] * Math.PI / 180)
      // bz
    ];
  }
});
function deltaEJz(color2, sample) {
  [color2, sample] = getColor([color2, sample]);
  let [Jz1, Cz1, Hz1] = jzczhz.from(color2);
  let [Jz2, Cz2, Hz2] = jzczhz.from(sample);
  let ΔJ = Jz1 - Jz2;
  let ΔC = Cz1 - Cz2;
  if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
    Hz1 = 0;
    Hz2 = 0;
  } else if (Number.isNaN(Hz1)) {
    Hz1 = Hz2;
  } else if (Number.isNaN(Hz2)) {
    Hz2 = Hz1;
  }
  let Δh = Hz1 - Hz2;
  let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(Δh / 2 * (Math.PI / 180));
  return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);
}
const c1 = 3424 / 4096;
const c2 = 2413 / 128;
const c3 = 2392 / 128;
const m1$1 = 2610 / 16384;
const m2 = 2523 / 32;
const im1 = 16384 / 2610;
const im2 = 32 / 2523;
const XYZtoLMS_M = [
  [0.3592832590121217, 0.6976051147779502, -0.035891593232029],
  [-0.1920808463704993, 1.100476797037432, 0.0753748658519118],
  [0.0070797844607479, 0.0748396662186362, 0.8433265453898765]
];
const LMStoIPT_M = [
  [2048 / 4096, 2048 / 4096, 0],
  [6610 / 4096, -13613 / 4096, 7003 / 4096],
  [17933 / 4096, -17390 / 4096, -543 / 4096]
];
const IPTtoLMS_M = [
  [0.9999999999999998, 0.0086090370379328, 0.111029625003026],
  [0.9999999999999998, -0.0086090370379328, -0.1110296250030259],
  [0.9999999999999998, 0.5600313357106791, -0.3206271749873188]
];
const LMStoXYZ_M = [
  [2.0701522183894223, -1.3263473389671563, 0.2066510476294053],
  [0.3647385209748072, 0.6805660249472273, -0.0453045459220347],
  [-0.0497472075358123, -0.0492609666966131, 1.1880659249923042]
];
const ictcp = new ColorSpace({
  id: "ictcp",
  name: "ICTCP",
  // From BT.2100-2 page 7:
  // During production, signal values are expected to exceed the
  // range E′ = [0.0 : 1.0]. This provides processing headroom and avoids
  // signal degradation during cascaded processing. Such values of E′,
  // below 0.0 or exceeding 1.0, should not be clipped during production
  // and exchange.
  // Values below 0.0 should not be clipped in reference displays (even
  // though they represent “negative” light) to allow the black level of
  // the signal (LB) to be properly set using test signals known as “PLUGE”
  coords: {
    i: {
      refRange: [0, 1],
      // Constant luminance,
      name: "I"
    },
    ct: {
      refRange: [-0.5, 0.5],
      // Full BT.2020 gamut in range [-0.5, 0.5]
      name: "CT"
    },
    cp: {
      refRange: [-0.5, 0.5],
      name: "CP"
    }
  },
  base: XYZ_Abs_D65,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);
    return LMStoICtCp(LMS);
  },
  toBase(ICtCp) {
    let LMS = ICtCptoLMS(ICtCp);
    return multiplyMatrices(LMStoXYZ_M, LMS);
  }
});
function LMStoICtCp(LMS) {
  let PQLMS = LMS.map(function(val) {
    let num = c1 + c2 * (val / 1e4) ** m1$1;
    let denom = 1 + c3 * (val / 1e4) ** m1$1;
    return (num / denom) ** m2;
  });
  return multiplyMatrices(LMStoIPT_M, PQLMS);
}
function ICtCptoLMS(ICtCp) {
  let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);
  let LMS = PQLMS.map(function(val) {
    let num = Math.max(val ** im2 - c1, 0);
    let denom = c2 - c3 * val ** im2;
    return 1e4 * (num / denom) ** im1;
  });
  return LMS;
}
function deltaEITP(color2, sample) {
  [color2, sample] = getColor([color2, sample]);
  let [I1, T1, P1] = ictcp.from(color2);
  let [I2, T2, P2] = ictcp.from(sample);
  return 720 * Math.sqrt((I1 - I2) ** 2 + 0.25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
}
const white$1 = WHITES.D65;
const adaptedCoef = 0.42;
const adaptedCoefInv = 1 / adaptedCoef;
const tau = 2 * Math.PI;
const cat16 = [
  [0.401288, 0.650173, -0.051461],
  [-0.250268, 1.204414, 0.045854],
  [-2079e-6, 0.048952, 0.953127]
];
const cat16Inv = [
  [1.8620678550872327, -1.0112546305316843, 0.14918677544445175],
  [0.38752654323613717, 0.6214474419314753, -0.008973985167612518],
  [-0.015841498849333856, -0.03412293802851557, 1.0499644368778496]
];
const m1 = [
  [460, 451, 288],
  [460, -891, -261],
  [460, -220, -6300]
];
const surroundMap = {
  dark: [0.8, 0.525, 0.8],
  dim: [0.9, 0.59, 0.9],
  average: [1, 0.69, 1]
};
const hueQuadMap = {
  // Red, Yellow, Green, Blue, Red
  h: [20.14, 90, 164.25, 237.53, 380.14],
  e: [0.8, 0.7, 1, 1.2, 0.8],
  H: [0, 100, 200, 300, 400]
};
const rad2deg = 180 / Math.PI;
const deg2rad$1 = Math.PI / 180;
function adapt(coords, fl) {
  const temp = coords.map((c) => {
    const x = spow(fl * Math.abs(c) * 0.01, adaptedCoef);
    return 400 * copySign(x, c) / (x + 27.13);
  });
  return temp;
}
function unadapt(adapted, fl) {
  const constant = 100 / fl * 27.13 ** adaptedCoefInv;
  return adapted.map((c) => {
    const cabs = Math.abs(c);
    return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c);
  });
}
function hueQuadrature(h) {
  let hp = constrain$1(h);
  if (hp <= hueQuadMap.h[0]) {
    hp += 360;
  }
  const i = bisectLeft(hueQuadMap.h, hp) - 1;
  const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
  const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
  const Hi = hueQuadMap.H[i];
  const t = (hp - hi) / ei;
  return Hi + 100 * t / (t + (hii - hp) / eii);
}
function invHueQuadrature(H2) {
  let Hp = (H2 % 400 + 400) % 400;
  const i = Math.floor(0.01 * Hp);
  Hp = Hp % 100;
  const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
  const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
  return constrain$1(
    (Hp * (eii * hi - ei * hii) - 100 * hi * eii) / (Hp * (eii - ei) - 100 * eii)
  );
}
function environment(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
  const env = {};
  env.discounting = discounting;
  env.refWhite = refWhite;
  env.surround = surround;
  const xyzW = refWhite.map((c) => {
    return c * 100;
  });
  env.la = adaptingLuminance;
  env.yb = backgroundLuminance;
  const yw = xyzW[1];
  const rgbW = multiplyMatrices(cat16, xyzW);
  surround = surroundMap[env.surround];
  const f = surround[0];
  env.c = surround[1];
  env.nc = surround[2];
  const k = 1 / (5 * env.la + 1);
  const k4 = k ** 4;
  env.fl = k4 * env.la + 0.1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
  env.flRoot = env.fl ** 0.25;
  env.n = env.yb / yw;
  env.z = 1.48 + Math.sqrt(env.n);
  env.nbb = 0.725 * env.n ** -0.2;
  env.ncb = env.nbb;
  const d2 = Math.max(
    Math.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1),
    0
  );
  env.dRgb = rgbW.map((c) => {
    return interpolate(1, yw / c, d2);
  });
  env.dRgbInv = env.dRgb.map((c) => {
    return 1 / c;
  });
  const rgbCW = rgbW.map((c, i) => {
    return c * env.dRgb[i];
  });
  const rgbAW = adapt(rgbCW, env.fl);
  env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + 0.05 * rgbAW[2]);
  return env;
}
const viewingConditions$1 = environment(
  white$1,
  64 / Math.PI * 0.2,
  20,
  "average",
  false
);
function fromCam16(cam16, env) {
  if (!(cam16.J !== void 0 ^ cam16.Q !== void 0)) {
    throw new Error("Conversion requires one and only one: 'J' or 'Q'");
  }
  if (!(cam16.C !== void 0 ^ cam16.M !== void 0 ^ cam16.s !== void 0)) {
    throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
  }
  if (!(cam16.h !== void 0 ^ cam16.H !== void 0)) {
    throw new Error("Conversion requires one and only one: 'h' or 'H'");
  }
  if (cam16.J === 0 || cam16.Q === 0) {
    return [0, 0, 0];
  }
  let hRad = 0;
  if (cam16.h !== void 0) {
    hRad = constrain$1(cam16.h) * deg2rad$1;
  } else {
    hRad = invHueQuadrature(cam16.H) * deg2rad$1;
  }
  const cosh = Math.cos(hRad);
  const sinh = Math.sin(hRad);
  let Jroot = 0;
  if (cam16.J !== void 0) {
    Jroot = spow(cam16.J, 1 / 2) * 0.1;
  } else if (cam16.Q !== void 0) {
    Jroot = 0.25 * env.c * cam16.Q / ((env.aW + 4) * env.flRoot);
  }
  let alpha = 0;
  if (cam16.C !== void 0) {
    alpha = cam16.C / Jroot;
  } else if (cam16.M !== void 0) {
    alpha = cam16.M / env.flRoot / Jroot;
  } else if (cam16.s !== void 0) {
    alpha = 4e-4 * cam16.s ** 2 * (env.aW + 4) / env.c;
  }
  const t = spow(
    alpha * Math.pow(1.64 - Math.pow(0.29, env.n), -0.73),
    10 / 9
  );
  const et = 0.25 * (Math.cos(hRad + 2) + 3.8);
  const A = env.aW * spow(Jroot, 2 / env.c / env.z);
  const p1 = 5e4 / 13 * env.nc * env.ncb * et;
  const p2 = A / env.nbb;
  const r = 23 * (p2 + 0.305) * zdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh));
  const a = r * cosh;
  const b2 = r * sinh;
  const rgb_c = unadapt(
    multiplyMatrices(m1, [p2, a, b2]).map((c) => {
      return c * 1 / 1403;
    }),
    env.fl
  );
  return multiplyMatrices(
    cat16Inv,
    rgb_c.map((c, i) => {
      return c * env.dRgbInv[i];
    })
  ).map((c) => {
    return c / 100;
  });
}
function toCam16(xyzd65, env) {
  const xyz100 = xyzd65.map((c) => {
    return c * 100;
  });
  const rgbA = adapt(
    multiplyMatrices(cat16, xyz100).map((c, i) => {
      return c * env.dRgb[i];
    }),
    env.fl
  );
  const a = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
  const b2 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
  const hRad = (Math.atan2(b2, a) % tau + tau) % tau;
  const et = 0.25 * (Math.cos(hRad + 2) + 3.8);
  const t = 5e4 / 13 * env.nc * env.ncb * zdiv(
    et * Math.sqrt(a ** 2 + b2 ** 2),
    rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + 0.305
  );
  const alpha = spow(t, 0.9) * Math.pow(1.64 - Math.pow(0.29, env.n), 0.73);
  const A = env.nbb * (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]);
  const Jroot = spow(A / env.aW, 0.5 * env.c * env.z);
  const J2 = 100 * spow(Jroot, 2);
  const Q2 = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
  const C = alpha * Jroot;
  const M = C * env.flRoot;
  const h = constrain$1(hRad * rad2deg);
  const H2 = hueQuadrature(h);
  const s = 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2);
  return { J: J2, C, h, s, Q: Q2, M, H: H2 };
}
new ColorSpace({
  id: "cam16-jmh",
  cssId: "--cam16-jmh",
  name: "CAM16-JMh",
  coords: {
    j: {
      refRange: [0, 100],
      name: "J"
    },
    m: {
      refRange: [0, 105],
      name: "Colorfulness"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: xyz_d65,
  fromBase(xyz) {
    const cam16 = toCam16(xyz, viewingConditions$1);
    return [cam16.J, cam16.M, cam16.h];
  },
  toBase(cam16) {
    return fromCam16(
      { J: cam16[0], M: cam16[1], h: cam16[2] },
      viewingConditions$1
    );
  }
});
const white = WHITES.D65;
const ε = 216 / 24389;
const κ = 24389 / 27;
function toLstar(y) {
  const fy = y > ε ? Math.cbrt(y) : (κ * y + 16) / 116;
  return 116 * fy - 16;
}
function fromLstar(lstar) {
  return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / κ;
}
function fromHct(coords, env) {
  let [h, c, t] = coords;
  let xyz = [];
  let j2 = 0;
  if (t === 0) {
    return [0, 0, 0];
  }
  let y = fromLstar(t);
  if (t > 0) {
    j2 = 0.00379058511492914 * t ** 2 + 0.608983189401032 * t + 0.9155088574762233;
  } else {
    j2 = 9514440756550361e-21 * t ** 2 + 0.08693057439788597 * t - 21.928975842194614;
  }
  const threshold = 2e-12;
  const max_attempts = 15;
  let attempt = 0;
  let last2 = Infinity;
  while (attempt <= max_attempts) {
    xyz = fromCam16({ J: j2, C: c, h }, env);
    const delta = Math.abs(xyz[1] - y);
    if (delta < last2) {
      if (delta <= threshold) {
        return xyz;
      }
      last2 = delta;
    }
    j2 = j2 - (xyz[1] - y) * j2 / (2 * xyz[1]);
    attempt += 1;
  }
  return fromCam16({ J: j2, C: c, h }, env);
}
function toHct(xyz, env) {
  const t = toLstar(xyz[1]);
  if (t === 0) {
    return [0, 0, 0];
  }
  const cam16 = toCam16(xyz, viewingConditions);
  return [constrain$1(cam16.h), cam16.C, t];
}
const viewingConditions = environment(
  white,
  200 / Math.PI * fromLstar(50),
  fromLstar(50) * 100,
  "average",
  false
);
const hct = new ColorSpace({
  id: "hct",
  name: "HCT",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    c: {
      refRange: [0, 145],
      name: "Colorfulness"
    },
    t: {
      refRange: [0, 100],
      name: "Tone"
    }
  },
  base: xyz_d65,
  fromBase(xyz) {
    return toHct(xyz);
  },
  toBase(hct2) {
    return fromHct(hct2, viewingConditions);
  },
  formats: {
    color: {
      id: "--hct",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
const deg2rad = Math.PI / 180;
const ucsCoeff = [1, 7e-3, 0.0228];
function convertUcsAb(coords) {
  if (coords[1] < 0) {
    coords = hct.fromBase(hct.toBase(coords));
  }
  const M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1)) / ucsCoeff[2];
  const hrad = coords[0] * deg2rad;
  const a = M * Math.cos(hrad);
  const b2 = M * Math.sin(hrad);
  return [coords[2], a, b2];
}
function deltaEHCT(color2, sample) {
  [color2, sample] = getColor([color2, sample]);
  let [t1, a1, b1] = convertUcsAb(hct.from(color2));
  let [t2, a2, b2] = convertUcsAb(hct.from(sample));
  return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);
}
const deltaEMethods = {
  deltaE76,
  deltaECMC,
  deltaE2000,
  deltaEJz,
  deltaEITP,
  deltaEOK,
  deltaEHCT
};
function calcEpsilon(jnd) {
  const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
  return Math.max(parseFloat(`1e${order - 2}`), 1e-6);
}
const GMAPPRESET = {
  "hct": {
    method: "hct.c",
    jnd: 2,
    deltaEMethod: "hct",
    blackWhiteClamp: {}
  },
  "hct-tonal": {
    method: "hct.c",
    jnd: 0,
    deltaEMethod: "hct",
    blackWhiteClamp: { channel: "hct.t", min: 0, max: 100 }
  }
};
function toGamut(color2, {
  method = defaults$1.gamut_mapping,
  space = void 0,
  deltaEMethod = "",
  jnd = 2,
  blackWhiteClamp = {}
} = {}) {
  color2 = getColor(color2);
  if (isString$1(arguments[1])) {
    space = arguments[1];
  } else if (!space) {
    space = color2.space;
  }
  space = ColorSpace.get(space);
  if (inGamut(color2, space, { epsilon: 0 })) {
    return color2;
  }
  let spaceColor;
  if (method === "css") {
    spaceColor = toGamutCSS(color2, { space });
  } else {
    if (method !== "clip" && !inGamut(color2, space)) {
      if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {
        ({ method, jnd, deltaEMethod, blackWhiteClamp } = GMAPPRESET[method]);
      }
      let de = deltaE2000;
      if (deltaEMethod !== "") {
        for (let m in deltaEMethods) {
          if ("deltae" + deltaEMethod.toLowerCase() === m.toLowerCase()) {
            de = deltaEMethods[m];
            break;
          }
        }
      }
      let clipped = toGamut(to(color2, space), { method: "clip", space });
      if (de(color2, clipped) > jnd) {
        if (Object.keys(blackWhiteClamp).length === 3) {
          let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
          let channel = get$1(to(color2, channelMeta.space), channelMeta.id);
          if (isNone(channel)) {
            channel = 0;
          }
          if (channel >= blackWhiteClamp.max) {
            return to({ space: "xyz-d65", coords: WHITES["D65"] }, color2.space);
          } else if (channel <= blackWhiteClamp.min) {
            return to({ space: "xyz-d65", coords: [0, 0, 0] }, color2.space);
          }
        }
        let coordMeta = ColorSpace.resolveCoord(method);
        let mapSpace = coordMeta.space;
        let coordId = coordMeta.id;
        let mappedColor = to(color2, mapSpace);
        mappedColor.coords.forEach((c, i) => {
          if (isNone(c)) {
            mappedColor.coords[i] = 0;
          }
        });
        let bounds = coordMeta.range || coordMeta.refRange;
        let min = bounds[0];
        let ε2 = calcEpsilon(jnd);
        let low = min;
        let high = get$1(mappedColor, coordId);
        while (high - low > ε2) {
          let clipped2 = clone$1(mappedColor);
          clipped2 = toGamut(clipped2, { space, method: "clip" });
          let deltaE = de(mappedColor, clipped2);
          if (deltaE - jnd < ε2) {
            low = get$1(mappedColor, coordId);
          } else {
            high = get$1(mappedColor, coordId);
          }
          set(mappedColor, coordId, (low + high) / 2);
        }
        spaceColor = to(mappedColor, space);
      } else {
        spaceColor = clipped;
      }
    } else {
      spaceColor = to(color2, space);
    }
    if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
      let bounds = Object.values(space.coords).map((c) => c.range || []);
      spaceColor.coords = spaceColor.coords.map((c, i) => {
        let [min, max] = bounds[i];
        if (min !== void 0) {
          c = Math.max(min, c);
        }
        if (max !== void 0) {
          c = Math.min(c, max);
        }
        return c;
      });
    }
  }
  if (space !== color2.space) {
    spaceColor = to(spaceColor, color2.space);
  }
  color2.coords = spaceColor.coords;
  return color2;
}
toGamut.returns = "color";
const COLORS = {
  WHITE: { space: OKLab, coords: [1, 0, 0] },
  BLACK: { space: OKLab, coords: [0, 0, 0] }
};
function toGamutCSS(origin, { space } = {}) {
  const JND = 0.02;
  const ε2 = 1e-4;
  origin = getColor(origin);
  if (!space) {
    space = origin.space;
  }
  space = ColorSpace.get(space);
  const oklchSpace = ColorSpace.get("oklch");
  if (space.isUnbounded) {
    return to(origin, space);
  }
  const origin_OKLCH = to(origin, oklchSpace);
  let L = origin_OKLCH.coords[0];
  if (L >= 1) {
    const white2 = to(COLORS.WHITE, space);
    white2.alpha = origin.alpha;
    return to(white2, space);
  }
  if (L <= 0) {
    const black = to(COLORS.BLACK, space);
    black.alpha = origin.alpha;
    return to(black, space);
  }
  if (inGamut(origin_OKLCH, space, { epsilon: 0 })) {
    return to(origin_OKLCH, space);
  }
  function clip(_color) {
    const destColor = to(_color, space);
    const spaceCoords = Object.values(space.coords);
    destColor.coords = destColor.coords.map((coord, index) => {
      if ("range" in spaceCoords[index]) {
        const [min2, max2] = spaceCoords[index].range;
        return clamp$1(min2, coord, max2);
      }
      return coord;
    });
    return destColor;
  }
  let min = 0;
  let max = origin_OKLCH.coords[1];
  let min_inGamut = true;
  let current2 = clone$1(origin_OKLCH);
  let clipped = clip(current2);
  let E = deltaEOK(clipped, current2);
  if (E < JND) {
    return clipped;
  }
  while (max - min > ε2) {
    const chroma = (min + max) / 2;
    current2.coords[1] = chroma;
    if (min_inGamut && inGamut(current2, space, { epsilon: 0 })) {
      min = chroma;
    } else {
      clipped = clip(current2);
      E = deltaEOK(clipped, current2);
      if (E < JND) {
        if (JND - E < ε2) {
          break;
        } else {
          min_inGamut = false;
          min = chroma;
        }
      } else {
        max = chroma;
      }
    }
  }
  return clipped;
}
function to(color2, space, { inGamut: inGamut2 } = {}) {
  color2 = getColor(color2);
  space = ColorSpace.get(space);
  let coords = space.from(color2);
  let ret = { space, coords, alpha: color2.alpha };
  if (inGamut2) {
    ret = toGamut(ret, inGamut2 === true ? void 0 : inGamut2);
  }
  return ret;
}
to.returns = "color";
function serialize(color2, {
  precision = defaults$1.precision,
  format = "default",
  inGamut: inGamut$1 = true,
  ...customOptions
} = {}) {
  let ret;
  color2 = getColor(color2);
  let formatId = format;
  format = color2.space.getFormat(format) ?? color2.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
  let coords = color2.coords.slice();
  inGamut$1 ||= format.toGamut;
  if (inGamut$1 && !inGamut(color2)) {
    coords = toGamut(clone$1(color2), inGamut$1 === true ? void 0 : inGamut$1).coords;
  }
  if (format.type === "custom") {
    customOptions.precision = precision;
    if (format.serialize) {
      ret = format.serialize(coords, color2.alpha, customOptions);
    } else {
      throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
    }
  } else {
    let name = format.name || "color";
    if (format.serializeCoords) {
      coords = format.serializeCoords(coords, precision);
    } else {
      if (precision !== null) {
        coords = coords.map((c) => {
          return serializeNumber(c, { precision });
        });
      }
    }
    let args = [...coords];
    if (name === "color") {
      let cssId = format.id || format.ids?.[0] || color2.space.id;
      args.unshift(cssId);
    }
    let alpha = color2.alpha;
    if (precision !== null) {
      alpha = serializeNumber(alpha, { precision });
    }
    let strAlpha = color2.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
    ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
  }
  return ret;
}
const toXYZ_M$1 = [
  [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
  [0.2289745640697488, 0.6917385218365064, 0.079286914093745],
  [0, 0.04511338185890264, 1.043944368900976]
];
const fromXYZ_M$1 = [
  [2.493496911941425, -0.9313836179191239, -0.40271078445071684],
  [-0.8294889695615747, 1.7626640603183463, 0.023624685841943577],
  [0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
];
const P3Linear = new RGBColorSpace({
  id: "p3-linear",
  cssId: "--display-p3-linear",
  name: "Linear P3",
  white: "D65",
  toXYZ_M: toXYZ_M$1,
  fromXYZ_M: fromXYZ_M$1
});
const toXYZ_M = [
  [0.41239079926595934, 0.357584339383878, 0.1804807884018343],
  [0.21263900587151027, 0.715168678767756, 0.07219231536073371],
  [0.01933081871559182, 0.11919477979462598, 0.9505321522496607]
];
const fromXYZ_M = [
  [3.2409699419045226, -1.537383177570094, -0.4986107602930034],
  [-0.9692436362808796, 1.8759675015077202, 0.04155505740717559],
  [0.05563007969699366, -0.20397695888897652, 1.0569715142428786]
];
const sRGBLinear = new RGBColorSpace({
  id: "srgb-linear",
  name: "Linear sRGB",
  white: "D65",
  toXYZ_M,
  fromXYZ_M
});
const KEYWORDS = {
  "aliceblue": [240 / 255, 248 / 255, 1],
  "antiquewhite": [250 / 255, 235 / 255, 215 / 255],
  "aqua": [0, 1, 1],
  "aquamarine": [127 / 255, 1, 212 / 255],
  "azure": [240 / 255, 1, 1],
  "beige": [245 / 255, 245 / 255, 220 / 255],
  "bisque": [1, 228 / 255, 196 / 255],
  "black": [0, 0, 0],
  "blanchedalmond": [1, 235 / 255, 205 / 255],
  "blue": [0, 0, 1],
  "blueviolet": [138 / 255, 43 / 255, 226 / 255],
  "brown": [165 / 255, 42 / 255, 42 / 255],
  "burlywood": [222 / 255, 184 / 255, 135 / 255],
  "cadetblue": [95 / 255, 158 / 255, 160 / 255],
  "chartreuse": [127 / 255, 1, 0],
  "chocolate": [210 / 255, 105 / 255, 30 / 255],
  "coral": [1, 127 / 255, 80 / 255],
  "cornflowerblue": [100 / 255, 149 / 255, 237 / 255],
  "cornsilk": [1, 248 / 255, 220 / 255],
  "crimson": [220 / 255, 20 / 255, 60 / 255],
  "cyan": [0, 1, 1],
  "darkblue": [0, 0, 139 / 255],
  "darkcyan": [0, 139 / 255, 139 / 255],
  "darkgoldenrod": [184 / 255, 134 / 255, 11 / 255],
  "darkgray": [169 / 255, 169 / 255, 169 / 255],
  "darkgreen": [0, 100 / 255, 0],
  "darkgrey": [169 / 255, 169 / 255, 169 / 255],
  "darkkhaki": [189 / 255, 183 / 255, 107 / 255],
  "darkmagenta": [139 / 255, 0, 139 / 255],
  "darkolivegreen": [85 / 255, 107 / 255, 47 / 255],
  "darkorange": [1, 140 / 255, 0],
  "darkorchid": [153 / 255, 50 / 255, 204 / 255],
  "darkred": [139 / 255, 0, 0],
  "darksalmon": [233 / 255, 150 / 255, 122 / 255],
  "darkseagreen": [143 / 255, 188 / 255, 143 / 255],
  "darkslateblue": [72 / 255, 61 / 255, 139 / 255],
  "darkslategray": [47 / 255, 79 / 255, 79 / 255],
  "darkslategrey": [47 / 255, 79 / 255, 79 / 255],
  "darkturquoise": [0, 206 / 255, 209 / 255],
  "darkviolet": [148 / 255, 0, 211 / 255],
  "deeppink": [1, 20 / 255, 147 / 255],
  "deepskyblue": [0, 191 / 255, 1],
  "dimgray": [105 / 255, 105 / 255, 105 / 255],
  "dimgrey": [105 / 255, 105 / 255, 105 / 255],
  "dodgerblue": [30 / 255, 144 / 255, 1],
  "firebrick": [178 / 255, 34 / 255, 34 / 255],
  "floralwhite": [1, 250 / 255, 240 / 255],
  "forestgreen": [34 / 255, 139 / 255, 34 / 255],
  "fuchsia": [1, 0, 1],
  "gainsboro": [220 / 255, 220 / 255, 220 / 255],
  "ghostwhite": [248 / 255, 248 / 255, 1],
  "gold": [1, 215 / 255, 0],
  "goldenrod": [218 / 255, 165 / 255, 32 / 255],
  "gray": [128 / 255, 128 / 255, 128 / 255],
  "green": [0, 128 / 255, 0],
  "greenyellow": [173 / 255, 1, 47 / 255],
  "grey": [128 / 255, 128 / 255, 128 / 255],
  "honeydew": [240 / 255, 1, 240 / 255],
  "hotpink": [1, 105 / 255, 180 / 255],
  "indianred": [205 / 255, 92 / 255, 92 / 255],
  "indigo": [75 / 255, 0, 130 / 255],
  "ivory": [1, 1, 240 / 255],
  "khaki": [240 / 255, 230 / 255, 140 / 255],
  "lavender": [230 / 255, 230 / 255, 250 / 255],
  "lavenderblush": [1, 240 / 255, 245 / 255],
  "lawngreen": [124 / 255, 252 / 255, 0],
  "lemonchiffon": [1, 250 / 255, 205 / 255],
  "lightblue": [173 / 255, 216 / 255, 230 / 255],
  "lightcoral": [240 / 255, 128 / 255, 128 / 255],
  "lightcyan": [224 / 255, 1, 1],
  "lightgoldenrodyellow": [250 / 255, 250 / 255, 210 / 255],
  "lightgray": [211 / 255, 211 / 255, 211 / 255],
  "lightgreen": [144 / 255, 238 / 255, 144 / 255],
  "lightgrey": [211 / 255, 211 / 255, 211 / 255],
  "lightpink": [1, 182 / 255, 193 / 255],
  "lightsalmon": [1, 160 / 255, 122 / 255],
  "lightseagreen": [32 / 255, 178 / 255, 170 / 255],
  "lightskyblue": [135 / 255, 206 / 255, 250 / 255],
  "lightslategray": [119 / 255, 136 / 255, 153 / 255],
  "lightslategrey": [119 / 255, 136 / 255, 153 / 255],
  "lightsteelblue": [176 / 255, 196 / 255, 222 / 255],
  "lightyellow": [1, 1, 224 / 255],
  "lime": [0, 1, 0],
  "limegreen": [50 / 255, 205 / 255, 50 / 255],
  "linen": [250 / 255, 240 / 255, 230 / 255],
  "magenta": [1, 0, 1],
  "maroon": [128 / 255, 0, 0],
  "mediumaquamarine": [102 / 255, 205 / 255, 170 / 255],
  "mediumblue": [0, 0, 205 / 255],
  "mediumorchid": [186 / 255, 85 / 255, 211 / 255],
  "mediumpurple": [147 / 255, 112 / 255, 219 / 255],
  "mediumseagreen": [60 / 255, 179 / 255, 113 / 255],
  "mediumslateblue": [123 / 255, 104 / 255, 238 / 255],
  "mediumspringgreen": [0, 250 / 255, 154 / 255],
  "mediumturquoise": [72 / 255, 209 / 255, 204 / 255],
  "mediumvioletred": [199 / 255, 21 / 255, 133 / 255],
  "midnightblue": [25 / 255, 25 / 255, 112 / 255],
  "mintcream": [245 / 255, 1, 250 / 255],
  "mistyrose": [1, 228 / 255, 225 / 255],
  "moccasin": [1, 228 / 255, 181 / 255],
  "navajowhite": [1, 222 / 255, 173 / 255],
  "navy": [0, 0, 128 / 255],
  "oldlace": [253 / 255, 245 / 255, 230 / 255],
  "olive": [128 / 255, 128 / 255, 0],
  "olivedrab": [107 / 255, 142 / 255, 35 / 255],
  "orange": [1, 165 / 255, 0],
  "orangered": [1, 69 / 255, 0],
  "orchid": [218 / 255, 112 / 255, 214 / 255],
  "palegoldenrod": [238 / 255, 232 / 255, 170 / 255],
  "palegreen": [152 / 255, 251 / 255, 152 / 255],
  "paleturquoise": [175 / 255, 238 / 255, 238 / 255],
  "palevioletred": [219 / 255, 112 / 255, 147 / 255],
  "papayawhip": [1, 239 / 255, 213 / 255],
  "peachpuff": [1, 218 / 255, 185 / 255],
  "peru": [205 / 255, 133 / 255, 63 / 255],
  "pink": [1, 192 / 255, 203 / 255],
  "plum": [221 / 255, 160 / 255, 221 / 255],
  "powderblue": [176 / 255, 224 / 255, 230 / 255],
  "purple": [128 / 255, 0, 128 / 255],
  "rebeccapurple": [102 / 255, 51 / 255, 153 / 255],
  "red": [1, 0, 0],
  "rosybrown": [188 / 255, 143 / 255, 143 / 255],
  "royalblue": [65 / 255, 105 / 255, 225 / 255],
  "saddlebrown": [139 / 255, 69 / 255, 19 / 255],
  "salmon": [250 / 255, 128 / 255, 114 / 255],
  "sandybrown": [244 / 255, 164 / 255, 96 / 255],
  "seagreen": [46 / 255, 139 / 255, 87 / 255],
  "seashell": [1, 245 / 255, 238 / 255],
  "sienna": [160 / 255, 82 / 255, 45 / 255],
  "silver": [192 / 255, 192 / 255, 192 / 255],
  "skyblue": [135 / 255, 206 / 255, 235 / 255],
  "slateblue": [106 / 255, 90 / 255, 205 / 255],
  "slategray": [112 / 255, 128 / 255, 144 / 255],
  "slategrey": [112 / 255, 128 / 255, 144 / 255],
  "snow": [1, 250 / 255, 250 / 255],
  "springgreen": [0, 1, 127 / 255],
  "steelblue": [70 / 255, 130 / 255, 180 / 255],
  "tan": [210 / 255, 180 / 255, 140 / 255],
  "teal": [0, 128 / 255, 128 / 255],
  "thistle": [216 / 255, 191 / 255, 216 / 255],
  "tomato": [1, 99 / 255, 71 / 255],
  "turquoise": [64 / 255, 224 / 255, 208 / 255],
  "violet": [238 / 255, 130 / 255, 238 / 255],
  "wheat": [245 / 255, 222 / 255, 179 / 255],
  "white": [1, 1, 1],
  "whitesmoke": [245 / 255, 245 / 255, 245 / 255],
  "yellow": [1, 1, 0],
  "yellowgreen": [154 / 255, 205 / 255, 50 / 255]
};
let coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
let coordGrammarNumber = Array(3).fill("<number>[0, 255]");
const sRGB = new RGBColorSpace({
  id: "srgb",
  name: "sRGB",
  base: sRGBLinear,
  fromBase: (rgb) => {
    return rgb.map((val) => {
      let sign = val < 0 ? -1 : 1;
      let abs = val * sign;
      if (abs > 31308e-7) {
        return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
      }
      return 12.92 * val;
    });
  },
  toBase: (rgb) => {
    return rgb.map((val) => {
      let sign = val < 0 ? -1 : 1;
      let abs = val * sign;
      if (abs <= 0.04045) {
        return val / 12.92;
      }
      return sign * ((abs + 0.055) / 1.055) ** 2.4;
    });
  },
  formats: {
    "rgb": {
      coords: coordGrammar
    },
    "rgb_number": {
      name: "rgb",
      commas: true,
      coords: coordGrammarNumber,
      noAlpha: true
    },
    "color": {
      /* use defaults */
    },
    "rgba": {
      coords: coordGrammar,
      commas: true,
      lastAlpha: true
    },
    "rgba_number": {
      name: "rgba",
      commas: true,
      coords: coordGrammarNumber
    },
    "hex": {
      type: "custom",
      toGamut: true,
      test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
      parse(str) {
        if (str.length <= 5) {
          str = str.replace(/[a-f0-9]/gi, "$&$&");
        }
        let rgba = [];
        str.replace(/[a-f0-9]{2}/gi, (component) => {
          rgba.push(parseInt(component, 16) / 255);
        });
        return {
          spaceId: "srgb",
          coords: rgba.slice(0, 3),
          alpha: rgba.slice(3)[0]
        };
      },
      serialize: (coords, alpha, {
        collapse = true
        // collapse to 3-4 digit hex when possible?
      } = {}) => {
        if (alpha < 1) {
          coords.push(alpha);
        }
        coords = coords.map((c) => Math.round(c * 255));
        let collapsible = collapse && coords.every((c) => c % 17 === 0);
        let hex = coords.map((c) => {
          if (collapsible) {
            return (c / 17).toString(16);
          }
          return c.toString(16).padStart(2, "0");
        }).join("");
        return "#" + hex;
      }
    },
    "keyword": {
      type: "custom",
      test: (str) => /^[a-z]+$/i.test(str),
      parse(str) {
        str = str.toLowerCase();
        let ret = { spaceId: "srgb", coords: null, alpha: 1 };
        if (str === "transparent") {
          ret.coords = KEYWORDS.black;
          ret.alpha = 0;
        } else {
          ret.coords = KEYWORDS[str];
        }
        if (ret.coords) {
          return ret;
        }
      }
    }
  }
});
const P3 = new RGBColorSpace({
  id: "p3",
  cssId: "display-p3",
  name: "P3",
  base: P3Linear,
  // Gamma encoding/decoding is the same as sRGB
  fromBase: sRGB.fromBase,
  toBase: sRGB.toBase
});
function getLuminance(color2) {
  return get$1(color2, [xyz_d65, "y"]);
}
function contrastWCAG21(color1, color2) {
  color1 = getColor(color1);
  color2 = getColor(color2);
  let Y1 = Math.max(getLuminance(color1), 0);
  let Y2 = Math.max(getLuminance(color2), 0);
  if (Y2 > Y1) {
    [Y1, Y2] = [Y2, Y1];
  }
  return (Y1 + 0.05) / (Y2 + 0.05);
}
const normBG = 0.56;
const normTXT = 0.57;
const revTXT = 0.62;
const revBG = 0.65;
const blkThrs = 0.022;
const blkClmp = 1.414;
const loClip = 0.1;
const deltaYmin = 5e-4;
const scaleBoW = 1.14;
const loBoWoffset = 0.027;
const scaleWoB = 1.14;
function fclamp(Y) {
  if (Y >= blkThrs) {
    return Y;
  }
  return Y + (blkThrs - Y) ** blkClmp;
}
function linearize(val) {
  let sign = val < 0 ? -1 : 1;
  let abs = Math.abs(val);
  return sign * Math.pow(abs, 2.4);
}
function contrastAPCA(background, foreground) {
  foreground = getColor(foreground);
  background = getColor(background);
  let S2;
  let C;
  let Sapc;
  let R2, G2, B;
  foreground = to(foreground, "srgb");
  [R2, G2, B] = foreground.coords;
  let lumTxt = linearize(R2) * 0.2126729 + linearize(G2) * 0.7151522 + linearize(B) * 0.072175;
  background = to(background, "srgb");
  [R2, G2, B] = background.coords;
  let lumBg = linearize(R2) * 0.2126729 + linearize(G2) * 0.7151522 + linearize(B) * 0.072175;
  let Ytxt = fclamp(lumTxt);
  let Ybg = fclamp(lumBg);
  let BoW = Ybg > Ytxt;
  if (Math.abs(Ybg - Ytxt) < deltaYmin) {
    C = 0;
  } else {
    if (BoW) {
      S2 = Ybg ** normBG - Ytxt ** normTXT;
      C = S2 * scaleBoW;
    } else {
      S2 = Ybg ** revBG - Ytxt ** revTXT;
      C = S2 * scaleWoB;
    }
  }
  if (Math.abs(C) < loClip) {
    Sapc = 0;
  } else if (C > 0) {
    Sapc = C - loBoWoffset;
  } else {
    Sapc = C + loBoWoffset;
  }
  return Sapc * 100;
}
function range$1(color1, color2, options2 = {}) {
  if (isRange(color1)) {
    let [r, options3] = [color1, color2];
    return range$1(...r.rangeArgs.colors, { ...r.rangeArgs.options, ...options3 });
  }
  let { space, outputSpace, progression, premultiplied } = options2;
  color1 = getColor(color1);
  color2 = getColor(color2);
  color1 = clone$1(color1);
  color2 = clone$1(color2);
  let rangeArgs = { colors: [color1, color2], options: options2 };
  if (space) {
    space = ColorSpace.get(space);
  } else {
    space = ColorSpace.registry[defaults$1.interpolationSpace] || color1.space;
  }
  outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
  color1 = to(color1, space);
  color2 = to(color2, space);
  color1 = toGamut(color1);
  color2 = toGamut(color2);
  if (space.coords.h && space.coords.h.type === "angle") {
    let arc = options2.hue = options2.hue || "shorter";
    let hue = [space, "h"];
    let [θ1, θ2] = [get$1(color1, hue), get$1(color2, hue)];
    if (isNaN(θ1) && !isNaN(θ2)) {
      θ1 = θ2;
    } else if (isNaN(θ2) && !isNaN(θ1)) {
      θ2 = θ1;
    }
    [θ1, θ2] = adjust(arc, [θ1, θ2]);
    set(color1, hue, θ1);
    set(color2, hue, θ2);
  }
  if (premultiplied) {
    color1.coords = color1.coords.map((c) => c * color1.alpha);
    color2.coords = color2.coords.map((c) => c * color2.alpha);
  }
  return Object.assign((p2) => {
    p2 = progression ? progression(p2) : p2;
    let coords = color1.coords.map((start2, i) => {
      let end = color2.coords[i];
      return interpolate(start2, end, p2);
    });
    let alpha = interpolate(color1.alpha, color2.alpha, p2);
    let ret = { space, coords, alpha };
    if (premultiplied) {
      ret.coords = ret.coords.map((c) => c / alpha);
    }
    if (outputSpace !== space) {
      ret = to(ret, outputSpace);
    }
    return ret;
  }, {
    rangeArgs
  });
}
function isRange(val) {
  return type$1(val) === "function" && !!val.rangeArgs;
}
defaults$1.interpolationSpace = "lab";
const HSL$1 = new ColorSpace({
  id: "hsl",
  name: "HSL",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: sRGB,
  // Adapted from https://drafts.csswg.org/css-color-4/better-rgbToHsl.js
  fromBase: (rgb) => {
    let max = Math.max(...rgb);
    let min = Math.min(...rgb);
    let [r, g2, b2] = rgb;
    let [h, s, l] = [NaN, 0, (min + max) / 2];
    let d2 = max - min;
    if (d2 !== 0) {
      s = l === 0 || l === 1 ? 0 : (max - l) / Math.min(l, 1 - l);
      switch (max) {
        case r:
          h = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h = (b2 - r) / d2 + 2;
          break;
        case b2:
          h = (r - g2) / d2 + 4;
      }
      h = h * 60;
    }
    if (s < 0) {
      h += 180;
      s = Math.abs(s);
    }
    if (h >= 360) {
      h -= 360;
    }
    return [h, s * 100, l * 100];
  },
  // Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative
  toBase: (hsl) => {
    let [h, s, l] = hsl;
    h = h % 360;
    if (h < 0) {
      h += 360;
    }
    s /= 100;
    l /= 100;
    function f(n2) {
      let k = (n2 + h / 30) % 12;
      let a = s * Math.min(l, 1 - l);
      return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
    }
    return [f(0), f(8), f(4)];
  },
  formats: {
    "hsl": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    },
    "hsla": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
      commas: true,
      lastAlpha: true
    }
  }
});
const HSV = new ColorSpace({
  id: "hsv",
  name: "HSV",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    v: {
      range: [0, 100],
      name: "Value"
    }
  },
  base: HSL$1,
  // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
  fromBase(hsl) {
    let [h, s, l] = hsl;
    s /= 100;
    l /= 100;
    let v = l + s * Math.min(l, 1 - l);
    return [
      h,
      // h is the same
      v === 0 ? 0 : 200 * (1 - l / v),
      // s
      100 * v
    ];
  },
  // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
  toBase(hsv) {
    let [h, s, v] = hsv;
    s /= 100;
    v /= 100;
    let l = v * (1 - s / 2);
    return [
      h,
      // h is the same
      l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,
      l * 100
    ];
  },
  formats: {
    color: {
      id: "--hsv",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
const HWB$1 = new ColorSpace({
  id: "hwb",
  name: "HWB",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    w: {
      range: [0, 100],
      name: "Whiteness"
    },
    b: {
      range: [0, 100],
      name: "Blackness"
    }
  },
  base: HSV,
  fromBase(hsv) {
    let [h, s, v] = hsv;
    return [h, v * (100 - s) / 100, 100 - v];
  },
  toBase(hwb) {
    let [h, w, b2] = hwb;
    w /= 100;
    b2 /= 100;
    let sum = w + b2;
    if (sum >= 1) {
      let gray = w / sum;
      return [h, 0, gray * 100];
    }
    let v = 1 - b2;
    let s = v === 0 ? 0 : 1 - w / v;
    return [h, s * 100, v * 100];
  },
  formats: {
    "hwb": {
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
const OKLCH$1 = new ColorSpace({
  id: "oklch",
  name: "Oklch",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    c: {
      refRange: [0, 0.4],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  white: "D65",
  base: OKLab,
  fromBase(oklab) {
    let [L, a, b2] = oklab;
    let h;
    const ε2 = 2e-4;
    if (Math.abs(a) < ε2 && Math.abs(b2) < ε2) {
      h = NaN;
    } else {
      h = Math.atan2(b2, a) * 180 / Math.PI;
    }
    return [
      L,
      // OKLab L is still L
      Math.sqrt(a ** 2 + b2 ** 2),
      // Chroma
      constrain$1(h)
      // Hue, in degrees [0 to 360)
    ];
  },
  // Convert from polar form
  toBase(oklch) {
    let [L, C, h] = oklch;
    let a, b2;
    if (isNaN(h)) {
      a = 0;
      b2 = 0;
    } else {
      a = C * Math.cos(h * Math.PI / 180);
      b2 = C * Math.sin(h * Math.PI / 180);
    }
    return [L, a, b2];
  },
  formats: {
    "oklch": {
      coords: ["<percentage> | <number>", "<number> | <percentage>[0,1]", "<number> | <angle>"]
    }
  }
});
var HSBSpace = new ColorSpace({
  id: "hsb",
  name: "HSB",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    b: {
      range: [0, 100],
      name: "Brightness"
    }
  },
  base: sRGB,
  fromBase: (rgb) => {
    const val = Math.max(...rgb);
    const chroma = val - Math.min(...rgb);
    let [red, green, blue] = rgb;
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      sat = chroma / val;
      if (red === val) {
        hue = (green - blue) / chroma;
      } else if (green === val) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6 * 360, sat * 100, val * 100];
  },
  toBase,
  formats: {
    default: {
      type: "custom",
      serialize: (coords, alpha) => {
        const rgb = toBase(coords);
        let ret = `rgb(${Math.round(rgb[0] * 100 * 100) / 100}% ${Math.round(rgb[1] * 100 * 100) / 100}% ${Math.round(rgb[2] * 100 * 100) / 100}%`;
        if (alpha < 1) {
          ret += ` / ${alpha}`;
        }
        ret += ")";
        return ret;
      }
    },
    "hsb": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    },
    "hsba": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
      commans: true,
      lastAlpha: true
    }
  }
});
function toBase(hsb) {
  const hue = hsb[0] / 360 * 6;
  const sat = hsb[1] / 100;
  const val = hsb[2] / 100;
  let RGB2 = [];
  if (sat === 0) {
    RGB2 = [val, val, val];
  } else {
    const sector = Math.floor(hue);
    const tint1 = val * (1 - sat);
    const tint2 = val * (1 - sat * (hue - sector));
    const tint3 = val * (1 - sat * (1 + sector - hue));
    let red, green, blue;
    if (sector === 1) {
      red = tint2;
      green = val;
      blue = tint1;
    } else if (sector === 2) {
      red = tint1;
      green = val;
      blue = tint3;
    } else if (sector === 3) {
      red = tint1;
      green = tint2;
      blue = val;
    } else if (sector === 4) {
      red = tint3;
      green = tint1;
      blue = val;
    } else if (sector === 5) {
      red = val;
      green = tint1;
      blue = tint2;
    } else {
      red = val;
      green = tint3;
      blue = tint1;
    }
    RGB2 = [red, green, blue];
  }
  return RGB2;
}
const map = (n2, start1, stop1, start2, stop2, clamp2) => {
  let result = (n2 - start1) / (stop1 - start1) * (stop2 - start2) + start2;
  if (clamp2) {
    result = Math.max(result, Math.min(start2, stop2));
    result = Math.min(result, Math.max(start2, stop2));
  }
  return result;
};
const serializationMap = {};
class Color {
  // Reference to underlying color object depending on implementation
  // Not meant to be used publicly unless the implementation is known for sure
  _color;
  // Color mode of the Color object, uses p5 color modes
  mode;
  static colorMap = {};
  static #colorjsMaxes = {};
  static #grayscaleMap = {};
  // Used to add additional color modes to p5.js
  // Uses underlying library's definition
  static addColorMode(mode, definition) {
    ColorSpace.register(definition);
    Color.colorMap[mode] = definition.id;
    Color.#colorjsMaxes[mode] = Object.values(definition.coords).reduce((acc, v) => {
      acc.push(v.refRange || v.range);
      return acc;
    }, []);
    Color.#colorjsMaxes[mode].push([0, 1]);
    Color.#grayscaleMap[mode] = definition.fromGray;
  }
  constructor(vals, colorMode, colorMaxes, { clamp: clamp2 = false } = {}) {
    this.mode = colorMode || RGB;
    if (vals instanceof Color) {
      const mode = colorMode ? Color.colorMap[colorMode] : Color.colorMap[vals.mode];
      this._color = to(vals._color, mode);
      this.mode = mode;
    } else if (typeof vals === "object" && !Array.isArray(vals) && vals !== null) {
      const mode = colorMode ? Color.colorMap[colorMode] : vals.spaceId;
      this._color = to(vals, mode);
      this.mode = colorMode || Object.entries(Color.colorMap).find(([key, val]) => {
        return val === this._color.spaceId;
      });
    } else if (typeof vals[0] === "string") {
      try {
        this._color = parse$4(vals[0]);
        const [mode] = Object.entries(Color.colorMap).find(([key, val]) => {
          return val === this._color.spaceId;
        });
        this.mode = mode;
        this._color = to(this._color, this._color.spaceId);
      } catch (err) {
        throw new Error("Invalid color string");
      }
    } else {
      let mappedVals;
      if (colorMaxes) {
        if (vals.length === 4) {
          mappedVals = Color.mapColorRange(vals, this.mode, colorMaxes, clamp2);
        } else if (vals.length === 3) {
          mappedVals = Color.mapColorRange(
            [vals[0], vals[1], vals[2]],
            this.mode,
            colorMaxes,
            clamp2
          );
          mappedVals.push(1);
        } else if (vals.length === 2) {
          if (Color.#grayscaleMap[this.mode]) {
            mappedVals = Color.#grayscaleMap[this.mode](
              vals[0],
              colorMaxes,
              clamp2
            );
          } else {
            mappedVals = Color.mapColorRange(
              [vals[0], vals[0], vals[0]],
              this.mode,
              colorMaxes,
              clamp2
            );
          }
          const alphaMaxes = Array.isArray(colorMaxes[colorMaxes.length - 1]) ? colorMaxes[colorMaxes.length - 1] : [0, colorMaxes[colorMaxes.length - 1]];
          mappedVals.push(
            map(
              vals[1],
              alphaMaxes[0],
              alphaMaxes[1],
              0,
              1,
              clamp2
            )
          );
        } else if (vals.length === 1) {
          if (Color.#grayscaleMap[this.mode]) {
            mappedVals = Color.#grayscaleMap[this.mode](
              vals[0],
              colorMaxes,
              clamp2
            );
          } else {
            mappedVals = Color.mapColorRange(
              [vals[0], vals[0], vals[0]],
              this.mode,
              colorMaxes,
              clamp2
            );
          }
          mappedVals.push(1);
        } else {
          throw new Error("Invalid color");
        }
      } else {
        mappedVals = vals;
      }
      const space = Color.colorMap[this.mode] || console.error("Invalid color mode");
      const coords = mappedVals.slice(0, 3);
      const color2 = {
        space,
        coords,
        alpha: mappedVals[3]
      };
      this._color = to(color2, space);
    }
  }
  // Convert from p5 color range to color.js color range
  static mapColorRange(origin, mode, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const colorjsMaxes = Color.#colorjsMaxes[mode];
    return origin.map((channel, i) => {
      const newval = map(
        channel,
        p5Maxes[i][0],
        p5Maxes[i][1],
        colorjsMaxes[i][0],
        colorjsMaxes[i][1],
        clamp2
      );
      return newval;
    });
  }
  // Convert from color.js color range to p5 color range
  static unmapColorRange(origin, mode, maxes) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const colorjsMaxes = Color.#colorjsMaxes[mode];
    return origin.map((channel, i) => {
      const newval = map(
        channel,
        colorjsMaxes[i][0],
        colorjsMaxes[i][1],
        p5Maxes[i][0],
        p5Maxes[i][1]
      );
      return newval;
    });
  }
  // Will do conversion in-Gamut as out of Gamut conversion is only really useful for futher conversions
  #toColorMode(mode) {
    return new Color(this._color, mode);
  }
  // Get raw coordinates of underlying library, can differ between libraries
  get _array() {
    return this._getRGBA();
  }
  array() {
    return this._array;
  }
  lerp(color2, amt, mode) {
    let spaceIndex = -1;
    while ((spaceIndex + 1 < this._color.space.path.length || spaceIndex + 1 < color2._color.space.path.length) && this._color.space.path[spaceIndex + 1] === color2._color.space.path[spaceIndex + 1]) {
      spaceIndex += 1;
    }
    if (spaceIndex === -1) {
      throw new Error("Cannot lerp colors. No common color space found");
    }
    const obj = range$1(this._color, color2._color, {
      space: this._color.space.path[spaceIndex].id
    })(amt);
    return new Color(obj, mode || this.mode);
  }
  /**
   * Returns the color formatted as a `String`.
   *
   * Calling `myColor.toString()` can be useful for debugging, as in
   * `print(myColor.toString())`. It's also helpful for using p5.js with other
   * libraries.
   *
   * The parameter, `format`, is optional. If a format string is passed, as in
   * `myColor.toString('#rrggbb')`, it will determine how the color string is
   * formatted. By default, color strings are formatted as `'rgba(r, g, b, a)'`.
   *
   * @param {String} [format] how the color string will be formatted.
   * Leaving this empty formats the string as rgba(r, g, b, a).
   * '#rgb' '#rgba' '#rrggbb' and '#rrggbbaa' format as hexadecimal color codes.
   * 'rgb' 'hsb' and 'hsl' return the color formatted in the specified color mode.
   * 'rgba' 'hsba' and 'hsla' are the same as above but with alpha channels.
   * 'rgb%' 'hsb%' 'hsl%' 'rgba%' 'hsba%' and 'hsla%' format as percentages.
   * @return {String} the formatted string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let myColor = color('darkorchid');
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the text.
   *   text(myColor.toString('#rrggbb'), 50, 50);
   *
   *   describe('The text "#9932cc" written in purple on a gray background.');
   * }
   * </code>
   * </div>
   */
  toString(format) {
    const key = `${this._color.space.id}-${this._color.coords.join(",")}-${this._color.alpha}-${format}`;
    let colorString = serializationMap[key];
    if (!colorString) {
      colorString = serialize(this._color, {
        format
      });
      serializationMap[key] = colorString;
    }
    return colorString;
  }
  /**
   * Checks the contrast between two colors. This method returns a boolean
   * value to indicate if the two color has enough contrast. `true` means that
   * the colors has enough contrast to be used as background color and body
   * text color. `false` means there is not enough contrast.
   *
   * A second argument can be passed to the method, `options` , which defines
   * the algorithm to be used. The algorithms currently supported are
   * WCAG 2.1 (`'WCAG21'`) or APCA (`'APCA'`). The default is WCAG 2.1. If a
   * value of `'all'` is passed to the `options` argument, an object containing
   * more details is returned. The details object will include the calculated
   * contrast value of the colors and different passing criteria.
   *
   * For more details about color contrast, you can check out
   * <a href="https://colorjs.io/docs/contrast">this page from color.js</a>, and the
   * <a href="https://webaim.org/resources/contrastchecker/">WebAIM color contrast checker.</a>
   *
   * @param {Color} other
   * @returns {boolean|object}
   * @example
   * <div>
   * <code>
   * let bgColor, fg1Color, fg2Color, msg1, msg2;
   * function setup() {
   *   createCanvas(100, 100);
   *   bgColor = color(0);
   *   fg1Color = color(100);
   *   fg2Color = color(220);
   *
   *   if(bgColor.contrast(fg1Color)){
   *     msg1 = 'good';
   *   }else{
   *     msg1 = 'bad';
   *   }
   *
   *   if(bgColor.contrast(fg2Color)){
   *     msg2 = 'good';
   *   }else{
   *     msg2 = 'bad';
   *   }
   *
   *   describe('A black canvas with a faint grey word saying "bad" at the top left and a brighter light grey word saying "good" in the middle of the canvas.');
   * }
   *
   * function draw(){
   *   background(bgColor);
   *
   *   textSize(18);
   *
   *   fill(fg1Color);
   *   text(msg1, 10, 30);
   *
   *   fill(fg2Color);
   *   text(msg2, 10, 60);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let bgColor, fgColor, contrast;
   * function setup() {
   *   createCanvas(100, 100);
   *   bgColor = color(0);
   *   fgColor = color(200);
   *   contrast = bgColor.contrast(fgColor, 'all');
   *
   *   describe('A black canvas with four short lines of grey text that respectively says: "WCAG 2.1", "12.55", "APCA", and "-73.30".');
   * }
   *
   * function draw(){
   *   background(bgColor);
   *
   *   textSize(14);
   *
   *   fill(fgColor);
   *   text('WCAG 2.1', 10, 25);
   *   text(nf(contrast.WCAG21.value, 0, 2), 10, 40);
   *
   *   text('APCA', 10, 70);
   *   text(nf(contrast.APCA.value, 0, 2), 10, 85);
   * }
   * </code>
   * </div>
   */
  contrast(other_color, options2 = "WCAG21") {
    if (options2 !== "all") {
      let contrastVal, minimum;
      switch (options2) {
        case "WCAG21":
          contrastVal = contrastWCAG21(this._color, other_color._color);
          minimum = 4.5;
          break;
        case "APCA":
          contrastVal = Math.abs(contrastAPCA(this._color, other_color._color));
          minimum = 75;
          break;
        default:
          return null;
      }
      return contrastVal >= minimum;
    } else {
      const wcag21Value = contrastWCAG21(this._color, other_color._color);
      const apcaValue = contrastAPCA(this._color, other_color._color);
      return {
        WCAG21: {
          value: wcag21Value,
          passedMinimum: wcag21Value >= 4.5,
          passedAAA: wcag21Value >= 7
        },
        APCA: {
          value: apcaValue,
          passedMinimum: Math.abs(apcaValue) >= 75
        }
      };
    }
  }
  /**
   * Sets the red component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} red the new red value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the red value.
   *   c.setRed(64);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is teal.');
   * }
   * </code>
   * </div>
   */
  setRed(new_red, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[RGB][0];
    const newval = map(new_red, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[0] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[0] = newval;
      this._color = to(representation, space);
    }
  }
  /**
   * Sets the green component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} green the new green value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the green value.
   *   c.setGreen(255);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is yellow.');
   * }
   * </code>
   * </div>
   */
  setGreen(new_green, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[RGB][1];
    const newval = map(new_green, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[1] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[1] = newval;
      this._color = to(representation, space);
    }
  }
  /**
   * Sets the blue component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} blue the new blue value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the blue value.
   *   c.setBlue(255);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is pale fuchsia.');
   * }
   * </code>
   * </div>
   */
  setBlue(new_blue, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[RGB][2];
    const newval = map(new_blue, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[2] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[2] = newval;
      this._color = to(representation, space);
    }
  }
  /**
   * Sets the alpha (transparency) value of a color.
   *
   * The range depends on the
   * <a href="#/p5/colorMode">colorMode()</a>. In the default RGB mode it's
   * between 0 and 255.
   *
   * @param {Number} alpha the new alpha value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the alpha value.
   *   c.setAlpha(128);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is faded pink.');
   * }
   * </code>
   * </div>
   */
  setAlpha(new_alpha, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[this.mode][3];
    const newval = map(new_alpha, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    this._color.alpha = newval;
  }
  _getRGBA(maxes = [1, 1, 1, 1]) {
    const colorjsMaxes = Color.#colorjsMaxes[RGB];
    let coords = structuredClone(to(this._color, "srgb").coords);
    coords.push(this._color.alpha);
    const rangeMaxes = maxes.map((v) => {
      if (!Array.isArray(v)) {
        return [0, v];
      } else {
        return v;
      }
    });
    coords = coords.map((coord, i) => {
      return map(
        coord,
        colorjsMaxes[i][0],
        colorjsMaxes[i][1],
        rangeMaxes[i][0],
        rangeMaxes[i][1]
      );
    });
    return coords;
  }
  _getMode() {
    return this.mode;
  }
  _getRed(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][0];
      return map(
        this._color.coords[0],
        colorjsMax[0],
        colorjsMax[1],
        max[0],
        max[1]
      );
    } else {
      const colorjsMax = Color.#colorjsMaxes[RGB][0];
      return map(to(this._color, "srgb").coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  /**
   * This function extracts the green value from a color object and
   * returns it in the range 0–255 by default. When `colorMode()` is given to an
   * RBG value, the green value within the givin range is returned
   */
  _getGreen(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][1];
      return map(
        this._color.coords[1],
        colorjsMax[0],
        colorjsMax[1],
        max[0],
        max[1]
      );
    } else {
      const colorjsMax = Color.#colorjsMaxes[RGB][1];
      return map(to(this._color, "srgb").coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getBlue(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][2];
      return map(
        this._color.coords[2],
        colorjsMax[0],
        colorjsMax[1],
        max[0],
        max[1]
      );
    } else {
      const colorjsMax = Color.#colorjsMaxes[RGB][2];
      return map(to(this._color, "srgb").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getAlpha(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[this.mode][3];
    return map(this._color.alpha, colorjsMax[0], colorjsMax[1], max[0], max[1]);
  }
  /**
   * Hue is the same in HSB and HSL, but the maximum value may be different.
   * This function will return the HSB-normalized saturation when supplied with
   * an HSB color object, but will default to the HSL-normalized saturation
   * otherwise.
   */
  _getHue(max = [0, 360]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB || this.mode === HSL) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][0];
      return map(
        this._color.coords[0],
        colorjsMax[0],
        colorjsMax[1],
        max[0],
        max[1]
      );
    } else {
      const colorjsMax = Color.#colorjsMaxes[HSL][0];
      return map(to(this._color, "hsl").coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  /**
   * Saturation is scaled differently in HSB and HSL. This function will return
   * the HSB saturation when supplied with an HSB color object, but will default
   * to the HSL saturation otherwise.
   */
  _getSaturation(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB || this.mode === HSL) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][1];
      return map(
        this._color.coords[1],
        colorjsMax[0],
        colorjsMax[1],
        max[0],
        max[1]
      );
    } else {
      const colorjsMax = Color.#colorjsMaxes[HSL][1];
      return map(to(this._color, "hsl").coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  /**
   * Brightness obtains the HSB brightness value from either a p5.Color object,
   * an array of color components, or a CSS color string.Depending on value,
   * when `colorMode()` is set to HSB, this function will return the
   * brightness value in the range. By default, this function will return
   * the HSB brightness within the range 0 - 100.
   */
  _getBrightness(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][2];
      return map(
        this._color.coords[2],
        colorjsMax[0],
        colorjsMax[1],
        max[0],
        max[1]
      );
    } else {
      const colorjsMax = Color.#colorjsMaxes[HSB][2];
      return map(to(this._color, "hsb").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getLightness(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSL) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][2];
      return map(
        this._color.coords[2],
        colorjsMax[0],
        colorjsMax[1],
        max[0],
        max[1]
      );
    } else {
      const colorjsMax = Color.#colorjsMaxes[HSL][2];
      return map(to(this._color, "hsl").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
}
function color$1(p53, fn2, lifecycles) {
  p53.Color = Color;
  sRGB.fromGray = P3.fromGray = function(val, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val, p5Maxes[2][0], p5Maxes[2][1], 0, 1, clamp2);
    return [v, v, v];
  };
  HSBSpace.fromGray = HSL$1.fromGray = function(val, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val, p5Maxes[2][0], p5Maxes[2][1], 0, 100, clamp2);
    return [0, 0, v];
  };
  HWB$1.fromGray = function(val, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const wbMax = Math.abs(p5Maxes[1][0] - p5Maxes[1][1]) / 2 + Math.abs(p5Maxes[2][0] - p5Maxes[2][1]) / 2;
    const nVal = map(val, 0, wbMax, 0, 100);
    let white2, black;
    if (nVal < 50) {
      black = nVal;
      white2 = 100 - nVal;
    } else if (nVal >= 50) {
      white2 = nVal;
      black = 100 - nVal;
    }
    return [0, white2, black];
  };
  Lab.fromGray = LCH$1.fromGray = OKLab.fromGray = OKLCH$1.fromGray = function(val, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val, p5Maxes[0][0], p5Maxes[0][1], 0, 100, clamp2);
    return [v, 0, 0];
  };
  p53.Color.addColorMode(RGB, sRGB);
  p53.Color.addColorMode(RGBHDR, P3);
  p53.Color.addColorMode(HSB, HSBSpace);
  p53.Color.addColorMode(HSL, HSL$1);
  p53.Color.addColorMode(HWB, HWB$1);
  p53.Color.addColorMode(LAB, Lab);
  p53.Color.addColorMode(LCH, LCH$1);
  p53.Color.addColorMode(OKLAB, OKLab);
  p53.Color.addColorMode(OKLCH, OKLCH$1);
  lifecycles.presetup = function() {
    const pInst = this;
    const setMethods = ["Red", "Green", "Blue", "Alpha"];
    for (let i in setMethods) {
      const method = setMethods[i];
      const setCopy = p53.Color.prototype["set" + method];
      p53.Color.prototype["set" + method] = function(newval, max) {
        max = max || pInst?._renderer?.states?.colorMaxes?.[RGB][i];
        return setCopy.call(this, newval, max);
      };
    }
    function decorateGet(channel, modes) {
      const getCopy = p53.Color.prototype["_get" + channel];
      p53.Color.prototype["_get" + channel] = function(max) {
        if (Object.keys(modes).includes(this.mode)) {
          max = max || pInst?._renderer?.states?.colorMaxes?.[this.mode][modes[this.mode]];
        } else {
          const defaultMode = Object.keys(modes)[0];
          max = max || pInst?._renderer?.states?.colorMaxes?.[defaultMode][modes[defaultMode]];
        }
        return getCopy.call(this, max);
      };
    }
    decorateGet("Red", {
      [RGB]: 0,
      [RGBHDR]: 0
    });
    decorateGet("Green", {
      [RGB]: 1,
      [RGBHDR]: 1
    });
    decorateGet("Blue", {
      [RGB]: 2,
      [RGBHDR]: 2
    });
    decorateGet("Alpha", {
      [RGB]: 3,
      [RGBHDR]: 3,
      [HSB]: 3,
      [HSL]: 3,
      [HWB]: 3,
      [LAB]: 3,
      [LCH]: 3,
      [OKLAB]: 3,
      [OKLCH]: 3
    });
    decorateGet("Hue", {
      [HSL]: 0,
      [HSB]: 0,
      [HWB]: 0,
      [LCH]: 2,
      [OKLCH]: 2
    });
    decorateGet("Saturation", {
      [HSL]: 1,
      [HSB]: 1
    });
    decorateGet("Brightness", {
      [HSB]: 2
    });
    decorateGet("Lightness", {
      [HSL]: 2
    });
  };
}
if (typeof p5 !== "undefined") {
  color$1(p5, p5.prototype);
}
const RGB = "rgb";
const RGBHDR = "rgbhdr";
const HSB = "hsb";
const HSL = "hsl";
const HWB = "hwb";
const LAB = "lab";
const LCH = "lch";
const OKLAB = "oklab";
const OKLCH = "oklch";
const RGBA = "rgba";
function creatingReading(p53, fn2) {
  fn2.RGB = RGB;
  fn2.RGBHDR = RGBHDR;
  fn2.HSB = HSB;
  fn2.HSL = HSL;
  fn2.HWB = HWB;
  fn2.LAB = LAB;
  fn2.LCH = LCH;
  fn2.OKLAB = OKLAB;
  fn2.OKLCH = OKLCH;
  fn2.RGBA = RGBA;
  p53.Renderer.states.colorMode = RGB;
  p53.Renderer.states.colorMaxes = {
    [RGB]: [255, 255, 255, 255],
    [RGBHDR]: [255, 255, 255, 255],
    [HSB]: [360, 100, 100, 1],
    [HSL]: [360, 100, 100, 1],
    [HWB]: [360, 100, 100, 1],
    [LAB]: [100, [-125, 125], [-125, 125], 1],
    [LCH]: [100, 150, 360, 1],
    [OKLAB]: [100, [-125, 125], [-125, 125], 1],
    [OKLCH]: [100, 150, 360, 1],
    clone: function() {
      const cloned = { ...this };
      for (const key in cloned) {
        if (cloned[key] instanceof Array) {
          cloned[key] = [...cloned[key]];
        }
      }
      return cloned;
    }
  };
  fn2.color = function(...args) {
    if (args[0] instanceof Color) {
      return args[0];
    }
    const arg = Array.isArray(args[0]) ? args[0] : args;
    return new Color(
      arg,
      this._renderer.states.colorMode,
      this._renderer.states.colorMaxes[this._renderer.states.colorMode],
      { clamp: true }
    );
  };
  fn2.red = function(c) {
    return this.color(c)._getRed();
  };
  fn2.green = function(c) {
    return this.color(c)._getGreen();
  };
  fn2.blue = function(c) {
    return this.color(c)._getBlue();
  };
  fn2.alpha = function(c) {
    return this.color(c)._getAlpha();
  };
  fn2.hue = function(c) {
    let colorMode = HSL;
    let i = 0;
    if (this._renderer.states.colorMode === HSB || this._renderer.states.colorMode === HSL) {
      colorMode = this._renderer.states.colorMode;
    } else if (this._renderer.states.colorMode === LCH || this._renderer.states.colorMode === OKLCH) {
      colorMode = this._renderer.states.colorMode;
      i = 2;
    }
    return this.color(c)._getHue(
      this._renderer.states.colorMaxes[colorMode][i]
    );
  };
  fn2.saturation = function(c) {
    const colorMode = this._renderer.states.colorMode === HSB ? HSB : HSL;
    return this.color(c)._getSaturation(
      this._renderer.states.colorMaxes[colorMode][1]
    );
  };
  fn2.brightness = function(c) {
    return this.color(c)._getBrightness(
      this._renderer.states.colorMaxes.hsb[2]
    );
  };
  fn2.lightness = function(c) {
    return this.color(c)._getLightness(
      this._renderer.states.colorMaxes.hsl[2]
    );
  };
  fn2.lerpColor = function(c12, c22, amt) {
    return c12.lerp(c22, amt, this._renderer.states.colorMode);
  };
  fn2.paletteLerp = function(color_stops, amt) {
    const first_color_stop = color_stops[0];
    if (amt < first_color_stop[1])
      return this.color(first_color_stop[0]);
    for (let i = 1; i < color_stops.length; i++) {
      const color_stop = color_stops[i];
      if (amt < color_stop[1]) {
        const prev_color_stop = color_stops[i - 1];
        return this.lerpColor(
          this.color(prev_color_stop[0]),
          this.color(color_stop[0]),
          (amt - prev_color_stop[1]) / (color_stop[1] - prev_color_stop[1])
        );
      }
    }
    return this.color(color_stops[color_stops.length - 1][0]);
  };
}
if (typeof p5 !== "undefined") {
  creatingReading(p5, p5.prototype);
}
class XML {
  constructor(DOM) {
    if (!DOM) {
      const xmlDoc = document.implementation.createDocument(null, "doc");
      this.DOM = xmlDoc.createElement("root");
    } else {
      this.DOM = DOM;
    }
  }
  /**
   * Returns the element's parent element as a new <a href="#/p5.XML">p5.XML</a>
   * object.
   *
   * @return {p5.XML} parent element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array with all mammal elements.
   *   let mammals = myXML.getChildren('mammal');
   *
   *   // Get the first mammal element.
   *   let firstMammal = mammals[0];
   *
   *   // Get the parent element.
   *   let parent = firstMammal.getParent();
   *
   *   // Get the parent element's name.
   *   let name = parent.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the parent element's name.
   *   text(name, 50, 50);
   *
   *   describe('The word "animals" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  getParent() {
    return new XML(this.DOM.parentElement);
  }
  /**
   * Returns the element's name as a `String`.
   *
   * An XML element's name is given by its tag. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the name `language`.
   *
   * @return {String} name of the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array with all mammal elements.
   *   let mammals = myXML.getChildren('mammal');
   *
   *   // Get the first mammal element.
   *   let firstMammal = mammals[0];
   *
   *   // Get the mammal element's name.
   *   let name = firstMammal.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's name.
   *   text(name, 50, 50);
   *
   *   describe('The word "mammal" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  getName() {
    return this.DOM.tagName;
  }
  /**
   * Sets the element's tag name.
   *
   * An XML element's name is given by its tag. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the name `language`.
   *
   * The parameter, `name`, is the element's new name as a string. For example,
   * calling `myXML.setName('planet')` will make the element's new tag name
   * `&lt;planet&gt;&lt;/planet&gt;`.
   *
   * @param {String} name new tag name of the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the element's original name.
   *   let oldName = myXML.getName();
   *
   *   // Set the element's name.
   *   myXML.setName('monsters');
   *
   *   // Get the element's new name.
   *   let newName = myXML.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's names.
   *   text(oldName, 50, 33);
   *   text(newName, 50, 67);
   *
   *   describe(
   *     'The words "animals" and "monsters" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code></div>
   */
  setName(name) {
    const content = this.DOM.innerHTML;
    const attributes2 = this.DOM.attributes;
    const xmlDoc = document.implementation.createDocument(null, "default");
    const newDOM = xmlDoc.createElement(name);
    newDOM.innerHTML = content;
    for (let i = 0; i < attributes2.length; i++) {
      newDOM.setAttribute(attributes2[i].nodeName, attributes2[i].nodeValue);
    }
    this.DOM = newDOM;
  }
  /**
   * Returns `true` if the element has child elements and `false` if not.
   *
   * @return {boolean} whether the element has children.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Check whether the element has child elements.
   *   let isParent = myXML.hasChildren();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Style the text.
   *   if (isParent === true) {
   *     text('Parent', 50, 50);
   *   } else {
   *     text('Not Parent', 50, 50);
   *   }
   *
   *   describe('The word "Parent" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  hasChildren() {
    return this.DOM.children.length > 0;
  }
  /**
   * Returns an array with the names of the element's child elements as
   * `String`s.
   *
   * @return {String[]} names of the child elements.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the names of the element's children as an array.
   *   let children = myXML.listChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Display the child element's name.
   *     text(children[i], 10, y);
   *   }
   *
   *   describe(
   *     'The words "mammal", "mammal", "mammal", and "reptile" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */
  listChildren() {
    const arr2 = [];
    for (let i = 0; i < this.DOM.childNodes.length; i++) {
      arr2.push(this.DOM.childNodes[i].nodeName);
    }
    return arr2;
  }
  /**
   * Returns an array with the element's child elements as new
   * <a href="#/p5.XML">p5.XML</a> objects.
   *
   * The parameter, `name`, is optional. If a string is passed, as in
   * `myXML.getChildren('cat')`, then the method will only return child elements
   * with the tag `&lt;cat&gt;`.
   *
   * @param {String} [name] name of the elements to return.
   * @return {p5.XML[]} child elements.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array of the child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", "Zebra", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array of the child elements
   *   // that are mammals.
   *   let children = myXML.getChildren('mammal');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", and "Zebra" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */
  getChildren(param) {
    if (param) {
      return elementsToP5XML(this.DOM.getElementsByTagName(param));
    } else {
      return elementsToP5XML(this.DOM.children);
    }
  }
  /**
   * Returns the first matching child element as a new
   * <a href="#/p5.XML">p5.XML</a> object.
   *
   * The parameter, `name`, is optional. If a string is passed, as in
   * `myXML.getChild('cat')`, then the first child element with the tag
   * `&lt;cat&gt;` will be returned. If a number is passed, as in
   * `myXML.getChild(1)`, then the child element at that index will be returned.
   *
   * @param {String|Integer} name element name or index.
   * @return {p5.XML} child element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element that is a mammal.
   *   let goat = myXML.getChild('mammal');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = goat.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Goat" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the child element at index 1.
   *   let leopard = myXML.getChild(1);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = leopard.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Leopard" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  getChild(param) {
    if (typeof param === "string") {
      for (const child of this.DOM.children) {
        if (child.tagName === param) return new XML(child);
      }
    } else {
      return new XML(this.DOM.children[param]);
    }
  }
  /**
   * Adds a new child element and returns a reference to it.
   *
   * The parameter, `child`, is the <a href="#/p5.XML">p5.XML</a> object to add
   * as a child element. For example, calling `myXML.addChild(otherXML)` inserts
   * `otherXML` as a child element of `myXML`.
   *
   * @param {p5.XML} child child element to add.
   * @return {p5.XML} added child element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a new p5.XML object.
   *   let newAnimal = new p5.XML();
   *
   *   // Set its properties.
   *   newAnimal.setName('hydrozoa');
   *   newAnimal.setAttribute('id', 4);
   *   newAnimal.setAttribute('species', 'Physalia physalis');
   *   newAnimal.setContent('Bluebottle');
   *
   *   // Add the child element.
   *   myXML.addChild(newAnimal);
   *
   *   // Get the first child element that is a hydrozoa.
   *   let blueBottle = myXML.getChild('hydrozoa');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = blueBottle.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Bluebottle" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  addChild(node) {
    if (node instanceof XML) {
      this.DOM.appendChild(node.DOM);
    }
  }
  /**
   * Removes the first matching child element.
   *
   * The parameter, `name`, is the child element to remove. If a string is
   * passed, as in `myXML.removeChild('cat')`, then the first child element
   * with the tag `&lt;cat&gt;` will be removed. If a number is passed, as in
   * `myXML.removeChild(1)`, then the child element at that index will be
   * removed.
   *
   * @param {String|Integer} name name or index of the child element to remove.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Remove the first mammal element.
   *   myXML.removeChild('mammal');
   *
   *   // Get an array of child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Leopard", "Zebra", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Remove the element at index 2.
   *   myXML.removeChild(2);
   *
   *   // Get an array of child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */
  removeChild(param) {
    let ind = -1;
    if (typeof param === "string") {
      for (let i = 0; i < this.DOM.children.length; i++) {
        if (this.DOM.children[i].tagName === param) {
          ind = i;
          break;
        }
      }
    } else {
      ind = param;
    }
    if (ind !== -1) {
      this.DOM.removeChild(this.DOM.children[ind]);
    }
  }
  /**
   * Returns the number of attributes the element has.
   *
   * @return {Integer} number of attributes.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element.
   *   let first = myXML.getChild(0);
   *
   *   // Get the number of attributes.
   *   let numAttributes = first.getAttributeCount();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the number of attributes.
   *   text(numAttributes, 50, 50);
   *
   *   describe('The number "2" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  getAttributeCount() {
    return this.DOM.attributes.length;
  }
  /**
   * Returns an `Array` with the names of the element's attributes.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @return {String[]} attribute names.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element.
   *   let first = myXML.getChild(0);
   *
   *   // Get the number of attributes.
   *   let attributes = first.listAttributes();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's attributes.
   *   text(attributes, 50, 50);
   *
   *   describe('The text "id,species" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  listAttributes() {
    const arr2 = [];
    for (const attribute of this.DOM.attributes) {
      arr2.push(attribute.nodeName);
    }
    return arr2;
  }
  /**
   * Returns `true` if the element has a given attribute and `false` if not.
   *
   * The parameter, `name`, is a string with the name of the attribute being
   * checked.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @return {boolean} whether the element has the attribute.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first mammal child element.
   *   let mammal = myXML.getChild('mammal');
   *
   *   // Check whether the element has an
   *   // species attribute.
   *   let hasSpecies = mammal.hasAttribute('species');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display whether the element has a species attribute.
   *   if (hasSpecies === true) {
   *     text('Species', 50, 50);
   *   } else {
   *     text('No species', 50, 50);
   *   }
   *
   *   describe('The text "Species" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  hasAttribute(name) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return obj[name] ? true : false;
  }
  /**
   * Return an attribute's value as a `Number`.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being checked. For example, calling `myXML.getNum('id')` returns the
   * element's `id` attribute as a number.
   *
   * The second parameter, `defaultValue`, is optional. If a number is passed,
   * as in `myXML.getNum('id', -1)`, it will be returned if the attribute
   * doesn't exist or can't be converted to a number.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @param {Number} [defaultValue] value to return if the attribute doesn't exist.
   * @return {Number} attribute value as a number.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's ID.
   *   let id = reptile.getNum('id');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the ID attribute.
   *   text(`${content} is ${id + 1}th`, 5, 50, 90);
   *
   *   describe(`The text "${content} is ${id + 1}th" written in black on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's size.
   *   let weight = reptile.getNum('weight', 135);
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the ID attribute.
   *   text(`${content} is ${weight}kg`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${content} is ${weight}kg" written in black on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */
  getNum(name, defaultValue) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return Number(obj[name]) || defaultValue || 0;
  }
  /**
   * Return an attribute's value as a string.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being checked. For example, calling `myXML.getString('color')` returns the
   * element's `id` attribute as a string.
   *
   * The second parameter, `defaultValue`, is optional. If a string is passed,
   * as in `myXML.getString('color', 'deeppink')`, it will be returned if the
   * attribute doesn't exist.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @param {Number} [defaultValue] value to return if the attribute doesn't exist.
   * @return {String} attribute value as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's species.
   *   let species = reptile.getString('species');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the species attribute.
   *   text(`${content}: ${species}`, 5, 50, 90);
   *
   *   describe(`The text "${content}: ${species}" written in black on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's color.
   *   let attribute = reptile.getString('color', 'green');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *   fill(attribute);
   *
   *   // Display the element's content.
   *   text(content, 50, 50);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   */
  getString(name, defaultValue) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return obj[name] ? String(obj[name]) : defaultValue || null;
  }
  /**
   * Sets an attribute to a given value.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being set.
   *
   * The second parameter, `value`, is the attribute's new value. For example,
   * calling `myXML.setAttribute('id', 123)` sets the `id` attribute to the
   * value 123.
   *
   * @param {String} name name of the attribute to be set.
   * @param {Number|String|Boolean} value attribute's new value.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Set the reptile's color.
   *   reptile.setAttribute('color', 'green');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's color.
   *   let attribute = reptile.getString('color');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(`${content} is ${attribute}`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${content} is ${attribute}" written in green on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */
  setAttribute(name, value) {
    this.DOM.setAttribute(name, value);
  }
  /**
   * Returns the element's content as a `String`.
   *
   * The parameter, `defaultValue`, is optional. If a string is passed, as in
   * `myXML.getContent('???')`, it will be returned if the element has no
   * content.
   *
   * @param {String} [defaultValue] value to return if the element has no
   *                                content.
   * @return {String} element's content as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(content, 5, 50, 90);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.XML object.
   *   let blankSpace = new p5.XML();
   *
   *   // Get the element's content and use a default value.
   *   let content = blankSpace.getContent('Your name');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(content, 5, 50, 90);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   */
  getContent(defaultValue) {
    let str;
    str = this.DOM.textContent;
    str = str.replace(/\s\s+/g, ",");
    return str || defaultValue || null;
  }
  /**
   * Sets the element's content.
   *
   * An element's content is the text between its tags. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the content `JavaScript`.
   *
   * The parameter, `content`, is a string with the element's new content.
   *
   * @method setContent
   * @param {String} content new content for the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's original content.
   *   let oldContent = reptile.getContent();
   *
   *   // Set the reptile's content.
   *   reptile.setContent('Loggerhead');
   *
   *   // Get the reptile's new content.
   *   let newContent = reptile.getContent();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's old and new content.
   *   text(`${oldContent}: ${newContent}`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${oldContent}: ${newContent}" written in green on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */
  setContent(content) {
    if (!this.DOM.children.length) {
      this.DOM.textContent = content;
    }
  }
  /**
   * Returns the element as a `String`.
   *
   * `myXML.serialize()` is useful for sending the element over the network or
   * saving it to a file.
   *
   * @return {String} element as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(12);
   *
   *   // Display instructions.
   *   text('Double-click to save', 5, 50, 90);
   *
   *   describe('The text "Double-click to save" written in black on a gray background.');
   * }
   *
   * // Save the file when the user double-clicks.
   * function doubleClicked() {
   *   // Create a p5.PrintWriter object.
   *   // Use the file format .xml.
   *   let myWriter = createWriter('animals', 'xml');
   *
   *   // Serialize the XML data to a string.
   *   let data = myXML.serialize();
   *
   *   // Write the data to the print stream.
   *   myWriter.write(data);
   *
   *   // Save the file and close the print stream.
   *   myWriter.close();
   * }
   * </code>
   * </div>
   */
  serialize() {
    const xmlSerializer = new XMLSerializer();
    return xmlSerializer.serializeToString(this.DOM);
  }
}
function elementsToP5XML(elements) {
  const arr2 = [];
  for (let i = 0; i < elements.length; i++) {
    arr2.push(new XML(elements[i]));
  }
  return arr2;
}
function xml(p53, fn2) {
  p53.XML = XML;
}
if (typeof p5 !== "undefined") {
  xml(p5, p5.prototype);
}
class File {
  constructor(file2, pInst) {
    this.file = file2;
    this._pInst = pInst;
    const typeList = file2.type.split("/");
    this.type = typeList[0];
    this.subtype = typeList[1];
    this.name = file2.name;
    this.size = file2.size;
    this.data = void 0;
  }
  static _createLoader(theFile, callback) {
    const reader = new FileReader();
    reader.onload = function(e2) {
      const p5file = new File(theFile);
      if (p5file.file.type === "application/json") {
        p5file.data = JSON.parse(e2.target.result);
      } else if (p5file.file.type === "text/xml") {
        const parser = new DOMParser();
        const xml2 = parser.parseFromString(e2.target.result, "text/xml");
        p5file.data = new XML(xml2.documentElement);
      } else {
        p5file.data = e2.target.result;
      }
      callback(p5file);
    };
    return reader;
  }
  static _load(f, callback) {
    if (/^text\//.test(f.type) || f.type === "application/json") {
      File._createLoader(f, callback).readAsText(f);
    } else if (!/^(video|audio)\//.test(f.type)) {
      File._createLoader(f, callback).readAsDataURL(f);
    } else {
      const file2 = new File(f);
      file2.data = URL.createObjectURL(f);
      callback(file2);
    }
  }
}
function file(p53, fn2) {
  p53.File = File;
}
if (typeof p5 !== "undefined") {
  file(p5, p5.prototype);
}
class Element {
  width;
  height;
  elt;
  constructor(elt, pInst) {
    this.elt = elt;
    this._pInst = this._pixelsState = pInst;
    this._events = {};
    this.width = this.elt.offsetWidth;
    this.height = this.elt.offsetHeight;
  }
  /**
   * Removes the element, stops all audio/video streams, and removes all
   * callback functions.
   *
   * @example
   * <div>
   * <code>
   * let p;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element.
   *   p = createP('p5*js');
   *   p.position(10, 10);
   *
   *   describe('The text "p5*js" written at the center of a gray square. ');
   * }
   *
   * // Remove the paragraph when the user double-clicks.
   * function doubleClicked() {
   *   p.remove();
   * }
   * </code>
   * </div>
   */
  remove() {
    if (this.stop) {
      this.stop();
      const sources = this.elt.srcObject;
      if (sources !== null) {
        const tracks = sources.getTracks();
        tracks.forEach((track) => {
          track.stop();
        });
      }
    }
    let sketch2 = this._pInst;
    if (sketch2 && !sketch2._elements && sketch2._pInst) {
      sketch2 = sketch2._pInst;
    }
    if (sketch2 && sketch2._elements) {
      const i = sketch2._elements.indexOf(this);
      if (i !== -1) sketch2._elements.splice(i, 1);
    }
    for (let ev in this._events) {
      this.elt.removeEventListener(ev, this._events[ev]);
    }
    if (this.elt && this.elt.parentNode) {
      this.elt.parentNode.removeChild(this.elt);
    }
  }
  /**
   * Attaches the element to a parent element.
   *
   * For example, a `&lt;div&gt;&lt;/div&gt;` element may be used as a box to
   * hold two pieces of text, a header and a paragraph. The
   * `&lt;div&gt;&lt;/div&gt;` is the parent element of both the header and
   * paragraph.
   *
   * The parameter `parent` can have one of three types. `parent` can be a
   * string with the parent element's ID, as in
   * `myElement.parent('container')`. It can also be another
   * <a href="#/p5.Element">p5.Element</a> object, as in
   * `myElement.parent(myDiv)`. Finally, `parent` can be an `HTMLElement`
   * object, as in `myElement.parent(anotherElement)`.
   *
   * Calling `myElement.parent()` without an argument returns the element's
   * parent.
   *
   * @param  {String|p5.Element|Object} parent ID, <a href="#/p5.Element">p5.Element</a>,
   *                                           or HTMLElement of desired parent element.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup()  {
   *   background(200);
   *
   *   // Create a div element.
   *   let div = createDiv();
   *
   *   // Place the div in the top-left corner.
   *   div.position(10, 20);
   *
   *   // Set its width and height.
   *   div.size(80, 60);
   *
   *   // Set its background color to white
   *   div.style('background-color', 'white');
   *
   *   // Align any text to the center.
   *   div.style('text-align', 'center');
   *
   *   // Set its ID to "container".
   *   div.id('container');
   *
   *   // Create a paragraph element.
   *   let p = createP('p5*js');
   *
   *   // Make the div its parent
   *   // using its ID "container".
   *   p.parent('container');
   *
   *   describe('The text "p5*js" written in black at the center of a white rectangle. The rectangle is inside a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup()  {
   *   background(200);
   *
   *   // Create rectangular div element.
   *   let div = createDiv();
   *
   *   // Place the div in the top-left corner.
   *   div.position(10, 20);
   *
   *   // Set its width and height.
   *   div.size(80, 60);
   *
   *   // Set its background color and align
   *   // any text to the center.
   *   div.style('background-color', 'white');
   *   div.style('text-align', 'center');
   *
   *   // Create a paragraph element.
   *   let p = createP('p5*js');
   *
   *   // Make the div its parent.
   *   p.parent(div);
   *
   *   describe('The text "p5*js" written in black at the center of a white rectangle. The rectangle is inside a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup()  {
   *   background(200);
   *
   *   // Create rectangular div element.
   *   let div = createDiv();
   *
   *   // Place the div in the top-left corner.
   *   div.position(10, 20);
   *
   *   // Set its width and height.
   *   div.size(80, 60);
   *
   *   // Set its background color and align
   *   // any text to the center.
   *   div.style('background-color', 'white');
   *   div.style('text-align', 'center');
   *
   *   // Create a paragraph element.
   *   let p = createP('p5*js');
   *
   *   // Make the div its parent
   *   // using the underlying
   *   // HTMLElement.
   *   p.parent(div.elt);
   *
   *   describe('The text "p5*js" written in black at the center of a white rectangle. The rectangle is inside a gray square.');
   * }
   * </code>
   * </div>
   */
  /**
   * @return {p5.Element}
   */
  parent(p2) {
    if (typeof p2 === "undefined") {
      return this.elt.parentNode;
    }
    if (typeof p2 === "string") {
      if (p2[0] === "#") {
        p2 = p2.substring(1);
      }
      p2 = document.getElementById(p2);
    } else if (p2 instanceof Element) {
      p2 = p2.elt;
    }
    p2.appendChild(this.elt);
    return this;
  }
  /**
   * Attaches the element as a child of another element.
   *
   * `myElement.child()` accepts either a string ID, DOM node, or
   * <a href="#/p5.Element">p5.Element</a>. For example,
   * `myElement.child(otherElement)`. If no argument is provided, an array of
   * children DOM nodes is returned.
   *
   * @returns {Node[]} an array of child nodes.
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div elements.
   *   let div0 = createDiv('Parent');
   *   let div1 = createDiv('Child');
   *
   *   // Make div1 the child of div0
   *   // using the p5.Element.
   *   div0.child(div1);
   *
   *   describe('A gray square with the words "Parent" and "Child" written beneath it.');
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div elements.
   *   let div0 = createDiv('Parent');
   *   let div1 = createDiv('Child');
   *
   *   // Give div1 an ID.
   *   div1.id('apples');
   *
   *   // Make div1 the child of div0
   *   // using its ID.
   *   div0.child('apples');
   *
   *   describe('A gray square with the words "Parent" and "Child" written beneath it.');
   * }
   * </code>
   * </div>
   *
   * <div class='norender notest'>
   * <code>
   * // This example assumes there is a div already on the page
   * // with id "myChildDiv".
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div elements.
   *   let div0 = createDiv('Parent');
   *
   *   // Select the child element by its ID.
   *   let elt = document.getElementById('myChildDiv');
   *
   *   // Make div1 the child of div0
   *   // using its HTMLElement object.
   *   div0.child(elt);
   *
   *   describe('A gray square with the words "Parent" and "Child" written beneath it.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String|p5.Element} [child] the ID, DOM node, or <a href="#/p5.Element">p5.Element</a>
   *                         to add to the current element
   * @chainable
   */
  child(childNode) {
    if (typeof childNode === "undefined") {
      return this.elt.childNodes;
    }
    if (typeof childNode === "string") {
      if (childNode[0] === "#") {
        childNode = childNode.substring(1);
      }
      childNode = document.getElementById(childNode);
    } else if (childNode instanceof Element) {
      childNode = childNode.elt;
    }
    if (childNode instanceof HTMLElement) {
      this.elt.appendChild(childNode);
    }
    return this;
  }
  /**
   * Sets the inner HTML of the element, replacing any existing HTML.
   *
   * The second parameter, `append`, is optional. If `true` is passed, as in
   * `myElement.html('hi', true)`, the HTML is appended instead of replacing
   * existing HTML.
   *
   * If no arguments are passed, as in `myElement.html()`, the element's inner
   * HTML is returned.
   *
   * @for p5.Element
   * @returns {String} the inner HTML of the element
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create the div element and set its size.
   *   let div = createDiv('');
   *   div.size(100, 100);
   *
   *   // Set the inner HTML to "hi".
   *   div.html('hi');
   *
   *   describe('A gray square with the word "hi" written beneath it.');
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div element and set its size.
   *   let div = createDiv('Hello ');
   *   div.size(100, 100);
   *
   *   // Append "World" to the div's HTML.
   *   div.html('World', true);
   *
   *   describe('A gray square with the text "Hello World" written beneath it.');
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div element.
   *   let div = createDiv('Hello');
   *
   *   // Prints "Hello" to the console.
   *   print(div.html());
   *
   *   describe('A gray square with the word "Hello!" written beneath it.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String} [html] the HTML to be placed inside the element
   * @param  {Boolean} [append] whether to append HTML to existing
   * @chainable
   */
  html(...args) {
    if (args.length === 0) {
      return this.elt.innerHTML;
    } else if (args[1]) {
      this.elt.insertAdjacentHTML("beforeend", args[0]);
      return this;
    } else {
      this.elt.innerHTML = args[0];
      return this;
    }
  }
  /**
   * Sets the element's ID using a given string.
   *
   * Calling `myElement.id()` without an argument returns its ID as a string.
   *
   * @param  {String} id ID of the element.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the canvas' ID
   *   // to "mycanvas".
   *   cnv.id('mycanvas');
   *
   *   // Get the canvas' ID.
   *   let id = cnv.id();
   *   text(id, 24, 54);
   *
   *   describe('The text "mycanvas" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  /**
   * @return {String} ID of the element.
   */
  id(id) {
    if (typeof id === "undefined") {
      return this.elt.id;
    }
    this.elt.id = id;
    this.width = this.elt.offsetWidth;
    this.height = this.elt.offsetHeight;
    return this;
  }
  /**
   * Adds a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class" target="_blank">class attribute</a>
   * to the element using a given string.
   *
   * Calling `myElement.class()` without an argument returns a string with its current classes.
   *
   * @param  {String} class class to add.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Add the class "small" to the
   *   // canvas element.
   *   cnv.class('small');
   *
   *   // Get the canvas element's class
   *   // and display it.
   *   let c = cnv.class();
   *   text(c, 35, 54);
   *
   *   describe('The word "small" written in black on a gray canvas.');
   *
   * }
   * </code>
   * </div>
   */
  /**
   * @return {String} element's classes, if any.
   */
  class(c) {
    if (typeof c === "undefined") {
      return this.elt.className;
    }
    this.elt.className = c;
    return this;
  }
  /**
   *
   * Adds a class to the element.
   *
   * @for p5.Element
   * @param  {String} class name of class to add.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element.
   *   let div = createDiv('div');
   *
   *   // Add a class to the div.
   *   div.addClass('myClass');
   *
   *   describe('A gray square.');
   * }
   * </code>
   * </div>
   */
  addClass(c) {
    if (this.elt.className) {
      if (!this.hasClass(c)) {
        this.elt.className = this.elt.className + " " + c;
      }
    } else {
      this.elt.className = c;
    }
    return this;
  }
  /**
   * Removes a class from the element.
   *
   * @param  {String} class name of class to remove.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * // In this example, a class is set when the div is created
   * // and removed when mouse is pressed. This could link up
   * // with a CSS style rule to toggle style properties.
   *
   * let div;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element.
   *   div = createDiv('div');
   *
   *   // Add a class to the div.
   *   div.addClass('myClass');
   *
   *   describe('A gray square.');
   * }
   *
   * // Remove 'myClass' from the div when the user presses the mouse.
   * function mousePressed() {
   *   div.removeClass('myClass');
   * }
   * </code>
   * </div>
   */
  removeClass(c) {
    this.elt.classList.remove(c);
    return this;
  }
  /**
   * Checks if a class is already applied to element.
   *
   * @returns {boolean} a boolean value if element has specified class.
   * @param c {String} name of class to check.
   *
   * @example
   * <div class='norender'>
   * <code>
   * let div;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element.
   *   div = createDiv('div');
   *
   *   // Add the class 'show' to the div.
   *   div.addClass('show');
   *
   *   describe('A gray square.');
   * }
   *
   * // Toggle the class 'show' when the mouse is pressed.
   * function mousePressed() {
   *   if (div.hasClass('show')) {
   *     div.addClass('show');
   *   } else {
   *     div.removeClass('show');
   *   }
   * }
   * </code>
   * </div>
   */
  hasClass(c) {
    return this.elt.classList.contains(c);
  }
  /**
   * Toggles whether a class is applied to the element.
   *
   * @param c {String} class name to toggle.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * let div;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element.
   *   div = createDiv('div');
   *
   *   // Add the 'show' class to the div.
   *   div.addClass('show');
   *
   *   describe('A gray square.');
   * }
   *
   * // Toggle the 'show' class when the mouse is pressed.
   * function mousePressed() {
   *   div.toggleClass('show');
   * }
   * </code>
   * </div>
   */
  toggleClass(c) {
    if (this.elt.classList.contains(c)) {
      this.elt.classList.remove(c);
    } else {
      this.elt.classList.add(c);
    }
    return this;
  }
  /**
   * Centers the element either vertically, horizontally, or both.
   *
   * `center()` will center the element relative to its parent or according to
   * the page's body if the element has no parent.
   *
   * If no argument is passed, as in `myElement.center()` the element is aligned
   * both vertically and horizontally.
   *
   * @param  {String} [align] passing 'vertical', 'horizontal' aligns element accordingly
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div element and style it.
   *   let div = createDiv('');
   *   div.size(10, 10);
   *   div.style('background-color', 'orange');
   *
   *   // Center the div relative to the page's body.
   *   div.center();
   *
   *   describe('A gray square and an orange rectangle. The rectangle is at the center of the page.');
   * }
   * </code>
   * </div>
   */
  center(align) {
    const style = this.elt.style.display;
    const hidden = this.elt.style.display === "none";
    const parentHidden = this.parent().style.display === "none";
    const pos = { x: this.elt.offsetLeft, y: this.elt.offsetTop };
    if (hidden) this.show();
    if (parentHidden) this.parent().show();
    this.elt.style.display = "block";
    this.position(0, 0);
    const wOffset = Math.abs(this.parent().offsetWidth - this.elt.offsetWidth);
    const hOffset = Math.abs(
      this.parent().offsetHeight - this.elt.offsetHeight
    );
    if (align === "both" || align === void 0) {
      this.position(
        wOffset / 2 + this.parent().offsetLeft,
        hOffset / 2 + this.parent().offsetTop
      );
    } else if (align === "horizontal") {
      this.position(wOffset / 2 + this.parent().offsetLeft, pos.y);
    } else if (align === "vertical") {
      this.position(pos.x, hOffset / 2 + this.parent().offsetTop);
    }
    this.style("display", style);
    if (hidden) this.hide();
    if (parentHidden) this.parent().hide();
    return this;
  }
  /**
   * Sets the element's position.
   *
   * The first two parameters, `x` and `y`, set the element's position relative
   * to the top-left corner of the web page.
   *
   * The third parameter, `positionType`, is optional. It sets the element's
   * <a target="_blank"
   * href="https://developer.mozilla.org/en-US/docs/Web/CSS/position">positioning scheme</a>.
   * `positionType` is a string that can be either `'static'`, `'fixed'`,
   * `'relative'`, `'sticky'`, `'initial'`, or `'inherit'`.
   *
   * If no arguments passed, as in `myElement.position()`, the method returns
   * the element's position in an object, as in `{ x: 0, y: 0 }`.
   *
   * @returns {Object} object of form `{ x: 0, y: 0 }` containing the element's position.
   *
   * @example
   * <div>
   * <code class='norender'>
   * function setup() {
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Positions the canvas 50px to the right and 100px
   *   // below the top-left corner of the window.
   *   cnv.position(50, 100);
   *
   *   describe('A gray square that is 50 pixels to the right and 100 pixels down from the top-left corner of the web page.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code class='norender'>
   * function setup() {
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Positions the canvas at the top-left corner
   *   // of the window with a 'fixed' position type.
   *   cnv.position(0, 0, 'fixed');
   *
   *   describe('A gray square in the top-left corner of the web page.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Number} [x] x-position relative to top-left of window (optional)
   * @param  {Number} [y] y-position relative to top-left of window (optional)
   * @param  {String} [positionType] it can be static, fixed, relative, sticky, initial or inherit (optional)
   * @chainable
   */
  position(...args) {
    if (args.length === 0) {
      return { x: this.elt.offsetLeft, y: this.elt.offsetTop };
    } else {
      let positionType = "absolute";
      if (args[2] === "static" || args[2] === "fixed" || args[2] === "relative" || args[2] === "sticky" || args[2] === "initial" || args[2] === "inherit") {
        positionType = args[2];
      }
      this.elt.style.position = positionType;
      this.elt.style.left = args[0] + "px";
      this.elt.style.top = args[1] + "px";
      this.x = args[0];
      this.y = args[1];
      return this;
    }
  }
  /**
   * Shows the current element.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let p;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element and hide it.
   *   p = createP('p5*js');
   *   p.position(10, 10);
   *   p.hide();
   *
   *   describe('A gray square. The text "p5*js" appears when the user double-clicks the square.');
   * }
   *
   * // Show the paragraph when the user double-clicks.
   * function doubleClicked() {
   *   p.show();
   * }
   * </code>
   * </div>
   */
  show() {
    this.elt.style.display = "block";
    return this;
  }
  /**
   * Hides the current element.
   *
   * @chainable
   *
   * @example
   * let p;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element.
   *   p = createP('p5*js');
   *   p.position(10, 10);
   *
   *   describe('The text "p5*js" at the center of a gray square. The text disappears when the user double-clicks the square.');
   * }
   *
   * // Hide the paragraph when the user double-clicks.
   * function doubleClicked() {
   *   p.hide();
   * }
   * </code>
   * </div>
   */
  hide() {
    this.elt.style.display = "none";
    return this;
  }
  /**
   * Sets the element's width and height.
   *
   * Calling `myElement.size()` without an argument returns the element's size
   * as an object with the properties `width` and `height`. For example,
   *  `{ width: 20, height: 10 }`.
   *
   * The first parameter, `width`, is optional. It's a number used to set the
   * element's width. Calling `myElement.size(10)`
   *
   * The second parameter, 'height`, is also optional. It's a
   * number used to set the element's height. For example, calling
   * `myElement.size(20, 10)` sets the element's width to 20 pixels and height
   * to 10 pixels.
   *
   * The constant `AUTO` can be used to adjust one dimension at a time while
   * maintaining the aspect ratio, which is `width / height`. For example,
   * consider an element that's 200 pixels wide and 100 pixels tall. Calling
   * `myElement.size(20, AUTO)` sets the width to 20 pixels and height to 10
   * pixels.
   *
   * Note: In the case of elements that need to load data, such as images, wait
   * to call `myElement.size()` until after the data loads.
   *
   * @return {Object} width and height of the element in an object.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a pink div element and place it at the top-left corner.
   *   let div = createDiv();
   *   div.position(10, 10);
   *   div.style('background-color', 'deeppink');
   *
   *   // Set the div's width to 80 pixels and height to 20 pixels.
   *   div.size(80, 20);
   *
   *   describe('A gray square with a pink rectangle near its top.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a pink div element and place it at the top-left corner.
   *   let div = createDiv();
   *   div.position(10, 10);
   *   div.style('background-color', 'deeppink');
   *
   *   // Set the div's width to 80 pixels and height to 40 pixels.
   *   div.size(80, 40);
   *
   *   // Get the div's size as an object.
   *   let s = div.size();
   *
   *   // Display the div's dimensions.
   *   div.html(`${s.width} x ${s.height}`);
   *
   *   describe('A gray square with a pink rectangle near its top. The text "80 x 40" is written within the rectangle.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img1;
   * let img2;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Load an image of an astronaut on the moon
   *   // and place it at the top-left of the canvas.
   *   img1 = createImg(
   *     'assets/moonwalk.jpg',
   *     'An astronaut walking on the moon',
   *     ''
   *   );
   *   img1.position(0, 0);
   *
   *   // Load an image of an astronaut on the moon
   *   // and place it at the top-left of the canvas.
   *   // Resize the image once it's loaded.
   *   img2 = createImg(
   *     'assets/moonwalk.jpg',
   *     'An astronaut walking on the moon',
   *     '',
   *     resizeImage
   *   );
   *   img2.position(0, 0);
   *
   *   describe('A gray square two copies of a space image at the top-left. The copy in front is smaller.');
   * }
   *
   * // Resize img2 and keep its aspect ratio.
   * function resizeImage() {
   *   img2.size(50, AUTO);
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {(Number|AUTO)} [w]   width of the element, either AUTO, or a number.
   * @param  {(Number|AUTO)} [h] height of the element, either AUTO, or a number.
   * @chainable
   */
  size(w, h) {
    if (arguments.length === 0) {
      return { width: this.elt.offsetWidth, height: this.elt.offsetHeight };
    } else {
      let aW = w;
      let aH = h;
      const AUTO$1 = AUTO;
      if (aW !== AUTO$1 || aH !== AUTO$1) {
        if (aW === AUTO$1) {
          aW = h * this.width / this.height;
        } else if (aH === AUTO$1) {
          aH = w * this.height / this.width;
        }
        if (this.elt instanceof HTMLCanvasElement) {
          const j2 = {};
          const k = this.elt.getContext("2d");
          let prop;
          for (prop in k) {
            j2[prop] = k[prop];
          }
          this.elt.setAttribute("width", aW * this._pInst._pixelDensity);
          this.elt.setAttribute("height", aH * this._pInst._pixelDensity);
          this.elt.style.width = aW + "px";
          this.elt.style.height = aH + "px";
          this._pInst.scale(
            this._pInst._pixelDensity,
            this._pInst._pixelDensity
          );
          for (prop in j2) {
            this.elt.getContext("2d")[prop] = j2[prop];
          }
        } else {
          this.elt.style.width = aW + "px";
          this.elt.style.height = aH + "px";
          this.elt.width = aW;
          this.elt.height = aH;
        }
        this.width = aW;
        this.height = aH;
        if (this._pInst && this._pInst._curElement) {
          if (this._pInst._curElement.elt === this.elt) {
            this._pInst.width = aW;
            this._pInst.height = aH;
          }
        }
      }
      return this;
    }
  }
  /**
   * Applies a style to the element by adding a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax" target="_blank">CSS declaration</a>.
   *
   * The first parameter, `property`, is a string. If the name of a style
   * property is passed, as in `myElement.style('color')`, the method returns
   * the current value as a string or `null` if it hasn't been set. If a
   * `property:style` string is passed, as in
   * `myElement.style('color:deeppink')`, the method sets the style `property`
   * to `value`.
   *
   * The second parameter, `value`, is optional. It sets the property's value.
   * `value` can be a string, as in
   * `myElement.style('color', 'deeppink')`, or a
   * <a href="#/p5.Color">p5.Color</a> object, as in
   * `myElement.style('color', myColor)`.
   *
   * @param  {String} property style property to set.
   * @returns {String} value of the property.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element and set its font color to "deeppink".
   *   let p = createP('p5*js');
   *   p.position(25, 20);
   *   p.style('color', 'deeppink');
   *
   *   describe('The text p5*js written in pink on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color('deeppink');
   *
   *   // Create a paragraph element and set its font color using a p5.Color object.
   *   let p = createP('p5*js');
   *   p.position(25, 20);
   *   p.style('color', c);
   *
   *   describe('The text p5*js written in pink on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element and set its font color to "deeppink"
   *   // using property:value syntax.
   *   let p = createP('p5*js');
   *   p.position(25, 20);
   *   p.style('color:deeppink');
   *
   *   describe('The text p5*js written in pink on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an empty paragraph element and set its font color to "deeppink".
   *   let p = createP();
   *   p.position(5, 5);
   *   p.style('color', 'deeppink');
   *
   *   // Get the element's color as an  RGB color string.
   *   let c = p.style('color');
   *
   *   // Set the element's inner HTML using the RGB color string.
   *   p.html(c);
   *
   *   describe('The text "rgb(255, 20, 147)" written in pink on a gray background.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String} property
   * @param  {String|p5.Color} value value to assign to the property.
   * @return {String} value of the property.
   * @chainable
   */
  style(prop, val) {
    const self2 = this;
    if (val instanceof Color) {
      val = val.toString();
    }
    if (typeof val === "undefined") {
      if (prop.indexOf(":") === -1) {
        let styles = window.getComputedStyle(self2.elt);
        let style = styles.getPropertyValue(prop);
        return style;
      } else {
        const attrs = prop.split(";");
        for (let i = 0; i < attrs.length; i++) {
          const parts = attrs[i].split(":");
          if (parts[0] && parts[1]) {
            this.elt.style[parts[0].trim()] = parts[1].trim();
          }
        }
      }
    } else {
      this.elt.style[prop] = val;
      if (prop === "width" || prop === "height" || prop === "left" || prop === "top") {
        let styles = window.getComputedStyle(self2.elt);
        let styleVal = styles.getPropertyValue(prop);
        let numVal = styleVal.replace(/[^\d.]/g, "");
        this[prop] = Math.round(parseFloat(numVal, 10));
      }
    }
    return this;
  }
  /* Helper method called by p5.Element.style() */
  _translate(...args) {
    this.elt.style.position = "absolute";
    let transform2 = "";
    if (this.elt.style.transform) {
      transform2 = this.elt.style.transform.replace(/translate3d\(.*\)/g, "");
      transform2 = transform2.replace(/translate[X-Z]?\(.*\)/g, "");
    }
    if (args.length === 2) {
      this.elt.style.transform = "translate(" + args[0] + "px, " + args[1] + "px)";
    } else if (args.length > 2) {
      this.elt.style.transform = "translate3d(" + args[0] + "px," + args[1] + "px," + args[2] + "px)";
      if (args.length === 3) {
        this.elt.parentElement.style.perspective = "1000px";
      } else {
        this.elt.parentElement.style.perspective = args[3] + "px";
      }
    }
    this.elt.style.transform += transform2;
    return this;
  }
  /* Helper method called by p5.Element.style() */
  _rotate(...args) {
    let transform2 = "";
    if (this.elt.style.transform) {
      transform2 = this.elt.style.transform.replace(/rotate3d\(.*\)/g, "");
      transform2 = transform2.replace(/rotate[X-Z]?\(.*\)/g, "");
    }
    if (args.length === 1) {
      this.elt.style.transform = "rotate(" + args[0] + "deg)";
    } else if (args.length === 2) {
      this.elt.style.transform = "rotate(" + args[0] + "deg, " + args[1] + "deg)";
    } else if (args.length === 3) {
      this.elt.style.transform = "rotateX(" + args[0] + "deg)";
      this.elt.style.transform += "rotateY(" + args[1] + "deg)";
      this.elt.style.transform += "rotateZ(" + args[2] + "deg)";
    }
    this.elt.style.transform += transform2;
    return this;
  }
  /**
   * Adds an
   * <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started#attributes" target="_blank">attribute</a>
   * to the element.
   *
   * This method is useful for advanced tasks. Most commonly-used attributes,
   * such as `id`, can be set with their dedicated methods. For example,
   * `nextButton.id('next')` sets an element's `id` attribute. Calling
   * `nextButton.attribute('id', 'next')` has the same effect.
   *
   * The first parameter, `attr`, is the attribute's name as a string. Calling
   * `myElement.attribute('align')` returns the attribute's current value as a
   * string or `null` if it hasn't been set.
   *
   * The second parameter, `value`, is optional. It's a string used to set the
   * attribute's value. For example, calling
   * `myElement.attribute('align', 'center')` sets the element's horizontal
   * alignment to `center`.
   *
   * @return {String} value of the attribute.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a container div element and place it at the top-left corner.
   *   let container = createDiv();
   *   container.position(0, 0);
   *
   *   // Create a paragraph element and place it within the container.
   *   // Set its horizontal alignment to "left".
   *   let p1 = createP('hi');
   *   p1.parent(container);
   *   p1.attribute('align', 'left');
   *
   *   // Create a paragraph element and place it within the container.
   *   // Set its horizontal alignment to "center".
   *   let p2 = createP('hi');
   *   p2.parent(container);
   *   p2.attribute('align', 'center');
   *
   *   // Create a paragraph element and place it within the container.
   *   // Set its horizontal alignment to "right".
   *   let p3 = createP('hi');
   *   p3.parent(container);
   *   p3.attribute('align', 'right');
   *
   *   describe('A gray square with the text "hi" written on three separate lines, each placed further to the right.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String} attr       attribute to set.
   * @param  {String} value      value to assign to the attribute.
   * @chainable
   */
  attribute(attr, value) {
    if (this.elt.firstChild != null && (this.elt.firstChild.type === "checkbox" || this.elt.firstChild.type === "radio")) {
      if (typeof value === "undefined") {
        return this.elt.firstChild.getAttribute(attr);
      } else {
        for (let i = 0; i < this.elt.childNodes.length; i++) {
          this.elt.childNodes[i].setAttribute(attr, value);
        }
      }
    } else if (typeof value === "undefined") {
      return this.elt.getAttribute(attr);
    } else {
      this.elt.setAttribute(attr, value);
      return this;
    }
  }
  /**
   * Removes an attribute from the element.
   *
   * The parameter `attr` is the attribute's name as a string. For example,
   * calling `myElement.removeAttribute('align')` removes its `align`
   * attribute if it's been set.
   *
   * @param  {String} attr       attribute to remove.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let p;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element and place it in the center of the canvas.
   *   // Set its "align" attribute to "center".
   *   p = createP('hi');
   *   p.position(0, 20);
   *   p.attribute('align', 'center');
   *
   *   describe('The text "hi" written in black at the center of a gray square. The text moves to the left edge when double-clicked.');
   * }
   *
   * // Remove the 'align' attribute when the user double-clicks the paragraph.
   * function doubleClicked() {
   *   p.removeAttribute('align');
   * }
   * </code>
   * </div>
   */
  removeAttribute(attr) {
    if (this.elt.firstChild != null && (this.elt.firstChild.type === "checkbox" || this.elt.firstChild.type === "radio")) {
      for (let i = 0; i < this.elt.childNodes.length; i++) {
        this.elt.childNodes[i].removeAttribute(attr);
      }
    }
    this.elt.removeAttribute(attr);
    return this;
  }
  /**
   * Returns or sets the element's value.
   *
   * Calling `myElement.value()` returns the element's current value.
   *
   * The parameter, `value`, is an optional number or string. If provided,
   * as in `myElement.value(123)`, it's used to set the element's value.
   *
   * @return {String|Number} value of the element.
   *
   * @example
   * <div>
   * <code>
   * let input;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a text input and place it beneath the canvas.
   *   // Set its default value to "hello".
   *   input = createInput('hello');
   *   input.position(0, 100);
   *
   *   describe('The text from an input box is displayed on a gray square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Use the input's value to display a message.
   *   let msg = input.value();
   *   text(msg, 0, 55);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let input;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a text input and place it beneath the canvas.
   *   // Set its default value to "hello".
   *   input = createInput('hello');
   *   input.position(0, 100);
   *
   *   describe('The text from an input box is displayed on a gray square. The text resets to "hello" when the user double-clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Use the input's value to display a message.
   *   let msg = input.value();
   *   text(msg, 0, 55);
   * }
   *
   * // Reset the input's value.
   * function doubleClicked() {
   *   input.value('hello');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String|Number}     value
   * @chainable
   */
  value(...args) {
    if (args.length > 0) {
      this.elt.value = args[0];
      return this;
    } else {
      if (this.elt.type === "range") {
        return parseFloat(this.elt.value);
      } else return this.elt.value;
    }
  }
  /**
   * Calls a function when the mouse is pressed over the element.
   *
   * Calling `myElement.mousePressed(false)` disables the function.
   *
   * Note: Some mobile browsers may also trigger this event when the element
   * receives a quick tap.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse is
   *                                pressed over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the canvas
   *   // is pressed.
   *   cnv.mousePressed(randomColor);
   *
   *   describe('A gray square changes color when the mouse is pressed.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mousePressed(fxn) {
    const eventPrependedFxn = function(event) {
      this._pInst.mouseIsPressed = true;
      this._pInst._activePointers.set(event.pointerId, event);
      this._pInst._setMouseButton(event);
      this._pInst._updatePointerCoords(event);
      return fxn.call(this, event);
    };
    Element._adjustListener("pointerdown", eventPrependedFxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse is pressed twice over the element.
   *
   * Calling `myElement.doubleClicked(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse is
   *                                double clicked over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // canvas is double-clicked.
   *   cnv.doubleClicked(randomColor);
   *
   *   describe('A gray square changes color when the user double-clicks the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  doubleClicked(fxn) {
    Element._adjustListener("dblclick", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse wheel scrolls over the element.
   *
   * The callback function, `fxn`, is passed an `event` object. `event` has
   * two numeric properties, `deltaY` and `deltaX`. `event.deltaY` is
   * negative if the mouse wheel rotates away from the user. It's positive if
   * the mouse wheel rotates toward the user. `event.deltaX` is positive if
   * the mouse wheel moves to the right. It's negative if the mouse wheel moves
   * to the left.
   *
   * Calling `myElement.mouseWheel(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse wheel is
   *                                scrolled over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // mouse wheel moves.
   *   cnv.mouseWheel(randomColor);
   *
   *   describe('A gray square changes color when the user scrolls the mouse wheel over the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call changeBackground() when the
   *   // mouse wheel moves.
   *   cnv.mouseWheel(changeBackground);
   *
   *   describe('A gray square. When the mouse wheel scrolls over the square, it changes color and displays shapes.');
   * }
   *
   * function changeBackground(event) {
   *   // Change the background color
   *   // based on deltaY.
   *   if (event.deltaY > 0) {
   *     background('deeppink');
   *   } else if (event.deltaY < 0) {
   *     background('cornflowerblue');
   *   } else {
   *     background(200);
   *   }
   *
   *   // Draw a shape based on deltaX.
   *   if (event.deltaX > 0) {
   *     circle(50, 50, 20);
   *   } else if (event.deltaX < 0) {
   *     square(40, 40, 20);
   *   }
   * }
   * </code>
   * </div>
   */
  mouseWheel(fxn) {
    Element._adjustListener("wheel", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse is released over the element.
   *
   * Calling `myElement.mouseReleased(false)` disables the function.
   *
   * Note: Some mobile browsers may also trigger this event when the element
   * receives a quick tap.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse is
   *                                pressed over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when a
   *   // mouse press ends.
   *   cnv.mouseReleased(randomColor);
   *
   *   describe('A gray square changes color when the user releases a mouse press.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseReleased(fxn) {
    Element._adjustListener("pointerup", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse is pressed and released over the element.
   *
   * Calling `myElement.mouseReleased(false)` disables the function.
   *
   * Note: Some mobile browsers may also trigger this event when the element
   * receives a quick tap.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse is
   *                                pressed and released over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when a
   *   // mouse press ends.
   *   cnv.mouseClicked(randomColor);
   *
   *   describe('A gray square changes color when the user releases a mouse press.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseClicked(fxn) {
    Element._adjustListener("click", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse moves over the element.
   *
   * Calling `myElement.mouseMoved(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse
   *                                moves over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // mouse moves.
   *   cnv.mouseMoved(randomColor);
   *
   *   describe('A gray square changes color when the mouse moves over the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseMoved(fxn) {
    Element._adjustListener("pointermove", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse moves onto the element.
   *
   * Calling `myElement.mouseOver(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse
   *                                moves onto the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // mouse moves onto the canvas.
   *   cnv.mouseOver(randomColor);
   *
   *   describe('A gray square changes color when the mouse moves onto the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseOver(fxn) {
    Element._adjustListener("pointerover", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse moves off the element.
   *
   * Calling `myElement.mouseOut(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse
   *                                moves off the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // mouse moves off the canvas.
   *   cnv.mouseOut(randomColor);
   *
   *   describe('A gray square changes color when the mouse moves off the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseOut(fxn) {
    Element._adjustListener("pointerout", fxn, this);
    return this;
  }
  /**
   * Calls a function when a file is dragged over the element.
   *
   * Calling `myElement.dragOver(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the file is
   *                                dragged over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Drag a file over the canvas to test.
   *
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call helloFile() when a
   *   // file is dragged over
   *   // the canvas.
   *   cnv.dragOver(helloFile);
   *
   *   describe('A gray square. The text "hello, file" appears when a file is dragged over the square.');
   * }
   *
   * function helloFile() {
   *   text('hello, file', 50, 50);
   * }
   * </code>
   * </div>
   */
  dragOver(fxn) {
    Element._adjustListener("dragover", fxn, this);
    return this;
  }
  /**
   * Calls a function when a file is dragged off the element.
   *
   * Calling `myElement.dragLeave(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the file is
   *                                dragged off the element.
   *                                `false` disables the function.
   * @chainable
   * @example
   * <div>
   * <code>
   * // Drag a file over, then off
   * // the canvas to test.
   *
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call byeFile() when a
   *   // file is dragged over,
   *   // then off the canvas.
   *   cnv.dragLeave(byeFile);
   *
   *   describe('A gray square. The text "bye, file" appears when a file is dragged over, then off the square.');
   * }
   *
   * function byeFile() {
   *   text('bye, file', 50, 50);
   * }
   * </code>
   * </div>
   */
  dragLeave(fxn) {
    Element._adjustListener("dragleave", fxn, this);
    return this;
  }
  /**
   * Calls a function when the element changes.
   *
   * Calling `myElement.changed(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the element changes.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let dropdown;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a dropdown menu and add a few color options.
   *   dropdown = createSelect();
   *   dropdown.position(0, 0);
   *   dropdown.option('red');
   *   dropdown.option('green');
   *   dropdown.option('blue');
   *
   *   // Call paintBackground() when the color option changes.
   *   dropdown.changed(paintBackground);
   *
   *   describe('A gray square with a dropdown menu at the top. The square changes color when an option is selected.');
   * }
   *
   * // Paint the background with the selected color.
   * function paintBackground() {
   *   let c = dropdown.value();
   *   background(c);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let checkbox;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a checkbox and place it beneath the canvas.
   *   checkbox = createCheckbox(' circle');
   *   checkbox.position(0, 100);
   *
   *   // Call repaint() when the checkbox changes.
   *   checkbox.changed(repaint);
   *
   *   describe('A gray square with a checkbox underneath it that says "circle". A white circle appears when the box is checked and disappears otherwise.');
   * }
   *
   * // Paint the background gray and determine whether to draw a circle.
   * function repaint() {
   *   background(200);
   *   if (checkbox.checked() === true) {
   *     circle(50, 50, 30);
   *   }
   * }
   * </code>
   * </div>
   */
  changed(fxn) {
    Element._adjustListener("change", fxn, this);
    return this;
  }
  /**
   * Calls a function when the element receives input.
   *
   * `myElement.input()` is often used to with text inputs and sliders. Calling
   * `myElement.input(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when input is detected within
   *                                the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let slider;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a slider and place it beneath the canvas.
   *   slider = createSlider(0, 255, 200);
   *   slider.position(0, 100);
   *
   *   // Call repaint() when the slider changes.
   *   slider.input(repaint);
   *
   *   describe('A gray square with a range slider underneath it. The background changes shades of gray when the slider is moved.');
   * }
   *
   * // Paint the background using slider's value.
   * function repaint() {
   *   let g = slider.value();
   *   background(g);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let input;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an input and place it beneath the canvas.
   *   input = createInput('');
   *   input.position(0, 100);
   *
   *   // Call repaint() when input is detected.
   *   input.input(repaint);
   *
   *   describe('A gray square with a text input bar beneath it. Any text written in the input appears in the middle of the square.');
   * }
   *
   * // Paint the background gray and display the input's value.
   * function repaint() {
   *   background(200);
   *   let msg = input.value();
   *   text(msg, 5, 50);
   * }
   * </code>
   * </div>
   */
  input(fxn) {
    Element._adjustListener("input", fxn, this);
    return this;
  }
  /**
   * Calls a function when the user drops a file on the element.
   *
   * The first parameter, `callback`, is a function to call once the file loads.
   * The callback function should have one parameter, `file`, that's a
   * <a href="#/p5.File">p5.File</a> object. If the user drops multiple files on
   * the element, `callback`, is called once for each file.
   *
   * The second parameter, `fxn`, is a function to call when the browser detects
   * one or more dropped files. The callback function should have one
   * parameter, `event`, that's a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent">DragEvent</a>.
   *
   * @param  {Function} callback  called when a file loads. Called once for each file dropped.
   * @param  {Function} [fxn]     called once when any files are dropped.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Drop an image on the canvas to view
   * // this example.
   * let img;
   *
   * function setup() {
   *   let c = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call handleFile() when a file that's dropped on the canvas has loaded.
   *   c.drop(handleFile);
   *
   *   describe('A gray square. When the user drops an image on the square, it is displayed.');
   * }
   *
   * // Remove the existing image and display the new one.
   * function handleFile(file) {
   *   // Remove the current image, if any.
   *   if (img) {
   *     img.remove();
   *   }
   *
   *   // Create an <img> element with the
   *   // dropped file.
   *   img = createImg(file.data, '');
   *   img.hide();
   *
   *   // Draw the image.
   *   image(img, 0, 0, width, height);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Drop an image on the canvas to view
   * // this example.
   * let img;
   * let msg;
   *
   * function setup() {
   *   let c = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call functions when the user drops a file on the canvas
   *   // and when the file loads.
   *   c.drop(handleFile, handleDrop);
   *
   *   describe('A gray square. When the user drops an image on the square, it is displayed. The id attribute of canvas element is also displayed.');
   * }
   *
   * // Display the image when it loads.
   * function handleFile(file) {
   *   // Remove the current image, if any.
   *   if (img) {
   *     img.remove();
   *   }
   *
   *   // Create an img element with the dropped file.
   *   img = createImg(file.data, '');
   *   img.hide();
   *
   *   // Draw the image.
   *   image(img, 0, 0, width, height);
   * }
   *
   * // Display the file's name when it loads.
   * function handleDrop(event) {
   *   // Remove current paragraph, if any.
   *   if (msg) {
   *     msg.remove();
   *   }
   *
   *   // Use event to get the drop target's id.
   *   let id = event.target.id;
   *
   *   // Write the canvas' id beneath it.
   *   msg = createP(id);
   *   msg.position(0, 100);
   *
   *   // Set the font color randomly for each drop.
   *   let c = random(['red', 'green', 'blue']);
   *   msg.style('color', c);
   *   msg.style('font-size', '12px');
   * }
   * </code>
   * </div>
   */
  drop(callback, fxn) {
    if (window.File && window.FileReader && window.FileList && window.Blob) {
      if (!this._dragDisabled) {
        this._dragDisabled = true;
        const preventDefault = function(evt) {
          evt.preventDefault();
        };
        this.elt.addEventListener("dragover", preventDefault);
        this.elt.addEventListener("dragleave", preventDefault);
      }
      Element._attachListener(
        "drop",
        function(evt) {
          evt.preventDefault();
          if (typeof fxn === "function") {
            fxn.call(this, evt);
          }
          const files2 = evt.dataTransfer.files;
          for (const f of files2) {
            File._load(f, callback);
          }
        },
        this
      );
    } else {
      console.log("The File APIs are not fully supported in this browser.");
    }
    return this;
  }
  /**
   * Makes the element draggable.
   *
   * The parameter, `elmnt`, is optional. If another
   * <a href="#/p5.Element">p5.Element</a> object is passed, as in
   * `myElement.draggable(otherElement)`, the other element will become draggable.
   *
   * @param  {p5.Element} [elmnt]  another <a href="#/p5.Element">p5.Element</a>.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let stickyNote;
   * let textInput;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element and style it.
   *   stickyNote = createDiv('Note');
   *   stickyNote.position(5, 5);
   *   stickyNote.size(80, 20);
   *   stickyNote.style('font-size', '16px');
   *   stickyNote.style('font-family', 'Comic Sans MS');
   *   stickyNote.style('background', 'orchid');
   *   stickyNote.style('padding', '5px');
   *
   *   // Make the note draggable.
   *   stickyNote.draggable();
   *
   *   // Create a panel div and style it.
   *   let panel = createDiv('');
   *   panel.position(5, 40);
   *   panel.size(80, 50);
   *   panel.style('background', 'orchid');
   *   panel.style('font-size', '16px');
   *   panel.style('padding', '5px');
   *   panel.style('text-align', 'center');
   *
   *   // Make the panel draggable.
   *   panel.draggable();
   *
   *   // Create a text input and style it.
   *   textInput = createInput('Note');
   *   textInput.size(70);
   *
   *   // Add the input to the panel.
   *   textInput.parent(panel);
   *
   *   // Call handleInput() when text is input.
   *   textInput.input(handleInput);
   *
   *   describe(
   *     'A gray square with two purple rectangles that move when dragged. The top rectangle displays the text that is typed into the bottom rectangle.'
   *   );
   * }
   *
   * // Update stickyNote's HTML when text is input.
   * function handleInput() {
   *   stickyNote.html(textInput.value());
   * }
   * </code>
   * </div>
   */
  draggable(elmMove) {
    let isTouch = "ontouchstart" in window;
    let x = 0, y = 0, px = 0, py = 0, elmDrag, dragMouseDownEvt = isTouch ? "touchstart" : "mousedown", closeDragElementEvt = isTouch ? "touchend" : "mouseup", elementDragEvt = isTouch ? "touchmove" : "mousemove";
    if (elmMove === void 0) {
      elmMove = this.elt;
      elmDrag = elmMove;
    } else if (elmMove !== this.elt && elmMove.elt !== this.elt) {
      elmMove = elmMove.elt;
      elmDrag = this.elt;
    }
    elmDrag.addEventListener(dragMouseDownEvt, dragMouseDown, false);
    elmDrag.style.cursor = "move";
    function dragMouseDown(e2) {
      e2 = e2 || window.event;
      if (isTouch) {
        const touches = e2.changedTouches;
        px = parseInt(touches[0].clientX);
        py = parseInt(touches[0].clientY);
      } else {
        px = parseInt(e2.clientX);
        py = parseInt(e2.clientY);
      }
      document.addEventListener(closeDragElementEvt, closeDragElement, false);
      document.addEventListener(elementDragEvt, elementDrag, false);
      return false;
    }
    function elementDrag(e2) {
      e2 = e2 || window.event;
      if (isTouch) {
        const touches = e2.changedTouches;
        x = px - parseInt(touches[0].clientX);
        y = py - parseInt(touches[0].clientY);
        px = parseInt(touches[0].clientX);
        py = parseInt(touches[0].clientY);
      } else {
        x = px - parseInt(e2.clientX);
        y = py - parseInt(e2.clientY);
        px = parseInt(e2.clientX);
        py = parseInt(e2.clientY);
      }
      elmMove.style.left = elmMove.offsetLeft - x + "px";
      elmMove.style.top = elmMove.offsetTop - y + "px";
    }
    function closeDragElement() {
      document.removeEventListener(
        closeDragElementEvt,
        closeDragElement,
        false
      );
      document.removeEventListener(elementDragEvt, elementDrag, false);
    }
    return this;
  }
  /**
   *
   * @private
   * @static
   * @param {String} ev
   * @param {Boolean|Function} fxn
   * @param {Element} ctx
   * @chainable
   * @alt
   * General handler for event attaching and detaching
   */
  static _adjustListener(ev, fxn, ctx) {
    if (fxn === false) {
      Element._detachListener(ev, ctx);
    } else {
      Element._attachListener(ev, fxn, ctx);
    }
    return this;
  }
  /**
   *
   * @private
   * @static
   * @param {String} ev
   * @param {Function} fxn
   * @param {Element} ctx
   */
  static _attachListener(ev, fxn, ctx) {
    if (ctx._events[ev]) {
      Element._detachListener(ev, ctx);
    }
    const f = fxn.bind(ctx);
    ctx.elt.addEventListener(ev, f, {
      capture: false,
      signal: ctx._pInst._removeSignal
    });
    ctx._events[ev] = f;
  }
  /**
   *
   * @private
   * @static
   * @param {String} ev
   * @param {Element} ctx
   */
  static _detachListener(ev, ctx) {
    const f = ctx._events[ev];
    ctx.elt.removeEventListener(ev, f, false);
    ctx._events[ev] = null;
  }
}
function element(p53, fn2) {
  p53.Element = Element;
}
if (typeof p5 !== "undefined") {
  element(p5, p5.prototype);
}
const Filters = {
  /*
   * Helper functions
   */
  /**
   * Returns the pixel buffer for a canvas.
   *
   * @private
   *
   * @param  {Canvas|ImageData} canvas the canvas to get pixels from
   * @return {Uint8ClampedArray}       a one-dimensional array containing
   *                                   the data in the RGBA order, with integer
   *                                   values between 0 and 255.
   */
  _toPixels(canvas2) {
    if (canvas2 instanceof ImageData) {
      return canvas2.data;
    } else {
      if (canvas2.getContext("2d")) {
        return canvas2.getContext("2d").getImageData(0, 0, canvas2.width, canvas2.height).data;
      } else if (canvas2.getContext("webgl")) {
        const gl = canvas2.getContext("webgl");
        const len = gl.drawingBufferWidth * gl.drawingBufferHeight * 4;
        const data2 = new Uint8Array(len);
        gl.readPixels(
          0,
          0,
          canvas2.width,
          canvas2.height,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          data2
        );
        return data2;
      }
    }
  },
  /**
   * Returns a 32-bit number containing ARGB data at the ith pixel in the
   * 1D array containing pixels data.
   *
   * @private
   *
   * @param  {Uint8ClampedArray} data array returned by _toPixels()
   * @param  {Integer}           i    index of a 1D Image Array
   * @return {Integer}                32-bit integer value representing
   *                                  ARGB value.
   */
  _getARGB(data2, i) {
    const offset2 = i * 4;
    return (
      // Combining the extracted components using bitwise OR operations to form the final ARGB value.
      data2[offset2 + 3] << 24 & 4278190080 | //Extract alpha component
      data2[offset2] << 16 & 16711680 | //Extract Red component
      data2[offset2 + 1] << 8 & 65280 | //Extract green component
      data2[offset2 + 2] & 255
    );
  },
  /**
   * Modifies pixels RGBA values to values contained in the data object.
   *
   * @private
   *
   * @param {Uint8ClampedArray} pixels array returned by _toPixels()
   * @param {Int32Array}        data   source 1D array where each value
   *                                   represents ARGB values
   */
  _setPixels(pixels2, data2) {
    let offset2 = 0;
    for (let i = 0, al = pixels2.length; i < al; i++) {
      offset2 = i * 4;
      pixels2[offset2 + 0] = (data2[i] & 16711680) >>> 16;
      pixels2[offset2 + 1] = (data2[i] & 65280) >>> 8;
      pixels2[offset2 + 2] = data2[i] & 255;
      pixels2[offset2 + 3] = (data2[i] & 4278190080) >>> 24;
    }
  },
  /**
   * Returns the ImageData object for a canvas.
   * https://developer.mozilla.org/en-US/docs/Web/API/ImageData
   *
   * @private
   *
   * @param  {Canvas|ImageData} canvas canvas to get image data from
   * @return {ImageData}               Holder of pixel data (and width and
   *                                   height) for a canvas
   */
  _toImageData(canvas2) {
    if (canvas2 instanceof ImageData) {
      return canvas2;
    } else {
      return canvas2.getContext("2d").getImageData(0, 0, canvas2.width, canvas2.height);
    }
  },
  /**
   * Returns a blank ImageData object.
   *
   * @private
   *
   * @param  {Integer} width
   * @param  {Integer} height
   * @return {ImageData}
   */
  _createImageData(width, height) {
    Filters._tmpCanvas = document.createElement("canvas");
    Filters._tmpCtx = Filters._tmpCanvas.getContext("2d");
    return this._tmpCtx.createImageData(width, height);
  },
  /**
   * Applys a filter function to a canvas.
   *
   * The difference between this and the actual filter functions defined below
   * is that the filter functions generally modify the pixel buffer but do
   * not actually put that data back to the canvas (where it would actually
   * update what is visible). By contrast this method does make the changes
   * actually visible in the canvas.
   *
   * The apply method is the method that callers of this module would generally
   * use. It has been separated from the actual filters to support an advanced
   * use case of creating a filter chain that executes without actually updating
   * the canvas in between everystep.
   *
   * @private
   * @param  {HTMLCanvasElement} canvas The input canvas to apply the filter on.
   * @param  {function(ImageData,Object)} func The filter function to apply to the canvas's pixel data.
   * @param  {Object} filterParam An optional parameter to pass to the filter function.
   */
  apply(canvas2, func, filterParam) {
    const pixelsState = canvas2.getContext("2d");
    const imageData = pixelsState.getImageData(
      0,
      0,
      canvas2.width,
      canvas2.height
    );
    const newImageData = func(imageData, filterParam);
    if (newImageData instanceof ImageData) {
      pixelsState.putImageData(
        newImageData,
        0,
        0,
        0,
        0,
        canvas2.width,
        canvas2.height
      );
    } else {
      pixelsState.putImageData(
        imageData,
        0,
        0,
        0,
        0,
        canvas2.width,
        canvas2.height
      );
    }
  },
  /*
   * Filters
   */
  /**
   * Converts the image to black and white pixels depending if they are above or
   * below the threshold defined by the level parameter. The parameter must be
   * between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.
   *
   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
   *
   * @private
   * @param  {Canvas} canvas Canvas to apply thershold filter on.
   * @param  {Float} level Threshold level (0-1).
   */
  threshold(canvas2, level = 0.5) {
    const pixels2 = Filters._toPixels(canvas2);
    const thresh = Math.floor(level * 255);
    for (let i = 0; i < pixels2.length; i += 4) {
      const r = pixels2[i];
      const g2 = pixels2[i + 1];
      const b2 = pixels2[i + 2];
      const gray = 0.2126 * r + 0.7152 * g2 + 0.0722 * b2;
      let val;
      if (gray >= thresh) {
        val = 255;
      } else {
        val = 0;
      }
      pixels2[i] = pixels2[i + 1] = pixels2[i + 2] = val;
    }
  },
  /**
   * Converts any colors in the image to grayscale equivalents.
   * No parameter is used.
   *
   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
   *
   * @private
   * @param {Canvas} canvas Canvas to apply gray filter on.
   */
  gray(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    for (let i = 0; i < pixels2.length; i += 4) {
      const r = pixels2[i];
      const g2 = pixels2[i + 1];
      const b2 = pixels2[i + 2];
      const gray = 0.2126 * r + 0.7152 * g2 + 0.0722 * b2;
      pixels2[i] = pixels2[i + 1] = pixels2[i + 2] = gray;
    }
  },
  /**
   * Sets the alpha channel to entirely opaque. No parameter is used.
   *
   * @private
   * @param {Canvas} canvas
   */
  opaque(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    for (let i = 0; i < pixels2.length; i += 4) {
      pixels2[i + 3] = 255;
    }
    return pixels2;
  },
  /**
   * Sets each pixel to its inverse value. No parameter is used.
   * @private
   * @param  {Canvas} canvas
   */
  invert(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    for (let i = 0; i < pixels2.length; i += 4) {
      pixels2[i] = 255 - pixels2[i];
      pixels2[i + 1] = 255 - pixels2[i + 1];
      pixels2[i + 2] = 255 - pixels2[i + 2];
    }
  },
  /**
   * Limits each channel of the image to the number of colors specified as
   * the parameter. The parameter can be set to values between 2 and 255, but
   * results are most noticeable in the lower ranges.
   *
   * Adapted from java based processing implementation
   *
   * @private
   * @param  {Canvas} canvas
   * @param  {Integer} level
   */
  posterize(canvas2, level = 4) {
    const pixels2 = Filters._toPixels(canvas2);
    if (level < 2 || level > 255) {
      throw new Error(
        "Level must be greater than 2 and less than 255 for posterize"
      );
    }
    const levels1 = level - 1;
    for (let i = 0; i < pixels2.length; i += 4) {
      const rlevel = pixels2[i];
      const glevel = pixels2[i + 1];
      const blevel = pixels2[i + 2];
      pixels2[i] = (rlevel * level >> 8) * 255 / levels1;
      pixels2[i + 1] = (glevel * level >> 8) * 255 / levels1;
      pixels2[i + 2] = (blevel * level >> 8) * 255 / levels1;
    }
  },
  /**
   * Increases the bright areas in an image.
   * @private
   * @param  {Canvas} canvas
   */
  dilate(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    let currIdx = 0;
    const maxIdx = pixels2.length ? pixels2.length / 4 : 0;
    const out = new Int32Array(maxIdx);
    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
    let idxRight, idxLeft, idxUp, idxDown;
    let colRight, colLeft, colUp, colDown;
    let lumRight, lumLeft, lumUp, lumDown;
    while (currIdx < maxIdx) {
      currRowIdx = currIdx;
      maxRowIdx = currIdx + canvas2.width;
      while (currIdx < maxRowIdx) {
        colOrig = colOut = Filters._getARGB(pixels2, currIdx);
        idxLeft = currIdx - 1;
        idxRight = currIdx + 1;
        idxUp = currIdx - canvas2.width;
        idxDown = currIdx + canvas2.width;
        if (idxLeft < currRowIdx) {
          idxLeft = currIdx;
        }
        if (idxRight >= maxRowIdx) {
          idxRight = currIdx;
        }
        if (idxUp < 0) {
          idxUp = 0;
        }
        if (idxDown >= maxIdx) {
          idxDown = currIdx;
        }
        colUp = Filters._getARGB(pixels2, idxUp);
        colLeft = Filters._getARGB(pixels2, idxLeft);
        colDown = Filters._getARGB(pixels2, idxDown);
        colRight = Filters._getARGB(pixels2, idxRight);
        currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
        lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
        lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
        lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
        lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
        if (lumLeft > currLum) {
          colOut = colLeft;
          currLum = lumLeft;
        }
        if (lumRight > currLum) {
          colOut = colRight;
          currLum = lumRight;
        }
        if (lumUp > currLum) {
          colOut = colUp;
          currLum = lumUp;
        }
        if (lumDown > currLum) {
          colOut = colDown;
          currLum = lumDown;
        }
        out[currIdx++] = colOut;
      }
    }
    Filters._setPixels(pixels2, out);
  },
  /**
   * Reduces the bright areas in an image.
   * Similar to `dilate()`, but updates the output color based on the lowest luminance value.
   * @private
   * @param  {Canvas} canvas
   */
  erode(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    let currIdx = 0;
    const maxIdx = pixels2.length ? pixels2.length / 4 : 0;
    const out = new Int32Array(maxIdx);
    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
    let idxRight, idxLeft, idxUp, idxDown;
    let colRight, colLeft, colUp, colDown;
    let lumRight, lumLeft, lumUp, lumDown;
    while (currIdx < maxIdx) {
      currRowIdx = currIdx;
      maxRowIdx = currIdx + canvas2.width;
      while (currIdx < maxRowIdx) {
        colOrig = colOut = Filters._getARGB(pixels2, currIdx);
        idxLeft = currIdx - 1;
        idxRight = currIdx + 1;
        idxUp = currIdx - canvas2.width;
        idxDown = currIdx + canvas2.width;
        if (idxLeft < currRowIdx) {
          idxLeft = currIdx;
        }
        if (idxRight >= maxRowIdx) {
          idxRight = currIdx;
        }
        if (idxUp < 0) {
          idxUp = 0;
        }
        if (idxDown >= maxIdx) {
          idxDown = currIdx;
        }
        colUp = Filters._getARGB(pixels2, idxUp);
        colLeft = Filters._getARGB(pixels2, idxLeft);
        colDown = Filters._getARGB(pixels2, idxDown);
        colRight = Filters._getARGB(pixels2, idxRight);
        currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
        lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
        lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
        lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
        lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
        if (lumLeft < currLum) {
          colOut = colLeft;
          currLum = lumLeft;
        }
        if (lumRight < currLum) {
          colOut = colRight;
          currLum = lumRight;
        }
        if (lumUp < currLum) {
          colOut = colUp;
          currLum = lumUp;
        }
        if (lumDown < currLum) {
          colOut = colDown;
          currLum = lumDown;
        }
        out[currIdx++] = colOut;
      }
    }
    Filters._setPixels(pixels2, out);
  },
  blur(canvas2, radius) {
    blurARGB(canvas2, radius);
  }
};
let blurRadius;
let blurKernelSize;
let blurKernel;
let blurMult;
function buildBlurKernel(r) {
  let radius = r * 3.5 | 0;
  radius = radius < 1 ? 1 : radius < 248 ? radius : 248;
  if (blurRadius !== radius) {
    blurRadius = radius;
    blurKernelSize = 1 + blurRadius << 1;
    blurKernel = new Int32Array(blurKernelSize);
    blurMult = new Array(blurKernelSize);
    for (let l = 0; l < blurKernelSize; l++) {
      blurMult[l] = new Int32Array(256);
    }
    let bk, bki;
    let bm, bmi;
    for (let i = 1, radiusi = radius - 1; i < radius; i++) {
      blurKernel[radius + i] = blurKernel[radiusi] = bki = radiusi * radiusi;
      bm = blurMult[radius + i];
      bmi = blurMult[radiusi--];
      for (let j2 = 0; j2 < 256; j2++) {
        bm[j2] = bmi[j2] = bki * j2;
      }
    }
    bk = blurKernel[radius] = radius * radius;
    bm = blurMult[radius];
    for (let k = 0; k < 256; k++) {
      bm[k] = bk * k;
    }
  }
}
function blurARGB(canvas2, radius) {
  const pixels2 = Filters._toPixels(canvas2);
  const width = canvas2.width;
  const height = canvas2.height;
  const numPackedPixels = width * height;
  const argb = new Int32Array(numPackedPixels);
  for (let j2 = 0; j2 < numPackedPixels; j2++) {
    argb[j2] = Filters._getARGB(pixels2, j2);
  }
  let sum, cr, cg, cb, ca;
  let read2, ri, ym, ymi, bk0;
  const a2 = new Int32Array(numPackedPixels);
  const r2 = new Int32Array(numPackedPixels);
  const g2 = new Int32Array(numPackedPixels);
  const b2 = new Int32Array(numPackedPixels);
  let yi = 0;
  buildBlurKernel(radius);
  let x, y, i;
  let bm;
  for (y = 0; y < height; y++) {
    for (x = 0; x < width; x++) {
      cb = cg = cr = ca = sum = 0;
      read2 = x - blurRadius;
      if (read2 < 0) {
        bk0 = -read2;
        read2 = 0;
      } else {
        if (read2 >= width) {
          break;
        }
        bk0 = 0;
      }
      for (i = bk0; i < blurKernelSize; i++) {
        if (read2 >= width) {
          break;
        }
        const c = argb[read2 + yi];
        bm = blurMult[i];
        ca += bm[(c & -16777216) >>> 24];
        cr += bm[(c & 16711680) >> 16];
        cg += bm[(c & 65280) >> 8];
        cb += bm[c & 255];
        sum += blurKernel[i];
        read2++;
      }
      ri = yi + x;
      a2[ri] = ca / sum;
      r2[ri] = cr / sum;
      g2[ri] = cg / sum;
      b2[ri] = cb / sum;
    }
    yi += width;
  }
  yi = 0;
  ym = -blurRadius;
  ymi = ym * width;
  for (y = 0; y < height; y++) {
    for (x = 0; x < width; x++) {
      cb = cg = cr = ca = sum = 0;
      if (ym < 0) {
        bk0 = ri = -ym;
        read2 = x;
      } else {
        if (ym >= height) {
          break;
        }
        bk0 = 0;
        ri = ym;
        read2 = x + ymi;
      }
      for (i = bk0; i < blurKernelSize; i++) {
        if (ri >= height) {
          break;
        }
        bm = blurMult[i];
        ca += bm[a2[read2]];
        cr += bm[r2[read2]];
        cg += bm[g2[read2]];
        cb += bm[b2[read2]];
        sum += blurKernel[i];
        ri++;
        read2 += width;
      }
      argb[x + yi] = ca / sum << 24 | cr / sum << 16 | cg / sum << 8 | cb / sum;
    }
    yi += width;
    ymi += width;
    ym++;
  }
  Filters._setPixels(pixels2, argb);
}
const calculateRemainder2D = function(xComponent, yComponent) {
  if (xComponent !== 0) {
    this.x = this.x % xComponent;
  }
  if (yComponent !== 0) {
    this.y = this.y % yComponent;
  }
  return this;
};
const calculateRemainder3D = function(xComponent, yComponent, zComponent) {
  if (xComponent !== 0) {
    this.x = this.x % xComponent;
  }
  if (yComponent !== 0) {
    this.y = this.y % yComponent;
  }
  if (zComponent !== 0) {
    this.z = this.z % zComponent;
  }
  return this;
};
class Vector {
  // This is how it comes in with createVector()
  // This check if the first argument is a function
  constructor(...args) {
    let values = args;
    if (typeof args[0] === "function") {
      this.isPInst = true;
      this._fromRadians = args[0];
      this._toRadians = args[1];
      values = args.slice(2);
    }
    let dimensions = values.length;
    if (dimensions === 0) {
      this.dimensions = 2;
      this._values = [0, 0, 0];
    } else {
      this.dimensions = dimensions;
      this._values = values;
    }
  }
  /**
   * Gets the values of the N-dimensional vector.
   *
   * This method returns an array of numbers that represent the vector.
   * Each number in the array corresponds to a different component of the vector,
   * like its position in different directions (e.g., x, y, z).
   *
   * @returns {Array<number>} The array of values representing the vector.
   */
  get values() {
    return this._values;
  }
  /**
   * Sets the values of the vector.
   *
   * This method allows you to update the entire vector with a new set of values.
   * You need to provide an array of numbers, where each number represents a component
   * of the vector (e.g., x, y, z). The length of the array should match the number of
   * dimensions of the vector. If the array is shorter, the missing components will be
   * set to 0. If the array is longer, the extra values will be ignored.
   *
   * @param {Array<number>} newValues - An array of numbers representing the new values for the vector.
   *
   */
  set values(newValues) {
    let dimensions = newValues.length;
    if (dimensions === 0) {
      this.dimensions = 2;
      this._values = [0, 0, 0];
    } else {
      this.dimensions = dimensions;
      this._values = newValues.slice();
    }
  }
  /**
   * Gets the x component of the vector.
   *
   * This method returns the value of the x component of the vector.
   * Think of the x component as the horizontal position or the first number in the vector.
   * If the x component is not defined, it will return 0.
   *
   * @returns {Number} The x component of the vector. Returns 0 if the value is not defined.
   */
  get x() {
    return this._values[0] || 0;
  }
  /**
   * Retrieves the value at the specified index from the vector.
   *
   * This method allows you to get the value of a specific component of the vector
   * by providing its index. Think of the vector as a list of numbers, where each
   * number represents a different direction (like x, y, or z). The index is just
   * the position of the number in that list.
   *
   * For example, if you have a vector with values 10, 20, 30 the index 0 would
   * give you the first value 10, index 1 would give you the second value 20,
   * and so on.
   *
   * @param {Number} index - The position of the value you want to get from the vector.
   * @returns {Number} The value at the specified position in the vector.
   * @throws Will throw an error if the index is out of bounds, meaning if you try to
   *          get a value from a position that doesn't exist in the vector.
   */
  getValue(index) {
    if (index < this._values.length) {
      return this._values[index];
    } else {
      p5._friendlyError(
        "The index parameter is trying to set a value outside the bounds of the vector",
        "p5.Vector.setValue"
      );
    }
  }
  /**
   * Sets the value at the specified index of the vector.
   *
   * This method allows you to change a specific component of the vector by providing its index and the new value you want to set.
   * Think of the vector as a list of numbers, where each number represents a different direction (like x, y, or z).
   * The index is just the position of the number in that list.
   *
   * For example, if you have a vector with values [0, 20, 30], and you want to change the second value (20) to 50,
   * you would use this method with index 1 (since indexes start at 0) and value 50.
   *
   * @param {Number} index - The position in the vector where you want to set the new value.
   * @param {Number} value - The new value you want to set at the specified position.
   * @throws Will throw an error if the index is outside the bounds of the vector, meaning if you try to set a value at a position that doesn't exist in the vector.
   */
  setValue(index, value) {
    if (index < this._values.length) {
      this._values[index] = value;
    } else {
      p5._friendlyError(
        "The index parameter is trying to set a value outside the bounds of the vector",
        "p5.Vector.setValue"
      );
    }
  }
  /**
   * Gets the y component of the vector.
   *
   * This method returns the value of the y component of the vector.
   * Think of the y component as the vertical position or the second number in the vector.
   * If the y component is not defined, it will return 0.
   *
   * @returns {Number} The y component of the vector. Returns 0 if the value is not defined.
   */
  get y() {
    return this._values[1] || 0;
  }
  /**
   * Gets the z component of the vector.
   *
   * This method returns the value of the z component of the vector.
   * Think of the z component as the depth or the third number in the vector.
   * If the z component is not defined, it will return 0.
   *
   * @returns {Number} The z component of the vector. Returns 0 if the value is not defined.
   */
  get z() {
    return this._values[2] || 0;
  }
  /**
   * Gets the w component of the vector.
   *
   * This method returns the value of the w component of the vector.
   * Think of the w component as the fourth number in the vector.
   * If the w component is not defined, it will return 0.
   *
   * @returns {Number} The w component of the vector. Returns 0 if the value is not defined.
   */
  get w() {
    return this._values[3] || 0;
  }
  /**
   * Sets the x component of the vector.
   *
   * This method allows you to change the x value of the vector.
   * The x value is the first number in the vector, representing the horizontal position.
   * By calling this method, you can update the x value to a new number.
   *
   * @param {Number} xVal - The new value for the x component.
   */
  set x(xVal) {
    if (this._values.length > 1) {
      this._values[0] = xVal;
    }
  }
  /**
   * Sets the y component of the vector.
   *
   * This method allows you to change the y value of the vector.
   * The y value is the second number in the vector, representing the vertical position.
   * By calling this method, you can update the y value to a new number.
   *
   * @param {Number} yVal - The new value for the y component.
   */
  set y(yVal) {
    if (this._values.length > 1) {
      this._values[1] = yVal;
    }
  }
  /**
   * Sets the z component of the vector.
   *
   * This method allows you to change the z value of the vector.
   * The z value is the third number in the vector, representing the depth or the third dimension.
   * By calling this method, you can update the z value to a new number.
   *
   * @param {Number} zVal - The new value for the z component.
   */
  set z(zVal) {
    if (this._values.length > 2) {
      this._values[2] = zVal;
    }
  }
  /**
   * Sets the w component of the vector.
   *
   * This method allows you to change the w value of the vector.
   * The w value is the fourth number in the vector, representing the fourth dimension.
   * By calling this method, you can update the w value to a new number.
   *
   * @param {Number} wVal - The new value for the w component.
   */
  set w(wVal) {
    if (this._values.length > 3) {
      this._values[3] = wVal;
    }
  }
  /**
   * Returns a string representation of a vector.
   *
   * Calling `toString()` is useful for printing vectors to the console while
   * debugging.
   *
   * @return {String} string representation of the vector.
   *
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   let v = createVector(20, 30);
   *
   *   // Prints 'vector[20, 30, 0]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   */
  toString() {
    return `vector[${this._values.join(", ")}]`;
  }
  /**
   * Sets the vector's `x`, `y`, and `z` components.
   *
   * `set()` can use separate numbers, as in `v.set(1, 2, 3)`, a
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.set(v2)`, or an
   * array of numbers, as in `v.set([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it will be set to 0. For
   * example, `v.set(4, 5)` sets `v.x` to 4, `v.y` to 5, and `v.z` to 0.
   * Calling `set()` with no arguments, as in `v.set()`, sets all the vector's
   * components to 0.
   *
   * @param {Number} [x] x component of the vector.
   * @param {Number} [y] y component of the vector.
   * @param {Number} [z] z component of the vector.
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top left.
   *   let pos = createVector(25, 25);
   *   point(pos);
   *
   *   // Top right.
   *   // set() with numbers.
   *   pos.set(75, 25);
   *   point(pos);
   *
   *   // Bottom right.
   *   // set() with a p5.Vector.
   *   let p2 = createVector(75, 75);
   *   pos.set(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // set() with an array.
   *   let arr = [25, 75];
   *   pos.set(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param {p5.Vector|Number[]} value vector to set.
   * @chainable
   */
  set(...args) {
    if (args[0] instanceof Vector) {
      this._values = args[0].values.slice();
    } else if (Array.isArray(args[0])) {
      this._values = args[0].map((arg) => arg || 0);
    } else {
      this._values = args.map((arg) => arg || 0);
    }
    this.dimensions = this._values.length;
    return this;
  }
  /**
   * Returns a copy of the <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @return {p5.Vector} copy of the <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100 ,100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let pos = createVector(50, 50);
   *
   *   // Make a copy.
   *   let pc = pos.copy();
   *
   *   // Draw the point.
   *   strokeWeight(5);
   *   point(pc);
   *
   *   describe('A black point drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */
  copy() {
    if (this.isPInst) {
      return new Vector(this._fromRadians, this._toRadians, ...this._values);
    } else {
      return new Vector(...this._values);
    }
  }
  /**
   * Adds to a vector's components.
   *
   * `add()` can use separate numbers, as in `v.add(1, 2, 3)`,
   * another <a href="#/p5.Vector">p5.Vector</a> object, as in `v.add(v2)`, or
   * an array of numbers, as in `v.add([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it won't change. For
   * example, `v.add(4, 5)` adds 4 to `v.x`, 5 to `v.y`, and 0 to `v.z`.
   * Calling `add()` with no arguments, as in `v.add()`, has no effect.
   *
   * This method supports N-dimensional vectors.
   *
   * The static version of `add()`, as in `p5.Vector.add(v2, v1)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number|Array} x   x component of the vector to be added or an array of components.
   * @param  {Number} [y] y component of the vector to be added.
   * @param  {Number} [z] z component of the vector to be added.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top left.
   *   let pos = createVector(25, 25);
   *   point(pos);
   *
   *   // Top right.
   *   // Add numbers.
   *   pos.add(50, 0);
   *   point(pos);
   *
   *   // Bottom right.
   *   // Add a p5.Vector.
   *   let p2 = createVector(0, 50);
   *   pos.add(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // Add an array.
   *   let arr = [-50, 0];
   *   pos.add(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top left.
   *   let p1 = createVector(25, 25);
   *
   *   // Center.
   *   let p2 = createVector(50, 50);
   *
   *   // Bottom right.
   *   // Add p1 and p2.
   *   let p3 = p5.Vector.add(p1, p2);
   *
   *   // Draw the points.
   *   strokeWeight(5);
   *   point(p1);
   *   point(p2);
   *   point(p3);
   *
   *   describe('Three black dots in a diagonal line from top left to bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red arrow extends from the top left corner to the center. A blue arrow extends from the tip of the red arrow. A purple arrow extends from the origin to the tip of the blue arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(-30, 20);
   *   drawArrow(v1, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.add(v1, v2);
   *   drawArrow(origin, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {p5.Vector|Number[]} value The vector to add
   * @chainable
   */
  add(...args) {
    if (args[0] instanceof Vector) {
      args = args[0].values;
    } else if (Array.isArray(args[0])) {
      args = args[0];
    }
    args.forEach((value, index) => {
      this._values[index] = (this._values[index] || 0) + (value || 0);
    });
    return this;
  }
  /**
   * Performs modulo (remainder) division with a vector's `x`, `y`, and `z`
   * components.
   *
   * `rem()` can use separate numbers, as in `v.rem(1, 2, 3)`,
   * another <a href="#/p5.Vector">p5.Vector</a> object, as in `v.rem(v2)`, or
   * an array of numbers, as in `v.rem([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.rem(2)`, then all the components
   * will be set to their values modulo 2. If two values are provided, as in
   * `v.rem(2, 3)`, then `v.z` won't change. Calling `rem()` with no
   * arguments, as in `v.rem()`, has no effect.
   *
   * The static version of `rem()`, as in `p5.Vector.rem(v2, v1)`, returns a
   * new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param {Number} x x component of divisor vector.
   * @param {Number} y y component of divisor vector.
   * @param {Number} z z component of divisor vector.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2);
   *
   *   // Prints 'p5.Vector Object : [1, 0, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2, 3);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 5]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2, 3, 4);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4, 5);
   *   let v2 = createVector(2, 3, 4);
   *
   *   // Divide a p5.Vector.
   *   v1.rem(v2);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide an array.
   *   let arr = [2, 3, 4];
   *   v.rem(arr);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4, 5);
   *   let v2 = createVector(2, 3, 4);
   *
   *   // Divide without modifying the original vectors.
   *   let v3 = p5.Vector.rem(v1, v2);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v3.toString());
   * }
   * </code>
   * </div>
   */
  /**
   * @param {p5.Vector | Number[]}  value  divisor vector.
   * @chainable
   */
  rem(x, y, z) {
    if (x instanceof Vector) {
      if ([x.x, x.y, x.z].every(Number.isFinite)) {
        const xComponent = parseFloat(x.x);
        const yComponent = parseFloat(x.y);
        const zComponent = parseFloat(x.z);
        return calculateRemainder3D.call(
          this,
          xComponent,
          yComponent,
          zComponent
        );
      }
    } else if (Array.isArray(x)) {
      if (x.every((element2) => Number.isFinite(element2))) {
        if (x.length === 2) {
          return calculateRemainder2D.call(this, x[0], x[1]);
        }
        if (x.length === 3) {
          return calculateRemainder3D.call(this, x[0], x[1], x[2]);
        }
      }
    } else if (arguments.length === 1) {
      if (Number.isFinite(arguments[0]) && arguments[0] !== 0) {
        this.x = this.x % arguments[0];
        this.y = this.y % arguments[0];
        this.z = this.z % arguments[0];
        return this;
      }
    } else if (arguments.length === 2) {
      const vectorComponents = [...arguments];
      if (vectorComponents.every((element2) => Number.isFinite(element2))) {
        if (vectorComponents.length === 2) {
          return calculateRemainder2D.call(
            this,
            vectorComponents[0],
            vectorComponents[1]
          );
        }
      }
    } else if (arguments.length === 3) {
      const vectorComponents = [...arguments];
      if (vectorComponents.every((element2) => Number.isFinite(element2))) {
        if (vectorComponents.length === 3) {
          return calculateRemainder3D.call(
            this,
            vectorComponents[0],
            vectorComponents[1],
            vectorComponents[2]
          );
        }
      }
    }
  }
  /**
   * Subtracts from a vector's `x`, `y`, and `z` components.
   *
   * `sub()` can use separate numbers, as in `v.sub(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.sub(v2)`, or an array
   * of numbers, as in `v.sub([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it won't change. For
   * example, `v.sub(4, 5)` subtracts 4 from `v.x`, 5 from `v.y`, and 0 from `v.z`.
   * Calling `sub()` with no arguments, as in `v.sub()`, has no effect.
   *
   * The static version of `sub()`, as in `p5.Vector.sub(v2, v1)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number} x   x component of the vector to subtract.
   * @param  {Number} [y] y component of the vector to subtract.
   * @param  {Number} [z] z component of the vector to subtract.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom right.
   *   let pos = createVector(75, 75);
   *   point(pos);
   *
   *   // Top right.
   *   // Subtract numbers.
   *   pos.sub(0, 50);
   *   point(pos);
   *
   *   // Top left.
   *   // Subtract a p5.Vector.
   *   let p2 = createVector(50, 0);
   *   pos.sub(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // Subtract an array.
   *   let arr = [0, -50];
   *   pos.sub(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let p1 = createVector(75, 75);
   *   let p2 = createVector(50, 50);
   *
   *   // Subtract with modifying the original vectors.
   *   let p3 = p5.Vector.sub(p1, p2);
   *
   *   // Draw the points.
   *   strokeWeight(5);
   *   point(p1);
   *   point(p2);
   *   point(p3);
   *
   *   describe('Three black dots in a diagonal line from top left to bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red and a blue arrow extend from the top left. A purple arrow extends from the tip of the red arrow to the tip of the blue arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(20, 70);
   *   drawArrow(origin, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.sub(v2, v1);
   *   drawArrow(v1, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {p5.Vector|Number[]} value the vector to subtract
   * @chainable
   */
  sub(...args) {
    if (args[0] instanceof Vector) {
      args[0].values.forEach((value, index) => {
        this._values[index] -= value || 0;
      });
    } else if (Array.isArray(args[0])) {
      args[0].forEach((value, index) => {
        this._values[index] -= value || 0;
      });
    } else {
      args.forEach((value, index) => {
        this._values[index] -= value || 0;
      });
    }
    return this;
  }
  /**
   * Multiplies a vector's `x`, `y`, and `z` components.
   *
   * `mult()` can use separate numbers, as in `v.mult(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.mult(v2)`, or an array
   * of numbers, as in `v.mult([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.mult(2)`, then all the components
   * will be multiplied by 2. If a value isn't provided for a component, it
   * won't change. For example, `v.mult(4, 5)` multiplies `v.x` by, `v.y` by 5,
   * and `v.z` by 1. Calling `mult()` with no arguments, as in `v.mult()`, has
   * no effect.
   *
   * The static version of `mult()`, as in `p5.Vector.mult(v, 2)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number} n The number to multiply with the vector
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Center.
   *   // Multiply all components by 2.
   *   p.mult(2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * 2 and p.y * 3
   *   p.mult(2, 3);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * 2 and p.y * 3
   *   let arr = [2, 3];
   *   p.mult(arr);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * p2.x and p.y * p2.y
   *   let p2 = createVector(2, 3);
   *   p.mult(p2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Create a new p5.Vector with
   *   // p3.x = p.x * p2.x
   *   // p3.y = p.y * p2.y
   *   let p2 = createVector(2, 3);
   *   let p3 = p5.Vector.mult(p, p2);
   *   point(p3);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extending from the top left corner. The blue arrow is twice the length of the red arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(25, 25);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = p5.Vector.mult(v1, 2);
   *   drawArrow(origin, v2, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Number} x number to multiply with the x component of the vector.
   * @param  {Number} y number to multiply with the y component of the vector.
   * @param  {Number} [z] number to multiply with the z component of the vector.
   * @chainable
   */
  /**
   * @param  {Number[]} arr array to multiply with the components of the vector.
   * @chainable
   */
  /**
   * @param  {p5.Vector} v vector to multiply with the components of the original vector.
   * @chainable
   */
  mult(...args) {
    if (args.length === 1 && args[0] instanceof Vector) {
      const v = args[0];
      const maxLen = Math.min(this._values.length, v.values.length);
      for (let i = 0; i < maxLen; i++) {
        if (Number.isFinite(v.values[i]) && typeof v.values[i] === "number") {
          this._values[i] *= v.values[i];
        } else {
          console.warn(
            "p5.Vector.prototype.mult:",
            "v contains components that are either undefined or not finite numbers"
          );
          return this;
        }
      }
    } else if (args.length === 1 && Array.isArray(args[0])) {
      const arr2 = args[0];
      const maxLen = Math.min(this._values.length, arr2.length);
      for (let i = 0; i < maxLen; i++) {
        if (Number.isFinite(arr2[i]) && typeof arr2[i] === "number") {
          this._values[i] *= arr2[i];
        } else {
          console.warn(
            "p5.Vector.prototype.mult:",
            "arr contains elements that are either undefined or not finite numbers"
          );
          return this;
        }
      }
    } else if (args.length === 1 && typeof args[0] === "number" && Number.isFinite(args[0])) {
      for (let i = 0; i < this._values.length; i++) {
        this._values[i] *= args[0];
      }
    }
    return this;
  }
  /**
   * Divides a vector's `x`, `y`, and `z` components.
   *
   * `div()` can use separate numbers, as in `v.div(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.div(v2)`, or an array
   * of numbers, as in `v.div([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.div(2)`, then all the components
   * will be divided by 2. If a value isn't provided for a component, it
   * won't change. For example, `v.div(4, 5)` divides `v.x` by, `v.y` by 5,
   * and `v.z` by 1. Calling `div()` with no arguments, as in `v.div()`, has
   * no effect.
   *
   * The static version of `div()`, as in `p5.Vector.div(v, 2)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number}    n The number to divide the vector by
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Center.
   *   let p = createVector(50, 50);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 2
   *   p.div(2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   p.div(2, 3);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   let arr = [2, 3];
   *   p.div(arr);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   let p2 = createVector(2, 3);
   *   p.div(p2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Create a new p5.Vector with
   *   // p3.x = p.x / p2.x
   *   // p3.y = p.y / p2.y
   *   let p2 = createVector(2, 3);
   *   let p3 = p5.Vector.div(p, p2);
   *   point(p3);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = p5.Vector.div(v1, 2);
   *   drawArrow(origin, v2, 'blue');
   *
   *   describe('Two arrows extending from the top left corner. The blue arrow is half the length of the red arrow.');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Number} x number to divide with the x component of the vector.
   * @param  {Number} y number to divide with the y component of the vector.
   * @param  {Number} [z] number to divide with the z component of the vector.
   * @chainable
   */
  /**
   * @param  {Number[]} arr array to divide the components of the vector by.
   * @chainable
   */
  /**
   * @param  {p5.Vector} v vector to divide the components of the original vector by.
   * @chainable
   */
  div(...args) {
    if (args.length === 0) return this;
    if (args.length === 1 && args[0] instanceof Vector) {
      const v = args[0];
      if (v._values.every(
        (val) => Number.isFinite(val) && typeof val === "number"
      )) {
        if (v._values.some((val) => val === 0)) {
          console.warn("p5.Vector.prototype.div:", "divide by 0");
          return this;
        }
        this._values = this._values.map((val, i) => val / v._values[i]);
      } else {
        console.warn(
          "p5.Vector.prototype.div:",
          "vector contains components that are either undefined or not finite numbers"
        );
      }
      return this;
    }
    if (args.length === 1 && Array.isArray(args[0])) {
      const arr2 = args[0];
      if (arr2.every((val) => Number.isFinite(val) && typeof val === "number")) {
        if (arr2.some((val) => val === 0)) {
          console.warn("p5.Vector.prototype.div:", "divide by 0");
          return this;
        }
        this._values = this._values.map((val, i) => val / arr2[i]);
      } else {
        console.warn(
          "p5.Vector.prototype.div:",
          "array contains components that are either undefined or not finite numbers"
        );
      }
      return this;
    }
    if (args.every((val) => Number.isFinite(val) && typeof val === "number")) {
      if (args.some((val) => val === 0)) {
        console.warn("p5.Vector.prototype.div:", "divide by 0");
        return this;
      }
      this._values = this._values.map((val, i) => val / args[0]);
    } else {
      console.warn(
        "p5.Vector.prototype.div:",
        "arguments contain components that are either undefined or not finite numbers"
      );
    }
    return this;
  }
  /**
   * Calculates the magnitude (length) of the vector.
   *
   * Use <a href="#/p5/mag">mag()</a> to calculate the magnitude of a 2D vector
   * using components as in `mag(x, y)`.
   *
   * @return {Number} magnitude of the vector.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let p = createVector(30, 40);
   *
   *   // Draw a line from the origin.
   *   line(0, 0, p.x, p.y);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the vector's magnitude.
   *   let m = p.mag();
   *   text(m, p.x, p.y);
   *
   *   describe('A diagonal black line extends from the top left corner of a gray square. The number 50 is written at the end of the line.');
   * }
   * </code>
   * </div>
   */
  mag() {
    return Math.sqrt(this.magSq());
  }
  /**
   * Calculates the magnitude (length) of the vector squared.
   *
   * @return {Number} squared magnitude of the vector.
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let p = createVector(30, 40);
   *
   *   // Draw a line from the origin.
   *   line(0, 0, p.x, p.y);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the vector's magnitude squared.
   *   let m = p.magSq();
   *   text(m, p.x, p.y);
   *
   *   describe('A diagonal black line extends from the top left corner of a gray square. The number 2500 is written at the end of the line.');
   * }
   * </code>
   * </div>
   */
  magSq() {
    return this._values.reduce(
      (sum, component) => sum + component * component,
      0
    );
  }
  /**
   * Calculates the dot product of two vectors.
   *
   * The dot product is a number that describes the overlap between two vectors.
   * Visually, the dot product can be thought of as the "shadow" one vector
   * casts on another. The dot product's magnitude is largest when two vectors
   * point in the same or opposite directions. Its magnitude is 0 when two
   * vectors form a right angle.
   *
   * The version of `dot()` with one parameter interprets it as another
   * <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * The version of `dot()` with multiple parameters interprets them as the
   * `x`, `y`, and `z` components of another vector.
   *
   * The static version of `dot()`, as in `p5.Vector.dot(v1, v2)`, is the same
   * as calling `v1.dot(v2)`.
   *
   * @param  {Number} x   x component of the vector.
   * @param  {Number} [y] y component of the vector.
   * @param  {Number} [z] z component of the vector.
   * @return {Number}     dot product.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4);
   *   let v2 = createVector(3, 0);
   *
   *   // Calculate the dot product.
   *   let dp = v1.dot(v2);
   *
   *   // Prints "9" to the console.
   *   print(dp);
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the dot product.
   *   let dp = p5.Vector.dot(v1, v2);
   *
   *   // Prints "0" to the console.
   *   print(dp);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows drawn on a gray square. A black arrow points to the right and a red arrow follows the mouse. The text "v1 • v2 = something" changes as the mouse moves.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Center.
   *   let v0 = createVector(50, 50);
   *
   *   // Draw the black arrow.
   *   let v1 = createVector(30, 0);
   *   drawArrow(v0, v1, 'black');
   *
   *   // Draw the red arrow.
   *   let v2 = createVector(mouseX - 50, mouseY - 50);
   *   drawArrow(v0, v2, 'red');
   *
   *   // Display the dot product.
   *   let dp = v2.dot(v1);
   *   text(`v2 • v1 = ${dp}`, 10, 20);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to be dotted.
   * @return {Number}
   */
  dot(...args) {
    if (args[0] instanceof Vector) {
      return this.dot(...args[0]._values);
    }
    return this._values.reduce((sum, component, index) => {
      return sum + component * (args[index] || 0);
    }, 0);
  }
  /**
   * Calculates the cross product of two vectors.
   *
   * The cross product is a vector that points straight out of the plane created
   * by two vectors. The cross product's magnitude is the area of the parallelogram
   * formed by the original two vectors.
   *
   * The static version of `cross()`, as in `p5.Vector.cross(v1, v2)`, is the same
   * as calling `v1.cross(v2)`.
   *
   * @param  {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to be crossed.
   * @return {p5.Vector}   cross product as a <a href="#/p5.Vector">p5.Vector</a>.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(3, 4);
   *
   *   // Calculate the cross product.
   *   let cp = v1.cross(v2);
   *
   *   // Prints "p5.Vector Object : [0, 0, 4]" to the console.
   *   print(cp.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(3, 4);
   *
   *   // Calculate the cross product.
   *   let cp = p5.Vector.cross(v1, v2);
   *
   *   // Prints "p5.Vector Object : [0, 0, 4]" to the console.
   *   print(cp.toString());
   * }
   * </code>
   * </div>
   */
  cross(v) {
    const x = this.y * v.z - this.z * v.y;
    const y = this.z * v.x - this.x * v.z;
    const z = this.x * v.y - this.y * v.x;
    if (this.isPInst) {
      return new Vector(this._fromRadians, this._toRadians, x, y, z);
    } else {
      return new Vector(x, y, z);
    }
  }
  /**
   * Calculates the distance between two points represented by vectors.
   *
   * A point's coordinates can be represented by the components of a vector
   * that extends from the origin to the point.
   *
   * The static version of `dist()`, as in `p5.Vector.dist(v1, v2)`, is the same
   * as calling `v1.dist(v2)`.
   *
   * Use <a href="#/p5/dist">dist()</a> to calculate the distance between points
   * using coordinates as in `dist(x1, y1, x2, y2)`.
   *
   * @submodule p5.Vector
   * @param  {p5.Vector} v x, y, and z coordinates of a <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}      distance.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the distance between them.
   *   let d = v1.dist(v2);
   *
   *   // Prints "1.414..." to the console.
   *   print(d);
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the distance between them.
   *   let d = p5.Vector.dist(v1, v2);
   *
   *   // Prints "1.414..." to the console.
   *   print(d);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red and a blue arrow extend from the top left. A purple arrow extends from the tip of the red arrow to the tip of the blue arrow. The number 36 is written in black near the purple arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(20, 70);
   *   drawArrow(origin, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.sub(v2, v1);
   *   drawArrow(v1, v3, 'purple');
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *
   *   // Display the magnitude. The same as floor(v3.mag());
   *   let m = floor(p5.Vector.dist(v1, v2));
   *   text(m, 50, 75);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  dist(v) {
    return v.copy().sub(this).mag();
  }
  /**
   * Scales the components of a <a href="#/p5.Vector">p5.Vector</a> object so
   * that its magnitude is 1.
   *
   * The static version of `normalize()`,  as in `p5.Vector.normalize(v)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @return {p5.Vector} normalized <a href="#/p5.Vector">p5.Vector</a>.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector.
   *   let v = createVector(10, 20, 2);
   *
   *   // Normalize.
   *   v.normalize();
   *
   *   // Prints "p5.Vector Object : [0.445..., 0.890..., 0.089...]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector.
   *   let v0 = createVector(10, 20, 2);
   *
   *   // Create a normalized copy.
   *   let v1 = p5.Vector.normalize(v0);
   *
   *   // Prints "p5.Vector Object : [10, 20, 2]" to the console.
   *   print(v0.toString());
   *   // Prints "p5.Vector Object : [0.445..., 0.890..., 0.089...]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A red and blue arrow extend from the center of a circle. Both arrows follow the mouse, but the blue arrow's length is fixed to the circle's radius.");
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   // Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Vector from the center to the mouse.
   *   let v1 = createVector(mouseX - 50, mouseY - 50);
   *
   *   // Circle's radius.
   *   let r = 25;
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   v1.normalize();
   *   drawArrow(v0, v1.mult(r), 'blue');
   *
   *   // Draw the circle.
   *   noFill();
   *   circle(50, 50, r * 2);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  normalize() {
    const len = this.mag();
    if (len !== 0) this.mult(1 / len);
    return this;
  }
  /**
   * Limits a vector's magnitude to a maximum value.
   *
   * The static version of `limit()`, as in `p5.Vector.limit(v, 5)`, returns a
   * new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * original.
   *
   * @param  {Number}    max maximum magnitude for the vector.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(10, 20, 2);
   *
   *   // Limit its magnitude.
   *   v.limit(5);
   *
   *   // Prints "p5.Vector Object : [2.227..., 4.454..., 0.445...]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(10, 20, 2);
   *
   *   // Create a copy an limit its magintude.
   *   let v1 = p5.Vector.limit(v0, 5);
   *
   *   // Prints "p5.Vector Object : [2.227..., 4.454..., 0.445...]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A red and blue arrow extend from the center of a circle. Both arrows follow the mouse, but the blue arrow never crosses the circle's edge.");
   * }
   * function draw() {
   *   background(240);
   *
   *   // Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Vector from the center to the mouse.
   *   let v1 = createVector(mouseX - 50, mouseY - 50);
   *
   *   // Circle's radius.
   *   let r = 25;
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v1.limit(r), 'blue');
   *
   *   // Draw the circle.
   *   noFill();
   *   circle(50, 50, r * 2);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  limit(max) {
    const mSq = this.magSq();
    if (mSq > max * max) {
      this.div(Math.sqrt(mSq)).mult(max);
    }
    return this;
  }
  /**
   * Sets a vector's magnitude to a given value.
   *
   * The static version of `setMag()`, as in `p5.Vector.setMag(v, 10)`, returns
   * a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * original.
   *
   * @param  {Number}    len new length for this vector.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 0);
   *
   *   // Prints "5" to the console.
   *   print(v.mag());
   *
   *   // Set its magnitude to 10.
   *   v.setMag(10);
   *
   *   // Prints "p5.Vector Object : [6, 8, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 4, 0);
   *
   *   // Create a copy with a magnitude of 10.
   *   let v1 = p5.Vector.setMag(v0, 10);
   *
   *   // Prints "5" to the console.
   *   print(v0.mag());
   *
   *   // Prints "p5.Vector Object : [6, 8, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the top left corner of a square toward its center. The red arrow reaches the center and the blue arrow only extends part of the way.');
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   let origin = createVector(0, 0);
   *   let v = createVector(50, 50);
   *
   *   // Draw the red arrow.
   *   drawArrow(origin, v, 'red');
   *
   *   // Set v's magnitude to 30.
   *   v.setMag(30);
   *
   *   // Draw the blue arrow.
   *   drawArrow(origin, v, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  setMag(n2) {
    return this.normalize().mult(n2);
  }
  /**
   * Calculates the angle a 2D vector makes with the positive x-axis.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `heading()` returns angles
   * in the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * The static version of `heading()`, as in `p5.Vector.heading(v)`, works the
   * same way.
   *
   * @return {Number} angle of rotation.
   *
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1);
   *
   *   // Prints "0.785..." to the console.
   *   print(v.heading());
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Prints "45" to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1);
   *
   *   // Prints "0.785..." to the console.
   *   print(p5.Vector.heading(v));
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Prints "45" to the console.
   *   print(p5.Vector.heading(v));
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black arrow extends from the top left of a square to its center. The text "Radians: 0.79" and "Degrees: 45" is written near the tip of the arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *   let v = createVector(50, 50);
   *
   *   // Draw the black arrow.
   *   drawArrow(origin, v, 'black');
   *
   *   // Use radians.
   *   angleMode(RADIANS);
   *
   *   // Display the heading in radians.
   *   let h = round(v.heading(), 2);
   *   text(`Radians: ${h}`, 20, 70);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Display the heading in degrees.
   *   h = v.heading();
   *   text(`Degrees: ${h}`, 20, 85);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  heading() {
    const h = Math.atan2(this.y, this.x);
    if (this.isPInst) return this._fromRadians(h);
    return h;
  }
  /**
   * Rotates a 2D vector to a specific angle without changing its magnitude.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `setHeading()` uses
   * the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param  {Number}    angle angle of rotation.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(v.heading());
   *
   *   // Point to the left.
   *   v.setHeading(PI);
   *
   *   // Prints "3.141..." to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(v.heading());
   *
   *   // Point to the left.
   *   v.setHeading(180);
   *
   *   // Prints "180" to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the center of a gray square. The red arrow points to the right and the blue arrow points down.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Point down.
   *   v1.setHeading(HALF_PI);
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v1, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  setHeading(a) {
    if (this.isPInst) a = this._toRadians(a);
    let m = this.mag();
    this.x = m * Math.cos(a);
    this.y = m * Math.sin(a);
    return this;
  }
  /**
   * Rotates a 2D vector by an angle without changing its magnitude.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `rotate()` uses
   * the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * The static version of `rotate()`, as in `p5.Vector.rotate(v, PI)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {Number}    angle angle of rotation.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   *
   *   // Rotate a quarter turn.
   *   v.rotate(HALF_PI);
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   *
   *   // Rotate a quarter turn.
   *   v.rotate(90);
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 0);
   *
   *   // Create a rotated copy.
   *   let v1 = p5.Vector.rotate(v0, HALF_PI);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v0.toString());
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 0);
   *
   *   // Create a rotated copy.
   *   let v1 = p5.Vector.rotate(v0, 90);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v0.toString());
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let v0;
   * let v1;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create p5.Vector objects.
   *   v0 = createVector(50, 50);
   *   v1 = createVector(30, 0);
   *
   *   describe('A black arrow extends from the center of a gray square. The arrow rotates clockwise.');
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   // Rotate v1.
   *   v1.rotate(0.01);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  rotate(a) {
    let newHeading = this.heading() + a;
    if (this.isPInst) newHeading = this._toRadians(newHeading);
    const mag = this.mag();
    this.x = Math.cos(newHeading) * mag;
    this.y = Math.sin(newHeading) * mag;
    return this;
  }
  /**
   * Calculates the angle between two vectors.
   *
   * The angles returned are signed, which means that
   * `v1.angleBetween(v2) === -v2.angleBetween(v1)`.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `angleBetween()` returns
   * angles in the units of the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param  {p5.Vector}    value x, y, and z components of a <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}       angle between the vectors.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(v0.angleBetween(v1));
   *
   *   // Prints "-1.570..." to the console.
   *   print(v1.angleBetween(v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(v0.angleBetween(v1));
   *
   *   // Prints "-90" to the console.
   *   print(v1.angleBetween(v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(p5.Vector.angleBetween(v0, v1));
   *
   *   // Prints "-1.570..." to the console.
   *   print(p5.Vector.angleBetween(v1, v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(p5.Vector.angleBetween(v0, v1));
   *
   *   // Prints "-90" to the console.
   *   print(p5.Vector.angleBetween(v1, v0));
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the center of a gray square. A red arrow points to the right and a blue arrow points down. The text "Radians: 1.57" and "Degrees: 90" is written above the arrows.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *   let v2 = createVector(0, 30);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Use radians.
   *   angleMode(RADIANS);
   *
   *   // Display the angle in radians.
   *   let angle = round(v1.angleBetween(v2), 2);
   *   text(`Radians: ${angle}`, 20, 20);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Display the angle in degrees.
   *   angle = round(v1.angleBetween(v2), 2);
   *   text(`Degrees: ${angle}`, 20, 35);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  angleBetween(v) {
    const magSqMult = this.magSq() * v.magSq();
    if (magSqMult === 0) {
      return NaN;
    }
    const u = this.cross(v);
    let angle = Math.atan2(u.mag(), this.dot(v)) * Math.sign(u.z || 1);
    if (this.isPInst) {
      angle = this._fromRadians(angle);
    }
    return angle;
  }
  /**
   * Calculates new `x`, `y`, and `z` components that are proportionally the
   * same distance between two vectors.
   *
   * The `amt` parameter is the amount to interpolate between the old vector and
   * the new vector. 0.0 keeps all components equal to the old vector's, 0.5 is
   * halfway between, and 1.0 sets all components equal to the new vector's.
   *
   * The static version of `lerp()`, as in `p5.Vector.lerp(v0, v1, 0.5)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {Number}    x   x component.
   * @param  {Number}    y   y component.
   * @param  {Number}    z   z component.
   * @param  {Number}    amt amount of interpolation between 0.0 (old vector)
   *                         and 1.0 (new vector). 0.5 is halfway between.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 1, 1);
   *   let v1 = createVector(3, 3, 3);
   *
   *   // Interpolate.
   *   v0.lerp(v1, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v0.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1, 1);
   *
   *   // Interpolate.
   *   v.lerp(3, 3, 3, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 1, 1);
   *   let v1 = createVector(3, 3, 3);
   *
   *   // Interpolate.
   *   let v2 = p5.Vector.lerp(v0, v1, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v2.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square. A red arrow points to the right, a blue arrow points down, and a purple arrow points to the bottom right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *   let v2 = createVector(0, 30);
   *
   *   // Interpolate.
   *   let v3 = p5.Vector.lerp(v1, v2, 0.5);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Draw the purple arrow.
   *   drawArrow(v0, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {p5.Vector} v  <a href="#/p5.Vector">p5.Vector</a> to lerp toward.
   * @param  {Number}    amt
   * @chainable
   */
  lerp(x, y, z, amt) {
    if (x instanceof Vector) {
      return this.lerp(x.x, x.y, x.z, y);
    }
    this.x += (x - this.x) * amt || 0;
    this.y += (y - this.y) * amt || 0;
    this.z += (z - this.z) * amt || 0;
    return this;
  }
  /**
   * Calculates a new heading and magnitude that are between two vectors.
   *
   * The `amt` parameter is the amount to interpolate between the old vector and
   * the new vector. 0.0 keeps the heading and magnitude equal to the old
   * vector's, 0.5 sets them halfway between, and 1.0 sets the heading and
   * magnitude equal to the new vector's.
   *
   * `slerp()` differs from <a href="#/p5.Vector/lerp">lerp()</a> because
   * it interpolates magnitude. Calling `v0.slerp(v1, 0.5)` sets `v0`'s
   * magnitude to a value halfway between its original magnitude and `v1`'s.
   * Calling `v0.lerp(v1, 0.5)` makes no such guarantee.
   *
   * The static version of `slerp()`, as in `p5.Vector.slerp(v0, v1, 0.5)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to slerp toward.
   * @param {Number} amt  amount of interpolation between 0.0 (old vector)
   *                      and 1.0 (new vector). 0.5 is halfway between.
   * @return {p5.Vector}
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 0);
   *
   *   // Prints "3" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0" to the console.
   *   print(v0.heading());
   *
   *   // Create a p5.Vector object.
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1" to the console.
   *   print(v1.mag());
   *
   *   // Prints "1.570..." to the console.
   *   print(v1.heading());
   *
   *   // Interpolate halfway between v0 and v1.
   *   v0.slerp(v1, 0.5);
   *
   *   // Prints "2" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0.785..." to the console.
   *   print(v0.heading());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 0);
   *
   *   // Prints "3" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0" to the console.
   *   print(v0.heading());
   *
   *   // Create a p5.Vector object.
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1" to the console.
   *   print(v1.mag());
   *
   *   // Prints "1.570..." to the console.
   *   print(v1.heading());
   *
   *   // Create a p5.Vector that's halfway between v0 and v1.
   *   let v3 = p5.Vector.slerp(v0, v1, 0.5);
   *
   *   // Prints "2" to the console.
   *   print(v3.mag());
   *
   *   // Prints "0.785..." to the console.
   *   print(v3.heading());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square. A red arrow points to the right, a blue arrow points to the left, and a purple arrow points down.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(20, 0);
   *   let v2 = createVector(-40, 0);
   *
   *   // Create a p5.Vector that's halfway between v1 and v2.
   *   let v3 = p5.Vector.slerp(v1, v2, 0.5);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Draw the purple arrow.
   *   drawArrow(v0, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  slerp(v, amt) {
    if (amt === 0) {
      return this;
    }
    if (amt === 1) {
      return this.set(v);
    }
    const selfMag = this.mag();
    const vMag = v.mag();
    const magmag = selfMag * vMag;
    if (magmag === 0) {
      this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
      return this;
    }
    const axis = this.cross(v);
    const axisMag = axis.mag();
    const theta = Math.atan2(axisMag, this.dot(v));
    if (axisMag > 0) {
      axis.x /= axisMag;
      axis.y /= axisMag;
      axis.z /= axisMag;
    } else if (theta < Math.PI * 0.5) {
      this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
      return this;
    } else {
      if (this.z === 0 && v.z === 0) {
        axis.set(0, 0, 1);
      } else if (this.x !== 0) {
        axis.set(this.y, -this.x, 0).normalize();
      } else {
        axis.set(1, 0, 0);
      }
    }
    const ey = axis.cross(this);
    const lerpedMagFactor = 1 - amt + amt * vMag / selfMag;
    const cosMultiplier = lerpedMagFactor * Math.cos(amt * theta);
    const sinMultiplier = lerpedMagFactor * Math.sin(amt * theta);
    this.x = this.x * cosMultiplier + ey.x * sinMultiplier;
    this.y = this.y * cosMultiplier + ey.y * sinMultiplier;
    this.z = this.z * cosMultiplier + ey.z * sinMultiplier;
    return this;
  }
  /**
   * Reflects a vector about a line in 2D or a plane in 3D.
   *
   * The orientation of the line or plane is described by a normal vector that
   * points away from the shape.
   *
   * The static version of `reflect()`, as in `p5.Vector.reflect(v, n)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {p5.Vector} surfaceNormal  <a href="#/p5.Vector">p5.Vector</a>
   *                                    to reflect about.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a normal vector.
   *   let n = createVector(0, 1);
   *   // Create a vector to reflect.
   *   let v = createVector(4, 6);
   *
   *   // Reflect v about n.
   *   v.reflect(n);
   *
   *   // Prints "p5.Vector Object : [4, -6, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a normal vector.
   *   let n = createVector(0, 1);
   *
   *   // Create a vector to reflect.
   *   let v0 = createVector(4, 6);
   *
   *   // Create a reflected vector.
   *   let v1 = p5.Vector.reflect(v0, n);
   *
   *   // Prints "p5.Vector Object : [4, -6, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square with a vertical line down its middle. A black arrow points to the right, a blue arrow points to the bottom left, and a red arrow points to the bottom right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Draw a vertical line.
   *   line(50, 0, 50, 100);
   *
   *   // Create a normal vector.
   *   let n = createVector(1, 0);
   *
   *   // Center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a vector to reflect.
   *   let v1 = createVector(30, 40);
   *
   *   // Create a reflected vector.
   *   let v2 = p5.Vector.reflect(v1, n);
   *
   *   // Scale the normal vector for drawing.
   *   n.setMag(30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, n, 'black');
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  reflect(surfaceNormal) {
    const surfaceNormalCopy = Vector.normalize(surfaceNormal);
    return this.sub(surfaceNormalCopy.mult(2 * this.dot(surfaceNormalCopy)));
  }
  /**
   * Returns the vector's components as an array of numbers.
   *
   * @return {Number[]} array with the vector's components.
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(20, 30);
   *
   *   // Prints "[20, 30, 0]" to the console.
   *   print(v.array());
   * }
   * </code>
   * </div>
   */
  array() {
    return [this.x || 0, this.y || 0, this.z || 0];
  }
  /**
   * Checks whether all the vector's components are equal to another vector's.
   *
   * `equals()` returns `true` if the vector's components are all the same as another
   * vector's and `false` if not.
   *
   * The version of `equals()` with one parameter interprets it as another
   * <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * The version of `equals()` with multiple parameters interprets them as the
   * components of another vector. Any missing parameters are assigned the value
   * 0.
   *
   * The static version of `equals()`, as in `p5.Vector.equals(v0, v1)`,
   * interprets both parameters as <a href="#/p5.Vector">p5.Vector</a> objects.
   *
   * @param {Number} [x] x component of the vector.
   * @param {Number} [y] y component of the vector.
   * @param {Number} [z] z component of the vector.
   * @return {Boolean} whether the vectors are equal.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(10, 20, 30);
   *   let v1 = createVector(10, 20, 30);
   *   let v2 = createVector(0, 0, 0);
   *
   *   // Prints "true" to the console.
   *   print(v0.equals(v1));
   *
   *   // Prints "false" to the console.
   *   print(v0.equals(v2));
   * }
   * </code>
   * </div>
   *
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(5, 10, 20);
   *   let v1 = createVector(5, 10, 20);
   *   let v2 = createVector(13, 10, 19);
   *
   *   // Prints "true" to the console.
   *   print(v0.equals(v1.x, v1.y, v1.z));
   *
   *   // Prints "false" to the console.
   *   print(v0.equals(v2.x, v2.y, v2.z));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(10, 20, 30);
   *   let v1 = createVector(10, 20, 30);
   *   let v2 = createVector(0, 0, 0);
   *
   *   // Prints "true" to the console.
   *   print(p5.Vector.equals(v0, v1));
   *
   *   // Prints "false" to the console.
   *   print(p5.Vector.equals(v0, v2));
   * }
   * </code>
   * </div>
   */
  /**
   * @param {p5.Vector|Array} value vector to compare.
   * @return {Boolean}
   */
  equals(...args) {
    let values;
    if (args[0] instanceof Vector) {
      values = args[0]._values;
    } else if (Array.isArray(args[0])) {
      values = args[0];
    } else {
      values = args;
    }
    for (let i = 0; i < this._values.length; i++) {
      if (this._values[i] !== (values[i] || 0)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Replaces the components of a <a href="#/p5.Vector">p5.Vector</a> that are very close to zero with zero.
   *
   * In computers, handling numbers with decimals can give slightly imprecise answers due to the way those numbers are represented.
   * This can make it hard to check if a number is zero, as it may be close but not exactly zero.
   * This method rounds very close numbers to zero to make those checks easier
   *
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
   *
   * @return {p5.Vector} with components very close to zero replaced with zero.
   * @chainable
   */
  clampToZero() {
    for (let i = 0; i < this._values.length; i++) {
      this._values[i] = this._clampToZero(this._values[i]);
    }
    return this;
  }
  /**
   * Helper function for clampToZero
   * @private
   */
  _clampToZero(val) {
    return Math.abs((val || 0) - 0) <= Number.EPSILON ? 0 : val;
  }
  // Static Methods
  /**
   * Creates a new 2D vector from an angle.
   *
   * @static
   * @param {Number}     angle desired angle, in radians. Unaffected by <a href="#/p5/angleMode">angleMode()</a>.
   * @param {Number}     [length] length of the new vector (defaults to 1).
   * @return {p5.Vector}       new <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngle(0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngle(0, 30);
   *
   *   // Prints "p5.Vector Object : [30, 0, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black arrow extends from the center of a gray square. It points to the right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create a p5.Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a p5.Vector with an angle 0 and magnitude 30.
   *   let v1 = p5.Vector.fromAngle(0, 30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  static fromAngle(angle, length) {
    if (typeof length === "undefined") {
      length = 1;
    }
    return new Vector(length * Math.cos(angle), length * Math.sin(angle));
  }
  /**
   * Creates a new 3D vector from a pair of ISO spherical angles.
   *
   * @static
   * @param {Number}     theta    polar angle in radians (zero is up).
   * @param {Number}     phi      azimuthal angle in radians
   *                               (zero is out of the screen).
   * @param {Number}     [length] length of the new vector (defaults to 1).
   * @return {p5.Vector}          new <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngles(0, 0);
   *
   *   // Prints "p5.Vector Object : [0, -1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A light shines on a pink sphere as it orbits.');
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Calculate the ISO angles.
   *   let theta = frameCount *  0.05;
   *   let phi = 0;
   *
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngles(theta, phi, 100);
   *
   *   // Create a point light using the p5.Vector.
   *   let c = color('deeppink');
   *   pointLight(c, v);
   *
   *   // Style the sphere.
   *   fill(255);
   *   noStroke();
   *
   *   // Draw the sphere.
   *   sphere(35);
   * }
   * </code>
   * </div>
   */
  static fromAngles(theta, phi, length) {
    if (typeof length === "undefined") {
      length = 1;
    }
    const cosPhi = Math.cos(phi);
    const sinPhi = Math.sin(phi);
    const cosTheta = Math.cos(theta);
    const sinTheta = Math.sin(theta);
    return new Vector(
      length * sinTheta * sinPhi,
      -length * cosTheta,
      length * sinTheta * cosPhi
    );
  }
  /**
   * Creates a new 2D unit vector with a random heading.
   *
   * @static
   * @return {p5.Vector} new <a href="#/p5.Vector">p5.Vector</a> object.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.random2D();
   *
   *   // Prints "p5.Vector Object : [x, y]" to the console
   *   // where x and y are small random numbers.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(1);
   *
   *   describe('A black arrow in extends from the center of a gray square. It changes direction once per second.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create a p5.Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a random p5.Vector.
   *   let v1 = p5.Vector.random2D();
   *
   *   // Scale v1 for drawing.
   *   v1.mult(30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  static random2D() {
    return this.fromAngle(Math.random() * TWO_PI);
  }
  /**
   * Creates a new 3D unit vector with a random heading.
   *
   * @static
   * @return {p5.Vector} new <a href="#/p5.Vector">p5.Vector</a> object.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.random3D();
   *
   *   // Prints "p5.Vector Object : [x, y, z]" to the console
   *   // where x, y, and z are small random numbers.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   */
  static random3D() {
    const angle = Math.random() * TWO_PI;
    const vz = Math.random() * 2 - 1;
    const vzBase = Math.sqrt(1 - vz * vz);
    const vx = vzBase * Math.cos(angle);
    const vy = vzBase * Math.sin(angle);
    return new Vector(vx, vy, vz);
  }
  // Returns a copy of a vector.
  /**
   * @static
   * @param  {p5.Vector} v the <a href="#/p5.Vector">p5.Vector</a> to create a copy of
   * @return {p5.Vector} the copy of the <a href="#/p5.Vector">p5.Vector</a> object
   */
  static copy(v) {
    return v.copy(v);
  }
  // Adds two vectors together and returns a new one.
  /**
   * @static
   * @param  {p5.Vector} v1 A <a href="#/p5.Vector">p5.Vector</a> to add
   * @param  {p5.Vector} v2 A <a href="#/p5.Vector">p5.Vector</a> to add
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} resulting <a href="#/p5.Vector">p5.Vector</a>.
   */
  static add(v1, v2, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 3) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.add"
        );
      }
    } else {
      target.set(v1);
    }
    target.add(v2);
    return target;
  }
  // Returns a vector remainder when it is divided by another vector
  /**
   * @static
   * @param  {p5.Vector} v1 The dividend <a href="#/p5.Vector">p5.Vector</a>
   * @param  {p5.Vector} v2 The divisor <a href="#/p5.Vector">p5.Vector</a>
   */
  /**
   * @static
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} v2
   * @return {p5.Vector} The resulting <a href="#/p5.Vector">p5.Vector</a>
   */
  static rem(v1, v2) {
    if (v1 instanceof Vector && v2 instanceof Vector) {
      let target = v1.copy();
      target.rem(v2);
      return target;
    }
  }
  /*
   * Subtracts one <a href="#/p5.Vector">p5.Vector</a> from another and returns a new one.  The second
   * vector (`v2`) is subtracted from the first (`v1`), resulting in `v1-v2`.
   */
  /**
   * @static
   * @param  {p5.Vector} v1 A <a href="#/p5.Vector">p5.Vector</a> to subtract from
   * @param  {p5.Vector} v2 A <a href="#/p5.Vector">p5.Vector</a> to subtract
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} The resulting <a href="#/p5.Vector">p5.Vector</a>
   */
  static sub(v1, v2, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 3) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.sub"
        );
      }
    } else {
      target.set(v1);
    }
    target.sub(v2);
    return target;
  }
  /**
   * Multiplies a vector by a scalar and returns a new vector.
   */
  /**
   * @static
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} [z]
   * @return {p5.Vector} resulting new <a href="#/p5.Vector">p5.Vector</a>.
   */
  /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number}  n
   * @param  {p5.Vector} [target] vector to receive the result.
   */
  /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} [target]
   */
  /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {Number[]} arr
   * @param  {p5.Vector} [target]
   */
  static mult(v, n2, target) {
    if (!target) {
      target = v.copy();
      if (arguments.length === 3) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.mult"
        );
      }
    } else {
      target.set(v);
    }
    target.mult(n2);
    return target;
  }
  /**
   * Rotates the vector (only 2D vectors) by the given angle; magnitude remains the same. Returns a new vector.
   */
  /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number} angle
   * @param  {p5.Vector} [target] The vector to receive the result
   */
  static rotate(v, a, target) {
    if (arguments.length === 2) {
      target = v.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.rotate"
        );
      }
      target.set(v);
    }
    target.rotate(a);
    return target;
  }
  /**
   * Divides a vector by a scalar and returns a new vector.
   */
  /**
   * @static
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} [z]
   * @return {p5.Vector} The resulting new <a href="#/p5.Vector">p5.Vector</a>
   */
  /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number}  n
   * @param  {p5.Vector} [target] The vector to receive the result
   */
  /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} [target]
   */
  /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {Number[]} arr
   * @param  {p5.Vector} [target]
   */
  static div(v, n2, target) {
    if (!target) {
      target = v.copy();
      if (arguments.length === 3) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.div"
        );
      }
    } else {
      target.set(v);
    }
    target.div(n2);
    return target;
  }
  /**
   * Calculates the dot product of two vectors.
   */
  /**
   * @static
   * @param  {p5.Vector} v1 first <a href="#/p5.Vector">p5.Vector</a>.
   * @param  {p5.Vector} v2 second <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}     dot product.
   */
  static dot(v1, v2) {
    return v1.dot(v2);
  }
  /**
   * Calculates the cross product of two vectors.
   */
  /**
   * @static
   * @param  {p5.Vector} v1 first <a href="#/p5.Vector">p5.Vector</a>.
   * @param  {p5.Vector} v2 second <a href="#/p5.Vector">p5.Vector</a>.
   * @return {p5.Vector}     cross product.
   */
  static cross(v1, v2) {
    return v1.cross(v2);
  }
  /**
   * Calculates the Euclidean distance between two points (considering a
   * point as a vector object).
   */
  /**
   * @static
   * @param  {p5.Vector} v1 The first <a href="#/p5.Vector">p5.Vector</a>
   * @param  {p5.Vector} v2 The second <a href="#/p5.Vector">p5.Vector</a>
   * @return {Number}     The distance
   */
  static dist(v1, v2) {
    return v1.dist(v2);
  }
  /**
   * Linear interpolate a vector to another vector and return the result as a
   * new vector.
   */
  /**
   * @static
   * @param {p5.Vector} v1
   * @param {p5.Vector} v2
   * @param {Number} amt
   * @param {p5.Vector} [target] The vector to receive the result
   * @return {p5.Vector}      The lerped value
   */
  static lerp(v1, v2, amt, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 4) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.lerp"
        );
      }
    } else {
      target.set(v1);
    }
    target.lerp(v2, amt);
    return target;
  }
  /**
   * Performs spherical linear interpolation with the other vector
   * and returns the resulting vector.
   * This works in both 3D and 2D. As for 2D, the result of slerping
   * between 2D vectors is always a 2D vector.
   */
  /**
   * @static
   * @param {p5.Vector} v1 old vector.
   * @param {p5.Vector} v2 new vector.
   * @param {Number} amt
   * @param {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} slerped vector between v1 and v2
   */
  static slerp(v1, v2, amt, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 4) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.slerp"
        );
      }
    } else {
      target.set(v1);
    }
    target.slerp(v2, amt);
    return target;
  }
  /**
   * Calculates the magnitude (length) of the vector and returns the result as
   * a float (this is simply the equation `sqrt(x*x + y*y + z*z)`.)
   */
  /**
   * @static
   * @param {p5.Vector} vecT The vector to return the magnitude of
   * @return {Number}        The magnitude of vecT
   */
  static mag(vecT) {
    return vecT.mag();
  }
  /**
   * Calculates the squared magnitude of the vector and returns the result
   * as a float (this is simply the equation <em>(x\*x + y\*y + z\*z)</em>.)
   * Faster if the real length is not required in the
   * case of comparing vectors, etc.
   */
  /**
   * @static
   * @param {p5.Vector} vecT the vector to return the squared magnitude of
   * @return {Number}        the squared magnitude of vecT
   */
  static magSq(vecT) {
    return vecT.magSq();
  }
  /**
   * Normalize the vector to length 1 (make it a unit vector).
   */
  /**
   * @static
   * @param {p5.Vector} v  The vector to normalize
   * @param {p5.Vector} [target] The vector to receive the result
   * @return {p5.Vector}   The vector v, normalized to a length of 1
   */
  static normalize(v, target) {
    if (arguments.length < 2) {
      target = v.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.normalize"
        );
      }
      target.set(v);
    }
    return target.normalize();
  }
  /**
   * Limit the magnitude of the vector to the value used for the <b>max</b>
   * parameter.
   */
  /**
   * @static
   * @param {p5.Vector} v  the vector to limit
   * @param {Number}    max
   * @param {p5.Vector} [target] the vector to receive the result (Optional)
   * @return {p5.Vector} v with a magnitude limited to max
   */
  static limit(v, max, target) {
    if (arguments.length < 3) {
      target = v.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.limit"
        );
      }
      target.set(v);
    }
    return target.limit(max);
  }
  /**
   * Set the magnitude of the vector to the value used for the <b>len</b>
   * parameter.
   */
  /**
   * @static
   * @param {p5.Vector} v  the vector to set the magnitude of
   * @param {Number}    len
   * @param {p5.Vector} [target] the vector to receive the result (Optional)
   * @return {p5.Vector} v with a magnitude set to len
   */
  static setMag(v, len, target) {
    if (arguments.length < 3) {
      target = v.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.setMag"
        );
      }
      target.set(v);
    }
    return target.setMag(len);
  }
  /**
   * Calculate the angle of rotation for this vector (only 2D vectors).
   * p5.Vectors created using <a href="#/p5/createVector">createVector()</a>
   * will take the current <a href="#/p5/angleMode">angleMode</a> into
   * consideration, and give the angle in radians or degrees accordingly.
   */
  /**
   * @static
   * @param {p5.Vector} v the vector to find the angle of
   * @return {Number} the angle of rotation
   */
  static heading(v) {
    return v.heading();
  }
  /**
   * Calculates and returns the angle between two vectors. This function will take
   * the <a href="#/p5/angleMode">angleMode</a> on v1 into consideration, and
   * give the angle in radians or degrees accordingly.
   */
  /**
   * @static
   * @param  {p5.Vector}    v1 the first vector.
   * @param  {p5.Vector}    v2 the second vector.
   * @return {Number}       angle between the two vectors.
   */
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  /**
   * Reflect a vector about a normal to a line in 2D, or about a normal to a
   * plane in 3D.
   */
  /**
   * @static
   * @param  {p5.Vector} incidentVector vector to be reflected.
   * @param  {p5.Vector} surfaceNormal
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} the reflected vector
   */
  static reflect(incidentVector, surfaceNormal, target) {
    if (arguments.length < 3) {
      target = incidentVector.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.reflect"
        );
      }
      target.set(incidentVector);
    }
    return target.reflect(surfaceNormal);
  }
  /**
   * Return a representation of this vector as a float array. This is only
   * for temporary use. If used in any other fashion, the contents should be
   * copied by using the <b>p5.Vector.<a href="#/p5.Vector/copy">copy()</a></b>
   * method to copy into your own vector.
   */
  /**
   * @static
   * @param  {p5.Vector} v the vector to convert to an array
   * @return {Number[]} an Array with the 3 values
   */
  static array(v) {
    return v.array();
  }
  /**
   * Equality check against a <a href="#/p5.Vector">p5.Vector</a>
   */
  /**
   * @static
   * @param {p5.Vector|Array} v1 the first vector to compare
   * @param {p5.Vector|Array} v2 the second vector to compare
   * @return {Boolean}
   */
  static equals(v1, v2) {
    let v;
    if (v1 instanceof Vector) {
      v = v1;
    } else if (v1 instanceof Array) {
      v = new Vector().set(v1);
    } else {
      p5._friendlyError(
        "The v1 parameter should be of type Array or p5.Vector",
        "p5.Vector.equals"
      );
    }
    return v.equals(v2);
  }
}
function vector(p53, fn2) {
  p53.Vector = Vector;
}
if (typeof p5 !== "undefined") {
  vector(p5, p5.prototype);
}
function polylineLength(vertices) {
  let length = 0;
  for (let i = 1; i < vertices.length; i++) {
    length += vertices[i - 1].position.dist(vertices[i].position);
  }
  return length;
}
class Vertex {
  constructor(properties) {
    for (const [key, value] of Object.entries(properties)) {
      this[key] = value;
    }
  }
  /*
  get array() {
    // convert to 1D array
    // call `toArray()` if value is an object with a toArray() method
    // handle primitive values separately
    // maybe handle object literals too, with Object.values()?
    // probably don’t need anything else for now?
  }
  */
  // TODO: make sure name of array conversion method is
  // consistent with any modifications to the names of corresponding
  // properties of p5.Vector and p5.Color
}
class ShapePrimitive {
  vertices;
  _shape = null;
  _primitivesIndex = null;
  _contoursIndex = null;
  isClosing = false;
  constructor(...vertices) {
    if (this.constructor === ShapePrimitive) {
      throw new Error("ShapePrimitive is an abstract class: it cannot be instantiated.");
    }
    if (vertices.length > 0) {
      this.vertices = vertices;
    } else {
      throw new Error("At least one vertex must be passed to the constructor.");
    }
  }
  get vertexCount() {
    return this.vertices.length;
  }
  get vertexCapacity() {
    throw new Error("Getter vertexCapacity must be implemented.");
  }
  get _firstInterpolatedVertex() {
    return this.startVertex();
  }
  get canOverrideAnchor() {
    return false;
  }
  accept(visitor) {
    throw new Error("Method accept() must be implemented.");
  }
  addToShape(shape2) {
    let lastContour = shape2.at(-1);
    if (lastContour.primitives.length === 0) {
      lastContour.primitives.push(this);
    } else {
      let lastPrimitive = shape2.at(-1, -1);
      let hasSameType = lastPrimitive instanceof this.constructor;
      let spareCapacity = lastPrimitive.vertexCapacity - lastPrimitive.vertexCount;
      let pushableVertices;
      let remainingVertices;
      if (hasSameType && spareCapacity > 0) {
        pushableVertices = this.vertices.splice(0, spareCapacity);
        remainingVertices = this.vertices;
        lastPrimitive.vertices.push(...pushableVertices);
        if (remainingVertices.length > 0) {
          lastContour.primitives.push(this);
        }
      } else {
        lastContour.primitives.push(this);
      }
    }
    let addedToShape = this.vertices.length > 0;
    if (addedToShape) {
      let lastContour2 = shape2.at(-1);
      this._primitivesIndex = lastContour2.primitives.length - 1;
      this._contoursIndex = shape2.contours.length - 1;
      this._shape = shape2;
    }
    return shape2.at(-1, -1);
  }
  get _nextPrimitive() {
    return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex + 1) : null;
  }
  get _belongsToShape() {
    return this._shape !== null;
  }
  handlesClose() {
    return false;
  }
  close(vertex2) {
    throw new Error("Unimplemented!");
  }
}
class Contour {
  #kind;
  primitives;
  constructor(kind = PATH) {
    this.#kind = kind;
    this.primitives = [];
  }
  get kind() {
    const isEmpty = this.primitives.length === 0;
    const isPath = this.#kind === PATH;
    return isEmpty && isPath ? EMPTY_PATH : this.#kind;
  }
  accept(visitor) {
    for (const primitive of this.primitives) {
      primitive.accept(visitor);
    }
  }
}
class Anchor extends ShapePrimitive {
  #vertexCapacity = 1;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitAnchor(this);
  }
  getEndVertex() {
    return this.vertices[0];
  }
}
class Segment extends ShapePrimitive {
  constructor(...vertices) {
    super(...vertices);
    if (this.constructor === Segment) {
      throw new Error("Segment is an abstract class: it cannot be instantiated.");
    }
  }
  // segments in a shape always have a predecessor
  // (either an anchor or another segment)
  get _previousPrimitive() {
    return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex - 1) : null;
  }
  getStartVertex() {
    return this._previousPrimitive.getEndVertex();
  }
  getEndVertex() {
    return this.vertices.at(-1);
  }
}
class LineSegment extends Segment {
  #vertexCapacity = 1;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitLineSegment(this);
  }
}
class BezierSegment extends Segment {
  #order;
  #vertexCapacity;
  constructor(order, ...vertices) {
    super(...vertices);
    let numericalOrder = Array.isArray(order) ? order[0] : order;
    this.#order = numericalOrder;
    this.#vertexCapacity = numericalOrder;
  }
  get order() {
    return this.#order;
  }
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  #_hullLength;
  hullLength() {
    if (this.#_hullLength === void 0) {
      this.#_hullLength = polylineLength([
        this.getStartVertex(),
        ...this.vertices
      ]);
    }
    return this.#_hullLength;
  }
  accept(visitor) {
    visitor.visitBezierSegment(this);
  }
}
class SplineSegment extends Segment {
  #vertexCapacity = Infinity;
  _splineProperties = {
    ends: INCLUDE,
    tightness: 0
  };
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitSplineSegment(this);
  }
  get _comesAfterSegment() {
    return this._previousPrimitive instanceof Segment;
  }
  get canOverrideAnchor() {
    return this._splineProperties.ends === EXCLUDE;
  }
  // assuming for now that the first interpolated vertex is always
  // the second vertex passed to splineVertex()
  // if this spline segment doesn't follow another segment,
  // the first vertex is in an anchor
  get _firstInterpolatedVertex() {
    if (this._splineProperties.ends === EXCLUDE) {
      return this._comesAfterSegment ? this.vertices[1] : this.vertices[0];
    } else {
      return this.getStartVertex();
    }
  }
  get _chainedToSegment() {
    if (this._belongsToShape && this._comesAfterSegment) {
      let interpolatedStartPosition = this._firstInterpolatedVertex.position;
      let predecessorEndPosition = this.getStartVertex().position;
      return predecessorEndPosition.equals(interpolatedStartPosition);
    } else {
      return false;
    }
  }
  // extend addToShape() with a warning in case second vertex
  // doesn't line up with end of last segment
  addToShape(shape2) {
    const added = super.addToShape(shape2);
    this._splineProperties.ends = shape2._splineProperties.ends;
    this._splineProperties.tightness = shape2._splineProperties.tightness;
    if (this._splineProperties.ends !== EXCLUDE) return added;
    let verticesPushed = !this._belongsToShape;
    let lastPrimitive = shape2.at(-1, -1);
    let message = (array1, array2) => `Spline does not start where previous path segment ends:
      second spline vertex at (${array1})
      expected to be at (${array2}).`;
    if (verticesPushed && // Only check once the first interpolated vertex has been added
    lastPrimitive.vertices.length === 2 && lastPrimitive._comesAfterSegment && !lastPrimitive._chainedToSegment) {
      let interpolatedStart = lastPrimitive._firstInterpolatedVertex.position;
      let predecessorEnd = lastPrimitive.getStartVertex().position;
      console.warn(
        message(interpolatedStart.array(), predecessorEnd.array())
      );
    }
    return added;
  }
  // override method on base class
  getEndVertex() {
    if (this._splineProperties.ends === INCLUDE) {
      return super.getEndVertex();
    } else if (this._splineProperties.ends === EXCLUDE) {
      return this.vertices.at(-2);
    } else {
      return this.getStartVertex();
    }
  }
  getControlPoints() {
    let points = [];
    if (this._comesAfterSegment) {
      points.push(this.getStartVertex());
    }
    points.push(this.getStartVertex());
    for (const vertex2 of this.vertices) {
      points.push(vertex2);
    }
    const prevVertex = this.getStartVertex();
    if (this._splineProperties.ends === INCLUDE) {
      points.unshift(prevVertex);
      points.push(this.vertices.at(-1));
    } else if (this._splineProperties.ends === JOIN) {
      points.unshift(this.vertices.at(-1));
      points.push(prevVertex, this.vertices.at(0));
    }
    return points;
  }
  handlesClose() {
    if (!this._belongsToShape) return false;
    const contour = this._shape.at(this._contoursIndex);
    return contour.primitives.length === 2 && this._primitivesIndex === 1;
  }
  close() {
    this._splineProperties.ends = JOIN;
  }
}
class Point extends ShapePrimitive {
  #vertexCapacity = 1;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitPoint(this);
  }
}
class Line extends ShapePrimitive {
  #vertexCapacity = 2;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitLine(this);
  }
}
class Triangle extends ShapePrimitive {
  #vertexCapacity = 3;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitTriangle(this);
  }
}
class Quad extends ShapePrimitive {
  #vertexCapacity = 4;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitQuad(this);
  }
}
class TriangleFan extends ShapePrimitive {
  #vertexCapacity = Infinity;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitTriangleFan(this);
  }
}
class TriangleStrip extends ShapePrimitive {
  #vertexCapacity = Infinity;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitTriangleStrip(this);
  }
}
class QuadStrip extends ShapePrimitive {
  #vertexCapacity = Infinity;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitQuadStrip(this);
  }
}
class PrimitiveShapeCreators {
  // TODO: make creators private?
  // That'd probably be better, but for now, it may be convenient to use
  // native Map properties like size, e.g. for testing, and it's simpler to
  // not have to wrap all the properties that might be useful
  creators;
  constructor() {
    let creators = /* @__PURE__ */ new Map();
    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
    creators.set(`vertex-${PATH}`, (...vertices) => new LineSegment(...vertices));
    creators.set(`vertex-${POINTS}`, (...vertices) => new Point(...vertices));
    creators.set(`vertex-${LINES}`, (...vertices) => new Line(...vertices));
    creators.set(`vertex-${TRIANGLES}`, (...vertices) => new Triangle(...vertices));
    creators.set(`vertex-${QUADS}`, (...vertices) => new Quad(...vertices));
    creators.set(`vertex-${TRIANGLE_FAN}`, (...vertices) => new TriangleFan(...vertices));
    creators.set(`vertex-${TRIANGLE_STRIP}`, (...vertices) => new TriangleStrip(...vertices));
    creators.set(`vertex-${QUAD_STRIP}`, (...vertices) => new QuadStrip(...vertices));
    creators.set(`bezierVertex-${EMPTY_PATH}`, (order, ...vertices) => new Anchor(...vertices));
    creators.set(`bezierVertex-${PATH}`, (order, ...vertices) => new BezierSegment(order, ...vertices));
    creators.set(`splineVertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
    creators.set(`splineVertex-${PATH}`, (...vertices) => new SplineSegment(...vertices));
    this.creators = creators;
  }
  get(vertexKind, shapeKind) {
    const key = `${vertexKind}-${shapeKind}`;
    return this.creators.get(key);
  }
  set(vertexKind, shapeKind, creator) {
    const key = `${vertexKind}-${shapeKind}`;
    this.creators.set(key, creator);
  }
  clear() {
    this.creators.clear();
  }
}
class Shape {
  #vertexProperties;
  #initialVertexProperties;
  #primitiveShapeCreators;
  #bezierOrder = 3;
  kind = null;
  contours = [];
  _splineProperties = {
    tightness: 0,
    ends: INCLUDE
  };
  userVertexProperties = null;
  constructor(vertexProperties, primitiveShapeCreators = new PrimitiveShapeCreators()) {
    this.#initialVertexProperties = vertexProperties;
    this.#vertexProperties = vertexProperties;
    this.#primitiveShapeCreators = primitiveShapeCreators;
    for (const key in this.#vertexProperties) {
      if (key !== "position" && key !== "textureCoordinates") {
        this[key] = function(value) {
          this.#vertexProperties[key] = value;
        };
      }
    }
  }
  serializeToArray(val) {
    if (val === null || val === void 0) {
      return [];
    }
    if (val instanceof Number) {
      return [val];
    } else if (val instanceof Array) {
      return val;
    } else if (val.array instanceof Function) {
      return val.array();
    } else {
      throw new Error(`Can't convert ${val} to array!`);
    }
  }
  vertexToArray(vertex2) {
    const array2 = [];
    for (const key in this.#vertexProperties) {
      if (this.userVertexProperties && key in this.userVertexProperties)
        continue;
      const val = vertex2[key];
      array2.push(...this.serializeToArray(val));
    }
    for (const key in this.userVertexProperties) {
      if (key in vertex2) {
        array2.push(...this.serializeToArray(vertex2[key]));
      } else {
        array2.push(...new Array(this.userVertexProperties[key]).fill(0));
      }
    }
    return array2;
  }
  hydrateValue(queue, original) {
    if (original === null) {
      return null;
    } else if (original instanceof Number) {
      return queue.shift();
    } else if (original instanceof Array) {
      const array2 = [];
      for (let i = 0; i < original.length; i++) {
        array2.push(queue.shift());
      }
      return array2;
    } else if (original instanceof Vector) {
      return new Vector(queue.shift(), queue.shift(), queue.shift());
    } else if (original instanceof Color) {
      const array2 = [
        queue.shift(),
        queue.shift(),
        queue.shift(),
        queue.shift()
      ];
      return new Color(array2);
    }
  }
  arrayToVertex(array2) {
    const vertex2 = {};
    const queue = [...array2];
    for (const key in this.#vertexProperties) {
      if (this.userVertexProperties && key in this.userVertexProperties)
        continue;
      const original = this.#vertexProperties[key];
      vertex2[key] = this.hydrateValue(queue, original);
    }
    for (const key in this.userVertexProperties) {
      const original = this.#vertexProperties[key];
      vertex2[key] = this.hydrateValue(queue, original);
    }
    return vertex2;
  }
  arrayScale(array2, scale) {
    return array2.map((v) => v * scale);
  }
  arraySum(first, ...rest) {
    return first.map((v, i) => {
      let result = v;
      for (let j2 = 0; j2 < rest.length; j2++) {
        result += rest[j2][i];
      }
      return result;
    });
  }
  arrayMinus(a, b2) {
    return a.map((v, i) => v - b2[i]);
  }
  evaluateCubicBezier([a, b2, c, d2], t) {
    return this.arraySum(
      this.arrayScale(a, Math.pow(1 - t, 3)),
      this.arrayScale(b2, 3 * Math.pow(1 - t, 2) * t),
      this.arrayScale(c, 3 * (1 - t) * Math.pow(t, 2)),
      this.arrayScale(d2, Math.pow(t, 3))
    );
  }
  evaluateQuadraticBezier([a, b2, c], t) {
    return this.arraySum(
      this.arrayScale(a, Math.pow(1 - t, 2)),
      this.arrayScale(b2, 2 * (1 - t) * t),
      this.arrayScale(c, t * t)
    );
  }
  /*
    catmullRomToBezier(vertices, tightness)
  
    Abbreviated description:
    Converts a Catmull-Rom spline to a sequence of Bezier curveTo points.
  
    Parameters:
    vertices -> Array [v0, v1, v2, v3, ...] of at least four vertices
    tightness -> Number affecting shape of curve
  
    Returns:
    array of Bezier curveTo control points, each represented as [c1, c2, c3][]
  
    TODO:
    1. It seems p5 contains code for converting from Catmull-Rom to Bezier in at least two places:
  
    catmullRomToBezier() is based on code in the legacy endShape() function:
    https://github.com/processing/p5.js/blob/1b66f097761d3c2057c0cec4349247d6125f93ca/src/core/p5.Renderer2D.js#L859C1-L886C1
  
    A different conversion can be found elsewhere in p5:
    https://github.com/processing/p5.js/blob/17304ce9e9ef3f967bd828102a51b62a2d39d4f4/src/typography/p5.Font.js#L1179
  
    A more careful review and comparison of both implementations would be helpful. They're different. I put
    catmullRomToBezier() together quickly without checking the math/algorithm, when I made the proof of concept
    for the refactor.
  
    2. It may be possible to replace the code in p5.Font.js with the code here, to reduce duplication.
    */
  catmullRomToBezier(vertices, tightness) {
    let s = 1 - tightness;
    let bezArrays = [];
    for (let i = 0; i + 3 < vertices.length; i++) {
      const [a, b2, c, d2] = vertices.slice(i, i + 4);
      const bezB = this.arraySum(
        b2,
        this.arrayScale(this.arrayMinus(c, a), s / 6)
      );
      const bezC = this.arraySum(
        c,
        this.arrayScale(this.arrayMinus(b2, d2), s / 6)
      );
      const bezD = c;
      bezArrays.push([bezB, bezC, bezD]);
    }
    return bezArrays;
  }
  // TODO for at() method:
  // RENAME?
  // -at() indicates it works like Array.prototype.at(), e.g. with negative indices
  // -get() may work better if we want to add a corresponding set() method
  // -a set() method could maybe check for problematic usage (e.g. inserting a Triangle into a PATH)
  // -renaming or removing would necessitate changes at call sites (it's already in use)
  // REFACTOR?
  // TEST
  at(contoursIndex, primitivesIndex, verticesIndex) {
    let contour;
    let primitive;
    contour = this.contours.at(contoursIndex);
    switch (arguments.length) {
      case 1:
        return contour;
      case 2:
        return contour.primitives.at(primitivesIndex);
      case 3:
        primitive = contour.primitives.at(primitivesIndex);
        return primitive.vertices.at(verticesIndex);
    }
  }
  // maybe call this clear() for consistency with PrimitiveShapeCreators.clear()?
  // note: p5.Geometry has a reset() method, but also clearColors()
  // looks like reset() isn't in the public reference, so maybe we can switch
  // everything to clear()? Not sure if reset/clear is used in other classes,
  // but it'd be good if geometries and shapes are consistent
  reset() {
    this.#vertexProperties = { ...this.#initialVertexProperties };
    this.kind = null;
    this.contours = [];
    this.userVertexProperties = null;
  }
  vertexProperty(name, data2) {
    this.userVertexProperties = this.userVertexProperties || {};
    const key = this.vertexPropertyKey(name);
    const dataArray2 = Array.isArray(data2) ? data2 : [data2];
    if (!this.userVertexProperties[key]) {
      this.userVertexProperties[key] = dataArray2.length;
    }
    this.#vertexProperties[key] = dataArray2;
  }
  vertexPropertyName(key) {
    return key.replace(/Src$/, "");
  }
  vertexPropertyKey(name) {
    return name + "Src";
  }
  bezierOrder(...order) {
    this.#bezierOrder = order;
  }
  splineProperty(key, value) {
    this._splineProperties[key] = value;
  }
  splineProperties(values) {
    if (values) {
      for (const key in values) {
        this.splineProperty(key, values[key]);
      }
    } else {
      return this._splineProperties;
    }
  }
  /*
  To-do: Maybe refactor #createVertex() since this has side effects that aren't advertised
  in the method name?
  */
  #createVertex(position, textureCoordinates) {
    this.#vertexProperties.position = position;
    if (textureCoordinates !== void 0) {
      this.#vertexProperties.textureCoordinates = textureCoordinates;
    }
    return new Vertex(this.#vertexProperties);
  }
  #createPrimitiveShape(vertexKind, shapeKind, ...vertices) {
    let primitiveShapeCreator = this.#primitiveShapeCreators.get(
      vertexKind,
      shapeKind
    );
    return vertexKind === "bezierVertex" ? primitiveShapeCreator(this.#bezierOrder, ...vertices) : primitiveShapeCreator(...vertices);
  }
  /*
      #generalVertex() is reused by the special vertex functions,
      including vertex(), bezierVertex(), splineVertex(), and arcVertex():
  
      It creates a vertex, builds a primitive including that
      vertex, and has the primitive add itself to the shape.
    */
  #generalVertex(kind, position, textureCoordinates) {
    let vertexKind = kind;
    let lastContourKind = this.at(-1).kind;
    let vertex2 = this.#createVertex(position, textureCoordinates);
    let primitiveShape = this.#createPrimitiveShape(
      vertexKind,
      lastContourKind,
      vertex2
    );
    return primitiveShape.addToShape(this);
  }
  vertex(position, textureCoordinates, { isClosing = false } = {}) {
    const added = this.#generalVertex("vertex", position, textureCoordinates);
    added.isClosing = isClosing;
  }
  bezierVertex(position, textureCoordinates) {
    this.#generalVertex("bezierVertex", position, textureCoordinates);
  }
  splineVertex(position, textureCoordinates) {
    this.#generalVertex("splineVertex", position, textureCoordinates);
  }
  arcVertex(position, textureCoordinates) {
    this.#generalVertex("arcVertex", position, textureCoordinates);
  }
  beginContour(shapeKind = PATH) {
    if (this.at(-1)?.kind === EMPTY_PATH) {
      this.contours.pop();
    }
    this.contours.push(new Contour(shapeKind));
  }
  endContour(closeMode = OPEN, _index = this.contours.length - 1) {
    const contour = this.at(_index);
    if (closeMode === CLOSE) {
      const isPath = contour.kind === PATH;
      const anchorVertex = this.at(_index, 0, 0);
      const anchorHasPosition = Object.hasOwn(anchorVertex, "position");
      const lastSegment = this.at(_index, -1);
      if (isPath && anchorHasPosition) {
        if (lastSegment.handlesClose()) {
          lastSegment.close(anchorVertex);
        } else {
          const rest = this.contours.splice(
            _index + 1,
            this.contours.length - _index - 1
          );
          const prevVertexProperties = this.#vertexProperties;
          this.#vertexProperties = { ...prevVertexProperties };
          for (const key in anchorVertex) {
            if (["position", "textureCoordinates"].includes(key)) continue;
            this.#vertexProperties[key] = anchorVertex[key];
          }
          this.vertex(
            anchorVertex.position,
            anchorVertex.textureCoordinates,
            { isClosing: true }
          );
          this.#vertexProperties = prevVertexProperties;
          this.contours.push(...rest);
        }
      }
    }
  }
  beginShape(shapeKind = PATH) {
    this.kind = shapeKind;
    this.beginContour(shapeKind);
  }
  /* TO-DO:
     Refactor?
     - Might not need anchorHasPosition.
     - Might combine conditions at top, and rely on shortcircuiting.
     Does nothing if shape is not a path or has multiple contours. Might discuss this.
  */
  endShape(closeMode = OPEN) {
    if (closeMode === CLOSE) {
      this.endContour(closeMode, 0);
    }
  }
  accept(visitor) {
    for (const contour of this.contours) {
      contour.accept(visitor);
    }
  }
}
class PrimitiveVisitor {
  constructor() {
    if (this.constructor === PrimitiveVisitor) {
      throw new Error("PrimitiveVisitor is an abstract class: it cannot be instantiated.");
    }
  }
  // path primitives
  visitAnchor(anchor) {
    throw new Error("Method visitAnchor() has not been implemented.");
  }
  visitLineSegment(lineSegment) {
    throw new Error("Method visitLineSegment() has not been implemented.");
  }
  visitBezierSegment(bezierSegment) {
    throw new Error("Method visitBezierSegment() has not been implemented.");
  }
  visitSplineSegment(curveSegment) {
    throw new Error("Method visitSplineSegment() has not been implemented.");
  }
  visitArcSegment(arcSegment) {
    throw new Error("Method visitArcSegment() has not been implemented.");
  }
  // isolated primitives
  visitPoint(point) {
    throw new Error("Method visitPoint() has not been implemented.");
  }
  visitLine(line) {
    throw new Error("Method visitLine() has not been implemented.");
  }
  visitTriangle(triangle) {
    throw new Error("Method visitTriangle() has not been implemented.");
  }
  visitQuad(quad) {
    throw new Error("Method visitQuad() has not been implemented.");
  }
  // tessellation primitives
  visitTriangleFan(triangleFan) {
    throw new Error("Method visitTriangleFan() has not been implemented.");
  }
  visitTriangleStrip(triangleStrip) {
    throw new Error("Method visitTriangleStrip() has not been implemented.");
  }
  visitQuadStrip(quadStrip) {
    throw new Error("Method visitQuadStrip() has not been implemented.");
  }
}
class PrimitiveToPath2DConverter extends PrimitiveVisitor {
  path = new Path2D();
  strokeWeight;
  constructor({ strokeWeight }) {
    super();
    this.strokeWeight = strokeWeight;
  }
  // path primitives
  visitAnchor(anchor) {
    let vertex2 = anchor.getEndVertex();
    this.path.moveTo(vertex2.position.x, vertex2.position.y);
  }
  visitLineSegment(lineSegment) {
    if (lineSegment.isClosing) {
      this.path.closePath();
    } else {
      let vertex2 = lineSegment.getEndVertex();
      this.path.lineTo(vertex2.position.x, vertex2.position.y);
    }
  }
  visitBezierSegment(bezierSegment) {
    let [v1, v2, v3] = bezierSegment.vertices;
    switch (bezierSegment.order) {
      case 2:
        this.path.quadraticCurveTo(
          v1.position.x,
          v1.position.y,
          v2.position.x,
          v2.position.y
        );
        break;
      case 3:
        this.path.bezierCurveTo(
          v1.position.x,
          v1.position.y,
          v2.position.x,
          v2.position.y,
          v3.position.x,
          v3.position.y
        );
        break;
    }
  }
  visitSplineSegment(splineSegment) {
    const shape2 = splineSegment._shape;
    if (splineSegment._splineProperties.ends === EXCLUDE && !splineSegment._comesAfterSegment) {
      let startVertex = splineSegment._firstInterpolatedVertex;
      this.path.moveTo(startVertex.position.x, startVertex.position.y);
    }
    const arrayVertices = splineSegment.getControlPoints().map(
      (v) => shape2.vertexToArray(v)
    );
    let bezierArrays = shape2.catmullRomToBezier(
      arrayVertices,
      splineSegment._splineProperties.tightness
    ).map((arr2) => arr2.map((vertArr) => shape2.arrayToVertex(vertArr)));
    for (const array2 of bezierArrays) {
      const points = array2.flatMap((vert) => [vert.position.x, vert.position.y]);
      this.path.bezierCurveTo(...points);
    }
  }
  visitPoint(point) {
    const { x, y } = point.vertices[0].position;
    this.path.moveTo(x, y);
    this.path.lineTo(x + 1e-5, y);
  }
  visitLine(line) {
    const { x: x0, y: y0 } = line.vertices[0].position;
    const { x: x1, y: y1 } = line.vertices[1].position;
    this.path.moveTo(x0, y0);
    this.path.lineTo(x1, y1);
  }
  visitTriangle(triangle) {
    const [v0, v1, v2] = triangle.vertices;
    this.path.moveTo(v0.position.x, v0.position.y);
    this.path.lineTo(v1.position.x, v1.position.y);
    this.path.lineTo(v2.position.x, v2.position.y);
    this.path.closePath();
  }
  visitQuad(quad) {
    const [v0, v1, v2, v3] = quad.vertices;
    this.path.moveTo(v0.position.x, v0.position.y);
    this.path.lineTo(v1.position.x, v1.position.y);
    this.path.lineTo(v2.position.x, v2.position.y);
    this.path.lineTo(v3.position.x, v3.position.y);
    this.path.closePath();
  }
  visitTriangleFan(triangleFan) {
    const [v0, ...rest] = triangleFan.vertices;
    for (let i = 0; i < rest.length - 1; i++) {
      const v1 = rest[i];
      const v2 = rest[i + 1];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
  visitTriangleStrip(triangleStrip) {
    for (let i = 0; i < triangleStrip.vertices.length - 2; i++) {
      const v0 = triangleStrip.vertices[i];
      const v1 = triangleStrip.vertices[i + 1];
      const v2 = triangleStrip.vertices[i + 2];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
  visitQuadStrip(quadStrip) {
    for (let i = 0; i < quadStrip.vertices.length - 3; i += 2) {
      const v0 = quadStrip.vertices[i];
      const v1 = quadStrip.vertices[i + 1];
      const v2 = quadStrip.vertices[i + 2];
      const v3 = quadStrip.vertices[i + 3];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v3.position.x, v3.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
}
class PrimitiveToVerticesConverter extends PrimitiveVisitor {
  contours = [];
  curveDetail;
  pointsToLines;
  constructor({ curveDetail = 1, pointsToLines = true } = {}) {
    super();
    this.curveDetail = curveDetail;
    this.pointsToLines = pointsToLines;
  }
  lastContour() {
    return this.contours[this.contours.length - 1];
  }
  visitAnchor(anchor) {
    this.contours.push([]);
    const next = anchor._nextPrimitive;
    if (next?.canOverrideAnchor) {
      this.lastContour().push(next._firstInterpolatedVertex);
    } else {
      this.lastContour().push(anchor.getEndVertex());
    }
  }
  visitLineSegment(lineSegment) {
    this.lastContour().push(lineSegment.getEndVertex());
  }
  visitBezierSegment(bezierSegment) {
    const contour = this.lastContour();
    const numPoints = Math.max(
      1,
      Math.ceil(bezierSegment.hullLength() * this.curveDetail)
    );
    const vertexArrays = [
      bezierSegment.getStartVertex(),
      ...bezierSegment.vertices
    ].map((v) => bezierSegment._shape.vertexToArray(v));
    for (let i = 0; i < numPoints; i++) {
      const t = (i + 1) / numPoints;
      contour.push(
        bezierSegment._shape.arrayToVertex(
          bezierSegment.order === 3 ? bezierSegment._shape.evaluateCubicBezier(vertexArrays, t) : bezierSegment._shape.evaluateQuadraticBezier(vertexArrays, t)
        )
      );
    }
  }
  visitSplineSegment(splineSegment) {
    const shape2 = splineSegment._shape;
    const contour = this.lastContour();
    const arrayVertices = splineSegment.getControlPoints().map(
      (v) => shape2.vertexToArray(v)
    );
    let bezierArrays = shape2.catmullRomToBezier(
      arrayVertices,
      splineSegment._splineProperties.tightness
    );
    let startVertex = shape2.vertexToArray(
      splineSegment._firstInterpolatedVertex
    );
    for (const array2 of bezierArrays) {
      const bezierControls = [startVertex, ...array2];
      const numPoints = Math.max(
        1,
        Math.ceil(
          polylineLength(bezierControls.map((v) => shape2.arrayToVertex(v))) * this.curveDetail
        )
      );
      for (let i = 0; i < numPoints; i++) {
        const t = (i + 1) / numPoints;
        contour.push(
          shape2.arrayToVertex(shape2.evaluateCubicBezier(bezierControls, t))
        );
      }
      startVertex = array2[2];
    }
  }
  visitPoint(point) {
    if (this.pointsToLines) {
      this.contours.push(...point.vertices.map((v) => [v, v]));
    } else {
      this.contours.push(point.vertices.slice());
    }
  }
  visitLine(line) {
    this.contours.push(line.vertices.slice());
  }
  visitTriangle(triangle) {
    this.contours.push(triangle.vertices.slice());
  }
  visitQuad(quad) {
    this.contours.push(quad.vertices.slice());
  }
  visitTriangleFan(triangleFan) {
    this.contours.push(triangleFan.vertices.slice());
  }
  visitTriangleStrip(triangleStrip) {
    this.contours.push(triangleStrip.vertices.slice());
  }
  visitQuadStrip(quadStrip) {
    this.contours.push(quadStrip.vertices.slice());
  }
}
class PointAtLengthGetter extends PrimitiveVisitor {
  constructor() {
    super();
  }
}
function customShapes(p53, fn2) {
  p53.Shape = Shape;
  p53.Contour = Contour;
  p53.ShapePrimitive = ShapePrimitive;
  p53.Vertex = Vertex;
  p53.Anchor = Anchor;
  p53.Segment = Segment;
  p53.LineSegment = LineSegment;
  p53.BezierSegment = BezierSegment;
  p53.SplineSegment = SplineSegment;
  p53.Point = Point;
  p53.Line = Line;
  p53.Triangle = Triangle;
  p53.Quad = Quad;
  p53.TriangleFan = TriangleFan;
  p53.TriangleStrip = TriangleStrip;
  p53.QuadStrip = QuadStrip;
  p53.PrimitiveVisitor = PrimitiveVisitor;
  p53.PrimitiveToPath2DConverter = PrimitiveToPath2DConverter;
  p53.PrimitiveToVerticesConverter = PrimitiveToVerticesConverter;
  p53.PointAtLengthGetter = PointAtLengthGetter;
  fn2.bezierOrder = function(order) {
    return this._renderer.bezierOrder(order);
  };
  fn2.splineVertex = function(...args) {
    let x = 0, y = 0, z = 0, u = 0, v = 0;
    if (args.length === 2) {
      [x, y] = args;
    } else if (args.length === 4) {
      [x, y, u, v] = args;
    } else if (args.length === 3) {
      [x, y, z] = args;
    } else if (args.length === 5) {
      [x, y, z, u, v] = args;
    }
    this._renderer.splineVertex(x, y, z, u, v);
  };
  fn2.splineProperty = function(property, value) {
    return this._renderer.splineProperty(property, value);
  };
  fn2.splineProperties = function(values) {
    return this._renderer.splineProperties(values);
  };
  fn2.vertex = function(x, y) {
    let z, u, v;
    z = u = v = 0;
    if (arguments.length === 3) {
      z = arguments[2];
    } else if (arguments.length === 4) {
      u = arguments[2];
      v = arguments[3];
    } else if (arguments.length === 5) {
      z = arguments[2];
      u = arguments[3];
      v = arguments[4];
    }
    this._renderer.vertex(x, y, z, u, v);
    return;
  };
  fn2.beginContour = function(kind) {
    this._renderer.beginContour(kind);
  };
  fn2.endContour = function(mode = OPEN) {
    this._renderer.endContour(mode);
  };
}
if (typeof p5 !== "undefined") {
  customShapes(p5, p5.prototype);
}
class States {
  #modified = {};
  constructor(initialState) {
    for (const key in initialState) {
      this[key] = initialState[key];
    }
  }
  setValue(key, value) {
    if (!(key in this.#modified)) {
      this.#modified[key] = this[key];
    }
    this[key] = value;
  }
  getDiff() {
    const diff = this.#modified;
    this.#modified = {};
    return diff;
  }
  getModified() {
    return this.#modified;
  }
  applyDiff(prevModified) {
    for (const key in this.#modified) {
      this[key] = this.#modified[key];
    }
    this.#modified = prevModified;
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var FileSaver$1 = { exports: {} };
var FileSaver = FileSaver$1.exports;
var hasRequiredFileSaver;
function requireFileSaver() {
  if (hasRequiredFileSaver) return FileSaver$1.exports;
  hasRequiredFileSaver = 1;
  (function(module) {
    var saveAs = saveAs || (function(view) {
      if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
      }
      var doc = view.document, get_URL = function() {
        return view.URL || view.webkitURL || view;
      }, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download" in save_link, click = function(node) {
        var event = new MouseEvent("click");
        node.dispatchEvent(event);
      }, is_safari = /constructor/i.test(view.HTMLElement) || view.safari, is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent), throw_outside = function(ex) {
        (view.setImmediate || view.setTimeout)(function() {
          throw ex;
        }, 0);
      }, force_saveable_type = "application/octet-stream", arbitrary_revoke_timeout = 1e3 * 40, revoke = function(file2) {
        var revoker = function() {
          if (typeof file2 === "string") {
            get_URL().revokeObjectURL(file2);
          } else {
            file2.remove();
          }
        };
        setTimeout(revoker, arbitrary_revoke_timeout);
      }, dispatch = function(filesaver, event_types, event) {
        event_types = [].concat(event_types);
        var i = event_types.length;
        while (i--) {
          var listener = filesaver["on" + event_types[i]];
          if (typeof listener === "function") {
            try {
              listener.call(filesaver, event || filesaver);
            } catch (ex) {
              throw_outside(ex);
            }
          }
        }
      }, auto_bom = function(blob) {
        if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
          return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
        }
        return blob;
      }, FileSaver2 = function(blob, name, no_auto_bom) {
        if (!no_auto_bom) {
          blob = auto_bom(blob);
        }
        var filesaver = this, type2 = blob.type, force = type2 === force_saveable_type, object_url, dispatch_all = function() {
          dispatch(filesaver, "writestart progress write writeend".split(" "));
        }, fs_error = function() {
          if ((is_chrome_ios || force && is_safari) && view.FileReader) {
            var reader = new FileReader();
            reader.onloadend = function() {
              var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, "data:attachment/file;");
              var popup = view.open(url, "_blank");
              if (!popup) view.location.href = url;
              url = void 0;
              filesaver.readyState = filesaver.DONE;
              dispatch_all();
            };
            reader.readAsDataURL(blob);
            filesaver.readyState = filesaver.INIT;
            return;
          }
          if (!object_url) {
            object_url = get_URL().createObjectURL(blob);
          }
          if (force) {
            view.location.href = object_url;
          } else {
            var opened = view.open(object_url, "_blank");
            if (!opened) {
              view.location.href = object_url;
            }
          }
          filesaver.readyState = filesaver.DONE;
          dispatch_all();
          revoke(object_url);
        };
        filesaver.readyState = filesaver.INIT;
        if (can_use_save_link) {
          object_url = get_URL().createObjectURL(blob);
          setTimeout(function() {
            save_link.href = object_url;
            save_link.download = name;
            click(save_link);
            dispatch_all();
            revoke(object_url);
            filesaver.readyState = filesaver.DONE;
          });
          return;
        }
        fs_error();
      }, FS_proto = FileSaver2.prototype, saveAs2 = function(blob, name, no_auto_bom) {
        return new FileSaver2(blob, name || blob.name || "download", no_auto_bom);
      };
      if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
        return function(blob, name, no_auto_bom) {
          name = name || blob.name || "download";
          if (!no_auto_bom) {
            blob = auto_bom(blob);
          }
          return navigator.msSaveOrOpenBlob(blob, name);
        };
      }
      FS_proto.abort = function() {
      };
      FS_proto.readyState = FS_proto.INIT = 0;
      FS_proto.WRITING = 1;
      FS_proto.DONE = 2;
      FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
      return saveAs2;
    })(
      typeof self !== "undefined" && self || typeof window !== "undefined" && window || FileSaver.content
    );
    if (module.exports) {
      module.exports.saveAs = saveAs;
    }
  })(FileSaver$1);
  return FileSaver$1.exports;
}
var FileSaverExports = requireFileSaver();
function downloadFile(data2, fName, extension) {
  const fx = _checkFileExtension(fName, extension);
  const filename = fx[0];
  let saveData = data2;
  if (!(saveData instanceof Blob)) {
    saveData = new Blob([data2]);
  }
  FileSaverExports.saveAs(saveData, filename);
}
function _checkFileExtension(filename, extension) {
  if (!extension || extension === true || extension === "true") {
    extension = "";
  }
  if (!filename) {
    filename = "untitled";
  }
  let ext = "";
  if (filename && filename.includes(".")) {
    ext = filename.split(".").pop();
  }
  if (extension) {
    if (ext !== extension) {
      ext = extension;
      filename = `${filename}.${ext}`;
    }
  }
  return [filename, ext];
}
class Image {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.drawingContext = this.canvas.getContext("2d");
    this._pixelsState = this;
    this._pixelDensity = 1;
    this.gifProperties = null;
    this._modified = false;
    this.pixels = [];
  }
  /**
   * Gets or sets the pixel density for high pixel density displays.
   *
   * By default, the density will be set to 1.
   *
   * Call this method with no arguments to get the default density, or pass
   * in a number to set the density. If a non-positive number is provided,
   * it defaults to 1.
   *
   * @param {Number} [density] A scaling factor for the number of pixels per
   * side
   * @returns {Number} The current density if called without arguments, or the instance for chaining if setting density.
   */
  pixelDensity(density) {
    if (typeof density !== "undefined") {
      if (density <= 0) {
        density = 1;
      }
      this._pixelDensity = density;
      this.width /= density;
      this.height /= density;
      return this;
    } else {
      return this._pixelDensity;
    }
  }
  /**
   * Helper function for animating GIF-based images with time
   */
  _animateGif(pInst) {
    const props = this.gifProperties;
    const curTime = pInst._lastRealFrameTime || window.performance.now();
    if (props.lastChangeTime === 0) {
      props.lastChangeTime = curTime;
    }
    if (props.playing) {
      props.timeDisplayed = curTime - props.lastChangeTime;
      const curDelay = props.frames[props.displayIndex].delay;
      if (props.timeDisplayed >= curDelay) {
        const skips = Math.floor(props.timeDisplayed / curDelay);
        props.timeDisplayed = 0;
        props.lastChangeTime = curTime;
        props.displayIndex += skips;
        props.loopCount = Math.floor(props.displayIndex / props.numFrames);
        if (props.loopLimit !== null && props.loopCount >= props.loopLimit) {
          props.playing = false;
        } else {
          const ind = props.displayIndex % props.numFrames;
          this.drawingContext.putImageData(props.frames[ind].image, 0, 0);
          props.displayIndex = ind;
          this.setModified(true);
        }
      }
    }
  }
  /**
   * Loads the current value of each pixel in the image into the `img.pixels`
   * array.
   *
   * `img.loadPixels()` must be called before reading or modifying pixel
   * values.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       img.set(x, y, 0);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   for (let i = 0; i < img.pixels.length; i += 4) {
   *     // Red.
   *     img.pixels[i] = 0;
   *     // Green.
   *     img.pixels[i + 1] = 0;
   *     // Blue.
   *     img.pixels[i + 2] = 0;
   *     // Alpha.
   *     img.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */
  loadPixels() {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    const w = this.width * pd;
    const h = this.height * pd;
    const imageData = this.drawingContext.getImageData(0, 0, w, h);
    pixelsState.imageData = imageData;
    this.pixels = pixelsState.pixels = imageData.data;
    this.setModified(true);
  }
  /**
   * Updates the canvas with the RGBA values in the
   * <a href="#/p5.Image/pixels">img.pixels</a> array.
   *
   * `img.updatePixels()` only needs to be called after changing values in
   * the <a href="#/p5.Image/pixels">img.pixels</a> array. Such changes can be
   * made directly after calling
   * <a href="#/p5.Image/loadPixels">img.loadPixels()</a> or by calling
   * <a href="#/p5.Image/set">img.set()</a>.
   *
   * The optional parameters `x`, `y`, `width`, and `height` define a
   * subsection of the image to update. Doing so can improve performance in
   * some cases.
   *
   * If the image was loaded from a GIF, then calling `img.updatePixels()`
   * will update the pixels in current frame.
   *
   * @param {Integer} [x] x-coordinate of the upper-left corner
   *                      of the subsection to update.
   * @param {Integer} [y] y-coordinate of the upper-left corner
   *                      of the subsection to update.
   * @param {Integer} [w] width of the subsection to update.
   * @param {Integer} [h] height of the subsection to update.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       img.set(x, y, 0);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let i = 0; i < img.pixels.length; i += 4) {
   *     // Red.
   *     img.pixels[i] = 0;
   *     // Green.
   *     img.pixels[i + 1] = 0;
   *     // Blue.
   *     img.pixels[i + 2] = 0;
   *     // Alpha.
   *     img.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */
  updatePixels(x, y, w, h) {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    if (x === void 0 && y === void 0 && w === void 0 && h === void 0) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    }
    x *= pd;
    y *= pd;
    w *= pd;
    h *= pd;
    if (this.gifProperties) {
      this.gifProperties.frames[this.gifProperties.displayIndex].image = pixelsState.imageData;
    }
    this.drawingContext.putImageData(pixelsState.imageData, x, y, 0, 0, w, h);
    this.setModified(true);
  }
  /**
   * Gets a pixel or a region of pixels from the image.
   *
   * `img.get()` is easy to use but it's not as fast as
   * <a href="#/p5.Image/pixels">img.pixels</a>. Use
   * <a href="#/p5.Image/pixels">img.pixels</a> to read many pixel values.
   *
   * The version of `img.get()` with no parameters returns the entire image.
   *
   * The version of `img.get()` with two parameters, as in `img.get(10, 20)`,
   * interprets them as coordinates. It returns an array with the
   * `[R, G, B, A]` values of the pixel at the given point.
   *
   * The version of `img.get()` with four parameters, as in
   * `img,get(10, 20, 50, 90)`, interprets them as
   * coordinates and dimensions. The first two parameters are the coordinates
   * of the upper-left corner of the subsection. The last two parameters are
   * the width and height of the subsection. It returns a subsection of the
   * canvas in a new <a href="#/p5.Image">p5.Image</a> object.
   *
   * Use `img.get()` instead of <a href="#/p5/get">get()</a> to work directly
   * with images.
   *
   * @param  {Number}               x x-coordinate of the pixel.
   * @param  {Number}               y y-coordinate of the pixel.
   * @param  {Number}               w width of the subsection to be returned.
   * @param  {Number}               h height of the subsection to be returned.
   * @return {p5.Image}             subsection as a <a href="#/p5.Image">p5.Image</a> object.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Copy the image.
   *   let img2 = get();
   *
   *   // Display the copied image on the right.
   *   image(img2, 50, 0);
   *
   *   describe('Two identical mountain landscapes shown side-by-side.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Get a pixel's color.
   *   let c = img.get(50, 90);
   *
   *   // Style the square using the pixel's color.
   *   fill(c);
   *   noStroke();
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   *
   *   describe('A mountain landscape with an olive green square in its center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Copy half of the image.
   *   let img2 = img.get(0, 0, img.width / 2, img.height / 2);
   *
   *   // Display half of the image.
   *   image(img2, 50, 50);
   *
   *   describe('A mountain landscape drawn on top of another mountain landscape.');
   * }
   * </code>
   * </div>
   */
  /**
   * @return {p5.Image}      whole <a href="#/p5.Image">p5.Image</a>
   */
  /**
   * @param  {Number}        x
   * @param  {Number}        y
   * @return {Number[]}      color of the pixel at (x, y) in array format `[R, G, B, A]`.
   */
  get(x, y, w, h) {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    const canvas2 = this.canvas;
    if (typeof x === "undefined" && typeof y === "undefined") {
      x = y = 0;
      w = pixelsState.width;
      h = pixelsState.height;
    } else {
      x *= pd;
      y *= pd;
      if (typeof w === "undefined" && typeof h === "undefined") {
        if (x < 0 || y < 0 || x >= canvas2.width || y >= canvas2.height) {
          return [0, 0, 0, 0];
        }
        return this._getPixel(x, y);
      }
    }
    const region = new Image(w * pd, h * pd);
    region.pixelDensity(pd);
    region.canvas.getContext("2d").drawImage(canvas2, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
    return region;
  }
  _getPixel(x, y) {
    let imageData, index;
    imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
    index = 0;
    return [
      imageData[index + 0],
      imageData[index + 1],
      imageData[index + 2],
      imageData[index + 3]
    ];
  }
  /**
   * Sets the color of one or more pixels within an image.
   *
   * `img.set()` is easy to use but it's not as fast as
   * <a href="#/p5.Image/pixels">img.pixels</a>. Use
   * <a href="#/p5.Image/pixels">img.pixels</a> to set many pixel values.
   *
   * `img.set()` interprets the first two parameters as x- and y-coordinates. It
   * interprets the last parameter as a grayscale value, a `[R, G, B, A]` pixel
   * array, a <a href="#/p5.Color">p5.Color</a> object, or another
   * <a href="#/p5.Image">p5.Image</a> object.
   *
   * <a href="#/p5.Image/updatePixels">img.updatePixels()</a> must be called
   * after using `img.set()` for changes to appear.
   *
   * @param {Number}              x x-coordinate of the pixel.
   * @param {Number}              y y-coordinate of the pixel.
   * @param {Number|Number[]|Object}   a grayscale value | pixel array |
   *                                   <a href="#/p5.Color">p5.Color</a> object |
   *                                   <a href="#/p5.Image">p5.Image</a> to copy.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(100, 100);
   *
   *   // Set four pixels to black.
   *   img.set(30, 20, 0);
   *   img.set(85, 20, 0);
   *   img.set(85, 75, 0);
   *   img.set(30, 75, 0);
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Four black dots arranged in a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(100, 100);
   *
   *   // Create a p5.Color object.
   *   let black = color(0);
   *
   *   // Set four pixels to black.
   *   img.set(30, 20, black);
   *   img.set(85, 20, black);
   *   img.set(85, 75, black);
   *   img.set(30, 75, black);
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Four black dots arranged in a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Draw a color gradient.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       let c = map(x, 0, img.width, 0, 255);
   *       img.set(x, y, c);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A square with a horiztonal color gradient from black to white drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Image object.
   *   let img2 = createImage(100, 100);
   *
   *   // Set the blank image's pixels using the landscape.
   *   img2.set(0, 0, img);
   *
   *   // Display the second image.
   *   image(img2, 0, 0);
   *
   *   describe('An image of a mountain landscape.');
   * }
   * </code>
   * </div>
   */
  set(x, y, imgOrCol) {
    x = Math.floor(x);
    y = Math.floor(y);
    const pixelsState = this._pixelsState;
    if (imgOrCol instanceof Image) {
      this.drawingContext.save();
      this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
      this.drawingContext.scale(
        this._pixelDensity,
        this._pixelDensity
      );
      this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);
      this.drawingContext.drawImage(imgOrCol.canvas, x, y);
      this.drawingContext.restore();
    } else {
      let r = 0, g2 = 0, b2 = 0, a = 0;
      let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);
      if (!pixelsState.imageData) {
        pixelsState.loadPixels();
      }
      if (typeof imgOrCol === "number") {
        if (idx < pixelsState.pixels.length) {
          r = imgOrCol;
          g2 = imgOrCol;
          b2 = imgOrCol;
          a = 255;
        }
      } else if (Array.isArray(imgOrCol)) {
        if (imgOrCol.length < 4) {
          throw new Error("pixel array must be of the form [R, G, B, A]");
        }
        if (idx < pixelsState.pixels.length) {
          r = imgOrCol[0];
          g2 = imgOrCol[1];
          b2 = imgOrCol[2];
          a = imgOrCol[3];
        }
      } else if (imgOrCol instanceof p5.Color) {
        if (idx < pixelsState.pixels.length) {
          [r, g2, b2, a] = imgOrCol._getRGBA([255, 255, 255, 255]);
        }
      }
      for (let i = 0; i < this._pixelDensity; i++) {
        for (let j2 = 0; j2 < this._pixelDensity; j2++) {
          idx = 4 * ((y * this._pixelDensity + j2) * this.width * this._pixelDensity + (x * this._pixelDensity + i));
          pixelsState.pixels[idx] = r;
          pixelsState.pixels[idx + 1] = g2;
          pixelsState.pixels[idx + 2] = b2;
          pixelsState.pixels[idx + 3] = a;
        }
      }
    }
    this.setModified(true);
  }
  /**
   * Resizes the image to a given width and height.
   *
   * The image's original aspect ratio can be kept by passing 0 for either
   * `width` or `height`. For example, calling `img.resize(50, 0)` on an image
   * that was 500 &times; 300 pixels will resize it to 50 &times; 30 pixels.
   *
   * @param {Number} width resized image width.
   * @param {Number} height resized image height.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image.
   *   img.resize(50, 100);
   *
   *   // Display the resized image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. One copy of the image is squeezed horizontally.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image, keeping the aspect ratio.
   *   img.resize(0, 30);
   *
   *   // Display the resized image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image, keeping the aspect ratio.
   *   img.resize(60, 0);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');
   * }
   * </code>
   * </div>
   */
  resize(width, height) {
    if (width === 0 && height === 0) {
      width = this.canvas.width;
      height = this.canvas.height;
    } else if (width === 0) {
      width = this.canvas.width * height / this.canvas.height;
    } else if (height === 0) {
      height = this.canvas.height * width / this.canvas.width;
    }
    width = Math.floor(width);
    height = Math.floor(height);
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = width;
    tempCanvas.height = height;
    if (this.gifProperties) {
      const props = this.gifProperties;
      const nearestNeighbor = (src, dst) => {
        let pos = 0;
        for (let y = 0; y < dst.height; y++) {
          for (let x = 0; x < dst.width; x++) {
            const srcX = Math.floor(x * src.width / dst.width);
            const srcY = Math.floor(y * src.height / dst.height);
            let srcPos = (srcY * src.width + srcX) * 4;
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
          }
        }
      };
      for (let i = 0; i < props.numFrames; i++) {
        const resizedImageData = this.drawingContext.createImageData(
          width,
          height
        );
        nearestNeighbor(props.frames[i].image, resizedImageData);
        props.frames[i].image = resizedImageData;
      }
    }
    tempCanvas.getContext("2d").drawImage(
      this.canvas,
      0,
      0,
      this.canvas.width,
      this.canvas.height,
      0,
      0,
      tempCanvas.width,
      tempCanvas.height
    );
    this.canvas.width = this.width = width;
    this.canvas.height = this.height = height;
    this.drawingContext.drawImage(
      tempCanvas,
      0,
      0,
      width,
      height,
      0,
      0,
      width,
      height
    );
    if (this.pixels.length > 0) {
      this.loadPixels();
    }
    this.setModified(true);
  }
  /**
   * Copies pixels from a source image to this image.
   *
   * The first parameter, `srcImage`, is an optional
   * <a href="#/p5.Image">p5.Image</a> object to copy. If a source image isn't
   * passed, then `img.copy()` can copy a region of this image to another
   * region.
   *
   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region
   * to copy from the source image. `(sx, sy)` is the top-left corner of the
   * region. `sw` and `sh` are the region's width and height.
   *
   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region
   * of this image to copy into. `(dx, dy)` is the top-left corner of the
   * region. `dw` and `dh` are the region's width and height.
   *
   * Calling `img.copy()` will scale pixels from the source region if it isn't
   * the same size as the destination region.
   *
   * @param  {p5.Image|p5.Element} srcImage source image.
   * @param  {Integer} sx x-coordinate of the source's upper-left corner.
   * @param  {Integer} sy y-coordinate of the source's upper-left corner.
   * @param  {Integer} sw source image width.
   * @param  {Integer} sh source image height.
   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.
   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.
   * @param  {Integer} dw destination image width.
   * @param  {Integer} dh destination image height.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Copy one region of the image to another.
   *   img.copy(7, 22, 10, 10, 35, 25, 50, 50);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Outline the copied region.
   *   stroke(255);
   *   noFill();
   *   square(7, 22, 10);
   *
   *   describe('An image of a mountain landscape. A square region is outlined in white. A larger square contains a pixelated view of the outlined region.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks.jpg');
   *   createCanvas(100, 100);
   *
   *   // Calculate the center of the bricks image.
   *   let x = bricks.width / 2;
   *   let y = bricks.height / 2;
   *
   *   // Copy the bricks to the mountains image.
   *   mountains.copy(bricks, 0, 0, x, y, 0, 0, x, y);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   describe('An image of a brick wall drawn at the top-left of an image of a mountain landscape.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Integer} sx
   * @param  {Integer} sy
   * @param  {Integer} sw
   * @param  {Integer} sh
   * @param  {Integer} dx
   * @param  {Integer} dy
   * @param  {Integer} dw
   * @param  {Integer} dh
   */
  copy(...args) {
    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
    if (args.length === 9) {
      srcImage = args[0];
      sx = args[1];
      sy = args[2];
      sw = args[3];
      sh = args[4];
      dx = args[5];
      dy = args[6];
      dw = args[7];
      dh = args[8];
    } else if (args.length === 8) {
      srcImage = this;
      sx = args[0];
      sy = args[1];
      sw = args[2];
      sh = args[3];
      dx = args[4];
      dy = args[5];
      dw = args[6];
      dh = args[7];
    } else {
      throw new Error("Signature not supported");
    }
    this._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
  }
  _copyHelper(dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {
    const s = srcImage.canvas.width / srcImage.width;
    let sxMod = 0;
    let syMod = 0;
    if (srcImage._renderer && srcImage._renderer.isP3D) {
      sxMod = srcImage.width / 2;
      syMod = srcImage.height / 2;
    }
    if (dstImage._renderer && dstImage._renderer.isP3D) {
      dstImage.push();
      dstImage.resetMatrix();
      dstImage.noLights();
      dstImage.blendMode(dstImage.BLEND);
      dstImage.imageMode(dstImage.CORNER);
      dstImage._renderer.image(
        srcImage,
        sx + sxMod,
        sy + syMod,
        sw,
        sh,
        dx,
        dy,
        dw,
        dh
      );
      dstImage.pop();
    } else {
      dstImage.drawingContext.drawImage(
        srcImage.canvas,
        s * (sx + sxMod),
        s * (sy + syMod),
        s * sw,
        s * sh,
        dx,
        dy,
        dw,
        dh
      );
    }
  }
  /**
   * Masks part of the image with another.
   *
   * `img.mask()` uses another <a href="#/p5.Image">p5.Image</a> object's
   * alpha channel as the alpha channel for this image. Masks are cumulative
   * and can't be removed once applied. If the mask has a different
   * pixel density from this image, the mask will be scaled.
   *
   * @param {p5.Image} srcImage source image.
   *
   * @example
   * <div>
   * <code>
   * let photo;
   * let maskImage;
   *
   * async function setup() {
   *   // Load the images.
   *   photo = await loadImage('assets/rockies.jpg');
   *   maskImage = await loadImage('assets/mask2.png');
   *   createCanvas(100, 100);
   *
   *   // Apply the mask.
   *   photo.mask(maskImage);
   *
   *   // Display the image.
   *   image(photo, 0, 0);
   *
   *   describe('An image of a mountain landscape. The right side of the image has a faded patch of white.');
   * }
   * </code>
   * </div>
   */
  // TODO: - Accept an array of alpha values.
  mask(p5Image) {
    if (p5Image === void 0) {
      p5Image = this;
    }
    const currBlend = this.drawingContext.globalCompositeOperation;
    let imgScaleFactor = this._pixelDensity;
    let maskScaleFactor = 1;
    if (p5Image instanceof Renderer) {
      maskScaleFactor = p5Image._pInst._renderer._pixelDensity;
    }
    const copyArgs = [
      p5Image,
      0,
      0,
      maskScaleFactor * p5Image.width,
      maskScaleFactor * p5Image.height,
      0,
      0,
      imgScaleFactor * this.width,
      imgScaleFactor * this.height
    ];
    this.drawingContext.globalCompositeOperation = "destination-in";
    if (this.gifProperties) {
      for (let i = 0; i < this.gifProperties.frames.length; i++) {
        this.drawingContext.putImageData(
          this.gifProperties.frames[i].image,
          0,
          0
        );
        this.copy(...copyArgs);
        this.gifProperties.frames[i].image = this.drawingContext.getImageData(
          0,
          0,
          imgScaleFactor * this.width,
          imgScaleFactor * this.height
        );
      }
      this.drawingContext.putImageData(
        this.gifProperties.frames[this.gifProperties.displayIndex].image,
        0,
        0
      );
    } else {
      this.copy(...copyArgs);
    }
    this.drawingContext.globalCompositeOperation = currBlend;
    this.setModified(true);
  }
  /**
   * Applies an image filter to the image.
   *
   * The preset options are:
   *
   * `INVERT`
   * Inverts the colors in the image. No parameter is used.
   *
   * `GRAY`
   * Converts the image to grayscale. No parameter is used.
   *
   * `THRESHOLD`
   * Converts the image to black and white. Pixels with a grayscale value
   * above a given threshold are converted to white. The rest are converted to
   * black. The threshold must be between 0.0 (black) and 1.0 (white). If no
   * value is specified, 0.5 is used.
   *
   * `OPAQUE`
   * Sets the alpha channel to be entirely opaque. No parameter is used.
   *
   * `POSTERIZE`
   * Limits the number of colors in the image. Each color channel is limited to
   * the number of colors specified. Values between 2 and 255 are valid, but
   * results are most noticeable with lower values. The default value is 4.
   *
   * `BLUR`
   * Blurs the image. The level of blurring is specified by a blur radius. Larger
   * values increase the blur. The default value is 4. A gaussian blur is used
   * in `P2D` mode. A box blur is used in `WEBGL` mode.
   *
   * `ERODE`
   * Reduces the light areas. No parameter is used.
   *
   * `DILATE`
   * Increases the light areas. No parameter is used.
   *
   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR)} filterType  either THRESHOLD, GRAY, OPAQUE, INVERT,
   *                                POSTERIZE, ERODE, DILATE or BLUR.
   * @param  {Number} [filterParam] parameter unique to each filter.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the INVERT filter.
   *   img.filter(INVERT);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A blue brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the GRAY filter.
   *   img.filter(GRAY);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A brick wall drawn in grayscale.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the THRESHOLD filter.
   *   img.filter(THRESHOLD);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A brick wall drawn in black and white.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the OPAQUE filter.
   *   img.filter(OPAQUE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the POSTERIZE filter.
   *   img.filter(POSTERIZE, 3);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('An image of a red brick wall drawn with a limited color palette.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the BLUR filter.
   *   img.filter(BLUR, 3);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A blurry image of a red brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the DILATE filter.
   *   img.filter(DILATE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall with bright lines between each brick.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the ERODE filter.
   *   img.filter(ERODE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall with faint lines between each brick.');
   * }
   * </code>
   * </div>
   */
  filter(operation, value) {
    Filters.apply(this.canvas, Filters[operation], value);
    this.setModified(true);
  }
  /**
   * Copies a region of pixels from another image into this one.
   *
   * The first parameter, `srcImage`, is the
   * <a href="#/p5.Image">p5.Image</a> object to blend.
   *
   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region
   * to blend from the source image. `(sx, sy)` is the top-left corner of the
   * region. `sw` and `sh` are the regions width and height.
   *
   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region
   * of the canvas to blend into. `(dx, dy)` is the top-left corner of the
   * region. `dw` and `dh` are the regions width and height.
   *
   * The tenth parameter, `blendMode`, sets the effect used to blend the images'
   * colors. The options are `BLEND`, `DARKEST`, `LIGHTEST`, `DIFFERENCE`,
   * `MULTIPLY`, `EXCLUSION`, `SCREEN`, `REPLACE`, `OVERLAY`, `HARD_LIGHT`,
   * `SOFT_LIGHT`, `DODGE`, `BURN`, `ADD`, or `NORMAL`.
   *
   * @param  {p5.Image} srcImage source image
   * @param  {Integer} sx x-coordinate of the source's upper-left corner.
   * @param  {Integer} sy y-coordinate of the source's upper-left corner.
   * @param  {Integer} sw source image width.
   * @param  {Integer} sh source image height.
   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.
   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.
   * @param  {Integer} dw destination image width.
   * @param  {Integer} dh destination image height.
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode the blend mode. either
   *     BLEND, DARKEST, LIGHTEST, DIFFERENCE,
   *     MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,
   *     SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.
   *
   * Available blend modes are: normal | multiply | screen | overlay |
   *            darken | lighten | color-dodge | color-burn | hard-light |
   *            soft-light | difference | exclusion | hue | saturation |
   *            color | luminosity
   *
   * http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/
   *
   * @example
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, ADD);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears faded on the right of the image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears transparent on the right of the image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears washed out on the right of the image.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Integer} sx
   * @param  {Integer} sy
   * @param  {Integer} sw
   * @param  {Integer} sh
   * @param  {Integer} dx
   * @param  {Integer} dy
   * @param  {Integer} dw
   * @param  {Integer} dh
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode
   */
  blend(...args) {
    const currBlend = this.drawingContext.globalCompositeOperation;
    const blendMode = args[args.length - 1];
    const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
    this.drawingContext.globalCompositeOperation = blendMode;
    this.copy(...copyArgs);
    this.drawingContext.globalCompositeOperation = currBlend;
    this.setModified(true);
  }
  /**
   * helper method for web GL mode to indicate that an image has been
   * changed or unchanged since last upload. gl texture upload will
   * set this value to false after uploading the texture.
   * @param {Boolean} val sets whether or not the image has been
   * modified.
   * @private
   */
  setModified(val) {
    this._modified = val;
  }
  /**
   * helper method for web GL mode to figure out if the image
   * has been modified and might need to be re-uploaded to texture
   * memory between frames.
   * @private
   * @return {boolean} a boolean indicating whether or not the
   * image has been updated or modified since last texture upload.
   */
  isModified() {
    return this._modified;
  }
  /**
   * Saves the image to a file.
   *
   * By default, `img.save()` saves the image as a PNG image called
   * `untitled.png`.
   *
   * The first parameter, `filename`, is optional. It's a string that sets the
   * file's name. If a file extension is included, as in
   * `img.save('drawing.png')`, then the image will be saved using that
   * format.
   *
   * The second parameter, `extension`, is also optional. It sets the files format.
   * Either `'png'` or `'jpg'` can be used. For example, `img.save('drawing', 'jpg')`
   * saves the canvas to a file called `drawing.jpg`.
   *
   * Note: The browser will either save the file immediately or prompt the user
   * with a dialogue window.
   *
   * The image will only be downloaded as an animated GIF if it was loaded
   * from a GIF file. See <a href="#/p5/saveGif">saveGif()</a> to create new
   * GIFs.
   *
   * @param {String} filename filename. Defaults to 'untitled'.
   * @param  {String} [extension] file extension, either 'png' or 'jpg'.
   *                            Defaults to 'png'.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('An image of a mountain landscape. The image is downloaded when the user presses the "s", "j", or "p" key.');
   * }
   *
   * // Save the image with different options when the user presses a key.
   * function keyPressed() {
   *   if (key === 's') {
   *     img.save();
   *   } else if (key === 'j') {
   *     img.save('rockies.jpg');
   *   } else if (key === 'p') {
   *     img.save('rockies', 'png');
   *   }
   * }
   * </code>
   * </div>
   */
  save(filename, extension) {
    if (this.gifProperties) {
      encodeAndDownloadGif(this, filename);
    } else {
      let htmlCanvas = this.canvas;
      extension = extension || _checkFileExtension(filename, extension)[1] || "png";
      let mimeType;
      switch (extension) {
        default:
          mimeType = "image/png";
          break;
        case "webp":
          mimeType = "image/webp";
          break;
        case "jpeg":
        case "jpg":
          mimeType = "image/jpeg";
          break;
      }
      htmlCanvas.toBlob((blob) => {
        downloadFile(blob, filename, extension);
      }, mimeType);
    }
  }
  async toBlob() {
    return new Promise((resolve) => {
      this.canvas.toBlob(resolve);
    });
  }
  // GIF Section
  /**
   * Restarts an animated GIF at its first frame.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-wink-loop-once.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon face winks once and then freezes. Clicking resets the face and makes it wink again.');
   * }
   *
   * function draw() {
   *   background(255);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   *
   * // Reset the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.reset();
   * }
   * </code>
   * </div>
   */
  reset() {
    if (this.gifProperties) {
      const props = this.gifProperties;
      props.playing = true;
      props.timeSinceStart = 0;
      props.timeDisplayed = 0;
      props.lastChangeTime = 0;
      props.loopCount = 0;
      props.displayIndex = 0;
      this.drawingContext.putImageData(props.frames[0].image, 0, 0);
    }
  }
  /**
   * Gets the index of the current frame in an animated GIF.
   *
   * @return {Number}       index of the GIF's current frame.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon eye repeatedly looks around, then outwards. A number displayed in the bottom-left corner increases from 0 to 124, then repeats.');
   * }
   *
   * function draw() {
   *   // Get the index of the current GIF frame.
   *   let index = gif.getCurrentFrame();
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   *
   *   // Display the current frame.
   *   text(index, 10, 90);
   * }
   * </code>
   * </div>
   */
  getCurrentFrame() {
    if (this.gifProperties) {
      const props = this.gifProperties;
      return props.displayIndex % props.numFrames;
    }
  }
  /**
   * Sets the current frame in an animated GIF.
   *
   * @param {Number} index index of the frame to display.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   * let frameSlider;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   // Get the index of the last frame.
   *   let maxFrame = gif.numFrames() - 1;
   *
   *   // Create a slider to control which frame is drawn.
   *   frameSlider = createSlider(0, maxFrame);
   *   frameSlider.position(10, 80);
   *   frameSlider.size(80);
   *
   *   describe('A cartoon eye looks around when a slider is moved.');
   * }
   *
   * function draw() {
   *   // Get the slider's value.
   *   let index = frameSlider.value();
   *
   *   // Set the GIF's frame.
   *   gif.setFrame(index);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   * </code>
   * </div>
   */
  setFrame(index) {
    if (this.gifProperties) {
      const props = this.gifProperties;
      if (index < props.numFrames && index >= 0) {
        props.timeDisplayed = 0;
        props.lastChangeTime = 0;
        props.displayIndex = index;
        this.drawingContext.putImageData(props.frames[index].image, 0, 0);
      } else {
        console.log(
          "Cannot set GIF to a frame number that is higher than total number of frames or below zero."
        );
      }
    }
  }
  /**
   * Returns the number of frames in an animated GIF.
   *
   * @return {Number} number of frames in the GIF.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon eye looks around. The text "n / 125" is shown at the bottom of the canvas.');
   * }
   *
   * function draw() {
   *   // Display the image.
   *   image(gif, 0, 0);
   *
   *   // Display the current state of playback.
   *   let total = gif.numFrames();
   *   let index = gif.getCurrentFrame();
   *   text(`${index} / ${total}`, 30, 90);
   * }
   * </code>
   * </div>
   */
  numFrames() {
    if (this.gifProperties) {
      return this.gifProperties.numFrames;
    }
  }
  /**
   * Plays an animated GIF that was paused with
   * <a href="#/p5.Image/pause">img.pause()</a>.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');
   * }
   *
   * function draw() {
   *   background(255);
   *   image(gif, 0, 0);
   * }
   *
   * // Pause the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.pause();
   * }
   *
   * // Play the GIF when the user releases the mouse.
   * function mouseReleased() {
   *   gif.play();
   * }
   * </code>
   * </div>
   */
  play() {
    if (this.gifProperties) {
      this.gifProperties.playing = true;
    }
  }
  /**
   * Pauses an animated GIF.
   *
   * The GIF can be resumed by calling
   * <a href="#/p5.Image/play">img.play()</a>.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');
   * }
   *
   * function draw() {
   *   background(255);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   *
   * // Pause the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.pause();
   * }
   *
   * // Play the GIF when the user presses the mouse.
   * function mouseReleased() {
   *   gif.play();
   * }
   * </code>
   * </div>
   */
  pause() {
    if (this.gifProperties) {
      this.gifProperties.playing = false;
    }
  }
  /**
   * Changes the delay between frames in an animated GIF.
   *
   * The first parameter, `delay`, is the length of the delay in milliseconds.
   *
   * The second parameter, `index`, is optional. If provided, only the frame
   * at `index` will have its delay modified. All other frames will keep
   * their default delay.
   *
   * @param {Number} d delay in milliseconds between switching frames.
   * @param {Number} [index] index of the frame that will have its delay modified.
   *
   * @example
   * <div>
   * <code>
   * let gifFast;
   * let gifSlow;
   *
   * async function setup() {
   *   // Load the images.
   *   gifFast = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *   gifSlow = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Resize the images.
   *   gifFast.resize(50, 50);
   *   gifSlow.resize(50, 50);
   *
   *   // Set the delay lengths.
   *   gifFast.delay(10);
   *   gifSlow.delay(100);
   *
   *   describe('Two animated eyes looking around. The eye on the left moves faster than the eye on the right.');
   * }
   *
   * function draw() {
   *   // Display the images.
   *   image(gifFast, 0, 0);
   *   image(gifSlow, 50, 0);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   // Set the delay of frame 67.
   *   gif.delay(3000, 67);
   *
   *   describe('An animated eye looking around. It pauses for three seconds while it looks down.');
   * }
   *
   * function draw() {
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   * </code>
   * </div>
   */
  delay(d2, index) {
    if (this.gifProperties) {
      const props = this.gifProperties;
      if (index < props.numFrames && index >= 0) {
        props.frames[index].delay = d2;
      } else {
        for (const frame of props.frames) {
          frame.delay = d2;
        }
      }
    }
  }
}
function encodeAndDownloadGif(pImg, filename) {
  const props = pImg.gifProperties;
  let loopLimit = props.loopLimit;
  if (loopLimit === 1) {
    loopLimit = null;
  } else if (loopLimit === null) {
    loopLimit = 0;
  }
  const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
  const allFramesPixelColors = [];
  const paletteFreqsAndFrames = {};
  for (let i = 0; i < props.numFrames; i++) {
    const paletteSet = /* @__PURE__ */ new Set();
    const data2 = props.frames[i].image.data;
    const dataLength = data2.length;
    const pixelColors = new Uint32Array(pImg.width * pImg.height);
    for (let j2 = 0, k = 0; j2 < dataLength; j2 += 4, k++) {
      const r = data2[j2 + 0];
      const g2 = data2[j2 + 1];
      const b2 = data2[j2 + 2];
      const color2 = r << 16 | g2 << 8 | b2 << 0;
      paletteSet.add(color2);
      pixelColors[k] = color2;
    }
    const paletteStr = [...paletteSet].sort().toString();
    if (paletteFreqsAndFrames[paletteStr] === void 0) {
      paletteFreqsAndFrames[paletteStr] = { freq: 1, frames: [i] };
    } else {
      paletteFreqsAndFrames[paletteStr].freq += 1;
      paletteFreqsAndFrames[paletteStr].frames.push(i);
    }
    allFramesPixelColors.push(pixelColors);
  }
  let framesUsingGlobalPalette = [];
  const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a, b2) {
    return paletteFreqsAndFrames[b2].freq - paletteFreqsAndFrames[a].freq;
  });
  const globalPalette = palettesSortedByFreq[0].split(",").map((a) => parseInt(a));
  framesUsingGlobalPalette = framesUsingGlobalPalette.concat(
    paletteFreqsAndFrames[globalPalette].frames
  );
  const globalPaletteSet = new Set(globalPalette);
  for (let i = 1; i < palettesSortedByFreq.length; i++) {
    const palette = palettesSortedByFreq[i].split(",").map((a) => parseInt(a));
    const difference = palette.filter((x) => !globalPaletteSet.has(x));
    if (globalPalette.length + difference.length <= 256) {
      for (let j2 = 0; j2 < difference.length; j2++) {
        globalPalette.push(difference[j2]);
        globalPaletteSet.add(difference[j2]);
      }
      framesUsingGlobalPalette = framesUsingGlobalPalette.concat(
        paletteFreqsAndFrames[palettesSortedByFreq[i]].frames
      );
    }
  }
  framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
  const globalIndicesLookup = {};
  for (let i = 0; i < globalPalette.length; i++) {
    if (!globalIndicesLookup[globalPalette[i]]) {
      globalIndicesLookup[globalPalette[i]] = i;
    }
  }
  let powof2 = 1;
  while (powof2 < globalPalette.length) {
    powof2 <<= 1;
  }
  globalPalette.length = powof2;
  const opts = {
    loop: loopLimit,
    palette: new Uint32Array(globalPalette)
  };
  const gifWriter = new omggif.GifWriter(buffer, pImg.width, pImg.height, opts);
  let previousFrame = {};
  for (let i = 0; i < props.numFrames; i++) {
    const localPaletteRequired = !framesUsingGlobalPalette.has(i);
    const palette = localPaletteRequired ? [] : globalPalette;
    const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
    const colorIndicesLookup = {};
    const cannotBeTransparent = /* @__PURE__ */ new Set();
    allFramesPixelColors[i].forEach((color2, k) => {
      if (localPaletteRequired) {
        if (colorIndicesLookup[color2] === void 0) {
          colorIndicesLookup[color2] = palette.length;
          palette.push(color2);
        }
        pixelPaletteIndex[k] = colorIndicesLookup[color2];
      } else {
        pixelPaletteIndex[k] = globalIndicesLookup[color2];
      }
      if (i > 0) {
        if (allFramesPixelColors[i - 1][k] !== color2) {
          cannotBeTransparent.add(color2);
        }
      }
    });
    const frameOpts = {};
    const canBeTransparent = palette.filter((a) => !cannotBeTransparent.has(a));
    if (canBeTransparent.length > 0) {
      const transparent = canBeTransparent[0];
      const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
      if (i > 0) {
        for (let k = 0; k < allFramesPixelColors[i].length; k++) {
          if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {
            pixelPaletteIndex[k] = transparentIndex;
          }
        }
        frameOpts.transparent = transparentIndex;
        previousFrame.frameOpts.disposal = 1;
      }
    }
    frameOpts.delay = props.frames[i].delay / 10;
    if (localPaletteRequired) {
      let powof22 = 1;
      while (powof22 < palette.length) {
        powof22 <<= 1;
      }
      palette.length = powof22;
      frameOpts.palette = new Uint32Array(palette);
    }
    if (i > 0) {
      gifWriter.addFrame(
        0,
        0,
        pImg.width,
        pImg.height,
        previousFrame.pixelPaletteIndex,
        previousFrame.frameOpts
      );
    }
    previousFrame = {
      pixelPaletteIndex,
      frameOpts
    };
  }
  previousFrame.frameOpts.disposal = 1;
  gifWriter.addFrame(
    0,
    0,
    pImg.width,
    pImg.height,
    previousFrame.pixelPaletteIndex,
    previousFrame.frameOpts
  );
  const extension = "gif";
  const blob = new Blob([buffer.slice(0, gifWriter.end())], {
    type: "image/gif"
  });
  downloadFile(blob, filename, extension);
}
function image$2(p53, fn2) {
  p53.Image = Image;
}
if (typeof p5 !== "undefined") {
  image$2(p5, p5.prototype);
}
class ClonableObject {
  constructor(obj = {}) {
    for (const key in obj) {
      this[key] = obj[key];
    }
  }
  clone() {
    return new ClonableObject(this);
  }
}
class Renderer {
  static states = {
    strokeColor: null,
    strokeSet: false,
    fillColor: null,
    fillSet: false,
    tint: null,
    imageMode: CORNER,
    rectMode: CORNER,
    ellipseMode: CENTER,
    strokeWeight: 1,
    textFont: { family: "sans-serif" },
    textLeading: 15,
    leadingSet: false,
    textSize: 12,
    textAlign: LEFT,
    textBaseline: BASELINE,
    bezierOrder: 3,
    splineProperties: new ClonableObject({
      ends: INCLUDE,
      tightness: 0
    }),
    textWrap: WORD,
    // added v2.0
    fontStyle: NORMAL,
    // v1: textStyle
    fontStretch: NORMAL,
    fontWeight: NORMAL,
    lineHeight: NORMAL,
    fontVariant: NORMAL,
    direction: "inherit"
  };
  constructor(pInst, w, h, isMainCanvas) {
    this._pInst = pInst;
    this._isMainCanvas = isMainCanvas;
    this.pixels = [];
    this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1;
    this.width = w;
    this.height = h;
    this._events = {};
    if (isMainCanvas) {
      this._isMainCanvas = true;
    }
    this.states = new States(Renderer.states);
    this.states.strokeColor = new Color([0, 0, 0]);
    this.states.fillColor = new Color([1, 1, 1]);
    this._pushPopStack = [];
    this._pushPopDepth = 0;
    this._clipping = false;
    this._clipInvert = false;
    this._currentShape = void 0;
  }
  get currentShape() {
    if (!this._currentShape) {
      this._currentShape = new Shape(this.getCommonVertexProperties());
    }
    return this._currentShape;
  }
  remove() {
  }
  pixelDensity(val) {
    let returnValue;
    if (typeof val === "number") {
      if (val !== this._pixelDensity) {
        this._pixelDensity = val;
      }
      returnValue = this;
      this.resize(this.width, this.height);
    } else {
      returnValue = this._pixelDensity;
    }
    return returnValue;
  }
  // Makes a shallow copy of the current states
  // and push it into the push pop stack
  push() {
    this._pushPopDepth++;
    this._pushPopStack.push(this.states.getDiff());
  }
  // Pop the previous states out of the push pop stack and
  // assign it back to the current state
  pop() {
    this._pushPopDepth--;
    const diff = this._pushPopStack.pop() || {};
    const modified = this.states.getModified();
    this.states.applyDiff(diff);
    this.updateShapeVertexProperties(modified);
    this.updateShapeProperties(modified);
  }
  bezierOrder(order) {
    if (order === void 0) {
      return this.states.bezierOrder;
    } else {
      this.states.setValue("bezierOrder", order);
      this.updateShapeProperties();
    }
  }
  bezierVertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : void 0;
    this.currentShape.bezierVertex(position, textureCoordinates);
  }
  splineProperty(key, value) {
    if (value === void 0) {
      return this.states.splineProperties[key];
    } else {
      this.states.setValue("splineProperties", this.states.splineProperties.clone());
      this.states.splineProperties[key] = value;
    }
    this.updateShapeProperties();
  }
  splineProperties(values) {
    if (values) {
      for (const key in values) {
        this.splineProperty(key, values[key]);
      }
    } else {
      return { ...this.states.splineProperties };
    }
  }
  splineVertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : void 0;
    this.currentShape.splineVertex(position, textureCoordinates);
  }
  curveDetail(d2) {
    if (d2 === void 0) {
      return this.states.curveDetail;
    } else {
      this.states.setValue("curveDetail", d2);
    }
  }
  beginShape(...args) {
    this.currentShape.reset();
    this.updateShapeVertexProperties();
    this.currentShape.beginShape(...args);
  }
  endShape(...args) {
    this.currentShape.endShape(...args);
    this.drawShape(this.currentShape);
  }
  beginContour(shapeKind) {
    this.currentShape.beginContour(shapeKind);
  }
  endContour(mode) {
    this.currentShape.endContour(mode);
  }
  drawShape(shape2, count) {
    throw new Error("Unimplemented");
  }
  vertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : void 0;
    this.currentShape.vertex(position, textureCoordinates);
  }
  bezier(x1, y1, x2, y2, x3, y3, x4, y4) {
    const oldOrder = this._pInst.bezierOrder();
    this._pInst.bezierOrder(oldOrder);
    this._pInst.beginShape();
    this._pInst.bezierVertex(x1, y1);
    this._pInst.bezierVertex(x2, y2);
    this._pInst.bezierVertex(x3, y3);
    this._pInst.bezierVertex(x4, y4);
    this._pInst.endShape();
    return this;
  }
  spline(...args) {
    if (args.length === 2 * 4) {
      const [x1, y1, x2, y2, x3, y3, x4, y4] = args;
      this._pInst.beginShape();
      this._pInst.splineVertex(x1, y1);
      this._pInst.splineVertex(x2, y2);
      this._pInst.splineVertex(x3, y3);
      this._pInst.splineVertex(x4, y4);
      this._pInst.endShape();
    } else if (args.length === 3 * 4) {
      const [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = args;
      this._pInst.beginShape();
      this._pInst.splineVertex(x1, y1, z1);
      this._pInst.splineVertex(x2, y2, z2);
      this._pInst.splineVertex(x3, y3, z3);
      this._pInst.splineVertex(x4, y4, z4);
      this._pInst.endShape();
    }
    return this;
  }
  beginClip(options2 = {}) {
    if (this._clipping) {
      throw new Error("It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?");
    }
    this._clipping = true;
    this._clipInvert = options2.invert;
  }
  endClip() {
    if (!this._clipping) {
      throw new Error("It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?");
    }
    this._clipping = false;
  }
  /**
   * Resize our canvas element.
   */
  resize(w, h) {
    this.width = w;
    this.height = h;
  }
  get(x, y, w, h) {
    const pd = this._pixelDensity;
    const canvas2 = this.canvas;
    if (typeof x === "undefined" && typeof y === "undefined") {
      x = y = 0;
      w = this.width;
      h = this.height;
    } else {
      x *= pd;
      y *= pd;
      if (typeof w === "undefined" && typeof h === "undefined") {
        if (x < 0 || y < 0 || x >= canvas2.width || y >= canvas2.height) {
          return [0, 0, 0, 0];
        }
        return this._getPixel(x, y);
      }
    }
    const region = new Image(w * pd, h * pd);
    region.pixelDensity(pd);
    region.canvas.getContext("2d").drawImage(canvas2, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
    return region;
  }
  scale(x, y) {
  }
  fill(...args) {
    this.states.setValue("fillSet", true);
    this.states.setValue("fillColor", this._pInst.color(...args));
    this.updateShapeVertexProperties();
  }
  noFill() {
    this.states.setValue("fillColor", null);
  }
  strokeWeight(w) {
    if (w === void 0) {
      return this.states.strokeWeight;
    } else {
      this.states.setValue("strokeWeight", w);
    }
  }
  stroke(...args) {
    this.states.setValue("strokeSet", true);
    this.states.setValue("strokeColor", this._pInst.color(...args));
    this.updateShapeVertexProperties();
  }
  noStroke() {
    this.states.setValue("strokeColor", null);
  }
  getCommonVertexProperties() {
    return {};
  }
  getSupportedIndividualVertexProperties() {
    return {
      textureCoordinates: false
    };
  }
  updateShapeProperties(modified) {
    if (!modified || modified.bezierOrder || modified.splineProperties) {
      const shape2 = this.currentShape;
      shape2.bezierOrder(this.states.bezierOrder);
      shape2.splineProperty("ends", this.states.splineProperties.ends);
      shape2.splineProperty("tightness", this.states.splineProperties.tightness);
    }
  }
  updateShapeVertexProperties(modified) {
    const props = this.getCommonVertexProperties();
    if (!modified || Object.keys(modified).some((k) => k in props)) {
      const shape2 = this.currentShape;
      for (const key in props) {
        shape2[key](props[key]);
      }
    }
  }
  _applyDefaults() {
    return this;
  }
  finishDraw() {
  }
  ///////////////////////////////
  //// TEXT SUPPORT METHODS
  //////////////////////////////
  _middleAlignOffset = function() {
    const { textFont, textSize } = this.states;
    const font2 = textFont?.font;
    const ctx = this.textDrawingContext();
    const metrics = ctx.measureText("X");
    let sCapHeight = (font2?.data || {})["OS/2"]?.sCapHeight;
    if (sCapHeight) {
      const unitsPerEm = font2.data.head.unitsPerEm;
      sCapHeight *= textSize / unitsPerEm;
    } else {
      sCapHeight = metrics.fontBoundingBoxAscent;
    }
    return metrics.alphabeticBaseline + sCapHeight / 2;
  };
}
function renderer(p53, fn2) {
  p53.Renderer = Renderer;
}
const VIDEO = "video";
const AUDIO = "audio";
class Cue {
  constructor(callback, time2, id, val) {
    this.callback = callback;
    this.time = time2;
    this.id = id;
    this.val = val;
  }
}
class MediaElement extends Element {
  constructor(elt, pInst) {
    super(elt, pInst);
    const self2 = this;
    this.elt.crossOrigin = "anonymous";
    this._prevTime = 0;
    this._cueIDCounter = 0;
    this._cues = [];
    this.pixels = [];
    this._pixelsState = this;
    this._pixelDensity = 1;
    this._modified = false;
    this._frameOnCanvas = -1;
    Object.defineProperty(self2, "src", {
      get() {
        const firstChildSrc = self2.elt.children[0].src;
        const srcVal = self2.elt.src === window.location.href ? "" : self2.elt.src;
        const ret = firstChildSrc === window.location.href ? srcVal : firstChildSrc;
        return ret;
      },
      set(newValue) {
        for (let i = 0; i < self2.elt.children.length; i++) {
          self2.elt.removeChild(self2.elt.children[i]);
        }
        const source = document.createElement("source");
        source.src = newValue;
        elt.appendChild(source);
        self2.elt.src = newValue;
        self2.modified = true;
      }
    });
    self2._onended = function() {
    };
    self2.elt.onended = function() {
      self2._onended(self2);
    };
  }
  /**
   * Plays audio or video from a media element.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display a message.
   *   text('Click to play', 50, 50);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to play" written in black on a gray background. A beat plays when the user clicks the square.');
   * }
   *
   * // Play the beat when the user presses the mouse.
   * function mousePressed() {
   *   beat.play();
   * }
   * </code>
   * </div>
   */
  play() {
    if (this.elt.currentTime === this.elt.duration) {
      this.elt.currentTime = 0;
    }
    let promise;
    if (this.elt.readyState > 1) {
      promise = this.elt.play();
    } else {
      this.elt.load();
      promise = this.elt.play();
    }
    if (promise && promise.catch) {
      promise.catch((e2) => {
        if (e2.name === "NotAllowedError") {
          if (typeof IS_MINIFIED === "undefined") {
            p5._friendlyAutoplayError(this.src);
          } else {
            console.error(e2);
          }
        } else {
          console.error("Media play method encountered an unexpected error", e2);
        }
      });
    }
    return this;
  }
  /**
   * Stops a media element and sets its current time to 0.
   *
   * Calling `media.play()` will restart playing audio/video from the beginning.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isStopped = true;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to start" written in black on a gray background. The beat starts or stops when the user presses the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different instructions based on playback.
   *   if (isStopped === true) {
   *     text('Click to start', 50, 50);
   *   } else {
   *     text('Click to stop', 50, 50);
   *   }
   * }
   *
   * // Adjust playback when the user presses the mouse.
   * function mousePressed() {
   *   if (isStopped === true) {
   *     // If the beat is stopped, play it.
   *     beat.play();
   *     isStopped = false;
   *   } else {
   *     // If the beat is playing, stop it.
   *     beat.stop();
   *     isStopped = true;
   *   }
   * }
   * </code>
   * </div>
   */
  stop() {
    this.elt.pause();
    this.elt.currentTime = 0;
    return this;
  }
  /**
   * Pauses a media element.
   *
   * Calling `media.play()` will resume playing audio/video from the moment it paused.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isPaused = true;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to play" written in black on a gray background. The beat plays or pauses when the user clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different instructions based on playback.
   *   if (isPaused === true) {
   *     text('Click to play', 50, 50);
   *   } else {
   *     text('Click to pause', 50, 50);
   *   }
   * }
   *
   * // Adjust playback when the user presses the mouse.
   * function mousePressed() {
   *   if (isPaused === true) {
   *     // If the beat is paused,
   *     // play it.
   *     beat.play();
   *     isPaused = false;
   *   } else {
   *     // If the beat is playing,
   *     // pause it.
   *     beat.pause();
   *     isPaused = true;
   *   }
   * }
   * </code>
   * </div>
   */
  pause() {
    this.elt.pause();
    return this;
  }
  /**
   * Plays the audio/video repeatedly in a loop.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isLooping = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to loop" written in black on a gray background. A beat plays repeatedly in a loop when the user clicks. The beat stops when the user clicks again.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different instructions based on playback.
   *   if (isLooping === true) {
   *     text('Click to stop', 50, 50);
   *   } else {
   *     text('Click to loop', 50, 50);
   *   }
   * }
   *
   * // Adjust playback when the user presses the mouse.
   * function mousePressed() {
   *   if (isLooping === true) {
   *     // If the beat is looping, stop it.
   *     beat.stop();
   *     isLooping = false;
   *   } else {
   *     // If the beat is stopped, loop it.
   *     beat.loop();
   *     isLooping = true;
   *   }
   * }
   * </code>
   * </div>
   */
  loop() {
    this.elt.setAttribute("loop", true);
    this.play();
    return this;
  }
  /**
   * Stops the audio/video from playing in a loop.
   *
   * The media will stop when it finishes playing.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isPlaying = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to play" written in black on a gray background. A beat plays when the user clicks. The beat stops when the user clicks again.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different instructions based on playback.
   *   if (isPlaying === true) {
   *     text('Click to stop', 50, 50);
   *   } else {
   *     text('Click to play', 50, 50);
   *   }
   * }
   *
   * // Adjust playback when the user presses the mouse.
   * function mousePressed() {
   *   if (isPlaying === true) {
   *     // If the beat is playing, stop it.
   *     beat.stop();
   *     isPlaying = false;
   *   } else {
   *     // If the beat is stopped, play it.
   *     beat.play();
   *     isPlaying = true;
   *   }
   * }
   * </code>
   * </div>
   */
  noLoop() {
    this.elt.removeAttribute("loop");
    return this;
  }
  /**
   * Sets up logic to check that autoplay succeeded.
   *
   * @private
   */
  _setupAutoplayFailDetection() {
    const timeout = setTimeout(() => {
      if (typeof IS_MINIFIED === "undefined") {
        p5._friendlyAutoplayError(this.src);
      } else {
        console.error(e);
      }
    }, 500);
    this.elt.addEventListener("play", () => clearTimeout(timeout), {
      passive: true,
      once: true
    });
  }
  /**
   * Sets the audio/video to play once it's loaded.
   *
   * The parameter, `shouldAutoplay`, is optional. Calling
   * `media.autoplay()` without an argument causes the media to play
   * automatically. If `true` is passed, as in `media.autoplay(true)`, the
   * media will automatically play. If `false` is passed, as in
   * `media.autoPlay(false)`, it won't play automatically.
   *
   * @param {Boolean} [shouldAutoplay] whether the element should autoplay.
   * @chainable
   *
   * @example
   * <div class='notest'>
   * <code>
   * let video;
   *
   * function setup() {
   *   noCanvas();
   *
   *   // Call handleVideo() once the video loads.
   *   video = createVideo('assets/fingers.mov', handleVideo);
   *
   *   describe('A video of fingers walking on a treadmill.');
   * }
   *
   * // Set the video's size and play it.
   * function handleVideo() {
   *   video.size(100, 100);
   *   video.autoplay();
   * }
   * </code>
   * </div>
   *
   * <div class='notest'>
   * <code>
   * function setup() {
   *   noCanvas();
   *
   *   // Load a video, but don't play it automatically.
   *   let video = createVideo('assets/fingers.mov', handleVideo);
   *
   *   // Play the video when the user clicks on it.
   *   video.mousePressed(handlePress);
   *
   *   describe('An image of fingers on a treadmill. They start walking when the user double-clicks on them.');
   * }
   * </code>
   * </div>
   *
   * // Set the video's size and playback mode.
   * function handleVideo() {
   *   video.size(100, 100);
   *   video.autoplay(false);
   * }
   *
   * // Play the video.
   * function handleClick() {
   *   video.play();
   * }
   */
  autoplay(val) {
    const oldVal = this.elt.getAttribute("autoplay");
    this.elt.setAttribute("autoplay", val);
    if (val && !oldVal) {
      const setupAutoplayFailDetection = () => this._setupAutoplayFailDetection();
      if (this.elt.readyState === 4) {
        setupAutoplayFailDetection();
      } else {
        this.elt.addEventListener("canplay", setupAutoplayFailDetection, {
          passive: true,
          once: true
        });
      }
    }
    return this;
  }
  /**
   * Sets the audio/video volume.
   *
   * Calling `media.volume()` without an argument returns the current volume
   * as a number in the range 0 (off) to 1 (maximum).
   *
   * The parameter, `val`, is optional. It's a number that sets the volume
   * from 0 (off) to 1 (maximum). For example, calling `media.volume(0.5)`
   * sets the volume to half of its maximum.
   *
   * @return {Number} current volume.
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "Volume: V" on a gray square with media controls beneath it. The number "V" oscillates between 0 and 1 as the music plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Produce a number between 0 and 1.
   *   let n = 0.5 * sin(frameCount * 0.01) + 0.5;
   *
   *   // Use n to set the volume.
   *   dragon.volume(n);
   *
   *   // Get the current volume and display it.
   *   let v = dragon.volume();
   *
   *   // Round v to 1 decimal place for display.
   *   v = round(v, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the volume.
   *   text(`Volume: ${v}`, 50, 50);
   * }
   * </code>
   * </div>
   */
  /**
   * @param {Number}            val volume between 0.0 and 1.0.
   * @chainable
   */
  volume(val) {
    if (typeof val === "undefined") {
      return this.elt.volume;
    } else {
      this.elt.volume = val;
    }
  }
  /**
   * Sets the audio/video playback speed.
   *
   * The parameter, `val`, is optional. It's a number that sets the playback
   * speed. 1 plays the media at normal speed, 0.5 plays it at half speed, 2
   * plays it at double speed, and so on. -1 plays the media at normal speed
   * in reverse.
   *
   * Calling `media.speed()` returns the current speed as a number.
   *
   * Note: Not all browsers support backward playback. Even if they do,
   * playback might not be smooth.
   *
   * @return {Number} current playback speed.
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "Speed: S" on a gray square with media controls beneath it. The number "S" oscillates between 0 and 1 as the music plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Produce a number between 0 and 2.
   *   let n = sin(frameCount * 0.01) + 1;
   *
   *   // Use n to set the playback speed.
   *   dragon.speed(n);
   *
   *   // Get the current speed and display it.
   *   let s = dragon.speed();
   *
   *   // Round s to 1 decimal place for display.
   *   s = round(s, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the speed.
   *   text(`Speed: ${s}`, 50, 50);
   * }
   * </code>
   */
  /**
   * @param {Number} speed  speed multiplier for playback.
   * @chainable
   */
  speed(val) {
    if (typeof val === "undefined") {
      return this.presetPlaybackRate || this.elt.playbackRate;
    } else {
      if (this.loadedmetadata) {
        this.elt.playbackRate = val;
      } else {
        this.presetPlaybackRate = val;
      }
    }
  }
  /**
   * Sets the media element's playback time.
   *
   * The parameter, `time`, is optional. It's a number that specifies the
   * time, in seconds, to jump to when playback begins.
   *
   * Calling `media.time()` without an argument returns the number of seconds
   * the audio/video has played.
   *
   * Note: Time resets to 0 when looping media restarts.
   *
   * @param {Number} [time] time to jump to (in seconds).
   * @return {Number} current time (in seconds).
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "S seconds" on a gray square with media controls beneath it. The number "S" increases as the song plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Get the current playback time.
   *   let s = dragon.time();
   *
   *   // Round s to 1 decimal place for display.
   *   s = round(s, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the playback time.
   *   text(`${s} seconds`, 50, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   // Jump to 2 seconds to start.
   *   dragon.time(2);
   *
   *   describe('The text "S seconds" on a gray square with media controls beneath it. The number "S" increases as the song plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Get the current playback time.
   *   let s = dragon.time();
   *
   *   // Round s to 1 decimal place for display.
   *   s = round(s, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the playback time.
   *   text(`${s} seconds`, 50, 50);
   * }
   * </code>
   * </div>
   */
  time(val) {
    if (typeof val !== "undefined") {
      this.elt.currentTime = val;
    }
    return this.elt.currentTime;
  }
  /**
   * Returns the audio/video's duration in seconds.
   *
   * @return {Number} duration (in seconds).
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "S seconds left" on a gray square with media controls beneath it. The number "S" decreases as the song plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the time remaining.
   *   let s = dragon.duration() - dragon.time();
   *
   *   // Round s to 1 decimal place for display.
   *   s = round(s, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the time remaining.
   *   text(`${s} seconds left`, 50, 50);
   * }
   * </code>
   * </div>
   */
  duration() {
    return this.elt.duration;
  }
  _ensureCanvas() {
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
      this.drawingContext = this.canvas.getContext("2d");
      this.setModified(true);
    }
    const needsRedraw = this._frameOnCanvas !== this._pInst.frameCount;
    if (this.loadedmetadata && needsRedraw) {
      if (this.canvas.width !== this.elt.width) {
        this.canvas.width = this.elt.width;
        this.canvas.height = this.elt.height;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
      }
      this.drawingContext.clearRect(
        0,
        0,
        this.canvas.width,
        this.canvas.height
      );
      if (this.flipped === true) {
        this.drawingContext.save();
        this.drawingContext.scale(-1, 1);
        this.drawingContext.translate(-this.canvas.width, 0);
      }
      this.drawingContext.drawImage(
        this.elt,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      );
      if (this.flipped === true) {
        this.drawingContext.restore();
      }
      this.setModified(true);
      this._frameOnCanvas = this._pInst.frameCount;
    }
  }
  loadPixels(...args) {
    this._ensureCanvas();
    return p5.Renderer2D.prototype.loadPixels.apply(this, args);
  }
  updatePixels(x, y, w, h) {
    if (this.loadedmetadata) {
      this._ensureCanvas();
      p5.Renderer2D.prototype.updatePixels.call(this, x, y, w, h);
    }
    this.setModified(true);
    return this;
  }
  get(...args) {
    this._ensureCanvas();
    return p5.Renderer2D.prototype.get.apply(this, args);
  }
  _getPixel(...args) {
    this.loadPixels();
    return p5.Renderer2D.prototype._getPixel.apply(this, args);
  }
  set(x, y, imgOrCol) {
    if (this.loadedmetadata) {
      this._ensureCanvas();
      p5.Renderer2D.prototype.set.call(this, x, y, imgOrCol);
      this.setModified(true);
    }
  }
  copy(...args) {
    this._ensureCanvas();
    p5.prototype.copy.apply(this, args);
  }
  mask(...args) {
    this.loadPixels();
    this.setModified(true);
    p5.Image.prototype.mask.apply(this, args);
  }
  /**
   * helper method for web GL mode to figure out if the element
   * has been modified and might need to be re-uploaded to texture
   * memory between frames.
   * @private
   * @return {boolean} a boolean indicating whether or not the
   * image has been updated or modified since last texture upload.
   */
  isModified() {
    return this._modified;
  }
  /**
   * helper method for web GL mode to indicate that an element has been
   * changed or unchanged since last upload. gl texture upload will
   * set this value to false after uploading the texture; or might set
   * it to true if metadata has become available but there is no actual
   * texture data available yet..
   * @param {Boolean} val sets whether or not the element has been
   * modified.
   * @private
   */
  setModified(value) {
    this._modified = value;
  }
  /**
   * Calls a function when the audio/video reaches the end of its playback.
   *
   * The element is passed as an argument to the callback function.
   *
   * Note: The function won't be called if the media is looping.
   *
   * @param  {Function} callback function to call when playback ends.
   *                             The `p5.MediaElement` is passed as
   *                             the argument.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isPlaying = false;
   * let isDone = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   // Call handleEnd() when the beat finishes.
   *   beat.onended(handleEnd);
   *
   *   describe('The text "Click to play" written in black on a gray square. A beat plays when the user clicks. The text "Done!" appears when the beat finishes playing.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different messages based on playback.
   *   if (isDone === true) {
   *     text('Done!', 50, 50);
   *   } else if (isPlaying === false) {
   *     text('Click to play', 50, 50);
   *   } else {
   *     text('Playing...', 50, 50);
   *   }
   * }
   *
   * // Play the beat when the user presses the mouse.
   * function mousePressed() {
   *   if (isPlaying === false) {
   *     isPlaying = true;
   *     beat.play();
   *   }
   * }
   *
   * // Set isDone when playback ends.
   * function handleEnd() {
   *   isDone = false;
   * }
   * </code>
   * </div>
   */
  onended(callback) {
    this._onended = callback;
    return this;
  }
  /*** CONNECT TO WEB AUDIO API / p5.sound.js ***/
  _getAudioContext() {
    return void 0;
  }
  _getSoundOut() {
    return void 0;
  }
  /**
   * Sends the element's audio to an output.
   *
   * The parameter, `audioNode`, can be an `AudioNode` or an object from the
   * `p5.sound` library.
   *
   * If no element is provided, as in `myElement.connect()`, the element
   * connects to the main output. All connections are removed by the
   * `.disconnect()` method.
   *
   * Note: This method is meant to be used with the p5.sound.js addon library.
   *
   * @param  {AudioNode|Object} audioNode AudioNode from the Web Audio API,
   * or an object from the p5.sound library
   */
  connect(obj) {
    let audioContext, mainOutput;
    if (this._getAudioContext() && this._getSoundOut()) {
      audioContext = this._getAudioContext();
      mainOutput = this._getSoundOut().input;
    } else {
      try {
        audioContext = obj.context;
        mainOutput = audioContext.destination;
      } catch (e2) {
        throw "connect() is meant to be used with Web Audio API or p5.sound.js";
      }
    }
    if (!this.audioSourceNode) {
      this.audioSourceNode = audioContext.createMediaElementSource(this.elt);
      this.audioSourceNode.connect(mainOutput);
    }
    if (obj) {
      if (obj.input) {
        this.audioSourceNode.connect(obj.input);
      } else {
        this.audioSourceNode.connect(obj);
      }
    } else {
      this.audioSourceNode.connect(mainOutput);
    }
  }
  /**
   * Disconnect all Web Audio routing, including to the main output.
   *
   * This is useful if you want to re-route the output through audio effects,
   * for example.
   *
   */
  disconnect() {
    if (this.audioSourceNode) {
      this.audioSourceNode.disconnect();
    } else {
      throw "nothing to disconnect";
    }
  }
  /*** SHOW / HIDE CONTROLS ***/
  /**
   * Show the default
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement" target="_blank">HTMLMediaElement</a>
   * controls.
   *
   * Note: The controls vary between web browsers.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background('cornflowerblue');
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(50);
   *
   *   // Display a dragon.
   *   text('🐉', 50, 50);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   let dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('A dragon emoji, 🐉, drawn in the center of a blue square. A song plays in the background. Audio controls are displayed beneath the canvas.');
   * }
   * </code>
   * </div>
   */
  showControls() {
    this.elt.style["text-align"] = "inherit";
    this.elt.controls = true;
  }
  /**
   * Hide the default
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement" target="_blank">HTMLMediaElement</a>
   * controls.
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   * let isHidden = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "Double-click to hide controls" written in the middle of a gray square. A song plays in the background. Audio controls are displayed beneath the canvas. The controls appear/disappear when the user double-clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *
   *   // Display a different message when controls are hidden or shown.
   *   if (isHidden === true) {
   *     text('Double-click to show controls', 10, 20, 80, 80);
   *   } else {
   *     text('Double-click to hide controls', 10, 20, 80, 80);
   *   }
   * }
   *
   * // Show/hide controls based on a double-click.
   * function doubleClicked() {
   *   if (isHidden === true) {
   *     dragon.showControls();
   *     isHidden = false;
   *   } else {
   *     dragon.hideControls();
   *     isHidden = true;
   *   }
   * }
   * </code>
   * </div>
   */
  hideControls() {
    this.elt.controls = false;
  }
  /**
   * Schedules a function to call when the audio/video reaches a specific time
   * during its playback.
   *
   * The first parameter, `time`, is the time, in seconds, when the function
   * should run. This value is passed to `callback` as its first argument.
   *
   * The second parameter, `callback`, is the function to call at the specified
   * cue time.
   *
   * The third parameter, `value`, is optional and can be any type of value.
   * `value` is passed to `callback`.
   *
   * Calling `media.addCue()` returns an ID as a string. This is useful for
   * removing the cue later.
   *
   * @param {Number}   time     cue time to run the callback function.
   * @param {Function} callback function to call at the cue time.
   * @param {Object} [value]    object to pass as the argument to
   *                            `callback`.
   * @return {Number} id ID of this cue,
   *                     useful for `media.removeCue(id)`.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   let beat = createAudio('assets/beat.mp3');
   *
   *   // Play the beat in a loop.
   *   beat.loop();
   *
   *   // Schedule a few events.
   *   beat.addCue(0, changeBackground, 'red');
   *   beat.addCue(2, changeBackground, 'deeppink');
   *   beat.addCue(4, changeBackground, 'orchid');
   *   beat.addCue(6, changeBackground, 'lavender');
   *
   *   describe('A red square with a beat playing in the background. Its color changes every 2 seconds while the audio plays.');
   * }
   *
   * // Change the background color.
   * function changeBackground(c) {
   *   background(c);
   * }
   * </code>
   * </div>
   */
  addCue(time2, callback, val) {
    const id = this._cueIDCounter++;
    const cue = new Cue(callback, time2, id, val);
    this._cues.push(cue);
    if (!this.elt.ontimeupdate) {
      this.elt.ontimeupdate = this._onTimeUpdate.bind(this);
    }
    return id;
  }
  /**
   * Removes a callback based on its ID.
   *
   * @param  {Number} id ID of the cue, created by `media.addCue()`.
   *
   * @example
   * <div>
   * <code>
   * let lavenderID;
   * let isRemoved = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   let beat = createAudio('assets/beat.mp3');
   *
   *   // Play the beat in a loop.
   *   beat.loop();
   *
   *   // Schedule a few events.
   *   beat.addCue(0, changeBackground, 'red');
   *   beat.addCue(2, changeBackground, 'deeppink');
   *   beat.addCue(4, changeBackground, 'orchid');
   *
   *   // Record the ID of the "lavender" callback.
   *   lavenderID = beat.addCue(6, changeBackground, 'lavender');
   *
   *   describe('The text "Double-click to remove lavender." written on a red square. The color changes every 2 seconds while the audio plays. The lavender option is removed when the user double-clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Display different instructions based on the available callbacks.
   *   if (isRemoved === false) {
   *     text('Double-click to remove lavender.', 10, 10, 80, 80);
   *   } else {
   *     text('No more lavender.', 10, 10, 80, 80);
   *   }
   * }
   *
   * // Change the background color.
   * function changeBackground(c) {
   *   background(c);
   * }
   *
   * // Remove the lavender color-change cue when the user double-clicks.
   * function doubleClicked() {
   *   if (isRemoved === false) {
   *     beat.removeCue(lavenderID);
   *     isRemoved = true;
   *   }
   * }
   * </code>
   * </div>
   */
  removeCue(id) {
    for (let i = 0; i < this._cues.length; i++) {
      if (this._cues[i].id === id) {
        console.log(id);
        this._cues.splice(i, 1);
      }
    }
    if (this._cues.length === 0) {
      this.elt.ontimeupdate = null;
    }
  }
  /**
   * Removes all functions scheduled with `media.addCue()`.
   *
   * @example
   * <div>
   * <code>
   * let isChanging = true;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   let beat = createAudio('assets/beat.mp3');
   *
   *   // Play the beat in a loop.
   *   beat.loop();
   *
   *   // Schedule a few events.
   *   beat.addCue(0, changeBackground, 'red');
   *   beat.addCue(2, changeBackground, 'deeppink');
   *   beat.addCue(4, changeBackground, 'orchid');
   *   beat.addCue(6, changeBackground, 'lavender');
   *
   *   describe('The text "Double-click to stop changing." written on a square. The color changes every 2 seconds while the audio plays. The color stops changing when the user double-clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Display different instructions based on the available callbacks.
   *   if (isChanging === true) {
   *     text('Double-click to stop changing.', 10, 10, 80, 80);
   *   } else {
   *     text('No more changes.', 10, 10, 80, 80);
   *   }
   * }
   *
   * // Change the background color.
   * function changeBackground(c) {
   *   background(c);
   * }
   *
   * // Remove cued functions and stop changing colors when the user
   * // double-clicks.
   * function doubleClicked() {
   *   if (isChanging === true) {
   *     beat.clearCues();
   *     isChanging = false;
   *   }
   * }
   * </code>
   * </div>
   */
  clearCues() {
    this._cues = [];
    this.elt.ontimeupdate = null;
  }
  // private method that checks for cues to be fired if events
  // have been scheduled using addCue(callback, time).
  _onTimeUpdate() {
    const playbackTime = this.time();
    for (let i = 0; i < this._cues.length; i++) {
      const callbackTime = this._cues[i].time;
      const val = this._cues[i].val;
      if (this._prevTime < callbackTime && callbackTime <= playbackTime) {
        this._cues[i].callback(val);
      }
    }
    this._prevTime = playbackTime;
  }
}
function media(p53, fn2) {
  function addElement(elt, pInst, media2) {
    const node = pInst._userNode ? pInst._userNode : document.body;
    node.appendChild(elt);
    const c = media2 ? new MediaElement(elt, pInst) : new Element(elt, pInst);
    pInst._elements.push(c);
    return c;
  }
  function createMedia(pInst, type2, src, callback) {
    const elt = document.createElement(type2);
    src = src || "";
    if (typeof src === "string") {
      src = [src];
    }
    for (const mediaSource of src) {
      const sourceEl = document.createElement("source");
      sourceEl.setAttribute("src", mediaSource);
      elt.appendChild(sourceEl);
    }
    const mediaEl = addElement(elt, pInst, true);
    mediaEl.loadedmetadata = false;
    elt.addEventListener("loadedmetadata", () => {
      mediaEl.width = elt.videoWidth;
      mediaEl.height = elt.videoHeight;
      if (mediaEl.elt.width === 0) mediaEl.elt.width = elt.videoWidth;
      if (mediaEl.elt.height === 0) mediaEl.elt.height = elt.videoHeight;
      if (mediaEl.presetPlaybackRate) {
        mediaEl.elt.playbackRate = mediaEl.presetPlaybackRate;
        delete mediaEl.presetPlaybackRate;
      }
      mediaEl.loadedmetadata = true;
    });
    if (typeof callback === "function") {
      const callbackHandler = () => {
        callback(mediaEl);
        elt.removeEventListener("canplaythrough", callbackHandler);
      };
      elt.addEventListener("canplaythrough", callbackHandler);
    }
    return mediaEl;
  }
  fn2.createVideo = function(src, callback) {
    return createMedia(this, VIDEO, src, callback);
  };
  fn2.createAudio = function(src, callback) {
    return createMedia(this, AUDIO, src, callback);
  };
  fn2.VIDEO = VIDEO;
  fn2.AUDIO = AUDIO;
  if (navigator.mediaDevices === void 0) {
    navigator.mediaDevices = {};
  }
  if (navigator.mediaDevices.getUserMedia === void 0) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      if (!getUserMedia) {
        return Promise.reject(
          new Error("getUserMedia is not implemented in this browser")
        );
      }
      return new Promise(function(resolve, reject) {
        getUserMedia.call(navigator, constraints, resolve, reject);
      });
    };
  }
  fn2.createCapture = function(...args) {
    if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) {
      throw new DOMException("getUserMedia not supported in this browser");
    }
    let useVideo = true;
    let useAudio = true;
    let constraints;
    let callback;
    let flipped = false;
    for (const arg of args) {
      if (arg === fn2.VIDEO) useAudio = false;
      else if (arg === fn2.AUDIO) useVideo = false;
      else if (typeof arg === "object") {
        if (arg.flipped !== void 0) {
          flipped = arg.flipped;
          delete arg.flipped;
        }
        constraints = Object.assign({}, constraints, arg);
      } else if (typeof arg === "function") {
        callback = arg;
      }
    }
    const videoConstraints = { video: useVideo, audio: useAudio };
    constraints = Object.assign({}, videoConstraints, constraints);
    const domElement = document.createElement(VIDEO);
    domElement.setAttribute("playsinline", "");
    navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
      try {
        if ("srcObject" in domElement) {
          domElement.srcObject = stream;
        } else {
          domElement.src = window.URL.createObjectURL(stream);
        }
      } catch (err) {
        domElement.src = stream;
      }
    }).catch((e2) => {
      if (e2.name === "NotFoundError")
        p53._friendlyError("No webcam found on this device", "createCapture");
      if (e2.name === "NotAllowedError")
        p53._friendlyError("Access to the camera was denied", "createCapture");
      console.error(e2);
    });
    const videoEl = addElement(domElement, this, true);
    videoEl.loadedmetadata = false;
    domElement.addEventListener("loadedmetadata", function() {
      domElement.play();
      if (domElement.width) {
        videoEl.width = domElement.width;
        videoEl.height = domElement.height;
        if (flipped) {
          videoEl.elt.style.transform = "scaleX(-1)";
        }
      } else {
        videoEl.width = videoEl.elt.width = domElement.videoWidth;
        videoEl.height = videoEl.elt.height = domElement.videoHeight;
      }
      videoEl.loadedmetadata = true;
      if (callback) callback(domElement.srcObject);
    });
    videoEl.flipped = flipped;
    return videoEl;
  };
  p53.MediaElement = MediaElement;
  MediaElement.prototype._getSoundOut = function() {
    return p53.soundOut;
  };
  MediaElement.prototype._getAudioContext = function() {
    if (typeof fn2.getAudioContext === "function") {
      return fn2.getAudioContext();
    } else {
      return void 0;
    }
  };
}
if (typeof p5 !== "undefined") {
  media(p5, p5.prototype);
}
function modeAdjust(a, b2, c, d2, mode) {
  let bbox;
  if (mode === CORNER) {
    bbox = {
      x: a,
      y: b2,
      w: Math.abs(c),
      h: Math.abs(d2)
    };
  } else if (mode === CORNERS) {
    bbox = {
      x: Math.min(a, c),
      y: Math.min(b2, d2),
      w: Math.abs(c - a),
      h: Math.abs(d2 - b2)
    };
  } else if (mode === RADIUS) {
    c = Math.abs(c);
    d2 = Math.abs(d2);
    bbox = {
      x: a - c,
      y: b2 - d2,
      w: 2 * c,
      h: 2 * d2
    };
  } else if (mode === CENTER) {
    c = Math.abs(c);
    d2 = Math.abs(d2);
    bbox = {
      x: a - c * 0.5,
      y: b2 - d2 * 0.5,
      w: c,
      h: d2
    };
  }
  return bbox;
}
var canvas = { modeAdjust };
function primitives(p53, fn2) {
  fn2._normalizeArcAngles = (start2, stop, width, height, correctForScaling) => {
    const epsilon = 1e-5;
    let separation;
    start2 = start2 - TWO_PI * Math.floor(start2 / TWO_PI);
    stop = stop - TWO_PI * Math.floor(stop / TWO_PI);
    separation = Math.min(
      Math.abs(start2 - stop),
      TWO_PI - Math.abs(start2 - stop)
    );
    if (correctForScaling) {
      if (start2 <= HALF_PI) {
        start2 = Math.atan(width / height * Math.tan(start2));
      } else if (start2 > HALF_PI && start2 <= 3 * HALF_PI) {
        start2 = Math.atan(width / height * Math.tan(start2)) + PI;
      } else {
        start2 = Math.atan(width / height * Math.tan(start2)) + TWO_PI;
      }
      if (stop <= HALF_PI) {
        stop = Math.atan(width / height * Math.tan(stop));
      } else if (stop > HALF_PI && stop <= 3 * HALF_PI) {
        stop = Math.atan(width / height * Math.tan(stop)) + PI;
      } else {
        stop = Math.atan(width / height * Math.tan(stop)) + TWO_PI;
      }
    }
    if (start2 > stop) {
      stop += TWO_PI;
    }
    return {
      start: start2,
      stop,
      correspondToSamePoint: separation < epsilon
    };
  };
  fn2.arc = function(x, y, w, h, start2, stop, mode, detail) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    if (start2 === stop) {
      return this;
    }
    start2 = this._toRadians(start2);
    stop = this._toRadians(stop);
    const vals = canvas.modeAdjust(
      x,
      y,
      w,
      h,
      this._renderer.states.ellipseMode
    );
    const angles = this._normalizeArcAngles(start2, stop, vals.w, vals.h, true);
    if (angles.correspondToSamePoint) {
      this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detail]);
    } else {
      this._renderer.arc(
        vals.x,
        vals.y,
        vals.w,
        vals.h,
        angles.start,
        // [0, TWO_PI)
        angles.stop,
        // [start, start + TWO_PI)
        mode,
        detail
      );
      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
        this._accsOutput("arc", [
          vals.x,
          vals.y,
          vals.w,
          vals.h,
          angles.start,
          angles.stop,
          mode
        ]);
      }
    }
    return this;
  };
  fn2.ellipse = function(x, y, w, h, detailX) {
    return this._renderEllipse(...arguments);
  };
  fn2.circle = function(...args) {
    const argss = args.slice(0, 2);
    argss.push(args[2], args[2]);
    return this._renderEllipse(...argss);
  };
  fn2._renderEllipse = function(x, y, w, h, detailX) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    if (typeof h === "undefined") {
      h = w;
    }
    const vals = canvas.modeAdjust(
      x,
      y,
      w,
      h,
      this._renderer.states.ellipseMode
    );
    this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detailX]);
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("ellipse", [vals.x, vals.y, vals.w, vals.h]);
    }
    return this;
  };
  fn2.line = function(...args) {
    if (this._renderer.states.strokeColor) {
      this._renderer.line(...args);
    }
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("line", args);
    }
    return this;
  };
  fn2.point = function(...args) {
    if (this._renderer.states.strokeColor) {
      if (args.length === 1 && args[0] instanceof p53.Vector) {
        this._renderer.point.call(
          this._renderer,
          args[0].x,
          args[0].y,
          args[0].z
        );
      } else {
        this._renderer.point(...args);
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._accsOutput("point", args);
        }
      }
    }
    return this;
  };
  fn2.quad = function(...args) {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      if (this._renderer.isP3D && args.length < 12) {
        this._renderer.quad.call(
          this._renderer,
          args[0],
          args[1],
          0,
          args[2],
          args[3],
          0,
          args[4],
          args[5],
          0,
          args[6],
          args[7],
          0,
          args[8],
          args[9]
        );
      } else {
        this._renderer.quad(...args);
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._accsOutput("quadrilateral", args);
        }
      }
    }
    return this;
  };
  fn2.rect = function(...args) {
    return this._renderRect(...args);
  };
  fn2.square = function(x, y, s, tl, tr, br, bl) {
    return this._renderRect.call(this, x, y, s, s, tl, tr, br, bl);
  };
  fn2._renderRect = function() {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      if (arguments.length === 3) {
        arguments[3] = arguments[2];
      }
      const vals = canvas.modeAdjust(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[3],
        this._renderer.states.rectMode
      );
      if (this._renderer.states.rectMode === CORNER) {
        vals.w = arguments[2];
        vals.h = arguments[3];
      }
      const args = [vals.x, vals.y, vals.w, vals.h];
      for (let i = 4; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      this._renderer.rect(args);
      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
        this._accsOutput("rectangle", [vals.x, vals.y, vals.w, vals.h]);
      }
    }
    return this;
  };
  fn2.triangle = function(...args) {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      this._renderer.triangle(args);
    }
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("triangle", args);
    }
    return this;
  };
}
if (typeof p5 !== "undefined") {
  primitives(p5, p5.prototype);
}
function attributes(p53, fn2) {
  fn2.ellipseMode = function(m) {
    if (m === CORNER || m === CORNERS || m === RADIUS || m === CENTER) {
      this._renderer.states.setValue("ellipseMode", m);
    }
    return this;
  };
  fn2.noSmooth = function() {
    if (!this._renderer.isP3D) {
      if ("imageSmoothingEnabled" in this.drawingContext) {
        this.drawingContext.imageSmoothingEnabled = false;
      }
    } else {
      this.setAttributes("antialias", false);
    }
    return this;
  };
  fn2.rectMode = function(m) {
    if (m === CORNER || m === CORNERS || m === RADIUS || m === CENTER) {
      this._renderer.states.setValue("rectMode", m);
    }
    return this;
  };
  fn2.smooth = function() {
    if (!this._renderer.isP3D) {
      if ("imageSmoothingEnabled" in this.drawingContext) {
        this.drawingContext.imageSmoothingEnabled = true;
      }
    } else {
      this.setAttributes("antialias", true);
    }
    return this;
  };
  fn2.strokeCap = function(cap) {
    if (cap === ROUND || cap === SQUARE || cap === PROJECT) {
      this._renderer.strokeCap(cap);
    }
    return this;
  };
  fn2.strokeJoin = function(join) {
    if (join === ROUND || join === BEVEL || join === MITER) {
      this._renderer.strokeJoin(join);
    }
    return this;
  };
  fn2.strokeWeight = function(w) {
    this._renderer.strokeWeight(w);
    return this;
  };
}
if (typeof p5 !== "undefined") {
  attributes(p5, p5.prototype);
}
function curves(p53, fn2) {
  fn2.bezier = function(...args) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    this._renderer.bezier(...args);
    return this;
  };
  fn2.bezierPoint = function(a, b2, c, d2, t) {
    const adjustedT = 1 - t;
    return Math.pow(adjustedT, 3) * a + 3 * Math.pow(adjustedT, 2) * t * b2 + 3 * adjustedT * Math.pow(t, 2) * c + Math.pow(t, 3) * d2;
  };
  fn2.bezierTangent = function(a, b2, c, d2, t) {
    const adjustedT = 1 - t;
    return 3 * d2 * Math.pow(t, 2) - 3 * c * Math.pow(t, 2) + 6 * c * adjustedT * t - 6 * b2 * adjustedT * t + 3 * b2 * Math.pow(adjustedT, 2) - 3 * a * Math.pow(adjustedT, 2);
  };
  fn2.spline = function(...args) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    this._renderer.spline(...args);
    return this;
  };
  fn2.splinePoint = function(a, b2, c, d2, t) {
    const s = this._renderer.states.splineProperties.tightness, t3 = t * t * t, t2 = t * t, f1 = (s - 1) / 2 * t3 + (1 - s) * t2 + (s - 1) / 2 * t, f2 = (s + 3) / 2 * t3 + (-5 - s) / 2 * t2 + 1, f3 = (-3 - s) / 2 * t3 + (s + 2) * t2 + (1 - s) / 2 * t, f4 = (1 - s) / 2 * t3 + (s - 1) / 2 * t2;
    return a * f1 + b2 * f2 + c * f3 + d2 * f4;
  };
  fn2.splineTangent = function(a, b2, c, d2, t) {
    const s = this._renderer.states.splineProperties.tightness, tt3 = t * t * 3, t2 = t * 2, f1 = (s - 1) / 2 * tt3 + (1 - s) * t2 + (s - 1) / 2, f2 = (s + 3) / 2 * tt3 + (-5 - s) / 2 * t2, f3 = (-3 - s) / 2 * tt3 + (s + 2) * t2 + (1 - s) / 2, f4 = (1 - s) / 2 * tt3 + (s - 1) / 2 * t2;
    return a * f1 + b2 * f2 + c * f3 + d2 * f4;
  };
}
if (typeof p5 !== "undefined") {
  curves(p5, p5.prototype);
}
function vertex(p53, fn2) {
  fn2.beginShape = function(kind) {
    this._renderer.beginShape(...arguments);
  };
  fn2.bezierVertex = function(...args) {
    this._renderer.bezierVertex(...args);
  };
  fn2.endShape = function(mode, count = 1) {
    if (count < 1) {
      console.log("🌸 p5.js says: You can not have less than one instance");
      count = 1;
    }
    this._renderer.endShape(mode, count);
  };
  fn2.normal = function(x, y, z) {
    this._assert3d("normal");
    this._renderer.normal(...arguments);
    return this;
  };
  fn2.vertexProperty = function(attributeName, data2) {
    this._renderer.vertexProperty(attributeName, data2);
  };
}
if (typeof p5 !== "undefined") {
  vertex(p5, p5.prototype);
}
function setting(p53, fn2) {
  fn2.beginClip = function(options2 = {}) {
    this._renderer.beginClip(options2);
  };
  fn2.endClip = function() {
    this._renderer.endClip();
  };
  fn2.clip = function(callback, options2) {
    this._renderer.beginClip(options2);
    callback();
    this._renderer.endClip(options2);
  };
  fn2.background = function(...args) {
    this._renderer.background(...args);
    return this;
  };
  fn2.clear = function(...args) {
    const _r = args[0] || 0;
    const _g = args[1] || 0;
    const _b = args[2] || 0;
    const _a = args[3] || 0;
    this._renderer.clear(_r, _g, _b, _a);
    return this;
  };
  fn2.colorMode = function(mode, max1, max2, max3, maxA) {
    if ([
      RGB,
      RGBHDR,
      HSB,
      HSL,
      HWB,
      LAB,
      LCH,
      OKLAB,
      OKLCH
    ].includes(mode)) {
      this._renderer.states.setValue("colorMode", mode);
      this._renderer.states.setValue("colorMaxes", this._renderer.states.colorMaxes.clone());
      const maxes = this._renderer.states.colorMaxes[mode];
      if (arguments.length === 2) {
        maxes[0] = max1;
        maxes[1] = max1;
        maxes[2] = max1;
        maxes[3] = max1;
      } else if (arguments.length === 4) {
        maxes[0] = max1;
        maxes[1] = max2;
        maxes[2] = max3;
      } else if (arguments.length === 5) {
        maxes[0] = max1;
        maxes[1] = max2;
        maxes[2] = max3;
        maxes[3] = maxA;
      }
    }
    return this._renderer.states.colorMode;
  };
  fn2.fill = function(...args) {
    this._renderer.fill(...args);
    return this;
  };
  fn2.noFill = function() {
    this._renderer.noFill();
    return this;
  };
  fn2.noStroke = function() {
    this._renderer.states.setValue("strokeColor", null);
    return this;
  };
  fn2.stroke = function(...args) {
    this._renderer.stroke(...args);
    return this;
  };
  fn2.erase = function(opacityFill = 255, opacityStroke = 255) {
    this._renderer.erase(opacityFill, opacityStroke);
    return this;
  };
  fn2.noErase = function() {
    this._renderer.noErase();
    return this;
  };
  fn2.blendMode = function(mode) {
    if (mode === NORMAL) {
      console.warn(
        "NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead."
      );
      mode = BLEND;
    }
    this._renderer.blendMode(mode);
  };
}
if (typeof p5 !== "undefined") {
  setting(p5, p5.prototype);
}
var omggif$1 = {};
var hasRequiredOmggif;
function requireOmggif() {
  if (hasRequiredOmggif) return omggif$1;
  hasRequiredOmggif = 1;
  function GifWriter(buf, width, height, gopts) {
    var p2 = 0;
    var gopts = gopts === void 0 ? {} : gopts;
    var loop_count = gopts.loop === void 0 ? null : gopts.loop;
    var global_palette = gopts.palette === void 0 ? null : gopts.palette;
    if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
      throw new Error("Width/Height invalid.");
    function check_palette_and_num_colors(palette) {
      var num_colors = palette.length;
      if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
        throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256."
        );
      }
      return num_colors;
    }
    buf[p2++] = 71;
    buf[p2++] = 73;
    buf[p2++] = 70;
    buf[p2++] = 56;
    buf[p2++] = 57;
    buf[p2++] = 97;
    var gp_num_colors_pow2 = 0;
    var background = 0;
    if (global_palette !== null) {
      var gp_num_colors = check_palette_and_num_colors(global_palette);
      while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
      gp_num_colors = 1 << gp_num_colors_pow2;
      --gp_num_colors_pow2;
      if (gopts.background !== void 0) {
        background = gopts.background;
        if (background >= gp_num_colors)
          throw new Error("Background index out of range.");
        if (background === 0)
          throw new Error("Background index explicitly passed as 0.");
      }
    }
    buf[p2++] = width & 255;
    buf[p2++] = width >> 8 & 255;
    buf[p2++] = height & 255;
    buf[p2++] = height >> 8 & 255;
    buf[p2++] = (global_palette !== null ? 128 : 0) | // Global Color Table Flag.
    gp_num_colors_pow2;
    buf[p2++] = background;
    buf[p2++] = 0;
    if (global_palette !== null) {
      for (var i = 0, il = global_palette.length; i < il; ++i) {
        var rgb = global_palette[i];
        buf[p2++] = rgb >> 16 & 255;
        buf[p2++] = rgb >> 8 & 255;
        buf[p2++] = rgb & 255;
      }
    }
    if (loop_count !== null) {
      if (loop_count < 0 || loop_count > 65535)
        throw new Error("Loop count invalid.");
      buf[p2++] = 33;
      buf[p2++] = 255;
      buf[p2++] = 11;
      buf[p2++] = 78;
      buf[p2++] = 69;
      buf[p2++] = 84;
      buf[p2++] = 83;
      buf[p2++] = 67;
      buf[p2++] = 65;
      buf[p2++] = 80;
      buf[p2++] = 69;
      buf[p2++] = 50;
      buf[p2++] = 46;
      buf[p2++] = 48;
      buf[p2++] = 3;
      buf[p2++] = 1;
      buf[p2++] = loop_count & 255;
      buf[p2++] = loop_count >> 8 & 255;
      buf[p2++] = 0;
    }
    var ended = false;
    this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
      if (ended === true) {
        --p2;
        ended = false;
      }
      opts = opts === void 0 ? {} : opts;
      if (x < 0 || y < 0 || x > 65535 || y > 65535)
        throw new Error("x/y invalid.");
      if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
        throw new Error("Width/Height invalid.");
      if (indexed_pixels.length < w * h)
        throw new Error("Not enough pixels for the frame size.");
      var using_local_palette = true;
      var palette = opts.palette;
      if (palette === void 0 || palette === null) {
        using_local_palette = false;
        palette = global_palette;
      }
      if (palette === void 0 || palette === null)
        throw new Error("Must supply either a local or global palette.");
      var num_colors = check_palette_and_num_colors(palette);
      var min_code_size = 0;
      while (num_colors >>= 1) ++min_code_size;
      num_colors = 1 << min_code_size;
      var delay = opts.delay === void 0 ? 0 : opts.delay;
      var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
      if (disposal < 0 || disposal > 3)
        throw new Error("Disposal out of range.");
      var use_transparency = false;
      var transparent_index = 0;
      if (opts.transparent !== void 0 && opts.transparent !== null) {
        use_transparency = true;
        transparent_index = opts.transparent;
        if (transparent_index < 0 || transparent_index >= num_colors)
          throw new Error("Transparent color index.");
      }
      if (disposal !== 0 || use_transparency || delay !== 0) {
        buf[p2++] = 33;
        buf[p2++] = 249;
        buf[p2++] = 4;
        buf[p2++] = disposal << 2 | (use_transparency === true ? 1 : 0);
        buf[p2++] = delay & 255;
        buf[p2++] = delay >> 8 & 255;
        buf[p2++] = transparent_index;
        buf[p2++] = 0;
      }
      buf[p2++] = 44;
      buf[p2++] = x & 255;
      buf[p2++] = x >> 8 & 255;
      buf[p2++] = y & 255;
      buf[p2++] = y >> 8 & 255;
      buf[p2++] = w & 255;
      buf[p2++] = w >> 8 & 255;
      buf[p2++] = h & 255;
      buf[p2++] = h >> 8 & 255;
      buf[p2++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
      if (using_local_palette === true) {
        for (var i2 = 0, il2 = palette.length; i2 < il2; ++i2) {
          var rgb2 = palette[i2];
          buf[p2++] = rgb2 >> 16 & 255;
          buf[p2++] = rgb2 >> 8 & 255;
          buf[p2++] = rgb2 & 255;
        }
      }
      p2 = GifWriterOutputLZWCodeStream(
        buf,
        p2,
        min_code_size < 2 ? 2 : min_code_size,
        indexed_pixels
      );
      return p2;
    };
    this.end = function() {
      if (ended === false) {
        buf[p2++] = 59;
        ended = true;
      }
      return p2;
    };
    this.getOutputBuffer = function() {
      return buf;
    };
    this.setOutputBuffer = function(v) {
      buf = v;
    };
    this.getOutputBufferPosition = function() {
      return p2;
    };
    this.setOutputBufferPosition = function(v) {
      p2 = v;
    };
  }
  function GifWriterOutputLZWCodeStream(buf, p2, min_code_size, index_stream) {
    buf[p2++] = min_code_size;
    var cur_subblock = p2++;
    var clear_code = 1 << min_code_size;
    var code_mask = clear_code - 1;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var cur_shift = 0;
    var cur = 0;
    function emit_bytes_to_buffer(bit_block_size) {
      while (cur_shift >= bit_block_size) {
        buf[p2++] = cur & 255;
        cur >>= 8;
        cur_shift -= 8;
        if (p2 === cur_subblock + 256) {
          buf[cur_subblock] = 255;
          cur_subblock = p2++;
        }
      }
    }
    function emit_code(c) {
      cur |= c << cur_shift;
      cur_shift += cur_code_size;
      emit_bytes_to_buffer(8);
    }
    var ib_code = index_stream[0] & code_mask;
    var code_table = {};
    emit_code(clear_code);
    for (var i = 1, il = index_stream.length; i < il; ++i) {
      var k = index_stream[i] & code_mask;
      var cur_key = ib_code << 8 | k;
      var cur_code = code_table[cur_key];
      if (cur_code === void 0) {
        cur |= ib_code << cur_shift;
        cur_shift += cur_code_size;
        while (cur_shift >= 8) {
          buf[p2++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p2 === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p2++;
          }
        }
        if (next_code === 4096) {
          emit_code(clear_code);
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_table = {};
        } else {
          if (next_code >= 1 << cur_code_size) ++cur_code_size;
          code_table[cur_key] = next_code++;
        }
        ib_code = k;
      } else {
        ib_code = cur_code;
      }
    }
    emit_code(ib_code);
    emit_code(eoi_code);
    emit_bytes_to_buffer(1);
    if (cur_subblock + 1 === p2) {
      buf[cur_subblock] = 0;
    } else {
      buf[cur_subblock] = p2 - cur_subblock - 1;
      buf[p2++] = 0;
    }
    return p2;
  }
  function GifReader(buf) {
    var p2 = 0;
    if (buf[p2++] !== 71 || buf[p2++] !== 73 || buf[p2++] !== 70 || buf[p2++] !== 56 || (buf[p2++] + 1 & 253) !== 56 || buf[p2++] !== 97) {
      throw new Error("Invalid GIF 87a/89a header.");
    }
    var width = buf[p2++] | buf[p2++] << 8;
    var height = buf[p2++] | buf[p2++] << 8;
    var pf0 = buf[p2++];
    var global_palette_flag = pf0 >> 7;
    var num_global_colors_pow2 = pf0 & 7;
    var num_global_colors = 1 << num_global_colors_pow2 + 1;
    buf[p2++];
    buf[p2++];
    var global_palette_offset = null;
    var global_palette_size = null;
    if (global_palette_flag) {
      global_palette_offset = p2;
      global_palette_size = num_global_colors;
      p2 += num_global_colors * 3;
    }
    var no_eof = true;
    var frames = [];
    var delay = 0;
    var transparent_index = null;
    var disposal = 0;
    var loop_count = null;
    this.width = width;
    this.height = height;
    while (no_eof && p2 < buf.length) {
      switch (buf[p2++]) {
        case 33:
          switch (buf[p2++]) {
            case 255:
              if (buf[p2] !== 11 || // 21 FF already read, check block size.
              // NETSCAPE2.0
              buf[p2 + 1] == 78 && buf[p2 + 2] == 69 && buf[p2 + 3] == 84 && buf[p2 + 4] == 83 && buf[p2 + 5] == 67 && buf[p2 + 6] == 65 && buf[p2 + 7] == 80 && buf[p2 + 8] == 69 && buf[p2 + 9] == 50 && buf[p2 + 10] == 46 && buf[p2 + 11] == 48 && // Sub-block
              buf[p2 + 12] == 3 && buf[p2 + 13] == 1 && buf[p2 + 16] == 0) {
                p2 += 14;
                loop_count = buf[p2++] | buf[p2++] << 8;
                p2++;
              } else {
                p2 += 12;
                while (true) {
                  var block_size = buf[p2++];
                  if (!(block_size >= 0)) throw Error("Invalid block size");
                  if (block_size === 0) break;
                  p2 += block_size;
                }
              }
              break;
            case 249:
              if (buf[p2++] !== 4 || buf[p2 + 4] !== 0)
                throw new Error("Invalid graphics extension block.");
              var pf1 = buf[p2++];
              delay = buf[p2++] | buf[p2++] << 8;
              transparent_index = buf[p2++];
              if ((pf1 & 1) === 0) transparent_index = null;
              disposal = pf1 >> 2 & 7;
              p2++;
              break;
            case 254:
              while (true) {
                var block_size = buf[p2++];
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;
                p2 += block_size;
              }
              break;
            default:
              throw new Error(
                "Unknown graphic control label: 0x" + buf[p2 - 1].toString(16)
              );
          }
          break;
        case 44:
          var x = buf[p2++] | buf[p2++] << 8;
          var y = buf[p2++] | buf[p2++] << 8;
          var w = buf[p2++] | buf[p2++] << 8;
          var h = buf[p2++] | buf[p2++] << 8;
          var pf2 = buf[p2++];
          var local_palette_flag = pf2 >> 7;
          var interlace_flag = pf2 >> 6 & 1;
          var num_local_colors_pow2 = pf2 & 7;
          var num_local_colors = 1 << num_local_colors_pow2 + 1;
          var palette_offset = global_palette_offset;
          var palette_size = global_palette_size;
          var has_local_palette = false;
          if (local_palette_flag) {
            var has_local_palette = true;
            palette_offset = p2;
            palette_size = num_local_colors;
            p2 += num_local_colors * 3;
          }
          var data_offset = p2;
          p2++;
          while (true) {
            var block_size = buf[p2++];
            if (!(block_size >= 0)) throw Error("Invalid block size");
            if (block_size === 0) break;
            p2 += block_size;
          }
          frames.push({
            x,
            y,
            width: w,
            height: h,
            has_local_palette,
            palette_offset,
            palette_size,
            data_offset,
            data_length: p2 - data_offset,
            transparent_index,
            interlaced: !!interlace_flag,
            delay,
            disposal
          });
          break;
        case 59:
          no_eof = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + buf[p2 - 1].toString(16));
      }
    }
    this.numFrames = function() {
      return frames.length;
    };
    this.loopCount = function() {
      return loop_count;
    };
    this.frameInfo = function(frame_num) {
      if (frame_num < 0 || frame_num >= frames.length)
        throw new Error("Frame index out of range.");
      return frames[frame_num];
    };
    this.decodeAndBlitFrameBGRA = function(frame_num, pixels2) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(
        buf,
        frame.data_offset,
        index_stream,
        num_pixels
      );
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null) trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i = 0, il = index_stream.length; i < il; ++i) {
        var index = index_stream[i];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g2 = buf[palette_offset2 + index * 3 + 1];
          var b2 = buf[palette_offset2 + index * 3 + 2];
          pixels2[op++] = b2;
          pixels2[op++] = g2;
          pixels2[op++] = r;
          pixels2[op++] = 255;
        }
        --xleft;
      }
    };
    this.decodeAndBlitFrameRGBA = function(frame_num, pixels2) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(
        buf,
        frame.data_offset,
        index_stream,
        num_pixels
      );
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null) trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i = 0, il = index_stream.length; i < il; ++i) {
        var index = index_stream[i];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g2 = buf[palette_offset2 + index * 3 + 1];
          var b2 = buf[palette_offset2 + index * 3 + 2];
          pixels2[op++] = r;
          pixels2[op++] = g2;
          pixels2[op++] = b2;
          pixels2[op++] = 255;
        }
        --xleft;
      }
    };
  }
  function GifReaderLZWOutputIndexStream(code_stream, p2, output2, output_length) {
    var min_code_size = code_stream[p2++];
    var clear_code = 1 << min_code_size;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var code_mask = (1 << cur_code_size) - 1;
    var cur_shift = 0;
    var cur = 0;
    var op = 0;
    var subblock_size = code_stream[p2++];
    var code_table = new Int32Array(4096);
    var prev_code = null;
    while (true) {
      while (cur_shift < 16) {
        if (subblock_size === 0) break;
        cur |= code_stream[p2++] << cur_shift;
        cur_shift += 8;
        if (subblock_size === 1) {
          subblock_size = code_stream[p2++];
        } else {
          --subblock_size;
        }
      }
      if (cur_shift < cur_code_size)
        break;
      var code2 = cur & code_mask;
      cur >>= cur_code_size;
      cur_shift -= cur_code_size;
      if (code2 === clear_code) {
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_mask = (1 << cur_code_size) - 1;
        prev_code = null;
        continue;
      } else if (code2 === eoi_code) {
        break;
      }
      var chase_code = code2 < next_code ? code2 : prev_code;
      var chase_length = 0;
      var chase = chase_code;
      while (chase > clear_code) {
        chase = code_table[chase] >> 8;
        ++chase_length;
      }
      var k = chase;
      var op_end = op + chase_length + (chase_code !== code2 ? 1 : 0);
      if (op_end > output_length) {
        console.log("Warning, gif stream longer than expected.");
        return;
      }
      output2[op++] = k;
      op += chase_length;
      var b2 = op;
      if (chase_code !== code2)
        output2[op++] = k;
      chase = chase_code;
      while (chase_length--) {
        chase = code_table[chase];
        output2[--b2] = chase & 255;
        chase >>= 8;
      }
      if (prev_code !== null && next_code < 4096) {
        code_table[next_code++] = prev_code << 8 | k;
        if (next_code >= code_mask + 1 && cur_code_size < 12) {
          ++cur_code_size;
          code_mask = code_mask << 1 | 1;
        }
      }
      prev_code = code2;
    }
    if (op !== output_length) {
      console.log("Warning, gif stream shorter than expected.");
    }
    return output2;
  }
  try {
    omggif$1.GifWriter = GifWriter;
    omggif$1.GifReader = GifReader;
  } catch (e2) {
  }
  return omggif$1;
}
var omggifExports = requireOmggif();
function parse$3(csv, options2, reviver = (v) => v) {
  const ctx = /* @__PURE__ */ Object.create(null);
  ctx.options = options2 || {};
  ctx.reviver = reviver;
  ctx.value = "";
  ctx.entry = [];
  ctx.output = [];
  ctx.col = 1;
  ctx.row = 1;
  ctx.options.delimiter = ctx.options.delimiter === void 0 ? '"' : options2.delimiter;
  if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0)
    throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
  ctx.options.separator = ctx.options.separator === void 0 ? "," : options2.separator;
  if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0)
    throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
  const lexer = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r
|
|\r|[^${escapeRegExp(ctx.options.delimiter)}${escapeRegExp(ctx.options.separator)}\r
]+`, "y");
  const isNewline = /^(\r\n|\n|\r)$/;
  let matches = [];
  let match = "";
  let state = 0;
  while ((matches = lexer.exec(csv)) !== null) {
    match = matches[0];
    switch (state) {
      case 0:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 3;
            break;
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            ctx.value += match;
            state = 2;
            break;
        }
        break;
      case 2:
        switch (true) {
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            state = 4;
            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
        }
        break;
      case 3:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 4;
            break;
          default:
            state = 3;
            ctx.value += match;
            break;
        }
        break;
      case 4:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 3;
            ctx.value += match;
            break;
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
        }
        break;
    }
  }
  if (ctx.entry.length !== 0) {
    valueEnd(ctx);
    entryEnd(ctx);
  }
  return ctx.output;
}
function stringify(array2, options2 = {}, replacer = (v) => v) {
  const ctx = /* @__PURE__ */ Object.create(null);
  ctx.options = options2;
  ctx.options.eof = ctx.options.eof !== void 0 ? ctx.options.eof : true;
  ctx.row = 1;
  ctx.col = 1;
  ctx.output = "";
  ctx.options.delimiter = ctx.options.delimiter === void 0 ? '"' : options2.delimiter;
  if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0)
    throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
  ctx.options.separator = ctx.options.separator === void 0 ? "," : options2.separator;
  if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0)
    throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
  const needsDelimiters = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r
|
|\r`);
  array2.forEach((row, rIdx) => {
    let entry = "";
    ctx.col = 1;
    row.forEach((col, cIdx) => {
      if (typeof col === "string") {
        col = col.replace(new RegExp(ctx.options.delimiter, "g"), `${ctx.options.delimiter}${ctx.options.delimiter}`);
        col = needsDelimiters.test(col) ? `${ctx.options.delimiter}${col}${ctx.options.delimiter}` : col;
      }
      entry += replacer(col, ctx.row, ctx.col);
      if (cIdx !== row.length - 1) {
        entry += ctx.options.separator;
      }
      ctx.col++;
    });
    switch (true) {
      case ctx.options.eof:
      case (!ctx.options.eof && rIdx !== array2.length - 1):
        ctx.output += `${entry}
`;
        break;
      default:
        ctx.output += `${entry}`;
        break;
    }
    ctx.row++;
  });
  return ctx.output;
}
function valueEnd(ctx) {
  const value = ctx.options.typed ? inferType(ctx.value) : ctx.value;
  ctx.entry.push(ctx.reviver(value, ctx.row, ctx.col));
  ctx.value = "";
  ctx.col++;
}
function entryEnd(ctx) {
  ctx.output.push(ctx.entry);
  ctx.entry = [];
  ctx.row++;
  ctx.col = 1;
}
function inferType(value) {
  const isNumber2 = /.\./;
  switch (true) {
    case value === "true":
    case value === "false":
      return value === "true";
    case isNumber2.test(value):
      return parseFloat(value);
    case isFinite(value):
      return parseInt(value);
    default:
      return value;
  }
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var X = { trailer: 59 };
function F(t = 256) {
  let e2 = 0, s = new Uint8Array(t);
  return { get buffer() {
    return s.buffer;
  }, reset() {
    e2 = 0;
  }, bytesView() {
    return s.subarray(0, e2);
  }, bytes() {
    return s.slice(0, e2);
  }, writeByte(r) {
    n2(e2 + 1), s[e2] = r, e2++;
  }, writeBytes(r, o = 0, i = r.length) {
    n2(e2 + i);
    for (let c = 0; c < i; c++) s[e2++] = r[c + o];
  }, writeBytesView(r, o = 0, i = r.byteLength) {
    n2(e2 + i), s.set(r.subarray(o, o + i), e2), e2 += i;
  } };
  function n2(r) {
    var o = s.length;
    if (o >= r) return;
    var i = 1024 * 1024;
    r = Math.max(r, o * (o < i ? 2 : 1.125) >>> 0), o != 0 && (r = Math.max(r, 256));
    let c = s;
    s = new Uint8Array(r), e2 > 0 && s.set(c.subarray(0, e2), 0);
  }
}
var O = 12, J = 5003, lt = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];
function at(t, e2, s, n2, r = F(512), o = new Uint8Array(256), i = new Int32Array(J), c = new Int32Array(J)) {
  let x = i.length, a = Math.max(2, n2);
  o.fill(0), c.fill(0), i.fill(-1);
  let l = 0, f = 0, g2 = a + 1, h = g2, b2 = false, w = h, _23 = (1 << w) - 1, u = 1 << g2 - 1, k = u + 1, B = u + 2, p2 = 0, A = s[0], z = 0;
  for (let y = x; y < 65536; y *= 2) ++z;
  z = 8 - z, r.writeByte(a), I(u);
  let d2 = s.length;
  for (let y = 1; y < d2; y++) {
    t: {
      let m = s[y], v = (m << O) + A, M = m << z ^ A;
      if (i[M] === v) {
        A = c[M];
        break t;
      }
      let V = M === 0 ? 1 : x - M;
      for (; i[M] >= 0; ) if (M -= V, M < 0 && (M += x), i[M] === v) {
        A = c[M];
        break t;
      }
      I(A), A = m, B < 1 << O ? (c[M] = B++, i[M] = v) : (i.fill(-1), B = u + 2, b2 = true, I(u));
    }
  }
  return I(A), I(k), r.writeByte(0), r.bytesView();
  function I(y) {
    for (l &= lt[f], f > 0 ? l |= y << f : l = y, f += w; f >= 8; ) o[p2++] = l & 255, p2 >= 254 && (r.writeByte(p2), r.writeBytesView(o, 0, p2), p2 = 0), l >>= 8, f -= 8;
    if ((B > _23 || b2) && (b2 ? (w = h, _23 = (1 << w) - 1, b2 = false) : (++w, _23 = w === O ? 1 << w : (1 << w) - 1)), y == k) {
      for (; f > 0; ) o[p2++] = l & 255, p2 >= 254 && (r.writeByte(p2), r.writeBytesView(o, 0, p2), p2 = 0), l >>= 8, f -= 8;
      p2 > 0 && (r.writeByte(p2), r.writeBytesView(o, 0, p2), p2 = 0);
    }
  }
}
var $ = at;
function D(t, e2, s) {
  return t << 8 & 63488 | e2 << 2 & 992 | s >> 3;
}
function G(t, e2, s, n2) {
  return t >> 4 | e2 & 240 | (s & 240) << 4 | (n2 & 240) << 8;
}
function j(t, e2, s) {
  return t >> 4 << 8 | e2 & 240 | s >> 4;
}
function R(t, e2, s) {
  return t < e2 ? e2 : t > s ? s : t;
}
function T(t) {
  return t * t;
}
function tt(t, e2, s) {
  var n2 = 0, r = 1e100;
  let o = t[e2], i = o.cnt;
  o.ac;
  let x = o.rc, a = o.gc, l = o.bc;
  for (var f = o.fw; f != 0; f = t[f].fw) {
    let h = t[f], b2 = h.cnt, w = i * b2 / (i + b2);
    if (!(w >= r)) {
      var g2 = 0;
      g2 += w * T(h.rc - x), !(g2 >= r) && (g2 += w * T(h.gc - a), !(g2 >= r) && (g2 += w * T(h.bc - l), !(g2 >= r) && (r = g2, n2 = f)));
    }
  }
  o.err = r, o.nn = n2;
}
function Q() {
  return { ac: 0, rc: 0, gc: 0, bc: 0, cnt: 0, nn: 0, fw: 0, bk: 0, tm: 0, mtm: 0, err: 0 };
}
function ut(t, e2) {
  let s = e2 === "rgb444" ? 4096 : 65536, n2 = new Array(s), r = t.length;
  if (e2 === "rgba4444") for (let o = 0; o < r; ++o) {
    let i = t[o], c = i >> 24 & 255, x = i >> 16 & 255, a = i >> 8 & 255, l = i & 255, f = G(l, a, x, c), g2 = f in n2 ? n2[f] : n2[f] = Q();
    g2.rc += l, g2.gc += a, g2.bc += x, g2.ac += c, g2.cnt++;
  }
  else if (e2 === "rgb444") for (let o = 0; o < r; ++o) {
    let i = t[o], c = i >> 16 & 255, x = i >> 8 & 255, a = i & 255, l = j(a, x, c), f = l in n2 ? n2[l] : n2[l] = Q();
    f.rc += a, f.gc += x, f.bc += c, f.cnt++;
  }
  else for (let o = 0; o < r; ++o) {
    let i = t[o], c = i >> 16 & 255, x = i >> 8 & 255, a = i & 255, l = D(a, x, c), f = l in n2 ? n2[l] : n2[l] = Q();
    f.rc += a, f.gc += x, f.bc += c, f.cnt++;
  }
  return n2;
}
function H(t, e2, s = {}) {
  let { format: n2 = "rgb565", clearAlpha: r = true, clearAlphaColor: o = 0, clearAlphaThreshold: i = 0, oneBitAlpha: c = false } = s;
  if (!t || !t.buffer) throw new Error("quantize() expected RGBA Uint8Array data");
  if (!(t instanceof Uint8Array) && !(t instanceof Uint8ClampedArray)) throw new Error("quantize() expected RGBA Uint8Array data");
  let x = new Uint32Array(t.buffer), a = s.useSqrt !== false, l = n2 === "rgba4444", f = ut(x, n2), g2 = f.length, h = g2 - 1, b2 = new Uint32Array(g2 + 1);
  for (var w = 0, u = 0; u < g2; ++u) {
    let C = f[u];
    if (C != null) {
      var _23 = 1 / C.cnt;
      l && (C.ac *= _23), C.rc *= _23, C.gc *= _23, C.bc *= _23, f[w++] = C;
    }
  }
  T(e2) / w < 0.022 && (a = false);
  for (var u = 0; u < w - 1; ++u) f[u].fw = u + 1, f[u + 1].bk = u, a && (f[u].cnt = Math.sqrt(f[u].cnt));
  a && (f[u].cnt = Math.sqrt(f[u].cnt));
  var k, B, p2;
  for (u = 0; u < w; ++u) {
    tt(f, u);
    var A = f[u].err;
    for (B = ++b2[0]; B > 1 && (p2 = B >> 1, !(f[k = b2[p2]].err <= A)); B = p2) b2[B] = k;
    b2[B] = u;
  }
  var z = w - e2;
  for (u = 0; u < z; ) {
    for (var d2; ; ) {
      var I = b2[1];
      if (d2 = f[I], d2.tm >= d2.mtm && f[d2.nn].mtm <= d2.tm) break;
      d2.mtm == h ? I = b2[1] = b2[b2[0]--] : (tt(f, I), d2.tm = u);
      var A = f[I].err;
      for (B = 1; (p2 = B + B) <= b2[0] && (p2 < b2[0] && f[b2[p2]].err > f[b2[p2 + 1]].err && p2++, !(A <= f[k = b2[p2]].err)); B = p2) b2[B] = k;
      b2[B] = I;
    }
    var y = f[d2.nn], m = d2.cnt, v = y.cnt, _23 = 1 / (m + v);
    l && (d2.ac = _23 * (m * d2.ac + v * y.ac)), d2.rc = _23 * (m * d2.rc + v * y.rc), d2.gc = _23 * (m * d2.gc + v * y.gc), d2.bc = _23 * (m * d2.bc + v * y.bc), d2.cnt += y.cnt, d2.mtm = ++u, f[y.bk].fw = y.fw, f[y.fw].bk = y.bk, y.mtm = h;
  }
  let M = [];
  var V = 0;
  for (u = 0; ; ++V) {
    let L = R(Math.round(f[u].rc), 0, 255), C = R(Math.round(f[u].gc), 0, 255), Y = R(Math.round(f[u].bc), 0, 255), E = 255;
    if (l) {
      if (E = R(Math.round(f[u].ac), 0, 255), c) {
        let st = typeof c == "number" ? c : 127;
        E = E <= st ? 0 : 255;
      }
      r && E <= i && (L = C = Y = o, E = 0);
    }
    let K = l ? [L, C, Y, E] : [L, C, Y];
    if (xt(M, K) || M.push(K), (u = f[u].fw) == 0) break;
  }
  return M;
}
function xt(t, e2) {
  for (let s = 0; s < t.length; s++) {
    let n2 = t[s], r = n2[0] === e2[0] && n2[1] === e2[1] && n2[2] === e2[2], o = n2.length >= 4 && e2.length >= 4 ? n2[3] === e2[3] : true;
    if (r && o) return true;
  }
  return false;
}
function U(t, e2) {
  var s = 0, n2;
  for (n2 = 0; n2 < t.length; n2++) {
    let r = t[n2] - e2[n2];
    s += r * r;
  }
  return s;
}
function W(t, e2, s = U) {
  let n2 = Infinity, r = -1;
  for (let o = 0; o < t.length; o++) {
    let i = t[o], c = s(e2, i);
    c < n2 && (n2 = c, r = o);
  }
  return r;
}
function ct(t = {}) {
  let { initialCapacity: e2 = 4096, auto: s = true } = t, n2 = F(e2), r = 5003, o = new Uint8Array(256), i = new Int32Array(r), c = new Int32Array(r), x = false;
  return { reset() {
    n2.reset(), x = false;
  }, finish() {
    n2.writeByte(X.trailer);
  }, bytes() {
    return n2.bytes();
  }, bytesView() {
    return n2.bytesView();
  }, get buffer() {
    return n2.buffer;
  }, get stream() {
    return n2;
  }, writeHeader: a, writeFrame(l, f, g2, h = {}) {
    let { transparent: b2 = false, transparentIndex: w = 0, delay: _23 = 0, palette: u = null, repeat: k = 0, colorDepth: B = 8, dispose: p2 = -1 } = h, A = false;
    if (s ? x || (A = true, a(), x = true) : A = Boolean(h.first), f = Math.max(0, Math.floor(f)), g2 = Math.max(0, Math.floor(g2)), A) {
      if (!u) throw new Error("First frame must include a { palette } option");
      pt(n2, f, g2, u, B), it(n2, u), k >= 0 && dt(n2, k);
    }
    let z = Math.round(_23 / 10);
    wt(n2, p2, z, b2, w);
    let d2 = Boolean(u) && !A;
    ht(n2, f, g2, d2 ? u : null), d2 && it(n2, u), yt(n2, l, f, g2, B, o, i, c);
  } };
  function a() {
    ft(n2, "GIF89a");
  }
}
function wt(t, e2, s, n2, r) {
  t.writeByte(33), t.writeByte(249), t.writeByte(4), r < 0 && (r = 0, n2 = false);
  var o, i;
  n2 ? (o = 1, i = 2) : (o = 0, i = 0), e2 >= 0 && (i = e2 & 7), i <<= 2;
  let c = 0;
  t.writeByte(0 | i | c | o), S(t, s), t.writeByte(r || 0), t.writeByte(0);
}
function pt(t, e2, s, n2, r = 8) {
  let o = 1, i = 0, c = Z(n2.length) - 1, x = o << 7 | r - 1 << 4 | i << 3 | c, a = 0, l = 0;
  S(t, e2), S(t, s), t.writeBytes([x, a, l]);
}
function dt(t, e2) {
  t.writeByte(33), t.writeByte(255), t.writeByte(11), ft(t, "NETSCAPE2.0"), t.writeByte(3), t.writeByte(1), S(t, e2), t.writeByte(0);
}
function it(t, e2) {
  let s = 1 << Z(e2.length);
  for (let n2 = 0; n2 < s; n2++) {
    let r = [0, 0, 0];
    n2 < e2.length && (r = e2[n2]), t.writeByte(r[0]), t.writeByte(r[1]), t.writeByte(r[2]);
  }
}
function ht(t, e2, s, n2) {
  if (t.writeByte(44), S(t, 0), S(t, 0), S(t, e2), S(t, s), n2) {
    let r = 0, o = 0, i = Z(n2.length) - 1;
    t.writeByte(128 | r | o | 0 | i);
  } else t.writeByte(0);
}
function yt(t, e2, s, n2, r = 8, o, i, c) {
  $(s, n2, e2, r, t, o, i, c);
}
function S(t, e2) {
  t.writeByte(e2 & 255), t.writeByte(e2 >> 8 & 255);
}
function ft(t, e2) {
  for (var s = 0; s < e2.length; s++) t.writeByte(e2.charCodeAt(s));
}
function Z(t) {
  return Math.max(Math.ceil(Math.log2(t)), 1);
}
function pixels(p53, fn2) {
  fn2.blend = function(...args) {
    if (this._renderer) {
      this._renderer.blend(...args);
    } else {
      p53.Renderer2D.prototype.blend.apply(this, args);
    }
  };
  fn2.copy = function(...args) {
    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
    if (args.length === 9) {
      srcImage = args[0];
      sx = args[1];
      sy = args[2];
      sw = args[3];
      sh = args[4];
      dx = args[5];
      dy = args[6];
      dw = args[7];
      dh = args[8];
    } else if (args.length === 8) {
      srcImage = this;
      sx = args[0];
      sy = args[1];
      sw = args[2];
      sh = args[3];
      dx = args[4];
      dy = args[5];
      dw = args[6];
      dh = args[7];
    } else {
      throw new Error("Signature not supported");
    }
    fn2._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
  };
  fn2._copyHelper = (dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) => {
    const s = srcImage.canvas.width / srcImage.width;
    let sxMod = 0;
    let syMod = 0;
    if (srcImage._renderer && srcImage._renderer.isP3D) {
      sxMod = srcImage.width / 2;
      syMod = srcImage.height / 2;
    }
    if (dstImage._renderer && dstImage._renderer.isP3D) {
      dstImage.push();
      dstImage.resetMatrix();
      dstImage.noLights();
      dstImage.blendMode(dstImage.BLEND);
      dstImage.imageMode(dstImage.CORNER);
      dstImage._renderer.image(
        srcImage,
        sx + sxMod,
        sy + syMod,
        sw,
        sh,
        dx,
        dy,
        dw,
        dh
      );
      dstImage.pop();
    } else {
      dstImage.drawingContext.drawImage(
        srcImage.canvas,
        s * (sx + sxMod),
        s * (sy + syMod),
        s * sw,
        s * sh,
        dx,
        dy,
        dw,
        dh
      );
    }
  };
  fn2.getFilterGraphicsLayer = function() {
    return this._renderer.getFilterGraphicsLayer();
  };
  fn2.filter = function(...args) {
    let { shader: shader2, operation, value, useWebGL } = parseFilterArgs(...args);
    if (this._renderer.isP3D && shader2) {
      this._renderer.filter(shader2);
      return;
    }
    if (!useWebGL && !this._renderer.isP3D) {
      if (this.canvas !== void 0) {
        Filters.apply(this.canvas, Filters[operation], value);
      } else {
        Filters.apply(this.elt, Filters[operation], value);
      }
      return;
    }
    if (!useWebGL && this._renderer.isP3D) {
      console.warn("filter() with useWebGL=false is not supported in WEBGL");
    }
    if (this._renderer.isP3D) {
      this._renderer.filter(operation, value);
    } else {
      if (shader2) {
        this._renderer.filterRenderer.setOperation(operation, value, shader2);
      } else {
        this._renderer.filterRenderer.setOperation(operation, value);
      }
      this._renderer.filterRenderer.applyFilter();
    }
  };
  function parseFilterArgs(...args) {
    let result = {
      shader: void 0,
      operation: void 0,
      value: void 0,
      useWebGL: true
    };
    if (args[0] instanceof p53.Shader) {
      result.shader = args[0];
      return result;
    } else {
      result.operation = args[0];
    }
    if (args.length > 1 && typeof args[1] === "number") {
      result.value = args[1];
    }
    if (args[args.length - 1] === false) {
      result.useWebGL = false;
    }
    return result;
  }
  fn2.get = function(x, y, w, h) {
    return this._renderer.get(...arguments);
  };
  fn2.loadPixels = function(...args) {
    return this._renderer.loadPixels();
  };
  fn2.set = function(x, y, imgOrCol) {
    this._renderer.set(x, y, imgOrCol);
  };
  fn2.updatePixels = function(x, y, w, h) {
    if (this.pixels.length === 0) {
      return;
    }
    this._renderer.updatePixels(x, y, w, h);
  };
}
if (typeof p5 !== "undefined") {
  pixels(p5, p5.prototype);
}
class MatrixInterface {
  // Private field to store the matrix
  #matrix = null;
  constructor(...args) {
    if (this.constructor === MatrixInterface) {
      throw new Error("Class is of abstract type and can't be instantiated");
    }
  }
}
const isPerfectSquare = (arr2) => {
  const sqDimention = Math.sqrt(arr2.length);
  if (sqDimention % 1 !== 0) {
    throw new Error("Array length must be a perfect square.");
  }
  return true;
};
let GLMAT_ARRAY_TYPE = Array;
let isMatrixArray = (x) => Array.isArray(x);
if (typeof Float32Array !== "undefined") {
  GLMAT_ARRAY_TYPE = Float32Array;
  isMatrixArray = (x) => Array.isArray(x) || x instanceof Float32Array;
}
class Matrix extends MatrixInterface {
  matrix;
  #sqDimention;
  constructor(...args) {
    super(...args);
    if (isMatrixArray(args[0]) && isPerfectSquare(args[0])) {
      const sqDimention = Math.sqrt(args[0].length);
      this.#sqDimention = sqDimention;
      this.matrix = GLMAT_ARRAY_TYPE.from(args[0]);
    } else if (typeof args[0] === "number") {
      this.#sqDimention = Number(args[0]);
      this.matrix = this.#createIdentityMatrix(args[0]);
    }
    return this;
  }
  /**
   * Returns the 3x3 matrix if the dimensions are 3x3, otherwise returns `undefined`.
   *
   * This method returns the matrix if its dimensions are 3x3.
   * If the matrix is not 3x3, it returns `undefined`.
   *
   * @returns {Array|undefined} The 3x3 matrix or `undefined` if the matrix is not 3x3.
   */
  get mat3() {
    if (this.#sqDimention === 3) {
      return this.matrix;
    } else {
      return void 0;
    }
  }
  /**
   * Returns the 4x4 matrix if the dimensions are 4x4, otherwise returns `undefined`.
   *
   * This method returns the matrix if its dimensions are 4x4.
   * If the matrix is not 4x4, it returns `undefined`.
   *
   * @returns {Array|undefined} The 4x4 matrix or `undefined` if the matrix is not 4x4.
   */
  get mat4() {
    if (this.#sqDimention === 4) {
      return this.matrix;
    } else {
      return void 0;
    }
  }
  /**
   * Adds the corresponding elements of the given matrix to this matrix, if the dimentions are the same.
   *
   * @param {Matrix} matrix - The matrix to add to this matrix. It must have the same dimensions as this matrix.
   * @returns {Matrix} The resulting matrix after addition.
   * @throws {Error} If the matrices do not have the same dimensions.
   *
   * @example
   * const matrix1 = new p5.Matrix([1, 2, 3]);
   * const matrix2 = new p5.Matrix([4, 5, 6]);
   * matrix1.add(matrix2); // matrix1 is now [5, 7, 9]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix1 = new p5.Matrix([1, 2, 3, 4]);
   *   const matrix2 = new p5.Matrix([5, 6, 7, 8]);
   *   matrix1.add(matrix2);
   *   console.log(matrix1.matrix); // Output: [6, 8, 10, 12]
   * }
   * </code></div>
   */
  add(matrix2) {
    if (this.matrix.length !== matrix2.matrix.length) {
      throw new Error("Matrices must be of the same dimension to add.");
    }
    for (let i = 0; i < this.matrix.length; i++) {
      this.matrix[i] += matrix2.matrix[i];
    }
    return this;
  }
  /**
   * Sets the value of a specific element in the matrix in column-major order.
   *
   * A matrix is stored in column-major order, meaning elements are arranged column by column.
   * This function allows you to update or change the value of a specific element
   * in the matrix by specifying its index in the column-major order and the new value.
   *
   * Parameters:
   * - `index` (number): The position in the matrix where the value should be set.
   *   Indices start from 0 and follow column-major order.
   * - `value` (any): The new value you want to assign to the specified element.
   *
   * Example:
   * If you have the following 3x3 matrix stored in column-major order:
   * ```
   * [
   *   1, 4, 7,  // Column 1
   *   2, 5, 8,  // Column 2
   *   3, 6, 9   // Column 3
   * ]
   * ```
   * Calling `setElement(4, 10)` will update the element at index 4
   * (which corresponds to row 2, column 2 in row-major order) to `10`.
   * The updated matrix will look like this:
   * ```
   * [
   *   1, 4, 7,
   *   2, 10, 8,
   *   3, 6, 9
   * ]
   * ```
   *
   * This function is useful for modifying specific parts of the matrix without
   * having to recreate the entire structure.
   *
   * @param {Number} index - The position in the matrix where the value should be set.
   *                         Must be a non-negative integer less than the length of the matrix.
   * @param {Number} value - The new value to be assigned to the specified position in the matrix.
   * @returns {Matrix} The current instance of the Matrix, allowing for method chaining.
   *
   * @example
   * // Assuming matrix is an instance of Matrix with initial values [1, 2, 3, 4] matrix.setElement(2, 99);
   * // Now the matrix values are [1, 2, 99, 4]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4]);
   *   matrix.setElement(2, 99);
   *   console.log(matrix.matrix); // Output: [1, 2, 99, 4]
   * }
   * </code></div>
   */
  setElement(index, value) {
    if (index >= 0 && index < this.matrix.length) {
      this.matrix[index] = value;
    }
    return this;
  }
  /**
   * Resets the current matrix to an identity matrix.
   *
   * This method replaces the current matrix with an identity matrix of the same dimensions.
   * An identity matrix is a square matrix with ones on the main diagonal and zeros elsewhere.
   * This is useful for resetting transformations or starting fresh with a clean matrix.
   *
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Resetting a 4x4 matrix to an identity matrix
   * const matrix = new p5.Matrix(4);
   * matrix.scale(2, 2, 2); // Apply some transformations
   * console.log(matrix.matrix); // Output: Transformed matrix
   * matrix.reset(); // Reset to identity matrix
   * console.log(matrix.matrix); // Output: Identity matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4);
   *   matrix.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Before reset:", matrix.matrix);
   *   matrix.reset(); // Reset to identity matrix
   *   console.log("After reset:", matrix.matrix);
   * }
   * </code></div>
   */
  reset() {
    this.matrix = this.#createIdentityMatrix(this.#sqDimention);
    return this;
  }
  /**
   * Replace the entire contents of a NxN matrix.
   *
   * This method allows you to replace the values of the current matrix with
   * those from another matrix, an array, or individual arguments. The input
   * can be a `Matrix` instance, an array of numbers, or individual numbers
   * that match the dimensions of the current matrix. The values are copied
   * without referencing the source object, ensuring that the original input
   * remains unchanged.
   *
   * If the input dimensions do not match the current matrix, an error will
   * be thrown to ensure consistency.
   *
   * @param {Matrix|Float32Array|Number[]} [inMatrix] - The input matrix, array,
   * or individual numbers to replace the current matrix values.
   * @returns {Matrix} The current instance of the Matrix class, allowing for
   * method chaining.
   *
   * @example
   * // Replacing the contents of a matrix with another matrix
   * const matrix1 = new p5.Matrix([1, 2, 3, 4]);
   * const matrix2 = new p5.Matrix([5, 6, 7, 8]);
   * matrix1.set(matrix2);
   * console.log(matrix1.matrix); // Output: [5, 6, 7, 8]
   *
   * // Replacing the contents of a matrix with an array
   * const matrix = new p5.Matrix([1, 2, 3, 4]);
   * matrix.set([9, 10, 11, 12]);
   * console.log(matrix.matrix); // Output: [9, 10, 11, 12]
   *
   * // Replacing the contents of a matrix with individual numbers
   * const matrix = new p5.Matrix(4); // Creates a 4x4 identity matrix
   * matrix.set(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);
   * console.log(matrix.matrix); // Output: [1, 2, 3, ..., 16]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4]);
   *   console.log("Before set:", matrix.matrix);
   *   matrix.set([5, 6, 7, 8]);
   *   console.log("After set:", matrix.matrix); // Output: [5, 6, 7, 8]
   * }
   * </code></div>
   */
  set(inMatrix) {
    let refArray = GLMAT_ARRAY_TYPE.from([...arguments]);
    if (inMatrix instanceof Matrix) {
      refArray = GLMAT_ARRAY_TYPE.from(inMatrix.matrix);
    } else if (isMatrixArray(inMatrix)) {
      refArray = GLMAT_ARRAY_TYPE.from(inMatrix);
    }
    if (refArray.length !== this.matrix.length) {
      p5._friendlyError(
        `Expected same dimensions values but received different ${refArray.length}.`,
        "p5.Matrix.set"
      );
      return this;
    }
    this.matrix = refArray;
    return this;
  }
  /**
   * Gets a copy of the matrix, returns a p5.Matrix object.
   *
   * This method creates a new instance of the `Matrix` class and copies the
   * current matrix values into it. The returned matrix is independent of the
   * original, meaning changes to the copy will not affect the original matrix.
   *
   * This is useful when you need to preserve the current state of a matrix
   * while performing operations on a duplicate.
   *
   * @return {p5.Matrix} A new instance of the `Matrix` class containing the
   *                     same values as the original matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4]);
   *   const copiedMatrix = originalMatrix.get();
   *   console.log("Original Matrix:", originalMatrix.matrix); // Output: [1, 2, 3, 4]
   *   console.log("Copied Matrix:", copiedMatrix.matrix); // Output: [1, 2, 3, 4]
   *
   *   // Modify the copied matrix
   *   copiedMatrix.setElement(2, 99);
   *   console.log("Modified Copied Matrix:", copiedMatrix.matrix); // Output: [1, 2, 99, 4]
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix); // Output: [1, 2, 3, 4]
   * }
   * </code></div>
   */
  get() {
    return new Matrix(this.matrix);
  }
  /**
   * Return a copy of this matrix.
   * If this matrix is 4x4, a 4x4 matrix with exactly the same entries will be
   * generated. The same is true if this matrix is 3x3 or any NxN matrix.
   *
   * This method is useful when you need to preserve the current state of a matrix
   * while performing operations on a duplicate. The returned matrix is independent
   * of the original, meaning changes to the copy will not affect the original matrix.
   *
   * @return {p5.Matrix}   The result matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const copiedMatrix = originalMatrix.copy();
   *   console.log("Original Matrix:", originalMatrix.matrix);
   *   console.log("Copied Matrix:", copiedMatrix.matrix);
   *
   *   // Modify the copied matrix
   *   copiedMatrix.setElement(4, 99);
   *   console.log("Modified Copied Matrix:", copiedMatrix.matrix);
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix);
   * }
   * </code></div>
   */
  copy() {
    return new Matrix(this.matrix);
  }
  /**
   * Creates a copy of the current matrix instance.
   * This method is useful when you need a duplicate of the matrix
   * without modifying the original one.
   *
   * @returns {Matrix} A new matrix instance that is a copy of the current matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const clonedMatrix = originalMatrix.clone();
   *   console.log("Original Matrix:", originalMatrix.matrix);
   *   console.log("Cloned Matrix:", clonedMatrix.matrix);
   *
   *   // Modify the cloned matrix
   *   clonedMatrix.setElement(4, 99);
   *   console.log("Modified Cloned Matrix:", clonedMatrix.matrix);
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix);
   * }
   * </code></div>
   */
  clone() {
    return this.copy();
  }
  /**
   * Returns the diagonal elements of the matrix in the form of an array.
   * A NxN matrix will return an array of length N.
   *
   * This method extracts the diagonal elements of the matrix, which are the
   * elements where the row index equals the column index. For example, in a
   * 3x3 matrix:
   * ```
   * [
   *   1, 2, 3,
   *   4, 5, 6,
   *   7, 8, 9
   * ]
   * ```
   * The diagonal elements are [1, 5, 9].
   *
   * This is useful for operations that require the main diagonal of a matrix,
   * such as calculating the trace of a matrix or verifying if a matrix is diagonal.
   *
   * @return {Number[]} An array obtained by arranging the diagonal elements
   *                    of the matrix in ascending order of index.
   *
   * @example
   * // Extracting the diagonal elements of a matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const diagonal = matrix.diagonal(); // [1, 5, 9]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const diagonal = matrix.diagonal();
   *   console.log("Diagonal elements:", diagonal); // Output: [1, 5, 9]
   * }
   * </code></div>
   */
  diagonal() {
    const diagonal = [];
    for (let i = 0; i < this.#sqDimention; i++) {
      diagonal.push(this.matrix[i * (this.#sqDimention + 1)]);
    }
    return diagonal;
  }
  /**
   * This function is only for 3x3 matrices A function that returns a row vector of a NxN matrix.
   *
   * This method extracts a specific row from the matrix and returns it as a `p5.Vector`.
   * The row is determined by the `columnIndex` parameter, which specifies the column
   * index of the matrix. This is useful for operations that require working with
   * individual rows of a matrix, such as row transformations or dot products.
   *
   * @param {Number} columnIndex - The index of the column to extract as a row vector.
   *                               Must be a non-negative integer less than the matrix dimension.
   * @return {p5.Vector} A `p5.Vector` representing the extracted row of the matrix.
   *
   * @example
   * // Extracting a row vector from a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const rowVector = matrix.row(1); // Returns a vector [2, 5, 8]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const rowVector = matrix.row(1); // Extract the second row (index 1)
   *   console.log("Row Vector:", rowVector.toString()); // Output: Row Vector: [2, 5, 8]
   * }
   * </code></div>
   */
  row(columnIndex) {
    const columnVector = [];
    for (let i = 0; i < this.#sqDimention; i++) {
      columnVector.push(this.matrix[i * this.#sqDimention + columnIndex]);
    }
    return new Vector(...columnVector);
  }
  /**
   * A function that returns a column vector of a NxN matrix.
   *
   * This method extracts a specific column from the matrix and returns it as a `p5.Vector`.
   * The column is determined by the `rowIndex` parameter, which specifies the row index
   * of the matrix. This is useful for operations that require working with individual
   * columns of a matrix, such as column transformations or dot products.
   *
   * @param {Number} rowIndex - The index of the row to extract as a column vector.
   *                             Must be a non-negative integer less than the matrix dimension.
   * @return {p5.Vector} A `p5.Vector` representing the extracted column of the matrix.
   *
   * @example
   * // Extracting a column vector from a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const columnVector = matrix.column(1); // Returns a vector [4, 5, 6]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const columnVector = matrix.column(1); // Extract the second column (index 1)
   *   console.log("Column Vector:", columnVector.toString()); // Output: Column Vector: [4, 5, 6]
   * }
   * </code></div>
   */
  column(rowIndex) {
    const rowVector = [];
    for (let i = 0; i < this.#sqDimention; i++) {
      rowVector.push(this.matrix[rowIndex * this.#sqDimention + i]);
    }
    return new Vector(...rowVector);
  }
  /**
   * Transposes the given matrix `a` based on the square dimension of the matrix.
   *
   * This method rearranges the elements of the matrix such that the rows become columns
   * and the columns become rows. It handles matrices of different dimensions (4x4, 3x3, NxN)
   * by delegating to specific transpose methods for each case.
   *
   * If no argument is provided, the method transposes the current matrix instance.
   * If an argument is provided, it transposes the given matrix `a` and updates the current matrix.
   *
   * @param {Array} [a] - The matrix to be transposed. It should be a 2D array where each sub-array represents a row.
   *                      If omitted, the current matrix instance is transposed.
   * @returns {Matrix} - The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Transposing a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * matrix.transpose();
   * console.log(matrix.matrix); // Output: [1, 4, 7, 2, 5, 8, 3, 6, 9]
   *
   * // Transposing a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4);
   * matrix4x4.transpose();
   * console.log(matrix4x4.matrix); // Output: Transposed 4x4 identity matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   console.log("Before transpose:", matrix.matrix);
   *   matrix.transpose();
   *   console.log("After transpose:", matrix.matrix); // Output: [1, 4, 7, 2, 5, 8, 3, 6, 9]
   * }
   * </code></div>
   */
  transpose(a) {
    if (this.#sqDimention === 4) {
      return this.#transpose4x4(a);
    } else if (this.#sqDimention === 3) {
      return this.#transpose3x3(a);
    } else {
      return this.#transposeNxN(a);
    }
  }
  /**
   * Multiplies the current matrix with another matrix or matrix-like array.
   *
   * This method supports several types of input:
   * - Another Matrix instance
   * - A matrix-like array (must be a perfect square, e.g., 4x4 or 3x3)
   * - Multiple arguments that form a perfect square matrix
   *
   * If the input is the same as the current matrix, a copy is made to avoid modifying the original matrix.
   *
   * The method determines the appropriate multiplication strategy based on the dimensions of the current matrix
   * and the input matrix. It supports 3x3, 4x4, and NxN matrices.
   *
   * @param {Matrix|Array|...number} multMatrix - The matrix or matrix-like array to multiply with.
   * @returns {Matrix|undefined} The resulting matrix after multiplication, or undefined if the input is invalid.
   * @chainable
   *
   * @example
   * // Multiplying two 3x3 matrices
   * const matrix1 = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const matrix2 = new p5.Matrix([9, 8, 7, 6, 5, 4, 3, 2, 1]);
   * matrix1.mult(matrix2);
   * console.log(matrix1.matrix); // Output: [30, 24, 18, 84, 69, 54, 138, 114, 90]
   *
   * // Multiplying a 4x4 matrix with another 4x4 matrix
   * const matrix4x4_1 = new p5.Matrix(4); // Identity matrix
   * const matrix4x4_2 = new p5.Matrix([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 2, 3, 1]);
   * matrix4x4_1.mult(matrix4x4_2);
   * console.log(matrix4x4_1.matrix); // Output: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 2, 3, 1]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix1 = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const matrix2 = new p5.Matrix([9, 8, 7, 6, 5, 4, 3, 2, 1]);
   *   console.log("Before multiplication:", matrix1.matrix);
   *   matrix1.mult(matrix2);
   *   console.log("After multiplication:", matrix1.matrix); // Output: [30, 24, 18, 84, 69, 54, 138, 114, 90]
   * }
   * </code></div>
   */
  mult(multMatrix) {
    let _src;
    if (multMatrix === this || multMatrix === this.matrix) {
      _src = this.copy().matrix;
    } else if (multMatrix instanceof Matrix) {
      _src = multMatrix.matrix;
    } else if (isMatrixArray(multMatrix) && isPerfectSquare(multMatrix)) {
      _src = multMatrix;
    } else if (isPerfectSquare(Array.from(arguments))) {
      _src = Array.from(arguments);
    } else ;
    if (this.#sqDimention === 4 && _src.length === 16) {
      return this.#mult4x4(_src);
    } else if (this.#sqDimention === 3 && _src.length === 9) {
      return this.#mult3x3(_src);
    } else {
      return this.#multNxN(_src);
    }
  }
  /**
   * Takes a vector and returns the vector resulting from multiplying to that vector by this matrix from left. This function is only for 3x3 matrices.
   *
   * This method applies the current 3x3 matrix to a given vector, effectively
   * transforming the vector using the matrix. The resulting vector is returned
   * as a new vector or stored in the provided target vector.
   *
   * @param {p5.Vector} multVector - The vector to which this matrix applies.
   * @param {p5.Vector} [target] - The vector to receive the result. If not provided,
   *                               a copy of the input vector will be created and returned.
   * @return {p5.Vector} - The transformed vector after applying the matrix.
   *
   * @example
   * // Multiplying a 3x3 matrix with a vector
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const vector = new p5.Vector(1, 2, 3);
   * const result = matrix.multiplyVec(vector);
   * console.log(result.toString()); // Output: Transformed vector
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const vector = new p5.Vector(1, 2, 3);
   *   const result = matrix.multiplyVec(vector);
   *   console.log("Original Vector:", vector.toString()); // Output : Original Vector: [1, 2, 3]
   *   console.log("Transformed Vector:", result.toString()); // Output : Transformed Vector: [30, 36, 42]
   * }
   * </code></div>
   */
  multiplyVec(multVector, target) {
    if (target === void 0) {
      target = multVector.copy();
    }
    for (let i = 0; i < this.#sqDimention; i++) {
      target.values[i] = this.row(i).dot(multVector);
    }
    return target;
  }
  /**
   * Inverts a given matrix.
   *
   * This method inverts a matrix based on its dimensions. Currently, it supports
   * 3x3 and 4x4 matrices. If the matrix dimension is greater than 4, an error is thrown.
   *
   * For 4x4 matrices, it uses a specialized algorithm to compute the inverse.
   * For 3x3 matrices, it uses a different algorithm optimized for smaller matrices.
   *
   * If the matrix is singular (non-invertible), the method will return `null`.
   *
   * @param {Array} a - The matrix to be inverted. It should be a 2D array representing the matrix.
   * @returns {Array|null} - The inverted matrix, or `null` if the matrix is singular.
   * @throws {Error} - Throws an error if the matrix dimension is greater than 4.
   *
   * @example
   * // Inverting a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 0, 1, 4, 5, 6, 0]);
   * const invertedMatrix = matrix.invert();
   * console.log(invertedMatrix.matrix); // Output: Inverted 3x3 matrix
   *
   * // Inverting a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4); // Identity matrix
   * matrix4x4.scale(2, 2, 2);
   * const invertedMatrix4x4 = matrix4x4.invert();
   * console.log(invertedMatrix4x4.matrix); // Output: Inverted 4x4 matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 0, 1, 4, 5, 6, 0]);
   *   console.log("Original Matrix:", matrix.matrix);
   *   const invertedMatrix = matrix.invert();
   *   if (invertedMatrix) {
   *     console.log("Inverted Matrix:", invertedMatrix.matrix);
   *   } else {
   *     console.log("Matrix is singular and cannot be inverted.");
   *   }
   * }
   * </code></div>
   */
  invert(a) {
    if (this.#sqDimention === 4) {
      return this.#invert4x4(a);
    } else if (this.#sqDimention === 3) {
      return this.#invert3x3(a);
    } else {
      throw new Error(
        "Invert is not implemented for N>4 at the moment, we are working on it"
      );
    }
  }
  /**
   * Creates a 3x3 matrix whose entries are the top left 3x3 part and returns it. This function is only for 4x4 matrices.
   *
   * This method extracts the top-left 3x3 portion of a 4x4 matrix and creates a new
   * 3x3 matrix from it. This is particularly useful in 3D graphics for operations
   * that require only the rotational or scaling components of a transformation matrix.
   *
   * If the current matrix is not 4x4, an error is thrown to ensure the method is used
   * correctly. The resulting 3x3 matrix is independent of the original matrix, meaning
   * changes to the new matrix will not affect the original.
   *
   * @return {p5.Matrix} A new 3x3 matrix containing the top-left portion of the original 4x4 matrix.
   * @throws {Error} If the current matrix is not 4x4.
   *
   * @example
   * // Extracting a 3x3 submatrix from a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4); // Creates a 4x4 identity matrix
   * matrix4x4.scale(2, 2, 2); // Apply scaling transformation
   * const subMatrix3x3 = matrix4x4.createSubMatrix3x3();
   * console.log("Original 4x4 Matrix:", matrix4x4.matrix);
   * console.log("Extracted 3x3 Submatrix:", subMatrix3x3.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix4x4 = new p5.Matrix(4); // Creates a 4x4 identity matrix
   *   matrix4x4.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Original 4x4 Matrix:", matrix4x4.matrix);
   *
   *   const subMatrix3x3 = matrix4x4.createSubMatrix3x3();
   *   console.log("Extracted 3x3 Submatrix:", subMatrix3x3.matrix);
   * }
   * </code></div>
   */
  createSubMatrix3x3() {
    if (this.#sqDimention === 4) {
      const result = new Matrix(3);
      result.mat3[0] = this.matrix[0];
      result.mat3[1] = this.matrix[1];
      result.mat3[2] = this.matrix[2];
      result.mat3[3] = this.matrix[4];
      result.mat3[4] = this.matrix[5];
      result.mat3[5] = this.matrix[6];
      result.mat3[6] = this.matrix[8];
      result.mat3[7] = this.matrix[9];
      result.mat3[8] = this.matrix[10];
      return result;
    } else {
      throw new Error("Matrix dimension must be 4 to create a 3x3 submatrix.");
    }
  }
  /**
   * Converts a 4×4 matrix to its 3×3 inverse transpose transform.
   * This is commonly used in MVMatrix to NMatrix conversions, particularly
   * in 3D graphics for transforming normal vectors.
   *
   * This method extracts the top-left 3×3 portion of a 4×4 matrix, inverts it,
   * and then transposes the result. If the matrix is singular (non-invertible),
   * the resulting matrix will be zeroed out.
   *
   * @param  {p5.Matrix} mat4 - The 4×4 matrix to be converted.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   * @throws {Error} If the current matrix is not 3×3.
   *
   * @example
   * // Converting a 4×4 matrix to its 3×3 inverse transpose
   * const mat4 = new p5.Matrix(4); // Create a 4×4 identity matrix
   * mat4.scale(2, 2, 2); // Apply scaling transformation
   * const mat3 = new p5.Matrix(3); // Create a 3×3 matrix
   * mat3.inverseTranspose4x4(mat4);
   * console.log("Converted 3×3 Matrix:", mat3.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const mat4 = new p5.Matrix(4); // Create a 4×4 identity matrix
   *   mat4.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Original 4×4 Matrix:", mat4.matrix);
   *
   *   const mat3 = new p5.Matrix(3); // Create a 3×3 matrix
   *   mat3.inverseTranspose4x4(mat4);
   *   console.log("Converted 3×3 Matrix:", mat3.matrix);
   * }
   * </code></div>
   */
  inverseTranspose4x4({ mat4 }) {
    if (this.#sqDimention !== 3) {
      throw new Error("This function only works with 3×3 matrices.");
    } else {
      this.matrix[0] = mat4[0];
      this.matrix[1] = mat4[1];
      this.matrix[2] = mat4[2];
      this.matrix[3] = mat4[4];
      this.matrix[4] = mat4[5];
      this.matrix[5] = mat4[6];
      this.matrix[6] = mat4[8];
      this.matrix[7] = mat4[9];
      this.matrix[8] = mat4[10];
    }
    const inverse = this.invert();
    if (inverse) {
      inverse.transpose(this.matrix);
    } else {
      for (let i = 0; i < 9; i++) {
        this.matrix[i] = 0;
      }
    }
    return this;
  }
  /**
   * Applies a transformation matrix to the current matrix.
   *
   * This method multiplies the current matrix by another matrix, which can be provided
   * in several forms: another Matrix instance, an array representing a matrix, or as
   * individual arguments representing the elements of a 4x4 matrix.
   *
   * This operation is useful for combining transformations such as translation, rotation,
   * scaling, and perspective projection into a single matrix. By applying a transformation
   * matrix, you can modify the current matrix to represent a new transformation.
   *
   * @param {Matrix|Array|number} multMatrix - The matrix to multiply with. This can be:
   *   - An instance of the Matrix class.
   *   - An array of 16 numbers representing a 4x4 matrix.
   *   - 16 individual numbers representing the elements of a 4x4 matrix.
   * @returns {Matrix} The current matrix after applying the transformation.
   *
   * @example
   * <div class="norender"><code>
   * function setup() {
   *
   * // Assuming `matrix` is an instance of Matrix
   * const anotherMatrix = new p5.Matrix(4);
   * const anotherMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
   * matrix.apply(anotherMatrix);
   *
   * // Applying a transformation using an array
   * const matrixArray = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
   * matrix.apply(matrixArray);
   *
   * // Applying a transformation using individual arguments
   * matrix.apply(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
   *
   *
   *   // Create a 4x4 identity matrix
   *   const matrix = new p5.Matrix(4);
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Create a scaling transformation matrix
   *   const scalingMatrix = new p5.Matrix([2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1]);
   *
   *   // Apply the scaling transformation
   *   matrix.apply(scalingMatrix);
   *   console.log("After Scaling Transformation:", matrix.matrix);
   *
   *   // Apply a translation transformation using an array
   *   const translationMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 5, 5, 5, 1];
   *   matrix.apply(translationMatrix);
   *   console.log("After Translation Transformation:", matrix.matrix);
   * }
   * </code></div>
   */
  apply(multMatrix) {
    let _src;
    if (multMatrix === this || multMatrix === this.matrix) {
      _src = this.copy().matrix;
    } else if (multMatrix instanceof Matrix) {
      _src = multMatrix.matrix;
    } else if (isMatrixArray(multMatrix)) {
      _src = multMatrix;
    } else if (arguments.length === 16) {
      _src = arguments;
    } else {
      return;
    }
    const mat4 = this.matrix;
    const m0 = mat4[0];
    const m4 = mat4[4];
    const m8 = mat4[8];
    const m12 = mat4[12];
    mat4[0] = _src[0] * m0 + _src[1] * m4 + _src[2] * m8 + _src[3] * m12;
    mat4[4] = _src[4] * m0 + _src[5] * m4 + _src[6] * m8 + _src[7] * m12;
    mat4[8] = _src[8] * m0 + _src[9] * m4 + _src[10] * m8 + _src[11] * m12;
    mat4[12] = _src[12] * m0 + _src[13] * m4 + _src[14] * m8 + _src[15] * m12;
    const m13 = mat4[1];
    const m5 = mat4[5];
    const m9 = mat4[9];
    const m132 = mat4[13];
    mat4[1] = _src[0] * m13 + _src[1] * m5 + _src[2] * m9 + _src[3] * m132;
    mat4[5] = _src[4] * m13 + _src[5] * m5 + _src[6] * m9 + _src[7] * m132;
    mat4[9] = _src[8] * m13 + _src[9] * m5 + _src[10] * m9 + _src[11] * m132;
    mat4[13] = _src[12] * m13 + _src[13] * m5 + _src[14] * m9 + _src[15] * m132;
    const m22 = mat4[2];
    const m6 = mat4[6];
    const m10 = mat4[10];
    const m14 = mat4[14];
    mat4[2] = _src[0] * m22 + _src[1] * m6 + _src[2] * m10 + _src[3] * m14;
    mat4[6] = _src[4] * m22 + _src[5] * m6 + _src[6] * m10 + _src[7] * m14;
    mat4[10] = _src[8] * m22 + _src[9] * m6 + _src[10] * m10 + _src[11] * m14;
    mat4[14] = _src[12] * m22 + _src[13] * m6 + _src[14] * m10 + _src[15] * m14;
    const m3 = mat4[3];
    const m7 = mat4[7];
    const m11 = mat4[11];
    const m15 = mat4[15];
    mat4[3] = _src[0] * m3 + _src[1] * m7 + _src[2] * m11 + _src[3] * m15;
    mat4[7] = _src[4] * m3 + _src[5] * m7 + _src[6] * m11 + _src[7] * m15;
    mat4[11] = _src[8] * m3 + _src[9] * m7 + _src[10] * m11 + _src[11] * m15;
    mat4[15] = _src[12] * m3 + _src[13] * m7 + _src[14] * m11 + _src[15] * m15;
    return this;
  }
  /**
   * Scales a p5.Matrix by scalars or a vector.
   *
   * This method applies a scaling transformation to the current matrix.
   * Scaling is a transformation that enlarges or shrinks objects by a scale factor
   * along the x, y, and z axes. The scale factors can be provided as individual
   * numbers, an array, or a `p5.Vector`.
   *
   * If a `p5.Vector` or an array is provided, the x, y, and z components are extracted
   * from it. If the z component is not provided, it defaults to 1 (no scaling along the z-axis).
   *
   * @param {p5.Vector|Float32Array|Number[]} s - The vector or scalars to scale by.
   *                                              Can be a `p5.Vector`, an array, or individual numbers.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Scaling a matrix by individual scalars
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.scale(2, 3, 4); // Scale by 2 along x, 3 along y, and 4 along z
   * console.log(matrix.matrix);
   *
   * // Scaling a matrix by a p5.Vector
   * const scaleVector = new p5.Vector(2, 3, 4);
   * matrix.scale(scaleVector);
   * console.log(matrix.matrix);
   *
   * // Scaling a matrix by an array
   * const scaleArray = [2, 3, 4];
   * matrix.scale(scaleArray);
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Scale the matrix by individual scalars
   *   matrix.scale(2, 3, 4);
   *   console.log("Scaled Matrix (2, 3, 4):", matrix.matrix);
   *
   *   // Scale the matrix by a p5.Vector
   *   const scaleVector = new p5.Vector(1.5, 2.5, 3.5);
   *   matrix.scale(scaleVector);
   *   console.log("Scaled Matrix (Vector):", matrix.matrix);
   *
   *   // Scale the matrix by an array
   *   const scaleArray = [0.5, 0.5, 0.5];
   *   matrix.scale(scaleArray);
   *   console.log("Scaled Matrix (Array):", matrix.matrix);
   * }
   * </code></div>
   */
  scale(x, y, z) {
    if (x instanceof Vector) {
      y = x.y;
      z = x.z;
      x = x.x;
    } else if (x instanceof Array) {
      y = x[1];
      z = x[2];
      x = x[0];
    }
    this.matrix[0] *= x;
    this.matrix[1] *= x;
    this.matrix[2] *= x;
    this.matrix[3] *= x;
    this.matrix[4] *= y;
    this.matrix[5] *= y;
    this.matrix[6] *= y;
    this.matrix[7] *= y;
    this.matrix[8] *= z;
    this.matrix[9] *= z;
    this.matrix[10] *= z;
    this.matrix[11] *= z;
    return this;
  }
  /**
   * Rotate the Matrix around a specified axis by a given angle.
   *
   * This method applies a rotation transformation to the matrix, modifying its orientation
   * in 3D space. The rotation is performed around the provided axis, which can be defined
   * as a `p5.Vector` or an array of numbers representing the x, y, and z components of the axis.
   * Rotate our Matrix around an axis by the given angle.
   * @param  {Number} a The angle of rotation in radians.
   *                    Angles in radians are a measure of rotation, where 2π radians
   *                    represent a full circle (360 degrees). For example:
   *                    - π/2 radians = 90 degrees (quarter turn)
   *                    - π radians = 180 degrees (half turn)
   *                    - 2π radians = 360 degrees (full turn)
   *                    Use `Math.PI` for π or `p5`'s `PI` constant if using p5.js.
   * @param  {p5.Vector|Number[]} axis The axis or axes to rotate around.
   *                                   This defines the direction of the rotation.
   *                                   - If using a `p5.Vector`, it should represent
   *                                     the x, y, and z components of the axis.
   *                                   - If using an array, it should be in the form
   *                                     [x, y, z], where x, y, and z are numbers.
   *                                   For example:
   *                                   - [1, 0, 0] rotates around the x-axis.
   *                                   - [0, 1, 0] rotates around the y-axis.
   *                                   - [0, 0, 1] rotates around the z-axis.   *
   * @chainable
   * inspired by Toji's gl-matrix lib, mat4 rotation
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
   *
   *   // Translate the matrix by a 3D vector
   *   matrix.rotate4x4(Math.PI, [1,0,0]);
   *   console.log("After rotation of PI degrees on vector [1,0,0]:", matrix.matrix.slice().toString()); // [1,0,0,0,0,-1,1.2246468525851679e-16,0,0,-1.2246468525851679e-16,-1,0,0,0,0,1]
   * }
   * </code></div>
   */
  rotate4x4(a, x, y, z) {
    if (x instanceof Vector) {
      y = x.y;
      z = x.z;
      x = x.x;
    } else if (x instanceof Array) {
      y = x[1];
      z = x[2];
      x = x[0];
    }
    const len = Math.sqrt(x * x + y * y + z * z);
    x *= 1 / len;
    y *= 1 / len;
    z *= 1 / len;
    const a00 = this.matrix[0];
    const a01 = this.matrix[1];
    const a02 = this.matrix[2];
    const a03 = this.matrix[3];
    const a10 = this.matrix[4];
    const a11 = this.matrix[5];
    const a12 = this.matrix[6];
    const a13 = this.matrix[7];
    const a20 = this.matrix[8];
    const a21 = this.matrix[9];
    const a22 = this.matrix[10];
    const a23 = this.matrix[11];
    const sA = Math.sin(a);
    const cA = Math.cos(a);
    const tA = 1 - cA;
    const b00 = x * x * tA + cA;
    const b01 = y * x * tA + z * sA;
    const b02 = z * x * tA - y * sA;
    const b10 = x * y * tA - z * sA;
    const b11 = y * y * tA + cA;
    const b12 = z * y * tA + x * sA;
    const b20 = x * z * tA + y * sA;
    const b21 = y * z * tA - x * sA;
    const b22 = z * z * tA + cA;
    this.matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
    this.matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
    this.matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
    this.matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
    this.matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
    this.matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
    this.matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
    this.matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
    this.matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
    this.matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
    this.matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
    this.matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
    return this;
  }
  /**
   * Translates the current matrix by a given vector.
   *
   * This method applies a translation transformation to the current matrix.
   * Translation moves the matrix by a specified amount along the x, y, and z axes.
   * The input vector can be a 2D or 3D vector. If the z-component is not provided,
   * it defaults to 0, meaning no translation along the z-axis.
   *
   * @param {Number[]} v - A vector representing the translation. It should be an array
   *                       with two or three elements: [x, y, z]. The z-component is optional.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Translating a matrix by a 3D vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.translate([10, 20, 30]); // Translate by 10 units along x, 20 along y, and 30 along z
   * console.log(matrix.matrix);
   *
   * // Translating a matrix by a 2D vector
   * matrix.translate([5, 15]); // Translate by 5 units along x and 15 along y
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
   *
   *   // Translate the matrix by a 3D vector
   *   matrix.translate([10, 20, 30]);
   *   console.log("After 3D Translation (10, 20, 30):", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,10,20,30,1]
   *
   *   // Translate the matrix by a 2D vector
   *   matrix.translate([5, 15]);
   *   console.log("After 2D Translation (5, 15):", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,15,35,30,1]
   * }
   * </code></div>
   */
  translate(v) {
    const x = v[0], y = v[1], z = v[2] || 0;
    this.matrix[12] += this.matrix[0] * x + this.matrix[4] * y + this.matrix[8] * z;
    this.matrix[13] += this.matrix[1] * x + this.matrix[5] * y + this.matrix[9] * z;
    this.matrix[14] += this.matrix[2] * x + this.matrix[6] * y + this.matrix[10] * z;
    this.matrix[15] += this.matrix[3] * x + this.matrix[7] * y + this.matrix[11] * z;
    return this;
  }
  /**
   * Rotates the matrix around the X-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the X-axis. The rotation angle is specified in radians.
   *
   * Rotating around the X-axis means that the Y and Z coordinates of the matrix
   * are transformed while the X coordinates remain unchanged. This is commonly
   * used in 3D graphics to create animations or transformations along the X-axis.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by.
   *
   * @example
   * // Rotating a matrix around the X-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateX(Math.PI / 4); // Rotate 45 degrees around the X-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the X-axis
   *   matrix.rotateX(Math.PI / 4);
   *   console.log("After Rotation (X-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */
  rotateX(a) {
    this.rotate4x4(a, 1, 0, 0);
  }
  /**
   * Rotates the matrix around the Y-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the Y-axis. The rotation is performed in 3D space, and the angle
   * is specified in radians. Rotating around the Y-axis means that the X and Z
   * coordinates of the matrix are transformed while the Y coordinates remain
   * unchanged. This is commonly used in 3D graphics to create animations or
   * transformations along the Y-axis.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by. Positive
   * values rotate the matrix counterclockwise, and negative values rotate it
   * clockwise.
   *
   * @example
   * // Rotating a matrix around the Y-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateY(Math.PI / 4); // Rotate 45 degrees around the Y-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the Y-axis
   *   matrix.rotateY(Math.PI / 4);
   *   console.log("After Rotation (Y-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */
  rotateY(a) {
    this.rotate4x4(a, 0, 1, 0);
  }
  /**
   * Rotates the matrix around the Z-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the Z-axis. The rotation is performed in a 4x4 matrix context, which
   * is commonly used in 3D graphics to handle transformations. Rotating around
   * the Z-axis means that the X and Y coordinates of the matrix are transformed
   * while the Z coordinates remain unchanged.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by. Positive
   * values rotate the matrix counterclockwise, and negative values rotate it
   * clockwise.
   *
   * @returns {Matrix} The current instance of the Matrix class, allowing for
   * method chaining.
   *
   * @example
   * // Rotating a matrix around the Z-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateZ(Math.PI / 4); // Rotate 45 degrees around the Z-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the Z-axis
   *   matrix.rotateZ(Math.PI / 4);
   *   console.log("After Rotation (Z-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */
  rotateZ(a) {
    this.rotate4x4(a, 0, 0, 1);
  }
  /**
   * Sets the perspective projection matrix.
   *
   * This method modifies the current matrix to represent a perspective projection.
   * Perspective projection is commonly used in 3D graphics to simulate the effect
   * of objects appearing smaller as they move further away from the camera.
   *
   * The perspective matrix is defined by the field of view (fovy), aspect ratio,
   * and the near and far clipping planes. The near and far clipping planes define
   * the range of depth that will be rendered, with anything outside this range
   * being clipped.
   *
   * @param {Number} fovy - The field of view in the y direction, in radians.
   * @param {Number} aspect - The aspect ratio of the viewport (width / height).
   * @param {Number} near - The distance to the near clipping plane. Must be greater than 0.
   * @param {Number} far - The distance to the far clipping plane. Must be greater than the near value.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Setting a perspective projection matrix
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.perspective(Math.PI / 4, 1.5, 0.1, 100); // Set perspective projection
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Set a perspective projection with a 45-degree field of view,
   *   // an aspect ratio of 1.5, and near/far clipping planes at 0.1 and 100.
   *   matrix.perspective(Math.PI / 4, 1.5, 0.1, 100);
   *   console.log("Perspective Matrix:", matrix.matrix);
   * }
   * </code></div>
   */
  perspective(fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
    this.matrix[0] = f / aspect;
    this.matrix[1] = 0;
    this.matrix[2] = 0;
    this.matrix[3] = 0;
    this.matrix[4] = 0;
    this.matrix[5] = f;
    this.matrix[6] = 0;
    this.matrix[7] = 0;
    this.matrix[8] = 0;
    this.matrix[9] = 0;
    this.matrix[10] = (far + near) * nf;
    this.matrix[11] = -1;
    this.matrix[12] = 0;
    this.matrix[13] = 0;
    this.matrix[14] = 2 * far * near * nf;
    this.matrix[15] = 0;
    return this;
  }
  /**
   * Sets this matrix to an orthographic projection matrix.
   *
   * An orthographic projection matrix is used to create a 2D rendering
   * of a 3D scene by projecting points onto a plane without perspective
   * distortion. This method modifies the current matrix to represent
   * the orthographic projection defined by the given parameters.
   *
   * @param {number} left - The coordinate for the left vertical clipping plane.
   * @param {number} right - The coordinate for the right vertical clipping plane.
   * @param {number} bottom - The coordinate for the bottom horizontal clipping plane.
   * @param {number} top - The coordinate for the top horizontal clipping plane.
   * @param {number} near - The distance to the near depth clipping plane. Must be positive.
   * @param {number} far - The distance to the far depth clipping plane. Must be positive.
   * @chainable
   * @returns {Matrix} The current matrix instance, updated with the orthographic projection.
   *
   * @example
   * <div class="norender"><code>
   * // Example using p5.js to demonstrate orthographic projection
   * function setup() {
   *  let orthoMatrix = new p5.Matrix(4);
   *  console.log(orthoMatrix.matrix.toString()) // Output: 1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1
   *  orthoMatrix.ortho(-200, 200, -200, 200, 0.1, 1000);
   *  console.log(orthoMatrix.matrix.toString()) // Output: [24 0.004999999888241291,0,0,0,0,0.004999999888241291,0,0,0,0,-0.0020002000965178013,0,0,0,-1.0002000331878662,1]
   *  applyMatrix(
   *     orthoMatrix.mat4[0], orthoMatrix.mat4[1], orthoMatrix.mat4[2], orthoMatrix.mat4[3],
   *     orthoMatrix.mat4[4], orthoMatrix.mat4[5], orthoMatrix.mat4[6], orthoMatrix.mat4[7],
   *     orthoMatrix.mat4[8], orthoMatrix.mat4[9], orthoMatrix.mat4[10], orthoMatrix.mat4[11],
   *     orthoMatrix.mat4[12], orthoMatrix.mat4[13], orthoMatrix.mat4[14], orthoMatrix.mat4[15]
   *  );
   *  console.log(orthoMatrix.matrix.toString()) // Output: [31 0.004999999888241291,0,0,0,0,0.004999999888241291,0,0,0,0,-0.0020002000965178013,0,0,0,-1.0002000331878662,1]
   *   }
   * </code></div>
   *
   */
  ortho(left, right, bottom, top, near, far) {
    const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
    this.matrix[0] = -2 * lr;
    this.matrix[1] = 0;
    this.matrix[2] = 0;
    this.matrix[3] = 0;
    this.matrix[4] = 0;
    this.matrix[5] = -2 * bt;
    this.matrix[6] = 0;
    this.matrix[7] = 0;
    this.matrix[8] = 0;
    this.matrix[9] = 0;
    this.matrix[10] = 2 * nf;
    this.matrix[11] = 0;
    this.matrix[12] = (left + right) * lr;
    this.matrix[13] = (top + bottom) * bt;
    this.matrix[14] = (far + near) * nf;
    this.matrix[15] = 1;
    return this;
  }
  /**
   * Applies a matrix to a vector with x, y, z, w components and returns the result as an array.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, w) and computes the resulting vector.
   * It is commonly used in 3D graphics for transformations such as translation, rotation, scaling, and perspective projection.
   *
   * The resulting vector is returned as an array of four numbers, representing the transformed x, y, z, and w components.
   *
   * @param {Number} x - The x component of the vector.
   * @param {Number} y - The y component of the vector.
   * @param {Number} z - The z component of the vector.
   * @param {Number} w - The w component of the vector.
   * @returns {Number[]} An array containing the transformed [x, y, z, w] components.
   *
   * @example
   * // Applying a matrix to a 4D vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const result = matrix.multiplyVec4(1, 2, 3, 1); // Transform the vector [1, 2, 3, 1]
   * console.log(result); // Output: [1, 2, 3, 1] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Apply the matrix to a 4D vector
   *   const result = matrix.multiplyVec4(1, 2, 3, 1);
   *   console.log("Transformed Vector:", result); // Output: [1, 2, 3, 1]
   *
   *   // Modify the matrix (e.g., apply a translation)
   *   matrix.translate([5, 5, 5]);
   *   console.log("Modified Matrix:", matrix.matrix);
   *
   *   // Apply the modified matrix to the same vector
   *   const transformedResult = matrix.multiplyVec4(1, 2, 3, 1);
   *   console.log("Transformed Vector after Translation:", transformedResult); // Output: [6, 7, 8, 1]
   * }
   * </code></div>
   */
  multiplyVec4(x, y, z, w) {
    const result = new Array(4);
    const m = this.matrix;
    result[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    result[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    result[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    result[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return result;
  }
  /**
   * Applies a matrix to a vector. The fourth component is set to 1.
   * Returns a vector consisting of the first
   * through third components of the result.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 1),
   * effectively transforming the vector using the matrix. The resulting
   * vector is returned as a new `p5.Vector` instance.
   *
   * This is useful for applying transformations such as translation,
   * rotation, scaling, or perspective projection to a point in 3D space.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed point.
   *
   * @example
   * // Applying a matrix to a 3D point
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const point = new p5.Vector(1, 2, 3); // Define a 3D point
   * const transformedPoint = matrix.multiplyPoint(point);
   * console.log(transformedPoint.toString()); // Output: [1, 2, 3] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a 3D point
   *   const point = new p5.Vector(1, 2, 3);
   *   console.log("Original Point:", point.toString());
   *
   *   // Apply the matrix to the point
   *   const transformedPoint = matrix.multiplyPoint(point);
   *   console.log("Transformed Point:", transformedPoint.toString());
   *
   *   // Modify the matrix (e.g., apply a translation)
   *   matrix.translate([5, 5, 5]);
   *   console.log("Modified Matrix:", matrix.matrix);
   *
   *   // Apply the modified matrix to the same point
   *   const translatedPoint = matrix.multiplyPoint(point);
   *   console.log("Translated Point:", translatedPoint.toString()); // Output: [6, 7, 8]
   * }
   * </code></div>
   */
  multiplyPoint({ x, y, z }) {
    const array2 = this.multiplyVec4(x, y, z, 1);
    return new Vector(array2[0], array2[1], array2[2]);
  }
  /**
   * Applies a matrix to a vector.
   * The fourth component is set to 1.
   * Returns the result of dividing the 1st to 3rd components
   * of the result by the 4th component as a vector.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 1),
   * effectively transforming the vector using the matrix. The resulting
   * vector is normalized by dividing its x, y, and z components by the w component.
   * This is useful for applying transformations such as perspective projection
   * to a point in 3D space.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed and normalized point.
   *
   * @example
   * // Applying a matrix to a 3D point and normalizing it
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const point = new p5.Vector(1, 2, 3); // Define a 3D point
   * const transformedPoint = matrix.multiplyAndNormalizePoint(point);
   * console.log(transformedPoint.toString()); // Output: [1, 2, 3] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a 3D point
   *   const point = new p5.Vector(1, 2, 3);
   *   console.log("Original Point:", point.toString());
   *
   *   // Apply the matrix to the point and normalize it
   *   const transformedPoint = matrix.multiplyAndNormalizePoint(point);
   *   console.log("Transformed and Normalized Point:", transformedPoint.toString());
   *
   *   // Modify the matrix (e.g., apply a perspective transformation)
   *   matrix.perspective(Math.PI / 4, 1.5, 0.1, 100);
   *   console.log("Modified Matrix (Perspective):", matrix.matrix);
   *
   *   // Apply the modified matrix to the same point
   *   const perspectivePoint = matrix.multiplyAndNormalizePoint(point);
   *   console.log("Point after Perspective Transformation:", perspectivePoint.toString());
   * }
   * </code></div>
   */
  multiplyAndNormalizePoint({ x, y, z }) {
    const array2 = this.multiplyVec4(x, y, z, 1);
    array2[0] /= array2[3];
    array2[1] /= array2[3];
    array2[2] /= array2[3];
    return new Vector(array2[0], array2[1], array2[2]);
  }
  /**
   * Applies a matrix to a vector.
   * The fourth component is set to 0.
   * Returns a vector consisting of the first
   * through third components of the result.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 0),
   * effectively transforming the direction vector using the matrix. The resulting
   * vector is returned as a new `p5.Vector` instance. This is particularly useful
   * for transforming direction vectors (e.g., normals) without applying translation.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed direction.
   *
   * @example
   * // Applying a matrix to a direction vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const direction = new p5.Vector(1, 0, 0); // Define a direction vector
   * const transformedDirection = matrix.multiplyDirection(direction);
   * console.log(transformedDirection.toString()); // Output: [1, 0, 0] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a direction vector
   *   const direction = new p5.Vector(1, 0, 0);
   *   console.log("Original Direction:", direction.toString());
   *
   *   // Apply the matrix to the direction vector
   *   const transformedDirection = matrix.multiplyDirection(direction);
   *   console.log("Transformed Direction:", transformedDirection.toString());
   *
   *   // Modify the matrix (e.g., apply a rotation)
   *   matrix.rotateY(Math.PI / 4); // Rotate 45 degrees around the Y-axis
   *   console.log("Modified Matrix (Rotation):", matrix.matrix);
   *
   *   // Apply the modified matrix to the same direction vector
   *   const rotatedDirection = matrix.multiplyDirection(direction);
   *   console.log("Rotated Direction:", rotatedDirection.toString()); // Output: Rotated vector
   * }
   * </code></div>
   */
  multiplyDirection({ x, y, z }) {
    const array2 = this.multiplyVec4(x, y, z, 0);
    return new Vector(array2[0], array2[1], array2[2]);
  }
  /**
   * Takes a vector and returns the vector resulting from multiplying. This function is only for 3x3 matrices.
   * that vector by this matrix from the left.
   *
   * This method applies the current 3x3 matrix to a given vector, effectively
   * transforming the vector using the matrix. The resulting vector is returned
   * as a new vector or stored in the provided target vector.
   *
   * This is useful for operations such as transforming points or directions
   * in 2D or 3D space using a 3x3 transformation matrix.
   *
   * @param {p5.Vector} multVector - The vector to which this matrix applies.
   * @param {p5.Vector} [target] - The vector to receive the result. If not provided,
   *                               a copy of the input vector will be created and returned.
   * @return {p5.Vector} - The transformed vector after applying the matrix.
   *
   * @example
   * // Multiplying a 3x3 matrix with a vector
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const vector = new p5.Vector(1, 2, 3);
   * const result = matrix.multiplyVec3(vector);
   * console.log(result.toString()); // Output: Transformed vector
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   // Create a 3x3 matrix
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a vector
   *   const vector = new p5.Vector(1, 2, 3);
   *   console.log("Original Vector:", vector.toString()); // Output: [1, 2, 3]
   *
   *   // Apply the matrix to the vector
   *   const transformedVector = matrix.multiplyVec3(vector);
   *   console.log("Transformed Vector:", transformedVector.toString()); // Output: [30, 36, 42]
   *
   *   // Modify the matrix (e.g., apply a scaling transformation)
   *   matrix.scale(2, 2, 2);
   *   console.log("Modified Matrix (Scaling):", matrix.matrix); // Output: [2, 4, 6, 8, 10, 12, 14, 16, 18]
   *
   *   // Apply the modified matrix to the same vector
   *   const scaledVector = matrix.multiplyVec3(vector);
   *   console.log("Scaled Vector:", scaledVector.toString()); // Output: [60, 72, 84]
   * }
   * </code></div>
   */
  multiplyVec3(multVector, target) {
    if (target === void 0) {
      target = multVector.copy();
    }
    target.x = this.row(0).dot(multVector);
    target.y = this.row(1).dot(multVector);
    target.z = this.row(2).dot(multVector);
    return target;
  }
  // ====================
  // PRIVATE
  /**
   * Creates identity matrix
   * This method updates the current matrix with the result of the multiplication.
   *
   * @private
   */
  #createIdentityMatrix(dimension) {
    if (dimension === 3)
      return new GLMAT_ARRAY_TYPE([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    if (dimension === 4)
      return new GLMAT_ARRAY_TYPE([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
    const identityMatrix = new GLMAT_ARRAY_TYPE(dimension * dimension).fill(0);
    for (let i = 0; i < dimension; i++) {
      identityMatrix[i * dimension + i] = 1;
    }
    return identityMatrix;
  }
  /**
   * Multiplies the current 4x4 matrix with another 4x4 matrix.
   * This method updates the current matrix with the result of the multiplication.
   *
   * @private
   * @param {number[]} _src - A 16-element array representing the 4x4 matrix to multiply with.
   *
   * @returns {this} The current instance with the updated matrix.
   *
   * @example
   * // Assuming `matrix` is an instance of the Matrix class
   * const srcMatrix = [
   *   1, 0, 0, 0,
   *   0, 1, 0, 0,
   *   0, 0, 1, 0,
   *   0, 0, 0, 1
   * ];
   * matrix.#mult4x4(srcMatrix);
   */
  #mult4x4(_src) {
    let b0 = this.matrix[0], b1 = this.matrix[1], b2 = this.matrix[2], b3 = this.matrix[3];
    this.matrix[0] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
    this.matrix[1] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
    this.matrix[2] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
    this.matrix[3] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
    b0 = this.matrix[4];
    b1 = this.matrix[5];
    b2 = this.matrix[6];
    b3 = this.matrix[7];
    this.matrix[4] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
    this.matrix[5] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
    this.matrix[6] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
    this.matrix[7] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
    b0 = this.matrix[8];
    b1 = this.matrix[9];
    b2 = this.matrix[10];
    b3 = this.matrix[11];
    this.matrix[8] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
    this.matrix[9] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
    this.matrix[10] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
    this.matrix[11] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
    b0 = this.matrix[12];
    b1 = this.matrix[13];
    b2 = this.matrix[14];
    b3 = this.matrix[15];
    this.matrix[12] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
    this.matrix[13] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
    this.matrix[14] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
    this.matrix[15] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
    return this;
  }
  /**
   * @param {p5.Matrix|Float32Array|Number[]} multMatrix The matrix
   *                                                we want to multiply by
   * @private
   * @chainable
   */
  #multNxN(multMatrix) {
    if (multMatrix.length !== this.matrix.length) {
      throw new Error("Matrices must be of the same dimension to multiply.");
    }
    const result = new GLMAT_ARRAY_TYPE(this.matrix.length).fill(0);
    for (let i = 0; i < this.#sqDimention; i++) {
      for (let j2 = 0; j2 < this.#sqDimention; j2++) {
        for (let k = 0; k < this.#sqDimention; k++) {
          result[i * this.#sqDimention + j2] += this.matrix[i * this.#sqDimention + k] * multMatrix[k * this.#sqDimention + j2];
        }
      }
    }
    this.matrix = result;
    return this;
  }
  /**
   * This function is only for 3x3 matrices.
   * multiply two mat3s. It is an operation to multiply the 3x3 matrix of
   * the argument from the right. Arguments can be a 3x3 p5.Matrix,
   * a Float32Array of length 9, or a javascript array of length 9.
   * In addition, it can also be done by enumerating 9 numbers.
   *
   * @param {p5.Matrix|Float32Array|Number[]} multMatrix The matrix
   *                                                we want to multiply by
   * @private
   * @chainable
   */
  #mult3x3(_src) {
    let b0 = this.mat3[0];
    let b1 = this.mat3[1];
    let b2 = this.mat3[2];
    this.mat3[0] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
    this.mat3[1] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
    this.mat3[2] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
    b0 = this.mat3[3];
    b1 = this.mat3[4];
    b2 = this.mat3[5];
    this.mat3[3] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
    this.mat3[4] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
    this.mat3[5] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
    b0 = this.mat3[6];
    b1 = this.mat3[7];
    b2 = this.mat3[8];
    this.mat3[6] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
    this.mat3[7] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
    this.mat3[8] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
    return this;
  }
  /**
   * Transposes a square matrix in place.
   * This method swaps the rows and columns of the matrix, effectively flipping it over its diagonal.
   *
   * @private
   * @returns {Matrix} The current instance of the Matrix, with the transposed values.
   */
  #transposeNxN() {
    const n2 = this.#sqDimention;
    for (let i = 0; i < n2; i++) {
      for (let j2 = 0; j2 < n2; j2++) {
        this.matrix[i * n2 + j2] = this.matrix[j2 * n2 + i];
      }
    }
    return this;
  }
  /**
   * transpose according to a given matrix
   * @param  {p5.Matrix|Float32Array|Number[]} a  the matrix to be
   *                                               based on to transpose
   * @private
   * @chainable
   */
  #transpose4x4(a) {
    console.log("====> 4x4");
    let a01, a02, a03, a12, a13, a23;
    if (a instanceof Matrix) {
      a01 = a.matrix[1];
      a02 = a.matrix[2];
      a03 = a.matrix[3];
      a12 = a.matrix[6];
      a13 = a.matrix[7];
      a23 = a.matrix[11];
      this.matrix[0] = a.matrix[0];
      this.matrix[1] = a.matrix[4];
      this.matrix[2] = a.matrix[8];
      this.matrix[3] = a.matrix[12];
      this.matrix[4] = a01;
      this.matrix[5] = a.matrix[5];
      this.matrix[6] = a.matrix[9];
      this.matrix[7] = a.matrix[13];
      this.matrix[8] = a02;
      this.matrix[9] = a12;
      this.matrix[10] = a.matrix[10];
      this.matrix[11] = a.matrix[14];
      this.matrix[12] = a03;
      this.matrix[13] = a13;
      this.matrix[14] = a23;
      this.matrix[15] = a.matrix[15];
    } else if (isMatrixArray(a)) {
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a12 = a[6];
      a13 = a[7];
      a23 = a[11];
      this.matrix[0] = a[0];
      this.matrix[1] = a[4];
      this.matrix[2] = a[8];
      this.matrix[3] = a[12];
      this.matrix[4] = a01;
      this.matrix[5] = a[5];
      this.matrix[6] = a[9];
      this.matrix[7] = a[13];
      this.matrix[8] = a02;
      this.matrix[9] = a12;
      this.matrix[10] = a[10];
      this.matrix[11] = a[14];
      this.matrix[12] = a03;
      this.matrix[13] = a13;
      this.matrix[14] = a23;
      this.matrix[15] = a[15];
    }
    return this;
  }
  /**
   * This function is only for 3x3 matrices.
   * transposes a 3×3 p5.Matrix by a mat3
   * If there is an array of arguments, the matrix obtained by transposing
   * the 3x3 matrix generated based on that array is set.
   * If no arguments, it transposes itself and returns it.
   *
   * @param  {Number[]} mat3 1-dimensional array
   * @private
   * @chainable
   */
  #transpose3x3(mat3) {
    if (mat3 === void 0) {
      mat3 = this.mat3;
    }
    const a01 = mat3[1];
    const a02 = mat3[2];
    const a12 = mat3[5];
    this.mat3[0] = mat3[0];
    this.mat3[1] = mat3[3];
    this.mat3[2] = mat3[6];
    this.mat3[3] = a01;
    this.mat3[4] = mat3[4];
    this.mat3[5] = mat3[7];
    this.mat3[6] = a02;
    this.mat3[7] = a12;
    this.mat3[8] = mat3[8];
    return this;
  }
  /**
   * Only 4x4 becasuse determinant is only 4x4 currently
   * invert  matrix according to a give matrix
   * @param  {p5.Matrix|Float32Array|Number[]} a   the matrix to be
   *                                                based on to invert
   * @private
   * @chainable
   */
  #invert4x4(a) {
    let a00, a01, a02, a03, a10, a11, a12, a13;
    let a20, a21, a22, a23, a30, a31, a32, a33;
    if (a instanceof Matrix) {
      a00 = a.matrix[0];
      a01 = a.matrix[1];
      a02 = a.matrix[2];
      a03 = a.matrix[3];
      a10 = a.matrix[4];
      a11 = a.matrix[5];
      a12 = a.matrix[6];
      a13 = a.matrix[7];
      a20 = a.matrix[8];
      a21 = a.matrix[9];
      a22 = a.matrix[10];
      a23 = a.matrix[11];
      a30 = a.matrix[12];
      a31 = a.matrix[13];
      a32 = a.matrix[14];
      a33 = a.matrix[15];
    } else if (isMatrixArray(a)) {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      a30 = a[12];
      a31 = a[13];
      a32 = a[14];
      a33 = a[15];
    }
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    this.matrix[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    this.matrix[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    this.matrix[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    this.matrix[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    this.matrix[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    this.matrix[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    this.matrix[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    this.matrix[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    this.matrix[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    this.matrix[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    this.matrix[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    this.matrix[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    this.matrix[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    this.matrix[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    this.matrix[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    this.matrix[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return this;
  }
  /**
   * Inverts a 3×3 matrix
   * @chainable
   * @private
   */
  #invert3x3() {
    const a00 = this.mat3[0];
    const a01 = this.mat3[1];
    const a02 = this.mat3[2];
    const a10 = this.mat3[3];
    const a11 = this.mat3[4];
    const a12 = this.mat3[5];
    const a20 = this.mat3[6];
    const a21 = this.mat3[7];
    const a22 = this.mat3[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    this.mat3[0] = b01 * det;
    this.mat3[1] = (-a22 * a01 + a02 * a21) * det;
    this.mat3[2] = (a12 * a01 - a02 * a11) * det;
    this.mat3[3] = b11 * det;
    this.mat3[4] = (a22 * a00 - a02 * a20) * det;
    this.mat3[5] = (-a12 * a00 + a02 * a10) * det;
    this.mat3[6] = b21 * det;
    this.mat3[7] = (-a21 * a00 + a01 * a20) * det;
    this.mat3[8] = (a11 * a00 - a01 * a10) * det;
    return this;
  }
  /**
   * inspired by Toji's mat4 determinant
   * @return {Number} Determinant of our 4×4 matrix
   * @private
   */
  #determinant4x4() {
    if (this.#sqDimention !== 4) {
      throw new Error(
        "Determinant is only implemented for 4x4 matrices. We are working on it."
      );
    }
    const d00 = this.matrix[0] * this.matrix[5] - this.matrix[1] * this.matrix[4], d01 = this.matrix[0] * this.matrix[6] - this.matrix[2] * this.matrix[4], d02 = this.matrix[0] * this.matrix[7] - this.matrix[3] * this.matrix[4], d03 = this.matrix[1] * this.matrix[6] - this.matrix[2] * this.matrix[5], d04 = this.matrix[1] * this.matrix[7] - this.matrix[3] * this.matrix[5], d05 = this.matrix[2] * this.matrix[7] - this.matrix[3] * this.matrix[6], d06 = this.matrix[8] * this.matrix[13] - this.matrix[9] * this.matrix[12], d07 = this.matrix[8] * this.matrix[14] - this.matrix[10] * this.matrix[12], d08 = this.matrix[8] * this.matrix[15] - this.matrix[11] * this.matrix[12], d09 = this.matrix[9] * this.matrix[14] - this.matrix[10] * this.matrix[13], d10 = this.matrix[9] * this.matrix[15] - this.matrix[11] * this.matrix[13], d11 = this.matrix[10] * this.matrix[15] - this.matrix[11] * this.matrix[14];
    return d00 * d11 - d01 * d10 + d02 * d09 + d03 * d08 - d04 * d07 + d05 * d06;
  }
  /**
   * PRIVATE
   */
  // matrix methods adapted from:
  // https://developer.mozilla.org/en-US/docs/Web/WebGL/
  // gluPerspective
  //
  // function _makePerspective(fovy, aspect, znear, zfar){
  //    const ymax = znear * Math.tan(fovy * Math.PI / 360.0);
  //    const ymin = -ymax;
  //    const xmin = ymin * aspect;
  //    const xmax = ymax * aspect;
  //    return _makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
  //  }
  ////
  //// glFrustum
  ////
  //function _makeFrustum(left, right, bottom, top, znear, zfar){
  //  const X = 2*znear/(right-left);
  //  const Y = 2*znear/(top-bottom);
  //  const A = (right+left)/(right-left);
  //  const B = (top+bottom)/(top-bottom);
  //  const C = -(zfar+znear)/(zfar-znear);
  //  const D = -2*zfar*znear/(zfar-znear);
  //  const frustrumMatrix =[
  //  X, 0, A, 0,
  //  0, Y, B, 0,
  //  0, 0, C, D,
  //  0, 0, -1, 0
  //];
  //return frustrumMatrix;
  // }
  // function _setMVPMatrices(){
  ////an identity matrix
  ////@TODO use the p5.Matrix class to abstract away our MV matrices and
  ///other math
  //const _mvMatrix =
  //[
  //  1.0,0.0,0.0,0.0,
  //  0.0,1.0,0.0,0.0,
  //  0.0,0.0,1.0,0.0,
  //  0.0,0.0,0.0,1.0
  //];
}
function matrix(p53, fn2) {
  p53.Matrix = Matrix;
}
if (typeof p5 !== "undefined") {
  matrix(p5, p5.prototype);
}
class DataArray {
  constructor(initialLength = 128) {
    this.length = 0;
    this.data = new Float32Array(initialLength);
    this.initialLength = initialLength;
  }
  /**
   * Returns a Float32Array window sized to the exact length of the data
   */
  dataArray() {
    return this.subArray(0, this.length);
  }
  /**
   * A "soft" clear, which keeps the underlying storage size the same, but
   * empties the contents of its dataArray()
   */
  clear() {
    this.length = 0;
  }
  /**
   * Can be used to scale a DataArray back down to fit its contents.
   */
  rescale() {
    if (this.length < this.data.length / 2) {
      const targetLength = 1 << Math.ceil(Math.log2(this.length));
      const newData = new Float32Array(targetLength);
      newData.set(this.data.subarray(0, this.length), 0);
      this.data = newData;
    }
  }
  /**
   * A full reset, which allocates a new underlying Float32Array at its initial
   * length
   */
  reset() {
    this.clear();
    this.data = new Float32Array(this.initialLength);
  }
  /**
   * Adds values to the DataArray, expanding its internal storage to
   * accommodate the new items.
   */
  push(...values) {
    this.ensureLength(this.length + values.length);
    this.data.set(values, this.length);
    this.length += values.length;
  }
  /**
   * Returns a copy of the data from the index `from`, inclusive, to the index
   * `to`, exclusive
   */
  slice(from, to2) {
    return this.data.slice(from, Math.min(to2, this.length));
  }
  /**
   * Returns a mutable Float32Array window from the index `from`, inclusive, to
   * the index `to`, exclusive
   */
  subArray(from, to2) {
    return this.data.subarray(from, Math.min(to2, this.length));
  }
  /**
   * Expand capacity of the internal storage until it can fit a target size
   */
  ensureLength(target) {
    while (this.data.length < target) {
      const newData = new Float32Array(this.data.length * 2);
      newData.set(this.data, 0);
      this.data = newData;
    }
  }
}
function dataArray(p53, fn2) {
  p53.DataArray = DataArray;
}
if (typeof p5 !== "undefined") {
  dataArray(p5, p5.prototype);
}
class Geometry {
  constructor(detailX, detailY, callback, renderer2) {
    this.renderer = renderer2;
    this.vertices = [];
    this.boundingBoxCache = null;
    this.lineVertices = new DataArray();
    this.lineTangentsIn = new DataArray();
    this.lineTangentsOut = new DataArray();
    this.lineSides = new DataArray();
    this.vertexNormals = [];
    this.faces = [];
    this.uvs = [];
    this.edges = [];
    this.vertexColors = [];
    this.vertexStrokeColors = [];
    this.userVertexProperties = {};
    this.lineVertexColors = new DataArray();
    this.detailX = detailX !== void 0 ? detailX : 1;
    this.detailY = detailY !== void 0 ? detailY : 1;
    this.dirtyFlags = {};
    this._hasFillTransparency = void 0;
    this._hasStrokeTransparency = void 0;
    this.gid = `_p5_Geometry_${Geometry.nextId}`;
    Geometry.nextId++;
    if (callback instanceof Function) {
      callback.call(this);
    }
  }
  /**
   * Calculates the position and size of the smallest box that contains the geometry.
   *
   * A bounding box is the smallest rectangular prism that contains the entire
   * geometry. It's defined by the box's minimum and maximum coordinates along
   * each axis, as well as the size (length) and offset (center).
   *
   * Calling `myGeometry.calculateBoundingBox()` returns an object with four
   * properties that describe the bounding box:
   *
   * ```js
   * // Get myGeometry's bounding box.
   * let bbox = myGeometry.calculateBoundingBox();
   *
   * // Print the bounding box to the console.
   * console.log(bbox);
   *
   * // {
   * //  // The minimum coordinate along each axis.
   * //  min: { x: -1, y: -2, z: -3 },
   * //
   * //  // The maximum coordinate along each axis.
   * //  max: { x: 1, y: 2, z: 3},
   * //
   * //  // The size (length) along each axis.
   * //  size: { x: 2, y: 4, z: 6},
   * //
   * //  // The offset (center) along each axis.
   * //  offset: { x: 0, y: 0, z: 0}
   * // }
   * ```
   *
   * @returns {Object} bounding box of the geometry.
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let particles;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a new p5.Geometry object with random spheres.
   *   particles = buildGeometry(createParticles);
   *
   *   describe('Ten white spheres placed randomly against a gray background. A box encloses the spheres.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the particles.
   *   noStroke();
   *   fill(255);
   *
   *   // Draw the particles.
   *   model(particles);
   *
   *   // Calculate the bounding box.
   *   let bbox = particles.calculateBoundingBox();
   *
   *   // Translate to the bounding box's center.
   *   translate(bbox.offset.x, bbox.offset.y, bbox.offset.z);
   *
   *   // Style the bounding box.
   *   stroke(255);
   *   noFill();
   *
   *   // Draw the bounding box.
   *   box(bbox.size.x, bbox.size.y, bbox.size.z);
   * }
   *
   * function createParticles() {
   *   for (let i = 0; i < 10; i += 1) {
   *     // Calculate random coordinates.
   *     let x = randomGaussian(0, 15);
   *     let y = randomGaussian(0, 15);
   *     let z = randomGaussian(0, 15);
   *
   *     push();
   *     // Translate to the particle's coordinates.
   *     translate(x, y, z);
   *     // Draw the particle.
   *     sphere(3);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   */
  calculateBoundingBox() {
    if (this.boundingBoxCache) {
      return this.boundingBoxCache;
    }
    let minVertex = new Vector(
      Number.MAX_VALUE,
      Number.MAX_VALUE,
      Number.MAX_VALUE
    );
    let maxVertex = new Vector(
      Number.MIN_VALUE,
      Number.MIN_VALUE,
      Number.MIN_VALUE
    );
    for (let i = 0; i < this.vertices.length; i++) {
      let vertex2 = this.vertices[i];
      minVertex.x = Math.min(minVertex.x, vertex2.x);
      minVertex.y = Math.min(minVertex.y, vertex2.y);
      minVertex.z = Math.min(minVertex.z, vertex2.z);
      maxVertex.x = Math.max(maxVertex.x, vertex2.x);
      maxVertex.y = Math.max(maxVertex.y, vertex2.y);
      maxVertex.z = Math.max(maxVertex.z, vertex2.z);
    }
    let size = new Vector(
      maxVertex.x - minVertex.x,
      maxVertex.y - minVertex.y,
      maxVertex.z - minVertex.z
    );
    let offset2 = new Vector(
      (minVertex.x + maxVertex.x) / 2,
      (minVertex.y + maxVertex.y) / 2,
      (minVertex.z + maxVertex.z) / 2
    );
    this.boundingBoxCache = {
      min: minVertex,
      max: maxVertex,
      size,
      offset: offset2
    };
    return this.boundingBoxCache;
  }
  reset() {
    this.renderer?.onReset?.(this);
    this._hasFillTransparency = void 0;
    this._hasStrokeTransparency = void 0;
    this.lineVertices.clear();
    this.lineTangentsIn.clear();
    this.lineTangentsOut.clear();
    this.lineSides.clear();
    this.vertices.length = 0;
    this.edges.length = 0;
    this.vertexColors.length = 0;
    this.vertexStrokeColors.length = 0;
    this.lineVertexColors.clear();
    this.vertexNormals.length = 0;
    this.uvs.length = 0;
    for (const propName in this.userVertexProperties) {
      this.userVertexProperties[propName].delete();
    }
    this.userVertexProperties = {};
    this.dirtyFlags = {};
  }
  hasFillTransparency() {
    if (this._hasFillTransparency === void 0) {
      this._hasFillTransparency = false;
      for (let i = 0; i < this.vertexColors.length; i += 4) {
        if (this.vertexColors[i + 3] < 1) {
          this._hasFillTransparency = true;
          break;
        }
      }
    }
    return this._hasFillTransparency;
  }
  hasStrokeTransparency() {
    if (this._hasStrokeTransparency === void 0) {
      this._hasStrokeTransparency = false;
      for (let i = 0; i < this.lineVertexColors.length; i += 4) {
        if (this.lineVertexColors[i + 3] < 1) {
          this._hasStrokeTransparency = true;
          break;
        }
      }
    }
    return this._hasStrokeTransparency;
  }
  /**
   * Removes the geometry’s internal colors.
   *
   * `p5.Geometry` objects can be created with "internal colors" assigned to
   * vertices or the entire shape. When a geometry has internal colors,
   * <a href="#/p5/fill">fill()</a> has no effect. Calling
   * `myGeometry.clearColors()` allows the
   * <a href="#/p5/fill">fill()</a> function to apply color to the geometry.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Geometry object.
   *   // Set its internal color to red.
   *   let myGeometry = buildGeometry(function() {
   *     fill(255, 0, 0);
   *     plane(20);
   *   });
   *
   *   // Style the shape.
   *   noStroke();
   *
   *   // Draw the p5.Geometry object (center).
   *   model(myGeometry);
   *
   *   // Translate the origin to the bottom-right.
   *   translate(25, 25, 0);
   *
   *   // Try to fill the geometry with green.
   *   fill(0, 255, 0);
   *
   *   // Draw the geometry again (bottom-right).
   *   model(myGeometry);
   *
   *   // Clear the geometry's colors.
   *   myGeometry.clearColors();
   *
   *   // Fill the geometry with blue.
   *   fill(0, 0, 255);
   *
   *   // Translate the origin up.
   *   translate(0, -50, 0);
   *
   *   // Draw the geometry again (top-right).
   *   model(myGeometry);
   *
   *   describe(
   *     'Three squares drawn against a gray background. Red squares are at the center and the bottom-right. A blue square is at the top-right.'
   *   );
   * }
   * </code>
   * </div>
   */
  clearColors() {
    this.vertexColors = [];
    return this;
  }
  /**
   * The `saveObj()` function exports `p5.Geometry` objects as
   * 3D models in the Wavefront .obj file format.
   * This way, you can use the 3D shapes you create in p5.js in other software
   * for rendering, animation, 3D printing, or more.
   *
   * The exported .obj file will include the faces and vertices of the `p5.Geometry`,
   * as well as its texture coordinates and normals, if it has them.
   *
   * @method saveObj
   * @param {String} [fileName='model.obj'] The name of the file to save the model as.
   *                                        If not specified, the default file name will be 'model.obj'.
   * @example
   * <div>
   * <code>
   * let myModel;
   * let saveBtn;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myModel = buildGeometry(function()) {
   *     for (let i = 0; i < 5; i++) {
   *       push();
   *       translate(
   *         random(-75, 75),
   *         random(-75, 75),
   *         random(-75, 75)
   *       );
   *       sphere(random(5, 50));
   *       pop();
   *     }
   *   });
   *
   *   saveBtn = createButton('Save .obj');
   *   saveBtn.mousePressed(() => myModel.saveObj());
   *
   *   describe('A few spheres rotating in space');
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   lights();
   *   rotateX(millis() * 0.001);
   *   rotateY(millis() * 0.002);
   *   model(myModel);
   * }
   * </code>
   * </div>
   */
  saveObj(fileName = "model.obj") {
    let objStr = "";
    this.vertices.forEach((v) => {
      objStr += `v ${v.x} ${v.y} ${v.z}
`;
    });
    if (this.uvs && this.uvs.length > 0) {
      for (let i = 0; i < this.uvs.length; i += 2) {
        objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}
`;
      }
    }
    if (this.vertexNormals && this.vertexNormals.length > 0) {
      this.vertexNormals.forEach((n2) => {
        objStr += `vn ${n2.x} ${n2.y} ${n2.z}
`;
      });
    }
    this.faces.forEach((face) => {
      let faceStr = "f";
      face.forEach((index) => {
        faceStr += " ";
        faceStr += index + 1;
        if (this.vertexNormals.length > 0 || this.uvs.length > 0) {
          faceStr += "/";
          if (this.uvs.length > 0) {
            faceStr += index + 1;
          }
          faceStr += "/";
          if (this.vertexNormals.length > 0) {
            faceStr += index + 1;
          }
        }
      });
      objStr += faceStr + "\n";
    });
    const blob = new Blob([objStr], { type: "text/plain" });
    downloadFile(blob, fileName, "obj");
  }
  /**
   * The `saveStl()` function exports `p5.Geometry` objects as
   * 3D models in the STL stereolithography file format.
   * This way, you can use the 3D shapes you create in p5.js in other software
   * for rendering, animation, 3D printing, or more.
   *
   * The exported .stl file will include the faces, vertices, and normals of the `p5.Geometry`.
   *
   * By default, this method saves a text-based .stl file. Alternatively, you can save a more compact
   * but less human-readable binary .stl file by passing `{ binary: true }` as a second parameter.
   *
   * @method saveStl
   * @param {String} [fileName='model.stl'] The name of the file to save the model as.
   *                                        If not specified, the default file name will be 'model.stl'.
   * @param {Object} [options] Optional settings.
   * @param {Boolean} [options.binary=false] Whether or not a binary .stl file is saved.
   * @example
   * <div>
   * <code>
   * let myModel;
   * let saveBtn1;
   * let saveBtn2;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myModel = buildGeometry(function() {
   *     for (let i = 0; i < 5; i++) {
   *       push();
   *       translate(
   *         random(-75, 75),
   *         random(-75, 75),
   *         random(-75, 75)
   *       );
   *       sphere(random(5, 50));
   *       pop();
   *     }
   *   });
   *
   *   saveBtn1 = createButton('Save .stl');
   *   saveBtn1.mousePressed(function() {
   *     myModel.saveStl();
   *   });
   *   saveBtn2 = createButton('Save binary .stl');
   *   saveBtn2.mousePressed(function() {
   *     myModel.saveStl('model.stl', { binary: true });
   *   });
   *
   *   describe('A few spheres rotating in space');
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   lights();
   *   rotateX(millis() * 0.001);
   *   rotateY(millis() * 0.002);
   *   model(myModel);
   * }
   * </code>
   * </div>
   */
  saveStl(fileName = "model.stl", { binary = false } = {}) {
    let modelOutput;
    let name = fileName.substring(0, fileName.lastIndexOf("."));
    let faceNormals = [];
    for (let f of this.faces) {
      const U2 = Vector.sub(this.vertices[f[1]], this.vertices[f[0]]);
      const V = Vector.sub(this.vertices[f[2]], this.vertices[f[0]]);
      const nx = U2.y * V.z - U2.z * V.y;
      const ny = U2.z * V.x - U2.x * V.z;
      const nz = U2.x * V.y - U2.y * V.x;
      faceNormals.push(new Vector(nx, ny, nz).normalize());
    }
    if (binary) {
      let offset2 = 80;
      const bufferLength = this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      modelOutput = new DataView(arrayBuffer);
      modelOutput.setUint32(offset2, this.faces.length, true);
      offset2 += 4;
      for (const [key, f] of Object.entries(this.faces)) {
        const norm = faceNormals[key];
        modelOutput.setFloat32(offset2, norm.x, true);
        offset2 += 4;
        modelOutput.setFloat32(offset2, norm.y, true);
        offset2 += 4;
        modelOutput.setFloat32(offset2, norm.z, true);
        offset2 += 4;
        for (let vertexIndex of f) {
          const vert = this.vertices[vertexIndex];
          modelOutput.setFloat32(offset2, vert.x, true);
          offset2 += 4;
          modelOutput.setFloat32(offset2, vert.y, true);
          offset2 += 4;
          modelOutput.setFloat32(offset2, vert.z, true);
          offset2 += 4;
        }
        modelOutput.setUint16(offset2, 0, true);
        offset2 += 2;
      }
    } else {
      modelOutput = "solid " + name + "\n";
      for (const [key, f] of Object.entries(this.faces)) {
        const norm = faceNormals[key];
        modelOutput += " facet norm " + norm.x + " " + norm.y + " " + norm.z + "\n";
        modelOutput += "  outer loop\n";
        for (let vertexIndex of f) {
          const vert = this.vertices[vertexIndex];
          modelOutput += "   vertex " + vert.x + " " + vert.y + " " + vert.z + "\n";
        }
        modelOutput += "  endloop\n";
        modelOutput += " endfacet\n";
      }
      modelOutput += "endsolid " + name + "\n";
    }
    const blob = new Blob([modelOutput], { type: "text/plain" });
    downloadFile(blob, fileName, "stl");
  }
  /**
   * Flips the geometry’s texture u-coordinates.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a rectangular
   * image that's used as a texture. The geometry's vertex at coordinates
   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.
   *
   * The <a href="#/p5.Geometry/uvs">myGeometry.uvs</a> array stores the
   * `(u, v)` coordinates for each vertex in the order it was added to the
   * geometry. Calling `myGeometry.flipU()` flips a geometry's u-coordinates
   * so that the texture appears mirrored horizontally.
   *
   * For example, a plane's four vertices are added clockwise starting from the
   * top-left corner. Here's how calling `myGeometry.flipU()` would change a
   * plane's texture coordinates:
   *
   * ```js
   * // Print the original texture coordinates.
   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]
   * console.log(myGeometry.uvs);
   *
   * // Flip the u-coordinates.
   * myGeometry.flipU();
   *
   * // Print the flipped texture coordinates.
   * // Output: [1, 0, 0, 0, 1, 1, 0, 1]
   * console.log(myGeometry.uvs);
   *
   * // Notice the swaps:
   * // Top vertices: [0, 0, 1, 0] --> [1, 0, 0, 0]
   * // Bottom vertices: [0, 1, 1, 1] --> [1, 1, 0, 1]
   * ```
   *
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Flip geom2's U texture coordinates.
   *   geom2.flipU();
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Right (flipped).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */
  flipU() {
    this.uvs = this.uvs.flat().map((val, index) => {
      if (index % 2 === 0) {
        return 1 - val;
      } else {
        return val;
      }
    });
  }
  /**
   * Flips the geometry’s texture v-coordinates.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a rectangular
   * image that's used as a texture. The geometry's vertex at coordinates
   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.
   *
   * The <a href="#/p5.Geometry/uvs">myGeometry.uvs</a> array stores the
   * `(u, v)` coordinates for each vertex in the order it was added to the
   * geometry. Calling `myGeometry.flipV()` flips a geometry's v-coordinates
   * so that the texture appears mirrored vertically.
   *
   * For example, a plane's four vertices are added clockwise starting from the
   * top-left corner. Here's how calling `myGeometry.flipV()` would change a
   * plane's texture coordinates:
   *
   * ```js
   * // Print the original texture coordinates.
   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]
   * console.log(myGeometry.uvs);
   *
   * // Flip the v-coordinates.
   * myGeometry.flipV();
   *
   * // Print the flipped texture coordinates.
   * // Output: [0, 1, 1, 1, 0, 0, 1, 0]
   * console.log(myGeometry.uvs);
   *
   * // Notice the swaps:
   * // Left vertices: [0, 0] <--> [1, 0]
   * // Right vertices: [1, 0] <--> [1, 1]
   * ```
   *
   * @method flipV
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Flip geom2's V texture coordinates.
   *   geom2.flipV();
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Right (flipped).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */
  flipV() {
    this.uvs = this.uvs.flat().map((val, index) => {
      if (index % 2 === 0) {
        return val;
      } else {
        return 1 - val;
      }
    });
  }
  /**
   * Computes the geometry's faces using its vertices.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to form triangles that
   * are stitched together. Each triangular patch on the geometry's surface is
   * called a *face*. `myGeometry.computeFaces()` performs the math needed to
   * define each face based on the distances between vertices.
   *
   * The geometry's vertices are stored as <a href="#/p5.Vector">p5.Vector</a>
   * objects in the <a href="#/p5.Geometry/vertices">myGeometry.vertices</a>
   * array. The geometry's first vertex is the
   * <a href="#/p5.Vector">p5.Vector</a> object at `myGeometry.vertices[0]`,
   * its second vertex is `myGeometry.vertices[1]`, its third vertex is
   * `myGeometry.vertices[2]`, and so on.
   *
   * Calling `myGeometry.computeFaces()` fills the
   * <a href="#/p5.Geometry/faces">myGeometry.faces</a> array with three-element
   * arrays that list the vertices that form each face. For example, a geometry
   * made from a rectangle has two faces because a rectangle is made by joining
   * two triangles. <a href="#/p5.Geometry/faces">myGeometry.faces</a> for a
   * rectangle would be the two-dimensional array
   * `[[0, 1, 2], [2, 1, 3]]`. The first face, `myGeometry.faces[0]`, is the
   * array `[0, 1, 2]` because it's formed by connecting
   * `myGeometry.vertices[0]`, `myGeometry.vertices[1]`,and
   * `myGeometry.vertices[2]`. The second face, `myGeometry.faces[1]`, is the
   * array `[2, 1, 3]` because it's formed by connecting
   * `myGeometry.vertices[2]`, `myGeometry.vertices[1]`, and
   * `myGeometry.vertices[3]`.
   *
   * Note: `myGeometry.computeFaces()` only works when geometries have four or more vertices.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to myGeometry's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute myGeometry's faces array.
   *   myGeometry.computeFaces();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the shape.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry(1, 1, createShape);
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the shape.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   this.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   this.computeFaces();
   * }
   * </code>
   * </div>
   */
  computeFaces() {
    this.faces.length = 0;
    const sliceCount = this.detailX + 1;
    let a, b2, c, d2;
    for (let i = 0; i < this.detailY; i++) {
      for (let j2 = 0; j2 < this.detailX; j2++) {
        a = i * sliceCount + j2;
        b2 = i * sliceCount + j2 + 1;
        c = (i + 1) * sliceCount + j2 + 1;
        d2 = (i + 1) * sliceCount + j2;
        this.faces.push([a, b2, d2]);
        this.faces.push([d2, b2, c]);
      }
    }
    return this;
  }
  _getFaceNormal(faceId) {
    const face = this.faces[faceId];
    const vA = this.vertices[face[0]];
    const vB = this.vertices[face[1]];
    const vC = this.vertices[face[2]];
    const ab = Vector.sub(vB, vA);
    const ac = Vector.sub(vC, vA);
    const n2 = Vector.cross(ab, ac);
    const ln = Vector.mag(n2);
    let sinAlpha = ln / (Vector.mag(ab) * Vector.mag(ac));
    if (sinAlpha === 0 || isNaN(sinAlpha)) {
      console.warn(
        "p5.Geometry.prototype._getFaceNormal:",
        "face has colinear sides or a repeated vertex"
      );
      return n2;
    }
    if (sinAlpha > 1) sinAlpha = 1;
    return n2.mult(Math.asin(sinAlpha) / ln);
  }
  /**
   * Calculates the normal vector for each vertex on the geometry.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to create triangles
   * that are stitched together. Each triangular patch on the geometry's
   * surface is called a *face*. `myGeometry.computeNormals()` performs the
   * math needed to orient each face. Orientation is important for lighting
   * and other effects.
   *
   * A face's orientation is defined by its *normal vector* which points out
   * of the face and is normal (perpendicular) to the surface. Calling
   * `myGeometry.computeNormals()` first calculates each face's normal vector.
   * Then it calculates the normal vector for each vertex by averaging the
   * normal vectors of the faces surrounding the vertex. The vertex normals
   * are stored as <a href="#/p5.Vector">p5.Vector</a> objects in the
   * <a href="#/p5.Geometry/vertexNormals">myGeometry.vertexNormals</a> array.
   *
   * The first parameter, `shadingType`, is optional. Passing the constant
   * `FLAT`, as in `myGeometry.computeNormals(FLAT)`, provides neighboring
   * faces with their own copies of the vertices they share. Surfaces appear
   * tiled with flat shading. Passing the constant `SMOOTH`, as in
   * `myGeometry.computeNormals(SMOOTH)`, makes neighboring faces reuse their
   * shared vertices. Surfaces appear smoother with smooth shading. By
   * default, `shadingType` is `FLAT`.
   *
   * The second parameter, `options`, is also optional. If an object with a
   * `roundToPrecision` property is passed, as in
   * `myGeometry.computeNormals(SMOOTH, { roundToPrecision: 5 })`, it sets the
   * number of decimal places to use for calculations. By default,
   * `roundToPrecision` uses 3 decimal places.
   *
   * @param {(FLAT|SMOOTH)} [shadingType=FLAT] shading type. either FLAT or SMOOTH. Defaults to `FLAT`.
   * @param {Object} [options] shading options.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     torus();
   *   });
   *
   *   // Compute the vertex normals.
   *   myGeometry.computeNormals();
   *
   *   describe(
   *     "A white torus drawn on a dark gray background. Red lines extend outward from the torus' vertices."
   *   );
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   stroke(0);
   *
   *   // Display the helix.
   *   model(myGeometry);
   *
   *   // Style the normal vectors.
   *   stroke(255, 0, 0);
   *
   *   // Iterate over the vertices and vertexNormals arrays.
   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {
   *
   *     // Get the vertex p5.Vector object.
   *     let v = myGeometry.vertices[i];
   *
   *     // Get the vertex normal p5.Vector object.
   *     let n = myGeometry.vertexNormals[i];
   *
   *     // Calculate a point along the vertex normal.
   *     let p = p5.Vector.mult(n, 5);
   *
   *     // Draw the vertex normal as a red line.
   *     push();
   *     translate(v);
   *     line(0, 0, 0, p.x, p.y, p.z);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   myGeometry.computeFaces();
   *
   *   // Compute the surface normals.
   *   myGeometry.computeNormals();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Add a white point light.
   *   pointLight(255, 255, 255, 0, 0, 10);
   *
   *   // Style the p5.Geometry object.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Compute normals using default (FLAT) shading.
   *   myGeometry.computeNormals(FLAT);
   *
   *   describe('A white, helical structure drawn on a dark gray background. Its faces appear faceted.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Compute normals using smooth shading.
   *   myGeometry.computeNormals(SMOOTH);
   *
   *   describe('A white, helical structure drawn on a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Create an options object.
   *   let options = { roundToPrecision: 5 };
   *
   *   // Compute normals using smooth shading.
   *   myGeometry.computeNormals(SMOOTH, options);
   *
   *   describe('A white, helical structure drawn on a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   */
  computeNormals(shadingType = FLAT, { roundToPrecision = 3 } = {}) {
    const vertexNormals = this.vertexNormals;
    let vertices = this.vertices;
    const faces = this.faces;
    let iv;
    if (shadingType === SMOOTH) {
      const vertexIndices = {};
      const uniqueVertices = [];
      const power = Math.pow(10, roundToPrecision);
      const rounded = (val) => Math.round(val * power) / power;
      const getKey = (vert) => `${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;
      for (let i = 0; i < vertices.length; i++) {
        const vertex2 = vertices[i];
        const key = getKey(vertex2);
        if (vertexIndices[key] === void 0) {
          vertexIndices[key] = uniqueVertices.length;
          uniqueVertices.push(vertex2);
        }
      }
      faces.forEach((face) => {
        for (let fv = 0; fv < 3; ++fv) {
          const originalVertexIndex = face[fv];
          const originalVertex = vertices[originalVertexIndex];
          const key = getKey(originalVertex);
          face[fv] = vertexIndices[key];
        }
      });
      this.edges.forEach((edge) => {
        for (let ev = 0; ev < 2; ++ev) {
          const originalVertexIndex = edge[ev];
          const originalVertex = vertices[originalVertexIndex];
          const key = getKey(originalVertex);
          edge[ev] = vertexIndices[key];
        }
      });
      this.vertices = vertices = uniqueVertices;
    }
    vertexNormals.length = 0;
    for (iv = 0; iv < vertices.length; ++iv) {
      vertexNormals.push(new Vector());
    }
    faces.forEach((face, f) => {
      const faceNormal = this._getFaceNormal(f);
      for (let fv = 0; fv < 3; ++fv) {
        const vertexIndex = face[fv];
        vertexNormals[vertexIndex].add(faceNormal);
      }
    });
    for (iv = 0; iv < vertices.length; ++iv) {
      vertexNormals[iv].normalize();
    }
    return this;
  }
  /**
   * Averages the vertex normals. Used in curved
   * surfaces
   * @private
   * @chainable
   */
  averageNormals() {
    for (let i = 0; i <= this.detailY; i++) {
      const offset2 = this.detailX + 1;
      let temp = Vector.add(
        this.vertexNormals[i * offset2],
        this.vertexNormals[i * offset2 + this.detailX]
      );
      temp = Vector.div(temp, 2);
      this.vertexNormals[i * offset2] = temp;
      this.vertexNormals[i * offset2 + this.detailX] = temp;
    }
    return this;
  }
  /**
   * Averages pole normals.  Used in spherical primitives
   * @private
   * @chainable
   */
  averagePoleNormals() {
    let sum = new Vector(0, 0, 0);
    for (let i = 0; i < this.detailX; i++) {
      sum.add(this.vertexNormals[i]);
    }
    sum = Vector.div(sum, this.detailX);
    for (let i = 0; i < this.detailX; i++) {
      this.vertexNormals[i] = sum;
    }
    sum = new Vector(0, 0, 0);
    for (let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--) {
      sum.add(this.vertexNormals[i]);
    }
    sum = Vector.div(sum, this.detailX);
    for (let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--) {
      this.vertexNormals[i] = sum;
    }
    return this;
  }
  /**
   * Create a 2D array for establishing stroke connections
   * @private
   * @chainable
   */
  _makeTriangleEdges() {
    this.edges.length = 0;
    for (let j2 = 0; j2 < this.faces.length; j2++) {
      this.edges.push([this.faces[j2][0], this.faces[j2][1]]);
      this.edges.push([this.faces[j2][1], this.faces[j2][2]]);
      this.edges.push([this.faces[j2][2], this.faces[j2][0]]);
    }
    return this;
  }
  /**
   * @example
   * <div>
   * <code>
   * let tetrahedron;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   describe('A rotating tetrahedron');
   *
   *   tetrahedron = new p5.Geometry();
   *
   *   // Give each geometry a unique gid
   *   tetrahedron.gid = 'tetrahedron';
   *
   *   // Add four points of the tetrahedron
   *
   *   let radius = 50;
   *   // A 2D triangle:
   *   tetrahedron.vertices.push(createVector(radius, 0, 0));
   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));
   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));
   *   // Add a tip in the z axis:
   *   tetrahedron.vertices.push(createVector(0, 0, radius));
   *
   *   // Create the four faces by connecting the sets of three points
   *   tetrahedron.faces.push([0, 1, 2]);
   *   tetrahedron.faces.push([0, 1, 3]);
   *   tetrahedron.faces.push([0, 2, 3]);
   *   tetrahedron.faces.push([1, 2, 3]);
   *   tetrahedron.makeEdgesFromFaces();
   * }
   * function draw() {
   *   background(200);
   *   strokeWeight(2);
   *   orbitControl();
   *   rotateY(millis() * 0.001);
   *   model(tetrahedron);
   * }
   * </code>
   * </div>
   */
  makeEdgesFromFaces() {
    this._makeTriangleEdges();
  }
  /**
   * Converts each line segment into the vertices and vertex attributes needed
   * to turn the line into a polygon on screen. This will include:
   * - Two triangles line segment to create a rectangle
   * - Two triangles per endpoint to create a stroke cap rectangle. A fragment
   *   shader is responsible for displaying the appropriate cap style within
   *   that rectangle.
   * - Four triangles per join between adjacent line segments, creating a quad on
   *   either side of the join, perpendicular to the lines. A vertex shader will
   *   discard the quad in the "elbow" of the join, and a fragment shader will
   *   display the appropriate join style within the remaining quad.
   *
   * @private
   * @chainable
   */
  _edgesToVertices() {
    this.lineVertices.clear();
    this.lineTangentsIn.clear();
    this.lineTangentsOut.clear();
    this.lineSides.clear();
    const potentialCaps = /* @__PURE__ */ new Map();
    const connected = /* @__PURE__ */ new Set();
    let lastValidDir;
    for (let i = 0; i < this.edges.length; i++) {
      const prevEdge = this.edges[i - 1];
      const currEdge = this.edges[i];
      const isPoint = currEdge[0] === currEdge[1];
      const begin = this.vertices[currEdge[0]];
      const end = this.vertices[currEdge[1]];
      const prevColor = this.vertexStrokeColors.length > 0 && prevEdge ? this.vertexStrokeColors.slice(
        prevEdge[1] * 4,
        (prevEdge[1] + 1) * 4
      ) : [0, 0, 0, 0];
      const fromColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(
        currEdge[0] * 4,
        (currEdge[0] + 1) * 4
      ) : [0, 0, 0, 0];
      const toColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(
        currEdge[1] * 4,
        (currEdge[1] + 1) * 4
      ) : [0, 0, 0, 0];
      const dir = isPoint ? new Vector(0, 1, 0) : end.copy().sub(begin).normalize();
      const dirOK = dir.magSq() > 0;
      if (dirOK) {
        this._addSegment(begin, end, fromColor, toColor, dir);
      }
      if (!this.renderer?._simpleLines) {
        if (i > 0 && prevEdge[1] === currEdge[0]) {
          if (!connected.has(currEdge[0])) {
            connected.add(currEdge[0]);
            potentialCaps.delete(currEdge[0]);
            if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 1e-8) {
              this._addJoin(begin, lastValidDir, dir, fromColor);
            }
          }
        } else if (isPoint) {
          this._addCap(begin, dir.copy().mult(-1), fromColor);
          this._addCap(begin, dir, fromColor);
        } else {
          if (dirOK && !connected.has(currEdge[0])) {
            const existingCap = potentialCaps.get(currEdge[0]);
            if (existingCap) {
              this._addJoin(
                begin,
                existingCap.dir,
                dir,
                fromColor
              );
              potentialCaps.delete(currEdge[0]);
              connected.add(currEdge[0]);
            } else {
              potentialCaps.set(currEdge[0], {
                point: begin,
                dir: dir.copy().mult(-1),
                color: fromColor
              });
            }
          }
          if (!isPoint && lastValidDir && !connected.has(prevEdge[1])) {
            const existingCap = potentialCaps.get(prevEdge[1]);
            if (existingCap) {
              this._addJoin(
                this.vertices[prevEdge[1]],
                lastValidDir,
                existingCap.dir.copy().mult(-1),
                prevColor
              );
              potentialCaps.delete(prevEdge[1]);
              connected.add(prevEdge[1]);
            } else {
              potentialCaps.set(prevEdge[1], {
                point: this.vertices[prevEdge[1]],
                dir: lastValidDir,
                color: prevColor
              });
            }
            lastValidDir = void 0;
          }
        }
        if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {
          const existingCap = potentialCaps.get(currEdge[1]);
          if (existingCap) {
            this._addJoin(
              end,
              dir,
              existingCap.dir.copy().mult(-1),
              toColor
            );
            potentialCaps.delete(currEdge[1]);
            connected.add(currEdge[1]);
          } else {
            potentialCaps.set(currEdge[1], {
              point: end,
              dir,
              color: toColor
            });
          }
        }
        if (dirOK) {
          lastValidDir = dir;
        }
      }
    }
    for (const { point, dir, color: color2 } of potentialCaps.values()) {
      this._addCap(point, dir, color2);
    }
    return this;
  }
  /**
   * Adds the vertices and vertex attributes for two triangles making a rectangle
   * for a straight line segment. A vertex shader is responsible for picking
   * proper coordinates on the screen given the centerline positions, the tangent,
   * and the side of the centerline each vertex belongs to. Sides follow the
   * following scheme:
   *
   *  -1            -1
   *   o-------------o
   *   |             |
   *   o-------------o
   *   1             1
   *
   * @private
   * @chainable
   */
  _addSegment(begin, end, fromColor, toColor, dir) {
    const a = begin.array();
    const b2 = end.array();
    const dirArr = dir.array();
    this.lineSides.push(1, 1, -1, 1, -1, -1);
    for (const tangents of [this.lineTangentsIn, this.lineTangentsOut]) {
      for (let i = 0; i < 6; i++) {
        tangents.push(...dirArr);
      }
    }
    this.lineVertices.push(...a, ...b2, ...a, ...b2, ...b2, ...a);
    if (!this.renderer?._simpleLines) {
      this.lineVertexColors.push(
        ...fromColor,
        ...toColor,
        ...fromColor,
        ...toColor,
        ...toColor,
        ...fromColor
      );
    }
    return this;
  }
  /**
   * Adds the vertices and vertex attributes for two triangles representing the
   * stroke cap of a line. A fragment shader is responsible for displaying the
   * appropriate cap style within the rectangle they make.
   *
   * The lineSides buffer will include the following values for the points on
   * the cap rectangle:
   *
   *           -1  -2
   * -----------o---o
   *            |   |
   * -----------o---o
   *            1   2
   * @private
   * @chainable
   */
  _addCap(point, tangent, color2) {
    const ptArray = point.array();
    const tanInArray = tangent.array();
    const tanOutArray = [0, 0, 0];
    for (let i = 0; i < 6; i++) {
      this.lineVertices.push(...ptArray);
      this.lineTangentsIn.push(...tanInArray);
      this.lineTangentsOut.push(...tanOutArray);
      this.lineVertexColors.push(...color2);
    }
    this.lineSides.push(-1, 2, -2, 1, 2, -1);
    return this;
  }
  /**
   * Adds the vertices and vertex attributes for four triangles representing a
   * join between two adjacent line segments. This creates a quad on either side
   * of the shared vertex of the two line segments, with each quad perpendicular
   * to the lines. A vertex shader will discard all but the quad in the "elbow" of
   * the join, and a fragment shader will display the appropriate join style
   * within the remaining quad.
   *
   * The lineSides buffer will include the following values for the points on
   * the join rectangles:
   *
   *            -1     -2
   * -------------o----o
   *              |    |
   *       1 o----o----o -3
   *         |    | 0  |
   * --------o----o    |
   *        2|    3    |
   *         |         |
   *         |         |
   * @private
   * @chainable
   */
  _addJoin(point, fromTangent, toTangent, color2) {
    const ptArray = point.array();
    const tanInArray = fromTangent.array();
    const tanOutArray = toTangent.array();
    for (let i = 0; i < 12; i++) {
      this.lineVertices.push(...ptArray);
      this.lineTangentsIn.push(...tanInArray);
      this.lineTangentsOut.push(...tanOutArray);
      this.lineVertexColors.push(...color2);
    }
    this.lineSides.push(-1, -3, -2, -1, 0, -3);
    this.lineSides.push(3, 1, 2, 3, 0, 1);
    return this;
  }
  /**
   * Transforms the geometry's vertices to fit snugly within a 100×100×100 box
   * centered at the origin.
   *
   * Calling `myGeometry.normalize()` translates the geometry's vertices so that
   * they're centered at the origin `(0, 0, 0)`. Then it scales the vertices so
   * that they fill a 100×100×100 box. As a result, small geometries will grow
   * and large geometries will shrink.
   *
   * Note: `myGeometry.normalize()` only works when called in the
   * <a href="#/p5/setup">setup()</a> function.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a very small torus.
   *   myGeometry = buildGeometry(function() {;
   *     torus(1, 0.25);
   *   });
   *
   *   // Normalize the torus so its vertices fill
   *   // the range [-100, 100].
   *   myGeometry.normalize();
   *
   *   describe('A white torus rotates slowly against a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the torus.
   *   noStroke();
   *
   *   // Draw the torus.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   */
  normalize() {
    if (this.vertices.length > 0) {
      const maxPosition = this.vertices[0].copy();
      const minPosition = this.vertices[0].copy();
      for (let i = 0; i < this.vertices.length; i++) {
        maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);
        minPosition.x = Math.min(minPosition.x, this.vertices[i].x);
        maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);
        minPosition.y = Math.min(minPosition.y, this.vertices[i].y);
        maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);
        minPosition.z = Math.min(minPosition.z, this.vertices[i].z);
      }
      const center = Vector.lerp(maxPosition, minPosition, 0.5);
      const dist = Vector.sub(maxPosition, minPosition);
      const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);
      const scale = 200 / longestDist;
      for (let i = 0; i < this.vertices.length; i++) {
        this.vertices[i].sub(center);
        this.vertices[i].mult(scale);
      }
    }
    return this;
  }
  /** Sets the shader's vertex property or attribute variables.
   *
   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some
   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are
   * set using <a href="#/p5/vertex">vertex()</a>, <a href="#/p5/normal">normal()</a>
   * and <a href="#/p5/fill">fill()</a> respectively. Custom properties can also
   * be defined within <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a>.
   *
   * The first parameter, `propertyName`, is a string with the property's name.
   * This is the same variable name which should be declared in the shader, as in
   * `in vec3 aProperty`, similar to .`setUniform()`.
   *
   * The second parameter, `data`, is the value assigned to the shader variable. This value
   * will be pushed directly onto the Geometry object. There should be the same number
   * of custom property values as vertices, this method should be invoked once for each
   * vertex.
   *
   * The `data` can be a Number or an array of numbers. Tn the shader program the type
   * can be declared according to the WebGL specification. Common types include `float`,
   * `vec2`, `vec3`, `vec4` or matrices.
   *
   * See also the global <a href="#/p5/vertexProperty">vertexProperty()</a> function.
   *
   * @example
   * <div>
   * <code>
   * let geo;
   *
   * function cartesianToSpherical(x, y, z) {
   *   let r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
   *   let theta = acos(z / r);
   *   let phi = atan2(y, x);
   *   return { theta, phi };
   * }
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Modify the material shader to display roughness.
   *   const myShader = baseMaterialShader().modify({
   *     vertexDeclarations:`in float aRoughness;
   *                         out float vRoughness;`,
   *     fragmentDeclarations: 'in float vRoughness;',
   *     'void afterVertex': `() {
   *         vRoughness = aRoughness;
   *     }`,
   *     'vec4 combineColors': `(ColorComponents components) {
   *             vec4 color = vec4(0.);
   *             color.rgb += components.diffuse * components.baseColor * (1.0-vRoughness);
   *             color.rgb += components.ambient * components.ambientColor;
   *             color.rgb += components.specular * components.specularColor * (1.0-vRoughness);
   *             color.a = components.opacity;
   *             return color;
   *     }`
   *   });
   *
   *   // Create the Geometry object.
   *   geo = buildGeometry(function() {
   *     fill('hotpink');
   *     sphere(45, 50, 50);
   *   });
   *
   *   // Set the roughness value for every vertex.
   *   for (let v of geo.vertices){
   *
   *     // convert coordinates to spherical coordinates
   *     let spherical = cartesianToSpherical(v.x, v.y, v.z);
   *
   *     // Set the custom roughness vertex property.
   *     let roughness = noise(spherical.theta*5, spherical.phi*5);
   *     geo.vertexProperty('aRoughness', roughness);
   *   }
   *
   *   // Use the custom shader.
   *   shader(myShader);
   *
   *   describe('A rough pink sphere rotating on a blue background.');
   * }
   *
   * function draw() {
   *   // Set some styles and lighting
   *   background('lightblue');
   *   noStroke();
   *
   *   specularMaterial(255,125,100);
   *   shininess(2);
   *
   *   directionalLight('white', -1, 1, -1);
   *   ambientLight(320);
   *
   *   rotateY(millis()*0.001);
   *
   *   // Draw the geometry
   *   model(geo);
   * }
   * </code>
   * </div>
   *
   * @param {String} propertyName the name of the vertex property.
   * @param {Number|Number[]} data the data tied to the vertex property.
   * @param {Number} [size] optional size of each unit of data.
   */
  vertexProperty(propertyName, data2, size) {
    let prop;
    if (!this.userVertexProperties[propertyName]) {
      prop = this.userVertexProperties[propertyName] = this._userVertexPropertyHelper(propertyName, data2, size);
    }
    prop = this.userVertexProperties[propertyName];
    if (size) {
      prop.pushDirect(data2);
    } else {
      prop.setCurrentData(data2);
      prop.pushCurrentData();
    }
  }
  _userVertexPropertyHelper(propertyName, data2, size) {
    const geometryInstance = this;
    const prop = this.userVertexProperties[propertyName] = {
      name: propertyName,
      dataSize: size ? size : data2.length ? data2.length : 1,
      geometry: geometryInstance,
      // Getters
      getName() {
        return this.name;
      },
      getCurrentData() {
        if (this.currentData === void 0) {
          this.currentData = new Array(this.getDataSize()).fill(0);
        }
        return this.currentData;
      },
      getDataSize() {
        return this.dataSize;
      },
      getSrcName() {
        const src = this.name.concat("Src");
        return src;
      },
      getDstName() {
        const dst = this.name.concat("Buffer");
        return dst;
      },
      getSrcArray() {
        const srcName = this.getSrcName();
        return this.geometry[srcName];
      },
      //Setters
      setCurrentData(data3) {
        data3.length ? data3.length : 1;
        this.currentData = data3;
      },
      // Utilities
      pushCurrentData() {
        const data3 = this.getCurrentData();
        this.pushDirect(data3);
      },
      pushDirect(data3) {
        if (data3.length) {
          this.getSrcArray().push(...data3);
        } else {
          this.getSrcArray().push(data3);
        }
      },
      resetSrcArray() {
        this.geometry[this.getSrcName()] = [];
      },
      delete() {
        const srcName = this.getSrcName();
        delete this.geometry[srcName];
        delete this;
      }
    };
    this[prop.getSrcName()] = [];
    return this.userVertexProperties[propertyName];
  }
}
Geometry.nextId = 0;
function geometry(p53, fn2) {
  p53.Geometry = Geometry;
}
if (typeof p5 !== "undefined") {
  geometry(p5, p5.prototype);
}
class GeometryBuilder {
  constructor(renderer2) {
    this.renderer = renderer2;
    renderer2._pInst.push();
    this.identityMatrix = new Matrix(4);
    renderer2.states.setValue("uModelMatrix", new Matrix(4));
    this.geometry = new Geometry(
      void 0,
      void 0,
      void 0,
      this.renderer
    );
    this.geometry.gid = `_p5_GeometryBuilder_${GeometryBuilder.nextGeometryId}`;
    GeometryBuilder.nextGeometryId++;
    this.hasTransform = false;
  }
  /**
   * @private
   * Applies the current transformation matrix to each vertex.
   */
  transformVertices(vertices) {
    if (!this.hasTransform) return vertices;
    return vertices.map(
      (v) => this.renderer.states.uModelMatrix.multiplyPoint(v)
    );
  }
  /**
   * @private
   * Applies the current normal matrix to each normal.
   */
  transformNormals(normals) {
    if (!this.hasTransform) return normals;
    return normals.map(
      (v) => this.renderer.scratchMat3.multiplyVec(v)
      // this is a vec3
    );
  }
  /**
   * @private
   * Adds a p5.Geometry to the builder's combined geometry, flattening
   * transformations.
   */
  addGeometry(input) {
    this.hasTransform = !this.renderer.states.uModelMatrix.mat4.every((v, i) => v === this.identityMatrix.mat4[i]);
    if (this.hasTransform) {
      this.renderer.scratchMat3.inverseTranspose4x4(
        this.renderer.states.uModelMatrix
      );
    }
    let startIdx = this.geometry.vertices.length;
    this.geometry.vertices.push(...this.transformVertices(input.vertices));
    this.geometry.vertexNormals.push(
      ...this.transformNormals(input.vertexNormals)
    );
    this.geometry.uvs.push(...input.uvs);
    const inputUserVertexProps = input.userVertexProperties;
    const builtUserVertexProps = this.geometry.userVertexProperties;
    const numPreviousVertices = this.geometry.vertices.length - input.vertices.length;
    for (const propName in builtUserVertexProps) {
      if (propName in inputUserVertexProps) {
        continue;
      }
      const prop = builtUserVertexProps[propName];
      const size = prop.getDataSize();
      const numMissingValues = size * input.vertices.length;
      const missingValues = Array(numMissingValues).fill(0);
      prop.pushDirect(missingValues);
    }
    for (const propName in inputUserVertexProps) {
      const prop = inputUserVertexProps[propName];
      const data2 = prop.getSrcArray();
      const size = prop.getDataSize();
      if (numPreviousVertices > 0 && !(propName in builtUserVertexProps)) {
        const numMissingValues = size * numPreviousVertices;
        const missingValues = Array(numMissingValues).fill(0);
        this.geometry.vertexProperty(propName, missingValues, size);
      }
      this.geometry.vertexProperty(propName, data2, size);
    }
    if (this.renderer.states.fillColor) {
      this.geometry.faces.push(
        ...input.faces.map((f) => f.map((idx) => idx + startIdx))
      );
    }
    if (this.renderer.states.strokeColor) {
      this.geometry.edges.push(
        ...input.edges.map((edge) => edge.map((idx) => idx + startIdx))
      );
    }
    const vertexColors = [...input.vertexColors];
    while (vertexColors.length < input.vertices.length * 4) {
      vertexColors.push(...this.renderer.states.curFillColor);
    }
    this.geometry.vertexColors.push(...vertexColors);
  }
  /**
   * Adds geometry from the renderer's immediate mode into the builder's
   * combined geometry.
   */
  addImmediate(geometry2, shapeMode, { validateFaces = false } = {}) {
    const faces = [];
    if (this.renderer.states.fillColor) {
      if (shapeMode === TRIANGLE_STRIP || shapeMode === QUAD_STRIP) {
        for (let i = 2; i < geometry2.vertices.length; i++) {
          if (i % 2 === 0) {
            faces.push([i, i - 1, i - 2]);
          } else {
            faces.push([i, i - 2, i - 1]);
          }
        }
      } else if (shapeMode === TRIANGLE_FAN) {
        for (let i = 2; i < geometry2.vertices.length; i++) {
          faces.push([0, i - 1, i]);
        }
      } else if (shapeMode === TRIANGLES) {
        for (let i = 0; i < geometry2.vertices.length; i += 3) {
          if (!validateFaces || geometry2.vertices[i].copy().sub(geometry2.vertices[i + 1]).cross(geometry2.vertices[i].copy().sub(geometry2.vertices[i + 2])).magSq() > 0) {
            faces.push([i, i + 1, i + 2]);
          }
        }
      }
    }
    this.addGeometry(Object.assign({}, geometry2, { faces }));
  }
  /**
   * Adds geometry from the renderer's retained mode into the builder's
   * combined geometry.
   */
  addRetained(geometry2) {
    this.addGeometry(geometry2);
  }
  /**
   * Cleans up the state of the renderer and returns the combined geometry that
   * was built.
   * @returns p5.Geometry The flattened, combined geometry
   */
  finish() {
    this.renderer._pInst.pop();
    return this.geometry;
  }
}
GeometryBuilder.nextGeometryId = 0;
class Quat {
  constructor(w, x, y, z) {
    this.w = w;
    this.vec = new Vector(x, y, z);
  }
  /**
   * Returns a Quaternion for the
   * axis angle representation of the rotation
   *
   * @method fromAxisAngle
   * @param {Number} [angle] Angle with which the points needs to be rotated
   * @param {Number} [x] x component of the axis vector
   * @param {Number} [y] y component of the axis vector
   * @param {Number} [z] z component of the axis vector
   * @chainable
   */
  static fromAxisAngle(angle, x, y, z) {
    const w = Math.cos(angle / 2);
    const vec = new Vector(x, y, z).normalize().mult(Math.sin(angle / 2));
    return new Quat(w, vec.x, vec.y, vec.z);
  }
  conjugate() {
    return new Quat(this.w, -this.vec.x, -this.vec.y, -this.vec.z);
  }
  /**
   * Multiplies a quaternion with other quaternion.
   * @method mult
   * @param  {p5.Quat} [quat] quaternion to multiply with the quaternion calling the method.
   * @chainable
   */
  multiply(quat2) {
    return new Quat(
      this.w * quat2.w - this.vec.x * quat2.vec.x - this.vec.y * quat2.vec.y - this.vec.z - quat2.vec.z,
      this.w * quat2.vec.x + this.vec.x * quat2.w + this.vec.y * quat2.vec.z - this.vec.z * quat2.vec.y,
      this.w * quat2.vec.y - this.vec.x * quat2.vec.z + this.vec.y * quat2.w + this.vec.z * quat2.vec.x,
      this.w * quat2.vec.z + this.vec.x * quat2.vec.y - this.vec.y * quat2.vec.x + this.vec.z * quat2.w
    );
  }
  /**
   * This is similar to quaternion multiplication
   * but when multipying vector with quaternion
   * the multiplication can be simplified to the below formula.
   * This was taken from the below stackexchange link
   * https://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion/50545#50545
   * @private
   * @param {p5.Vector} [p] vector to rotate on the axis quaternion
   */
  rotateVector(p2) {
    return Vector.mult(p2, this.w * this.w - this.vec.dot(this.vec)).add(Vector.mult(this.vec, 2 * p2.dot(this.vec))).add(Vector.mult(this.vec, 2 * this.w).cross(p2)).clampToZero();
  }
  /**
   * Rotates the Quaternion by the quaternion passed
   * which contains the axis of roation and angle of rotation
   *
   * @method rotateBy
   * @param {p5.Quat} [axesQuat] axis quaternion which contains
   *  the axis of rotation and angle of rotation
   * @chainable
   */
  rotateBy(axesQuat) {
    return axesQuat.multiply(this).multiply(axesQuat.conjugate()).vec.clampToZero();
  }
}
function quat(p53, fn2) {
  p53.Quat = Quat;
}
if (typeof p5 !== "undefined") {
  quat(p5, p5.prototype);
}
var libtess_min$1 = { exports: {} };
var libtess_min = libtess_min$1.exports;
var hasRequiredLibtess_min;
function requireLibtess_min() {
  if (hasRequiredLibtess_min) return libtess_min$1.exports;
  hasRequiredLibtess_min = 1;
  (function(module) {
    var n2;
    function t(a, b2) {
      return a.b === b2.b && a.a === b2.a;
    }
    function u(a, b2) {
      return a.b < b2.b || a.b === b2.b && a.a <= b2.a;
    }
    function v(a, b2, c) {
      var d2 = b2.b - a.b, e2 = c.b - b2.b;
      return 0 < d2 + e2 ? d2 < e2 ? b2.a - a.a + d2 / (d2 + e2) * (a.a - c.a) : b2.a - c.a + e2 / (d2 + e2) * (c.a - a.a) : 0;
    }
    function x(a, b2, c) {
      var d2 = b2.b - a.b, e2 = c.b - b2.b;
      return 0 < d2 + e2 ? (b2.a - c.a) * d2 + (b2.a - a.a) * e2 : 0;
    }
    function z(a, b2) {
      return a.a < b2.a || a.a === b2.a && a.b <= b2.b;
    }
    function aa(a, b2, c) {
      var d2 = b2.a - a.a, e2 = c.a - b2.a;
      return 0 < d2 + e2 ? d2 < e2 ? b2.b - a.b + d2 / (d2 + e2) * (a.b - c.b) : b2.b - c.b + e2 / (d2 + e2) * (c.b - a.b) : 0;
    }
    function ba(a, b2, c) {
      var d2 = b2.a - a.a, e2 = c.a - b2.a;
      return 0 < d2 + e2 ? (b2.b - c.b) * d2 + (b2.b - a.b) * e2 : 0;
    }
    function ca(a) {
      return u(a.b.a, a.a);
    }
    function da(a) {
      return u(a.a, a.b.a);
    }
    function A(a, b2, c, d2) {
      a = 0 > a ? 0 : a;
      c = 0 > c ? 0 : c;
      return a <= c ? 0 === c ? (b2 + d2) / 2 : b2 + a / (a + c) * (d2 - b2) : d2 + c / (a + c) * (b2 - d2);
    }
    function ea(a) {
      var b2 = B(a.b);
      C(b2, a.c);
      C(b2.b, a.c);
      D2(b2, a.a);
      return b2;
    }
    function E(a, b2) {
      var c = false, d2 = false;
      a !== b2 && (b2.a !== a.a && (d2 = true, F2(b2.a, a.a)), b2.d !== a.d && (c = true, G2(b2.d, a.d)), H2(b2, a), d2 || (C(b2, a.a), a.a.c = a), c || (D2(b2, a.d), a.d.a = a));
    }
    function I(a) {
      var b2 = a.b, c = false;
      a.d !== a.b.d && (c = true, G2(a.d, a.b.d));
      a.c === a ? F2(a.a, null) : (a.b.d.a = J2(a), a.a.c = a.c, H2(a, J2(a)), c || D2(a, a.d));
      b2.c === b2 ? (F2(b2.a, null), G2(b2.d, null)) : (a.d.a = J2(b2), b2.a.c = b2.c, H2(b2, J2(b2)));
      fa(a);
    }
    function K(a) {
      var b2 = B(a), c = b2.b;
      H2(b2, a.e);
      b2.a = a.b.a;
      C(c, b2.a);
      b2.d = c.d = a.d;
      b2 = b2.b;
      H2(a.b, J2(a.b));
      H2(a.b, b2);
      a.b.a = b2.a;
      b2.b.a.c = b2.b;
      b2.b.d = a.b.d;
      b2.f = a.f;
      b2.b.f = a.b.f;
      return b2;
    }
    function L(a, b2) {
      var c = false, d2 = B(a), e2 = d2.b;
      b2.d !== a.d && (c = true, G2(b2.d, a.d));
      H2(d2, a.e);
      H2(e2, b2);
      d2.a = a.b.a;
      e2.a = b2.a;
      d2.d = e2.d = a.d;
      a.d.a = e2;
      c || D2(d2, a.d);
      return d2;
    }
    function B(a) {
      var b2 = new M(), c = new M(), d2 = a.b.h;
      c.h = d2;
      d2.b.h = b2;
      b2.h = a;
      a.b.h = c;
      b2.b = c;
      b2.c = b2;
      b2.e = c;
      c.b = b2;
      c.c = c;
      return c.e = b2;
    }
    function H2(a, b2) {
      var c = a.c, d2 = b2.c;
      c.b.e = b2;
      d2.b.e = a;
      a.c = d2;
      b2.c = c;
    }
    function C(a, b2) {
      var c = b2.f, d2 = new N(b2, c);
      c.e = d2;
      b2.f = d2;
      c = d2.c = a;
      do
        c.a = d2, c = c.c;
      while (c !== a);
    }
    function D2(a, b2) {
      var c = b2.d, d2 = new ga(b2, c);
      c.b = d2;
      b2.d = d2;
      d2.a = a;
      d2.c = b2.c;
      c = a;
      do
        c.d = d2, c = c.e;
      while (c !== a);
    }
    function fa(a) {
      var b2 = a.h;
      a = a.b.h;
      b2.b.h = a;
      a.b.h = b2;
    }
    function F2(a, b2) {
      var c = a.c, d2 = c;
      do
        d2.a = b2, d2 = d2.c;
      while (d2 !== c);
      c = a.f;
      d2 = a.e;
      d2.f = c;
      c.e = d2;
    }
    function G2(a, b2) {
      var c = a.a, d2 = c;
      do
        d2.d = b2, d2 = d2.e;
      while (d2 !== c);
      c = a.d;
      d2 = a.b;
      d2.d = c;
      c.b = d2;
    }
    function ha(a) {
      var b2 = 0;
      Math.abs(a[1]) > Math.abs(a[0]) && (b2 = 1);
      Math.abs(a[2]) > Math.abs(a[b2]) && (b2 = 2);
      return b2;
    }
    var O2 = 4 * 1e150;
    function P(a, b2) {
      a.f += b2.f;
      a.b.f += b2.b.f;
    }
    function ia(a, b2, c) {
      a = a.a;
      b2 = b2.a;
      c = c.a;
      if (b2.b.a === a) return c.b.a === a ? u(b2.a, c.a) ? 0 >= x(c.b.a, b2.a, c.a) : 0 <= x(b2.b.a, c.a, b2.a) : 0 >= x(c.b.a, a, c.a);
      if (c.b.a === a) return 0 <= x(b2.b.a, a, b2.a);
      b2 = v(b2.b.a, a, b2.a);
      a = v(c.b.a, a, c.a);
      return b2 >= a;
    }
    function Q2(a) {
      a.a.i = null;
      var b2 = a.e;
      b2.a.c = b2.c;
      b2.c.a = b2.a;
      a.e = null;
    }
    function ja(a, b2) {
      I(a.a);
      a.c = false;
      a.a = b2;
      b2.i = a;
    }
    function ka(a) {
      var b2 = a.a.a;
      do
        a = R2(a);
      while (a.a.a === b2);
      a.c && (b2 = L(S2(a).a.b, a.a.e), ja(a, b2), a = R2(a));
      return a;
    }
    function la(a, b2, c) {
      var d2 = new ma();
      d2.a = c;
      d2.e = na(a.f, b2.e, d2);
      return c.i = d2;
    }
    function oa(a, b2) {
      switch (a.s) {
        case 100130:
          return 0 !== (b2 & 1);
        case 100131:
          return 0 !== b2;
        case 100132:
          return 0 < b2;
        case 100133:
          return 0 > b2;
        case 100134:
          return 2 <= b2 || -2 >= b2;
      }
      return false;
    }
    function pa(a) {
      var b2 = a.a, c = b2.d;
      c.c = a.d;
      c.a = b2;
      Q2(a);
    }
    function T2(a, b2, c) {
      a = b2;
      for (b2 = b2.a; a !== c; ) {
        a.c = false;
        var d2 = S2(a), e2 = d2.a;
        if (e2.a !== b2.a) {
          if (!d2.c) {
            pa(a);
            break;
          }
          e2 = L(b2.c.b, e2.b);
          ja(d2, e2);
        }
        b2.c !== e2 && (E(J2(e2), e2), E(b2, e2));
        pa(a);
        b2 = d2.a;
        a = d2;
      }
      return b2;
    }
    function U2(a, b2, c, d2, e2, f) {
      var g2 = true;
      do
        la(a, b2, c.b), c = c.c;
      while (c !== d2);
      for (null === e2 && (e2 = S2(b2).a.b.c); ; ) {
        d2 = S2(b2);
        c = d2.a.b;
        if (c.a !== e2.a) break;
        c.c !== e2 && (E(J2(c), c), E(J2(e2), c));
        d2.f = b2.f - c.f;
        d2.d = oa(a, d2.f);
        b2.b = true;
        !g2 && qa(a, b2) && (P(c, e2), Q2(b2), I(e2));
        g2 = false;
        b2 = d2;
        e2 = c;
      }
      b2.b = true;
      f && ra(a, b2);
    }
    function sa(a, b2, c, d2, e2) {
      var f = [b2.g[0], b2.g[1], b2.g[2]];
      b2.d = null;
      b2.d = a.o ? a.o(f, c, d2, a.c) || null : null;
      null === b2.d && (e2 ? a.n || (V(a, 100156), a.n = true) : b2.d = c[0]);
    }
    function ta(a, b2, c) {
      var d2 = [null, null, null, null];
      d2[0] = b2.a.d;
      d2[1] = c.a.d;
      sa(a, b2.a, d2, [0.5, 0.5, 0, 0], false);
      E(b2, c);
    }
    function ua(a, b2, c, d2, e2) {
      var f = Math.abs(b2.b - a.b) + Math.abs(b2.a - a.a), g2 = Math.abs(c.b - a.b) + Math.abs(c.a - a.a), h = e2 + 1;
      d2[e2] = 0.5 * g2 / (f + g2);
      d2[h] = 0.5 * f / (f + g2);
      a.g[0] += d2[e2] * b2.g[0] + d2[h] * c.g[0];
      a.g[1] += d2[e2] * b2.g[1] + d2[h] * c.g[1];
      a.g[2] += d2[e2] * b2.g[2] + d2[h] * c.g[2];
    }
    function qa(a, b2) {
      var c = S2(b2), d2 = b2.a, e2 = c.a;
      if (u(d2.a, e2.a)) {
        if (0 < x(e2.b.a, d2.a, e2.a)) return false;
        if (!t(d2.a, e2.a)) K(e2.b), E(d2, J2(e2)), b2.b = c.b = true;
        else if (d2.a !== e2.a) {
          var c = a.e, f = d2.a.h;
          if (0 <= f) {
            var c = c.b, g2 = c.d, h = c.e, k = c.c, l = k[f];
            g2[l] = g2[c.a];
            k[g2[l]] = l;
            l <= --c.a && (1 >= l ? W2(c, l) : u(h[g2[l >> 1]], h[g2[l]]) ? W2(c, l) : va(c, l));
            h[f] = null;
            k[f] = c.b;
            c.b = f;
          } else for (c.c[-(f + 1)] = null; 0 < c.a && null === c.c[c.d[c.a - 1]]; ) --c.a;
          ta(a, J2(e2), d2);
        }
      } else {
        if (0 > x(d2.b.a, e2.a, d2.a)) return false;
        R2(b2).b = b2.b = true;
        K(d2.b);
        E(J2(e2), d2);
      }
      return true;
    }
    function wa(a, b2) {
      var c = S2(b2), d2 = b2.a, e2 = c.a, f = d2.a, g2 = e2.a, h = d2.b.a, k = e2.b.a, l = new N();
      x(h, a.a, f);
      x(k, a.a, g2);
      if (f === g2 || Math.min(f.a, h.a) > Math.max(g2.a, k.a)) return false;
      if (u(f, g2)) {
        if (0 < x(k, f, g2)) return false;
      } else if (0 > x(h, g2, f)) return false;
      var r = h, p2 = f, q = k, y = g2, m, w;
      u(r, p2) || (m = r, r = p2, p2 = m);
      u(q, y) || (m = q, q = y, y = m);
      u(r, q) || (m = r, r = q, q = m, m = p2, p2 = y, y = m);
      u(q, p2) ? u(p2, y) ? (m = v(r, q, p2), w = v(q, p2, y), 0 > m + w && (m = -m, w = -w), l.b = A(m, q.b, w, p2.b)) : (m = x(r, q, p2), w = -x(r, y, p2), 0 > m + w && (m = -m, w = -w), l.b = A(m, q.b, w, y.b)) : l.b = (q.b + p2.b) / 2;
      z(r, p2) || (m = r, r = p2, p2 = m);
      z(q, y) || (m = q, q = y, y = m);
      z(r, q) || (m = r, r = q, q = m, m = p2, p2 = y, y = m);
      z(q, p2) ? z(p2, y) ? (m = aa(r, q, p2), w = aa(q, p2, y), 0 > m + w && (m = -m, w = -w), l.a = A(m, q.a, w, p2.a)) : (m = ba(r, q, p2), w = -ba(r, y, p2), 0 > m + w && (m = -m, w = -w), l.a = A(m, q.a, w, y.a)) : l.a = (q.a + p2.a) / 2;
      u(l, a.a) && (l.b = a.a.b, l.a = a.a.a);
      r = u(f, g2) ? f : g2;
      u(r, l) && (l.b = r.b, l.a = r.a);
      if (t(l, f) || t(l, g2)) return qa(a, b2), false;
      if (!t(h, a.a) && 0 <= x(h, a.a, l) || !t(k, a.a) && 0 >= x(k, a.a, l)) {
        if (k === a.a) return K(d2.b), E(e2.b, d2), b2 = ka(b2), d2 = S2(b2).a, T2(a, S2(b2), c), U2(a, b2, J2(d2), d2, d2, true), true;
        if (h === a.a) {
          K(e2.b);
          E(d2.e, J2(e2));
          f = c = b2;
          g2 = f.a.b.a;
          do
            f = R2(f);
          while (f.a.b.a === g2);
          b2 = f;
          f = S2(b2).a.b.c;
          c.a = J2(e2);
          e2 = T2(a, c, null);
          U2(a, b2, e2.c, d2.b.c, f, true);
          return true;
        }
        0 <= x(h, a.a, l) && (R2(b2).b = b2.b = true, K(d2.b), d2.a.b = a.a.b, d2.a.a = a.a.a);
        0 >= x(k, a.a, l) && (b2.b = c.b = true, K(e2.b), e2.a.b = a.a.b, e2.a.a = a.a.a);
        return false;
      }
      K(d2.b);
      K(e2.b);
      E(J2(e2), d2);
      d2.a.b = l.b;
      d2.a.a = l.a;
      d2.a.h = xa(a.e, d2.a);
      d2 = d2.a;
      e2 = [0, 0, 0, 0];
      l = [f.d, h.d, g2.d, k.d];
      d2.g[0] = d2.g[1] = d2.g[2] = 0;
      ua(d2, f, h, e2, 0);
      ua(d2, g2, k, e2, 2);
      sa(a, d2, l, e2, true);
      R2(b2).b = b2.b = c.b = true;
      return false;
    }
    function ra(a, b2) {
      for (var c = S2(b2); ; ) {
        for (; c.b; ) b2 = c, c = S2(c);
        if (!b2.b && (c = b2, b2 = R2(b2), null === b2 || !b2.b)) break;
        b2.b = false;
        var d2 = b2.a, e2 = c.a, f;
        if (f = d2.b.a !== e2.b.a) a: {
          f = b2;
          var g2 = S2(f), h = f.a, k = g2.a, l = void 0;
          if (u(h.b.a, k.b.a)) {
            if (0 > x(h.b.a, k.b.a, h.a)) {
              f = false;
              break a;
            }
            R2(f).b = f.b = true;
            l = K(h);
            E(k.b, l);
            l.d.c = f.d;
          } else {
            if (0 < x(k.b.a, h.b.a, k.a)) {
              f = false;
              break a;
            }
            f.b = g2.b = true;
            l = K(k);
            E(h.e, k.b);
            l.b.d.c = f.d;
          }
          f = true;
        }
        f && (c.c ? (Q2(c), I(e2), c = S2(b2), e2 = c.a) : b2.c && (Q2(b2), I(d2), b2 = R2(c), d2 = b2.a));
        if (d2.a !== e2.a) {
          if (d2.b.a === e2.b.a || b2.c || c.c || d2.b.a !== a.a && e2.b.a !== a.a) qa(
            a,
            b2
          );
          else if (wa(a, b2)) break;
        }
        d2.a === e2.a && d2.b.a === e2.b.a && (P(e2, d2), Q2(b2), I(d2), b2 = R2(c));
      }
    }
    function ya(a, b2) {
      a.a = b2;
      for (var c = b2.c; null === c.i; ) if (c = c.c, c === b2.c) {
        var c = a, d2 = b2, e2 = new ma();
        e2.a = d2.c.b;
        var f = c.f, g2 = f.a;
        do
          g2 = g2.a;
        while (null !== g2.b && !f.c(f.b, e2, g2.b));
        var f = g2.b, h = S2(f), e2 = f.a, g2 = h.a;
        if (0 === x(e2.b.a, d2, e2.a)) e2 = f.a, t(e2.a, d2) || t(e2.b.a, d2) || (K(e2.b), f.c && (I(e2.c), f.c = false), E(d2.c, e2), ya(c, d2));
        else {
          var k = u(g2.b.a, e2.b.a) ? f : h, h = void 0;
          f.d || k.c ? (k === f ? h = L(d2.c.b, e2.e) : h = L(g2.b.c.b, d2.c).b, k.c ? ja(k, h) : (e2 = c, f = la(c, f, h), f.f = R2(f).f + f.a.f, f.d = oa(e2, f.f)), ya(c, d2)) : U2(c, f, d2.c, d2.c, null, true);
        }
        return;
      }
      c = ka(c.i);
      e2 = S2(c);
      f = e2.a;
      e2 = T2(
        a,
        e2,
        null
      );
      if (e2.c === f) {
        var f = e2, e2 = f.c, g2 = S2(c), h = c.a, k = g2.a, l = false;
        h.b.a !== k.b.a && wa(a, c);
        t(h.a, a.a) && (E(J2(e2), h), c = ka(c), e2 = S2(c).a, T2(a, S2(c), g2), l = true);
        t(k.a, a.a) && (E(f, J2(k)), f = T2(a, g2, null), l = true);
        l ? U2(a, c, f.c, e2, e2, true) : (u(k.a, h.a) ? d2 = J2(k) : d2 = h, d2 = L(f.c.b, d2), U2(a, c, d2, d2.c, d2.c, false), d2.b.i.c = true, ra(a, c));
      } else U2(a, c, e2.c, f, f, true);
    }
    function za(a, b2) {
      var c = new ma(), d2 = ea(a.b);
      d2.a.b = O2;
      d2.a.a = b2;
      d2.b.a.b = -O2;
      d2.b.a.a = b2;
      a.a = d2.b.a;
      c.a = d2;
      c.f = 0;
      c.d = false;
      c.c = false;
      c.h = true;
      c.b = false;
      d2 = a.f;
      d2 = na(d2, d2.a, c);
      c.e = d2;
    }
    function Aa(a) {
      this.a = new Ba();
      this.b = a;
      this.c = ia;
    }
    function na(a, b2, c) {
      do
        b2 = b2.c;
      while (null !== b2.b && !a.c(a.b, b2.b, c));
      a = new Ba(c, b2.a, b2);
      b2.a.c = a;
      return b2.a = a;
    }
    function Ba(a, b2, c) {
      this.b = a || null;
      this.a = b2 || this;
      this.c = c || this;
    }
    function X2() {
      this.d = Y;
      this.p = this.b = this.q = null;
      this.j = [0, 0, 0];
      this.s = 100130;
      this.n = false;
      this.o = this.a = this.e = this.f = null;
      this.m = false;
      this.c = this.r = this.i = this.k = this.l = this.h = null;
    }
    var Y = 0;
    n2 = X2.prototype;
    n2.x = function() {
      Z2(this, Y);
    };
    n2.B = function(a, b2) {
      switch (a) {
        case 100142:
          return;
        case 100140:
          switch (b2) {
            case 100130:
            case 100131:
            case 100132:
            case 100133:
            case 100134:
              this.s = b2;
              return;
          }
          break;
        case 100141:
          this.m = !!b2;
          return;
        default:
          V(this, 100900);
          return;
      }
      V(this, 100901);
    };
    n2.y = function(a) {
      switch (a) {
        case 100142:
          return 0;
        case 100140:
          return this.s;
        case 100141:
          return this.m;
        default:
          V(this, 100900);
      }
      return false;
    };
    n2.A = function(a, b2, c) {
      this.j[0] = a;
      this.j[1] = b2;
      this.j[2] = c;
    };
    n2.z = function(a, b2) {
      var c = b2 ? b2 : null;
      switch (a) {
        case 100100:
        case 100106:
          this.h = c;
          break;
        case 100104:
        case 100110:
          this.l = c;
          break;
        case 100101:
        case 100107:
          this.k = c;
          break;
        case 100102:
        case 100108:
          this.i = c;
          break;
        case 100103:
        case 100109:
          this.p = c;
          break;
        case 100105:
        case 100111:
          this.o = c;
          break;
        case 100112:
          this.r = c;
          break;
        default:
          V(this, 100900);
      }
    };
    n2.C = function(a, b2) {
      var c = false, d2 = [0, 0, 0];
      Z2(this, 2);
      for (var e2 = 0; 3 > e2; ++e2) {
        var f = a[e2];
        -1e150 > f && (f = -1e150, c = true);
        1e150 < f && (f = 1e150, c = true);
        d2[e2] = f;
      }
      c && V(this, 100155);
      c = this.q;
      null === c ? (c = ea(this.b), E(c, c.b)) : (K(c), c = c.e);
      c.a.d = b2;
      c.a.g[0] = d2[0];
      c.a.g[1] = d2[1];
      c.a.g[2] = d2[2];
      c.f = 1;
      c.b.f = -1;
      this.q = c;
    };
    n2.u = function(a) {
      Z2(this, Y);
      this.d = 1;
      this.b = new Ca();
      this.c = a;
    };
    n2.t = function() {
      Z2(this, 1);
      this.d = 2;
      this.q = null;
    };
    n2.v = function() {
      Z2(this, 2);
      this.d = 1;
    };
    n2.w = function() {
      Z2(this, 1);
      this.d = Y;
      var a = this.j[0], b2 = this.j[1], c = this.j[2], d2 = false, e2 = [a, b2, c];
      if (0 === a && 0 === b2 && 0 === c) {
        for (var b2 = [-2 * 1e150, -2 * 1e150, -2 * 1e150], f = [2 * 1e150, 2 * 1e150, 2 * 1e150], c = [], g2 = [], d2 = this.b.c, a = d2.e; a !== d2; a = a.e) for (var h = 0; 3 > h; ++h) {
          var k = a.g[h];
          k < f[h] && (f[h] = k, g2[h] = a);
          k > b2[h] && (b2[h] = k, c[h] = a);
        }
        a = 0;
        b2[1] - f[1] > b2[0] - f[0] && (a = 1);
        b2[2] - f[2] > b2[a] - f[a] && (a = 2);
        if (f[a] >= b2[a]) e2[0] = 0, e2[1] = 0, e2[2] = 1;
        else {
          b2 = 0;
          f = g2[a];
          c = c[a];
          g2 = [0, 0, 0];
          f = [f.g[0] - c.g[0], f.g[1] - c.g[1], f.g[2] - c.g[2]];
          h = [0, 0, 0];
          for (a = d2.e; a !== d2; a = a.e) h[0] = a.g[0] - c.g[0], h[1] = a.g[1] - c.g[1], h[2] = a.g[2] - c.g[2], g2[0] = f[1] * h[2] - f[2] * h[1], g2[1] = f[2] * h[0] - f[0] * h[2], g2[2] = f[0] * h[1] - f[1] * h[0], k = g2[0] * g2[0] + g2[1] * g2[1] + g2[2] * g2[2], k > b2 && (b2 = k, e2[0] = g2[0], e2[1] = g2[1], e2[2] = g2[2]);
          0 >= b2 && (e2[0] = e2[1] = e2[2] = 0, e2[ha(f)] = 1);
        }
        d2 = true;
      }
      g2 = ha(e2);
      a = this.b.c;
      b2 = (g2 + 1) % 3;
      c = (g2 + 2) % 3;
      g2 = 0 < e2[g2] ? 1 : -1;
      for (e2 = a.e; e2 !== a; e2 = e2.e) e2.b = e2.g[b2], e2.a = g2 * e2.g[c];
      if (d2) {
        e2 = 0;
        d2 = this.b.a;
        for (a = d2.b; a !== d2; a = a.b) if (b2 = a.a, !(0 >= b2.f)) {
          do
            e2 += (b2.a.b - b2.b.a.b) * (b2.a.a + b2.b.a.a), b2 = b2.e;
          while (b2 !== a.a);
        }
        if (0 > e2) for (e2 = this.b.c, d2 = e2.e; d2 !== e2; d2 = d2.e) d2.a = -d2.a;
      }
      this.n = false;
      e2 = this.b.b;
      for (a = e2.h; a !== e2; a = d2) if (d2 = a.h, b2 = a.e, t(a.a, a.b.a) && a.e.e !== a && (ta(this, b2, a), I(a), a = b2, b2 = a.e), b2.e === a) {
        if (b2 !== a) {
          if (b2 === d2 || b2 === d2.b) d2 = d2.h;
          I(b2);
        }
        if (a === d2 || a === d2.b) d2 = d2.h;
        I(a);
      }
      this.e = e2 = new Da();
      d2 = this.b.c;
      for (a = d2.e; a !== d2; a = a.e) a.h = xa(e2, a);
      Ea(e2);
      this.f = new Aa(this);
      za(this, -O2);
      for (za(this, O2); null !== (e2 = Fa(this.e)); ) {
        for (; ; ) {
          a: if (a = this.e, 0 === a.a) d2 = Ga(a.b);
          else if (d2 = a.c[a.d[a.a - 1]], 0 !== a.b.a && (a = Ga(a.b), u(a, d2))) {
            d2 = a;
            break a;
          }
          if (null === d2 || !t(d2, e2)) break;
          d2 = Fa(this.e);
          ta(
            this,
            e2.c,
            d2.c
          );
        }
        ya(this, e2);
      }
      this.a = this.f.a.a.b.a.a;
      for (e2 = 0; null !== (d2 = this.f.a.a.b); ) d2.h || ++e2, Q2(d2);
      this.f = null;
      e2 = this.e;
      e2.b = null;
      e2.d = null;
      this.e = e2.c = null;
      e2 = this.b;
      for (a = e2.a.b; a !== e2.a; a = d2) d2 = a.b, a = a.a, a.e.e === a && (P(a.c, a), I(a));
      if (!this.n) {
        e2 = this.b;
        if (this.m) for (a = e2.b.h; a !== e2.b; a = d2) d2 = a.h, a.b.d.c !== a.d.c ? a.f = a.d.c ? 1 : -1 : I(a);
        else for (a = e2.a.b; a !== e2.a; a = d2) if (d2 = a.b, a.c) {
          for (a = a.a; u(a.b.a, a.a); a = a.c.b) ;
          for (; u(a.a, a.b.a); a = a.e) ;
          b2 = a.c.b;
          for (c = void 0; a.e !== b2; ) if (u(a.b.a, b2.a)) {
            for (; b2.e !== a && (ca(b2.e) || 0 >= x(b2.a, b2.b.a, b2.e.b.a)); ) c = L(b2.e, b2), b2 = c.b;
            b2 = b2.c.b;
          } else {
            for (; b2.e !== a && (da(a.c.b) || 0 <= x(a.b.a, a.a, a.c.b.a)); ) c = L(a, a.c.b), a = c.b;
            a = a.e;
          }
          for (; b2.e.e !== a; ) c = L(b2.e, b2), b2 = c.b;
        }
        if (this.h || this.i || this.k || this.l) if (this.m) for (e2 = this.b, d2 = e2.a.b; d2 !== e2.a; d2 = d2.b) {
          if (d2.c) {
            this.h && this.h(2, this.c);
            a = d2.a;
            do
              this.k && this.k(a.a.d, this.c), a = a.e;
            while (a !== d2.a);
            this.i && this.i(this.c);
          }
        }
        else {
          e2 = this.b;
          d2 = !!this.l;
          a = false;
          b2 = -1;
          for (c = e2.a.d; c !== e2.a; c = c.d) if (c.c) {
            a || (this.h && this.h(4, this.c), a = true);
            g2 = c.a;
            do
              d2 && (f = g2.b.d.c ? 0 : 1, b2 !== f && (b2 = f, this.l && this.l(!!b2, this.c))), this.k && this.k(g2.a.d, this.c), g2 = g2.e;
            while (g2 !== c.a);
          }
          a && this.i && this.i(this.c);
        }
        if (this.r) {
          e2 = this.b;
          for (a = e2.a.b; a !== e2.a; a = d2) if (d2 = a.b, !a.c) {
            b2 = a.a;
            c = b2.e;
            g2 = void 0;
            do
              g2 = c, c = g2.e, g2.d = null, null === g2.b.d && (g2.c === g2 ? F2(g2.a, null) : (g2.a.c = g2.c, H2(g2, J2(g2))), f = g2.b, f.c === f ? F2(f.a, null) : (f.a.c = f.c, H2(f, J2(f))), fa(g2));
            while (g2 !== b2);
            b2 = a.d;
            a = a.b;
            a.d = b2;
            b2.b = a;
          }
          this.r(this.b);
          this.c = this.b = null;
          return;
        }
      }
      this.b = this.c = null;
    };
    function Z2(a, b2) {
      if (a.d !== b2) for (; a.d !== b2; ) if (a.d < b2) switch (a.d) {
        case Y:
          V(a, 100151);
          a.u(null);
          break;
        case 1:
          V(a, 100152), a.t();
      }
      else switch (a.d) {
        case 2:
          V(a, 100154);
          a.v();
          break;
        case 1:
          V(a, 100153), a.w();
      }
    }
    function V(a, b2) {
      a.p && a.p(b2, a.c);
    }
    function ga(a, b2) {
      this.b = a || this;
      this.d = b2 || this;
      this.a = null;
      this.c = false;
    }
    function M() {
      this.h = this;
      this.i = this.d = this.a = this.e = this.c = this.b = null;
      this.f = 0;
    }
    function J2(a) {
      return a.b.e;
    }
    function Ca() {
      this.c = new N();
      this.a = new ga();
      this.b = new M();
      this.d = new M();
      this.b.b = this.d;
      this.d.b = this.b;
    }
    function N(a, b2) {
      this.e = a || this;
      this.f = b2 || this;
      this.d = this.c = null;
      this.g = [0, 0, 0];
      this.h = this.a = this.b = 0;
    }
    function Da() {
      this.c = [];
      this.d = null;
      this.a = 0;
      this.e = false;
      this.b = new Ha();
    }
    function Ea(a) {
      a.d = [];
      for (var b2 = 0; b2 < a.a; b2++) a.d[b2] = b2;
      a.d.sort(/* @__PURE__ */ (function(a2) {
        return function(b3, e2) {
          return u(a2[b3], a2[e2]) ? 1 : -1;
        };
      })(a.c));
      a.e = true;
      Ia(a.b);
    }
    function xa(a, b2) {
      if (a.e) {
        var c = a.b, d2 = ++c.a;
        2 * d2 > c.f && (c.f *= 2, c.c = Ja(c.c, c.f + 1));
        var e2;
        0 === c.b ? e2 = d2 : (e2 = c.b, c.b = c.c[c.b]);
        c.e[e2] = b2;
        c.c[e2] = d2;
        c.d[d2] = e2;
        c.h && va(c, d2);
        return e2;
      }
      c = a.a++;
      a.c[c] = b2;
      return -(c + 1);
    }
    function Fa(a) {
      if (0 === a.a) return Ka(a.b);
      var b2 = a.c[a.d[a.a - 1]];
      if (0 !== a.b.a && u(Ga(a.b), b2)) return Ka(a.b);
      do
        --a.a;
      while (0 < a.a && null === a.c[a.d[a.a - 1]]);
      return b2;
    }
    function Ha() {
      this.d = Ja([0], 33);
      this.e = [null, null];
      this.c = [0, 0];
      this.a = 0;
      this.f = 32;
      this.b = 0;
      this.h = false;
      this.d[1] = 1;
    }
    function Ja(a, b2) {
      for (var c = Array(b2), d2 = 0; d2 < a.length; d2++) c[d2] = a[d2];
      for (; d2 < b2; d2++) c[d2] = 0;
      return c;
    }
    function Ia(a) {
      for (var b2 = a.a; 1 <= b2; --b2) W2(a, b2);
      a.h = true;
    }
    function Ga(a) {
      return a.e[a.d[1]];
    }
    function Ka(a) {
      var b2 = a.d, c = a.e, d2 = a.c, e2 = b2[1], f = c[e2];
      0 < a.a && (b2[1] = b2[a.a], d2[b2[1]] = 1, c[e2] = null, d2[e2] = a.b, a.b = e2, 0 < --a.a && W2(a, 1));
      return f;
    }
    function W2(a, b2) {
      for (var c = a.d, d2 = a.e, e2 = a.c, f = b2, g2 = c[f]; ; ) {
        var h = f << 1;
        h < a.a && u(d2[c[h + 1]], d2[c[h]]) && (h += 1);
        var k = c[h];
        if (h > a.a || u(d2[g2], d2[k])) {
          c[f] = g2;
          e2[g2] = f;
          break;
        }
        c[f] = k;
        e2[k] = f;
        f = h;
      }
    }
    function va(a, b2) {
      for (var c = a.d, d2 = a.e, e2 = a.c, f = b2, g2 = c[f]; ; ) {
        var h = f >> 1, k = c[h];
        if (0 === h || u(d2[k], d2[g2])) {
          c[f] = g2;
          e2[g2] = f;
          break;
        }
        c[f] = k;
        e2[k] = f;
        f = h;
      }
    }
    function ma() {
      this.e = this.a = null;
      this.f = 0;
      this.c = this.b = this.h = this.d = false;
    }
    function S2(a) {
      return a.e.c.b;
    }
    function R2(a) {
      return a.e.a.b;
    }
    libtess_min.libtess = {
      GluTesselator: X2,
      windingRule: { GLU_TESS_WINDING_ODD: 100130, GLU_TESS_WINDING_NONZERO: 100131, GLU_TESS_WINDING_POSITIVE: 100132, GLU_TESS_WINDING_NEGATIVE: 100133, GLU_TESS_WINDING_ABS_GEQ_TWO: 100134 },
      primitiveType: { GL_LINE_LOOP: 2, GL_TRIANGLES: 4, GL_TRIANGLE_STRIP: 5, GL_TRIANGLE_FAN: 6 },
      errorType: { GLU_TESS_MISSING_BEGIN_POLYGON: 100151, GLU_TESS_MISSING_END_POLYGON: 100153, GLU_TESS_MISSING_BEGIN_CONTOUR: 100152, GLU_TESS_MISSING_END_CONTOUR: 100154, GLU_TESS_COORD_TOO_LARGE: 100155, GLU_TESS_NEED_COMBINE_CALLBACK: 100156 },
      gluEnum: { GLU_TESS_MESH: 100112, GLU_TESS_TOLERANCE: 100142, GLU_TESS_WINDING_RULE: 100140, GLU_TESS_BOUNDARY_ONLY: 100141, GLU_INVALID_ENUM: 100900, GLU_INVALID_VALUE: 100901, GLU_TESS_BEGIN: 100100, GLU_TESS_VERTEX: 100101, GLU_TESS_END: 100102, GLU_TESS_ERROR: 100103, GLU_TESS_EDGE_FLAG: 100104, GLU_TESS_COMBINE: 100105, GLU_TESS_BEGIN_DATA: 100106, GLU_TESS_VERTEX_DATA: 100107, GLU_TESS_END_DATA: 100108, GLU_TESS_ERROR_DATA: 100109, GLU_TESS_EDGE_FLAG_DATA: 100110, GLU_TESS_COMBINE_DATA: 100111 }
    };
    X2.prototype.gluDeleteTess = X2.prototype.x;
    X2.prototype.gluTessProperty = X2.prototype.B;
    X2.prototype.gluGetTessProperty = X2.prototype.y;
    X2.prototype.gluTessNormal = X2.prototype.A;
    X2.prototype.gluTessCallback = X2.prototype.z;
    X2.prototype.gluTessVertex = X2.prototype.C;
    X2.prototype.gluTessBeginPolygon = X2.prototype.u;
    X2.prototype.gluTessBeginContour = X2.prototype.t;
    X2.prototype.gluTessEndContour = X2.prototype.v;
    X2.prototype.gluTessEndPolygon = X2.prototype.w;
    {
      module.exports = libtess_min.libtess;
    }
  })(libtess_min$1);
  return libtess_min$1.exports;
}
var libtess_minExports = requireLibtess_min();
const libtess = /* @__PURE__ */ getDefaultExportFromCjs(libtess_minExports);
class RenderBuffer {
  constructor(size, src, dst, attr, renderer2, map2) {
    this.size = size;
    this.src = src;
    this.dst = dst;
    this.attr = attr;
    this._renderer = renderer2;
    this.map = map2;
  }
  default(cb) {
    this.default = cb;
    return this;
  }
  /**
   * Enables and binds the buffers used by shader when the appropriate data exists in geometry.
   * Must always be done prior to drawing geometry in WebGL.
   * @param {p5.Geometry} geometry Geometry that is going to be drawn
   * @param {p5.Shader} shader Active shader
   * @private
   */
  _prepareBuffer(geometry2, shader2) {
    this._renderer._prepareBuffer(this, geometry2, shader2);
  }
}
function renderBuffer(p53, fn2) {
  p53.RenderBuffer = RenderBuffer;
}
if (typeof p5 !== "undefined") {
  renderBuffer(p5, p5.prototype);
}
const INITIAL_BUFFER_STRIDES = {
  vertices: 1,
  vertexNormals: 1,
  vertexColors: 4,
  vertexStrokeColors: 4,
  uvs: 2
};
const INITIAL_VERTEX_SIZE = Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next) => acc + next);
class ShapeBuilder {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.shapeMode = PATH;
    this.geometry = new Geometry(
      void 0,
      void 0,
      void 0,
      this.renderer
    );
    this.geometry.gid = "__IMMEDIATE_MODE_GEOMETRY__";
    this.contourIndices = [];
    this._useUserVertexProperties = void 0;
    this._bezierVertex = [];
    this._quadraticVertex = [];
    this._curveVertex = [];
    this.isProcessingVertices = false;
    this._tessy = this._initTessy();
    this.tessyVertexSize = INITIAL_VERTEX_SIZE;
    this.bufferStrides = { ...INITIAL_BUFFER_STRIDES };
  }
  constructFromContours(shape2, contours) {
    if (this._useUserVertexProperties) {
      this._resetUserVertexProperties();
    }
    this.geometry.reset();
    this.contourIndices = [];
    this.shapeMode = shape2.contours[0].kind;
    const shouldProcessEdges = !!this.renderer.states.strokeColor;
    const userVertexPropertyHelpers = {};
    if (shape2.userVertexProperties) {
      this._useUserVertexProperties = true;
      for (const key in shape2.userVertexProperties) {
        const name = shape2.vertexPropertyName(key);
        const prop = this.geometry._userVertexPropertyHelper(
          name,
          [],
          shape2.userVertexProperties[key]
        );
        userVertexPropertyHelpers[key] = prop;
        this.tessyVertexSize += prop.getDataSize();
        this.bufferStrides[prop.getSrcName()] = prop.getDataSize();
        this.renderer.buffers.user.push(
          new RenderBuffer(
            prop.getDataSize(),
            prop.getSrcName(),
            prop.getDstName(),
            name,
            this.renderer
          )
        );
      }
    } else {
      this._useUserVertexProperties = false;
    }
    for (const contour of contours) {
      this.contourIndices.push(this.geometry.vertices.length);
      for (const vertex2 of contour) {
        if (this.shapeMode === QUADS) {
          if (this.geometry.vertices.length % 6 === 3) {
            for (const key in this.bufferStrides) {
              const stride = this.bufferStrides[key];
              const buffer = this.geometry[key];
              buffer.push(
                ...buffer.slice(
                  buffer.length - 3 * stride,
                  buffer.length - 2 * stride
                ),
                ...buffer.slice(buffer.length - stride, buffer.length)
              );
            }
          }
        }
        this.geometry.vertices.push(vertex2.position);
        this.geometry.vertexNormals.push(vertex2.normal || new Vector(0, 0, 0));
        this.geometry.uvs.push(
          vertex2.textureCoordinates.x,
          vertex2.textureCoordinates.y
        );
        if (this.renderer.states.fillColor) {
          this.geometry.vertexColors.push(...vertex2.fill.array());
        } else {
          this.geometry.vertexColors.push(0, 0, 0, 0);
        }
        if (this.renderer.states.strokeColor) {
          this.geometry.vertexStrokeColors.push(...vertex2.stroke.array());
        } else {
          this.geometry.vertexStrokeColors.push(0, 0, 0, 0);
        }
        for (const key in userVertexPropertyHelpers) {
          const prop = userVertexPropertyHelpers[key];
          if (key in vertex2) {
            prop.setCurrentData(vertex2[key]);
          }
          prop.pushCurrentData();
        }
      }
    }
    if (shouldProcessEdges) {
      this.geometry.edges = this._calculateEdges(
        this.shapeMode,
        this.geometry.vertices
      );
    }
    if (shouldProcessEdges && !this.renderer.geometryBuilder) {
      this.geometry._edgesToVertices();
    }
    if (this.shapeMode === PATH) {
      this.isProcessingVertices = true;
      this._tesselateShape();
      this.isProcessingVertices = false;
    } else if (this.shapeMode === QUAD_STRIP) {
      this.shapeMode = TRIANGLE_STRIP;
    } else if (this.shapeMode === QUADS) {
      this.shapeMode = TRIANGLES;
    }
    if (this.renderer.states.textureMode === IMAGE && this.renderer.states._tex !== null && this.renderer.states._tex.width > 0 && this.renderer.states._tex.height > 0) {
      this.geometry.uvs = this.geometry.uvs.map((val, i) => {
        if (i % 2 === 0) {
          return val / this.renderer.states._tex.width;
        } else {
          return val / this.renderer.states._tex.height;
        }
      });
    }
  }
  _resetUserVertexProperties() {
    const properties = this.geometry.userVertexProperties;
    for (const propName in properties) {
      const prop = properties[propName];
      delete this.bufferStrides[propName];
      prop.delete();
    }
    this._useUserVertexProperties = false;
    this.tessyVertexSize = INITIAL_VERTEX_SIZE;
    this.geometry.userVertexProperties = {};
  }
  /**
   * Called from _processVertices(). This function calculates the stroke vertices for custom shapes and
   * tesselates shapes when applicable.
   * @private
   * @returns  {Number[]} indices for custom shape vertices indicating edges.
   */
  _calculateEdges(shapeMode, verts) {
    const res = [];
    let i = 0;
    const contourIndices = this.contourIndices.slice();
    let contourStart = -1;
    switch (shapeMode) {
      case TRIANGLE_STRIP:
        for (i = 0; i < verts.length - 2; i++) {
          res.push([i, i + 1]);
          res.push([i, i + 2]);
        }
        res.push([i, i + 1]);
        break;
      case TRIANGLE_FAN:
        for (i = 1; i < verts.length - 1; i++) {
          res.push([0, i]);
          res.push([i, i + 1]);
        }
        res.push([0, verts.length - 1]);
        break;
      case TRIANGLES:
        for (i = 0; i < verts.length - 2; i = i + 3) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 2]);
          res.push([i + 2, i]);
        }
        break;
      case LINES:
        for (i = 0; i < verts.length - 1; i = i + 2) {
          res.push([i, i + 1]);
        }
        break;
      case QUADS:
        for (i = 0; i < verts.length - 5; i += 6) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 2]);
          res.push([i + 2, i + 5]);
          res.push([i + 5, i]);
        }
        break;
      case QUAD_STRIP:
        for (i = 0; i < verts.length - 2; i += 2) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 3]);
          res.push([i, i + 2]);
        }
        res.push([i, i + 1]);
        break;
      default:
        for (i = 0; i < verts.length; i++) {
          if (i === contourIndices[0]) {
            contourStart = contourIndices.shift();
          } else if (verts[contourStart] && verts[i].equals(verts[contourStart])) {
            res.push([i - 1, contourStart]);
          } else {
            res.push([i - 1, i]);
          }
        }
        break;
    }
    return res;
  }
  /**
   * Called from _processVertices() when applicable. This function tesselates immediateMode.geometry.
   * @private
   */
  _tesselateShape() {
    const contours = [];
    for (let i = 0; i < this.geometry.vertices.length; i++) {
      if (this.contourIndices.length > 0 && this.contourIndices[0] === i) {
        this.contourIndices.shift();
        contours.push([]);
      }
      contours[contours.length - 1].push(
        this.geometry.vertices[i].x,
        this.geometry.vertices[i].y,
        this.geometry.vertices[i].z,
        this.geometry.uvs[i * 2],
        this.geometry.uvs[i * 2 + 1],
        this.geometry.vertexColors[i * 4],
        this.geometry.vertexColors[i * 4 + 1],
        this.geometry.vertexColors[i * 4 + 2],
        this.geometry.vertexColors[i * 4 + 3],
        this.geometry.vertexNormals[i].x,
        this.geometry.vertexNormals[i].y,
        this.geometry.vertexNormals[i].z
      );
      for (const propName in this.geometry.userVertexProperties) {
        const prop = this.geometry.userVertexProperties[propName];
        const start2 = i * prop.getDataSize();
        const end = start2 + prop.getDataSize();
        const vals = prop.getSrcArray().slice(start2, end);
        contours[contours.length - 1].push(...vals);
      }
    }
    const polyTriangles = this._triangulate(contours);
    if (polyTriangles.length === 0) {
      return;
    }
    this.shapeMode = TRIANGLES;
    const originalVertices = this.geometry.vertices;
    this.geometry.vertices = [];
    this.geometry.vertexNormals = [];
    this.geometry.uvs = [];
    for (const propName in this.geometry.userVertexProperties) {
      const prop = this.geometry.userVertexProperties[propName];
      prop.resetSrcArray();
    }
    const colors = [];
    for (let j2 = 0, polyTriLength = polyTriangles.length; j2 < polyTriLength; j2 = j2 + this.tessyVertexSize) {
      colors.push(...polyTriangles.slice(j2 + 5, j2 + 9));
      this.geometry.vertexNormals.push(
        new Vector(...polyTriangles.slice(j2 + 9, j2 + 12))
      );
      {
        let offset2 = 12;
        for (const propName in this.geometry.userVertexProperties) {
          const prop = this.geometry.userVertexProperties[propName];
          const size = prop.getDataSize();
          const start2 = j2 + offset2;
          const end = start2 + size;
          prop.setCurrentData(polyTriangles.slice(start2, end));
          prop.pushCurrentData();
          offset2 += size;
        }
      }
      this.geometry.vertices.push(new Vector(...polyTriangles.slice(j2, j2 + 3)));
      this.geometry.uvs.push(...polyTriangles.slice(j2 + 3, j2 + 5));
    }
    if (this.renderer.geometryBuilder) {
      const newIndex = /* @__PURE__ */ new Map();
      this.geometry.edges = this.geometry.edges.map((edge) => edge.map((origIdx) => {
        if (!newIndex.has(origIdx)) {
          const orig = originalVertices[origIdx];
          let newVertIndex = this.geometry.vertices.findIndex(
            (v) => orig.x === v.x && orig.y === v.y && orig.z === v.z
          );
          if (newVertIndex === -1) {
            let closestDist = Infinity;
            let closestIndex = 0;
            for (let i = 0; i < this.geometry.vertices.length; i++) {
              const vert = this.geometry.vertices[i];
              const dX = orig.x - vert.x;
              const dY = orig.y - vert.y;
              const dZ = orig.z - vert.z;
              const dist = dX * dX + dY * dY + dZ * dZ;
              if (dist < closestDist) {
                closestDist = dist;
                closestIndex = i;
              }
            }
            newVertIndex = closestIndex;
          }
          newIndex.set(origIdx, newVertIndex);
        }
        return newIndex.get(origIdx);
      }));
    }
    this.geometry.vertexColors = colors;
  }
  _initTessy() {
    function vertexCallback(data2, polyVertArray) {
      for (const element2 of data2) {
        polyVertArray.push(element2);
      }
    }
    function begincallback(type2) {
      if (type2 !== libtess.primitiveType.GL_TRIANGLES) {
        console.log(`expected TRIANGLES but got type: ${type2}`);
      }
    }
    function errorcallback(errno) {
      console.log("error callback");
      console.log(`error number: ${errno}`);
    }
    const combinecallback = (coords, data2, weight) => {
      const result = new Array(this.tessyVertexSize).fill(0);
      for (let i = 0; i < weight.length; i++) {
        for (let j2 = 0; j2 < result.length; j2++) {
          if (weight[i] === 0 || !data2[i]) continue;
          result[j2] += data2[i][j2] * weight[i];
        }
      }
      return result;
    };
    function edgeCallback(flag) {
    }
    const tessy = new libtess.GluTesselator();
    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, begincallback);
    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, errorcallback);
    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combinecallback);
    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
    tessy.gluTessProperty(
      libtess.gluEnum.GLU_TESS_WINDING_RULE,
      libtess.windingRule.GLU_TESS_WINDING_NONZERO
    );
    return tessy;
  }
  /**
   * Runs vertices through libtess to convert them into triangles
   * @private
   */
  _triangulate(contours) {
    const z = contours[0] ? contours[0][2] : void 0;
    let allSameZ = true;
    for (const contour of contours) {
      for (let j2 = 0; j2 < contour.length; j2 += this.tessyVertexSize) {
        if (contour[j2 + 2] !== z) {
          allSameZ = false;
          break;
        }
      }
    }
    if (allSameZ) {
      this._tessy.gluTessNormal(0, 0, 1);
    } else {
      this._tessy.gluTessNormal(0, 0, 0);
    }
    const triangleVerts = [];
    this._tessy.gluTessBeginPolygon(triangleVerts);
    for (const contour of contours) {
      this._tessy.gluTessBeginContour();
      for (let j2 = 0; j2 < contour.length; j2 += this.tessyVertexSize) {
        const coords = contour.slice(
          j2,
          j2 + this.tessyVertexSize
        );
        this._tessy.gluTessVertex(coords, coords);
      }
      this._tessy.gluTessEndContour();
    }
    this._tessy.gluTessEndPolygon();
    return triangleVerts;
  }
}
class GeometryBufferCache {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.cache = {};
  }
  numCached() {
    return Object.keys(this.cache).length;
  }
  isCached(gid) {
    return this.cache[gid] !== void 0;
  }
  getGeometryByID(gid) {
    return this.cache[gid]?.geometry;
  }
  getCached(model) {
    return this.getCachedID(model.gid);
  }
  getCachedID(gid) {
    return this.cache[gid];
  }
  ensureCached(geometry2) {
    const gid = geometry2.gid;
    if (!gid) {
      throw new Error("The p5.Geometry you passed in has no gid property!");
    }
    if (this.isCached(gid)) return this.getCached(geometry2);
    this.freeBuffers(gid);
    if (Object.keys(this.cache).length > 1e3) {
      const key = Object.keys(this.cache)[0];
      this.freeBuffers(key);
    }
    const buffers = { geometry: geometry2 };
    this.cache[gid] = buffers;
    const indices = geometry2.faces.length ? geometry2.faces.flat() : null;
    let indexType = null;
    if (indices) {
      const hasVertexIndicesOverMaxUInt16 = indices.some((i) => i > 65535);
      indexType = hasVertexIndicesOverMaxUInt16 ? Uint32Array : Uint16Array;
    }
    this.renderer._ensureGeometryBuffers(buffers, indices, indexType);
    return buffers;
  }
  freeBuffers(gid) {
    const buffers = this.cache[gid];
    if (!buffers) {
      return;
    }
    delete this.cache[gid];
    this.renderer._freeBuffers(buffers);
  }
}
const filterParamDefaults = {
  [BLUR]: 3,
  [POSTERIZE]: 4,
  [THRESHOLD]: 0.5
};
const DefaultFill = "#000000";
const textCoreConstants = {
  IDEOGRAPHIC: "ideographic",
  _CTX_MIDDLE: "middle",
  _TEXT_BOUNDS: "_textBoundsSingle",
  _FONT_BOUNDS: "_fontBoundsSingle",
  HANGING: "hanging",
  START: "start",
  END: "end"
};
function textCore(p53, fn2) {
  const LeadingScale = 1.275;
  const LinebreakRe = /\r?\n/g;
  const CommaDelimRe = /,\s+/;
  const QuotedRe = /^".*"$/;
  const SpecialCharRe = /[^\x00-\x7F]/;
  const TabsRe = /\t/g;
  const FontVariationSettings = "fontVariationSettings";
  const VariableAxes = ["wght", "wdth", "ital", "slnt", "opsz"];
  const VariableAxesRe = new RegExp(`(?:${VariableAxes.join("|")})`);
  const textFunctions = [
    "text",
    "textAlign",
    "textAscent",
    "textDescent",
    "textLeading",
    "textMode",
    "textFont",
    "textSize",
    "textStyle",
    "textWidth",
    "textWrap",
    "textBounds",
    "textDirection",
    "textProperty",
    "textProperties",
    "fontBounds",
    "fontWidth",
    "fontAscent",
    "fontDescent",
    "textWeight"
  ];
  textFunctions.forEach((func) => {
    fn2[func] = function(...args) {
      if (!(func in Renderer.prototype)) {
        throw Error(`Renderer2D.prototype.${func} is not defined.`);
      }
      return this._renderer[func](...args);
    };
    p53.Graphics.prototype[func] = function(...args) {
      return this._renderer[func](...args);
    };
  });
  const RendererTextProps = {
    textAlign: { default: fn2.LEFT, type: "Context2d" },
    textBaseline: { default: fn2.BASELINE, type: "Context2d" },
    textFont: { default: { family: "sans-serif" } },
    textLeading: { default: 15 },
    textSize: { default: 12 },
    textWrap: { default: fn2.WORD },
    fontStretch: { default: fn2.NORMAL, isShorthand: true },
    // font-stretch: { default:  normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded }
    fontWeight: { default: fn2.NORMAL, isShorthand: true },
    // font-stretch: { default:  normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded }
    lineHeight: { default: fn2.NORMAL, isShorthand: true },
    // line-height: { default:  normal | number | length | percentage }
    fontVariant: { default: fn2.NORMAL, isShorthand: true },
    // font-variant: { default:  normal | small-caps }
    fontStyle: { default: fn2.NORMAL, isShorthand: true },
    // font-style: { default:  normal | italic | oblique } [was 'textStyle' in v1]
    direction: { default: "inherit" }
    // direction: { default: inherit | ltr | rtl }
  };
  const ContextTextProps = ["font", "direction", "fontKerning", "fontStretch", "fontVariantCaps", "letterSpacing", "textAlign", "textBaseline", "textRendering", "wordSpacing"];
  const ShorthandFontProps = Object.keys(RendererTextProps).filter((p2) => RendererTextProps[p2].isShorthand);
  const FontStretchKeys = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
  let contextQueue, cachedDiv;
  Renderer.prototype.text = function(str, x, y, width, height) {
    let setBaseline = this.textDrawingContext().textBaseline;
    ({ x, y, width, height } = this._handleRectMode(x, y, width, height));
    let lines = this._processLines(str, width, height);
    lines = this._positionLines(x, y, width, height, lines);
    lines.forEach((line) => this._renderText(line.text, line.x, line.y));
    this.textDrawingContext().textBaseline = setBaseline;
  };
  Renderer.prototype.textBounds = function(str, x, y, width, height) {
    return this._computeBounds(
      textCoreConstants._TEXT_BOUNDS,
      str,
      x,
      y,
      width,
      height
    ).bounds;
  };
  Renderer.prototype.fontBounds = function(str, x, y, width, height) {
    return this._computeBounds(
      textCoreConstants._FONT_BOUNDS,
      str,
      x,
      y,
      width,
      height
    ).bounds;
  };
  Renderer.prototype.textWidth = function(theText) {
    let lines = this._processLines(theText);
    return Math.max(...lines.map((l) => this._textWidthSingle(l)));
  };
  Renderer.prototype.fontWidth = function(theText) {
    let lines = this._processLines(theText);
    return Math.max(...lines.map((l) => this._fontWidthSingle(l)));
  };
  Renderer.prototype.textAscent = function(txt = "") {
    if (!txt.length) return this.fontAscent();
    return this.textDrawingContext().measureText(txt).actualBoundingBoxAscent;
  };
  Renderer.prototype.fontAscent = function() {
    return this.textDrawingContext().measureText("_").fontBoundingBoxAscent;
  };
  Renderer.prototype.textDescent = function(txt = "") {
    if (!txt.length) return this.fontDescent();
    return this.textDrawingContext().measureText(txt).actualBoundingBoxDescent;
  };
  Renderer.prototype.fontDescent = function() {
    return this.textDrawingContext().measureText("_").fontBoundingBoxDescent;
  };
  Renderer.prototype.textAlign = function(h, v) {
    if (typeof h !== "undefined") {
      this.states.setValue("textAlign", h);
      if (typeof v !== "undefined") {
        if (v === fn2.CENTER) {
          v = textCoreConstants._CTX_MIDDLE;
        }
        this.states.setValue("textBaseline", v);
      }
      return this._applyTextProperties();
    }
    return {
      horizontal: this.states.textAlign,
      vertical: this.states.textBaseline
    };
  };
  Renderer.prototype._currentTextFont = function() {
    return this.states.textFont.font || this.states.textFont.family;
  };
  Renderer.prototype.textFont = function(font2, size, options2) {
    if (arguments.length === 0) {
      return this._currentTextFont();
    }
    let family = font2;
    if (font2 instanceof p53.Font) {
      family = font2.face.family;
    } else if (font2.data instanceof Uint8Array) {
      family = font2.name.fontFamily;
      if (font2.name?.fontSubfamily) {
        family += "-" + font2.name.fontSubfamily;
      }
    } else if (typeof font2 === "string") {
      if (typeof size === "undefined" && /[.0-9]+(%|em|p[xt])/.test(family)) {
        ({ family, size } = this._directSetFontString(family));
      }
    }
    if (typeof family !== "string") throw Error("null font in textFont()");
    if (arguments.length === 2 && typeof size === "object") {
      options2 = size;
      size = void 0;
    }
    this.states.setValue("textFont", { font: font2, family, size });
    if (typeof size !== "undefined") {
      this._setTextSize(size);
    }
    if (typeof options2 === "object") {
      this.textProperties(options2);
    }
    return this._applyTextProperties();
  };
  Renderer.prototype._directSetFontString = function(font2, debug = 0) {
    if (debug) console.log('_directSetFontString"' + font2 + '"');
    let defaults2 = ShorthandFontProps.reduce((props, p2) => {
      props[p2] = RendererTextProps[p2].default;
      return props;
    }, {});
    let el = this._cachedDiv(defaults2);
    el.style.font = font2;
    let style = getComputedStyle(el);
    ShorthandFontProps.forEach((prop) => {
      this.states[prop] = style[prop];
      if (debug) console.log("  this.states." + prop + '="' + style[prop] + '"');
    });
    return { family: style.fontFamily, size: style.fontSize };
  };
  Renderer.prototype.textLeading = function(leading) {
    if (typeof leading === "number") {
      this.states.setValue("leadingSet", true);
      this.states.setValue("textLeading", leading);
      return this._applyTextProperties();
    }
    return this.states.textLeading;
  };
  Renderer.prototype.textWeight = function(weight) {
    if (typeof weight === "number") {
      this.states.setValue("fontWeight", weight);
      this._applyTextProperties();
      if (!p53.prototype._isSafari()) {
        this._setCanvasStyleProperty("font-variation-settings", `"wght" ${weight}`);
      }
      return;
    }
    return this.states.fontWeight;
  };
  Renderer.prototype.textSize = function(size) {
    if (typeof size !== "undefined") {
      this._setTextSize(size);
      return this._applyTextProperties();
    }
    return this.states.textSize;
  };
  Renderer.prototype.textStyle = function(style) {
    if (typeof style !== "undefined") {
      this.states.setValue("fontStyle", style);
      return this._applyTextProperties();
    }
    return this.states.fontStyle;
  };
  Renderer.prototype.textWrap = function(wrapStyle) {
    if (wrapStyle === fn2.WORD || wrapStyle === fn2.CHAR) {
      this.states.setValue("textWrap", wrapStyle);
      return this._pInst;
    }
    return this.states.textWrap;
  };
  Renderer.prototype.textDirection = function(direction) {
    if (typeof direction !== "undefined") {
      this.states.setValue("direction", direction);
      return this._applyTextProperties();
    }
    return this.states.direction;
  };
  Renderer.prototype.textProperty = function(prop, value, opts) {
    let modified = false, debug = opts?.debug || false;
    if (typeof value === "undefined") {
      let props = this.textProperties();
      if (prop in props) return props[prop];
      throw Error('Unknown text option "' + prop + '"');
    }
    if (prop in this.states && this.states[prop] !== value) {
      this.states[prop] = value;
      modified = true;
      if (debug) {
        console.log("this.states." + prop + '="' + options[prop] + '"');
      }
    } else if (prop in this.textDrawingContext()) {
      this._setContextProperty(prop, value, debug);
      modified = true;
    } else if (prop in this.textCanvas().style) {
      this._setCanvasStyleProperty(prop, value, debug);
      modified = true;
    } else {
      console.warn('Ignoring unknown text option: "' + prop + '"\n');
    }
    return modified ? this._applyTextProperties() : this._pInst;
  };
  Renderer.prototype.textProperties = function(properties) {
    if (typeof properties !== "undefined") {
      Object.keys(properties).forEach((opt) => {
        this.textProperty(opt, properties[opt]);
      });
      return this._pInst;
    }
    let context2 = this.textDrawingContext();
    properties = ContextTextProps.reduce((props, p2) => {
      props[p2] = context2[p2];
      return props;
    }, {});
    Object.keys(RendererTextProps).forEach((p2) => {
      if (RendererTextProps[p2]?.type === "Context2d") {
        properties[p2] = context2[p2];
      } else {
        if (p2 === "textFont") {
          let current2 = this._currentTextFont();
          if (typeof current2 === "object" && "_pInst" in current2) {
            current2 = Object.assign({}, current2);
            delete current2._pInst;
          }
          properties[p2] = current2;
        } else {
          properties[p2] = this.states[p2];
        }
      }
    });
    return properties;
  };
  Renderer.prototype.textMode = function() {
  };
  Renderer.prototype._currentTextFont = function() {
    return this.states.textFont.font || this.states.textFont.family;
  };
  Renderer.prototype._computeBounds = function(type2, str, x, y, width, height, opts) {
    let context2 = this.textDrawingContext();
    let setBaseline = context2.textBaseline;
    let { textLeading, textAlign } = this.states;
    ({ width, height } = this._rectModeAdjust(x, y, width, height));
    let lines = this._processLines(str, width, height);
    let boxes = lines.map((line, i) => this[type2].bind(this)(line, x, y + i * textLeading));
    if (lines.length > 1 && typeof width !== "undefined") {
      boxes.forEach((bb) => bb.x += p53.Renderer2D.prototype._xAlignOffset.call(this, textAlign, width));
    }
    p53.Renderer2D.prototype._yAlignOffset.call(this, boxes, height || 0);
    let bounds = boxes[0];
    if (lines.length > 1) {
      bounds = this._aggregateBounds(boxes);
      if (!opts?.ignoreRectMode) {
        this._rectModeAlign(bounds, width || 0, height || 0);
      }
    }
    context2.textBaseline = setBaseline;
    return { bounds, lines };
  };
  Renderer.prototype._rectModeAdjust = function(x, y, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          break;
        case fn2.CORNERS:
          width -= x;
          height -= y;
          break;
        case fn2.RADIUS:
          width *= 2;
          height *= 2;
          break;
      }
    }
    return { x, y, width, height };
  };
  Renderer.prototype._setCanvasStyleProperty = function(opt, val, debug) {
    let value = val.toString();
    if (debug) console.log("canvas.style." + opt + '="' + value + '"');
    if (opt === FontVariationSettings) {
      this._handleFontVariationSettings(value);
    }
    this.textCanvas().style[opt] = value;
    if (this.textCanvas().style[opt] !== value) ;
  };
  Renderer.prototype._handleFontVariationSettings = function(value, debug = false) {
    if (typeof value === "object") {
      value = Object.keys(value).map((k) => k + " " + value[k]).join(", ");
    }
    let values = value.split(CommaDelimRe);
    values.forEach((v) => {
      v = v.replace(/["']/g, "");
      let matches = VariableAxesRe.exec(v);
      if (matches && matches.length) {
        let axis = matches[0];
        let val = parseFloat(parseFloat(v.replace(axis, "").trim()).toFixed(3));
        switch (axis) {
          case "wght":
            if (debug) console.log("setting font-weight=" + val);
            if (this.states.fontWeight !== val) this.textWeight(val);
            return val;
          case "wdth":
            break;
          case "ital":
            if (debug) console.log("setting font-style=" + (val ? "italic" : "normal"));
            break;
          case "slnt":
            if (debug) console.log("setting font-style=" + (val ? "oblique" : "normal"));
            break;
          case "opsz":
            if (debug) console.log("setting font-optical-size=" + val);
            break;
        }
      }
    });
  };
  Renderer.prototype._setContextProperty = function(prop, val, debug = false) {
    if (this.textDrawingContext()[prop] === val) {
      return this._pInst;
    }
    (contextQueue ??= []).push([prop, val]);
    if (debug) console.log("queued context2d." + prop + '="' + val + '"');
  };
  Renderer.prototype._handleRectMode = function(x, y, width, height) {
    let rectMode = this.states.rectMode;
    if (typeof width !== "undefined") {
      switch (rectMode) {
        case fn2.RADIUS:
          width *= 2;
          x -= width / 2;
          if (typeof height !== "undefined") {
            height *= 2;
            y -= height / 2;
          }
          break;
        case fn2.CENTER:
          x -= width / 2;
          if (typeof height !== "undefined") {
            y -= height / 2;
          }
          break;
        case fn2.CORNERS:
          width -= x;
          if (typeof height !== "undefined") {
            height -= y;
          }
          break;
      }
    }
    return { x, y, width, height };
  };
  Renderer.prototype._fontSizePx = function(theSize, { family } = this.states.textFont) {
    const isNumString = (num) => !isNaN(num) && num.trim() !== "";
    if (isNumString(theSize)) {
      return parseFloat(theSize);
    }
    let ele = this._cachedDiv({ fontSize: theSize });
    ele.style.fontSize = theSize;
    ele.style.fontFamily = family;
    let fontSizeStr = getComputedStyle(ele).fontSize;
    let fontSize = parseFloat(fontSizeStr);
    if (typeof fontSize !== "number") {
      throw Error("textSize: invalid font-size");
    }
    return fontSize;
  };
  Renderer.prototype._cachedDiv = function(props) {
    if (typeof cachedDiv === "undefined") {
      let ele = document.createElement("div");
      ele.ariaHidden = "true";
      ele.style.display = "none";
      Object.entries(props).forEach(([prop, val]) => {
        ele.style[prop] = val;
      });
      this.textCanvas().appendChild(ele);
      cachedDiv = ele;
    }
    return cachedDiv;
  };
  Renderer.prototype._aggregateBounds = function(bboxes) {
    let minX = Math.min(...bboxes.map((b2) => b2.x));
    let minY = Math.min(...bboxes.map((b2) => b2.y));
    let maxY = Math.max(...bboxes.map((b2) => b2.y + b2.h));
    let maxX = Math.max(...bboxes.map((b2) => b2.x + b2.w));
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  };
  Renderer.prototype._processLines = function(str, width, height) {
    if (typeof width !== "undefined") {
      let drawingContext = this.textDrawingContext();
      if (drawingContext.textBaseline === fn2.BASELINE) {
        this.drawingContext.textBaseline = fn2.TOP;
      }
    }
    let lines = this._splitOnBreaks(str.toString());
    let hasLineBreaks = lines.length > 1;
    let hasWidth = typeof width !== "undefined";
    let exceedsWidth = hasWidth && lines.some((l) => this._textWidthSingle(l) > width);
    let { textLeading: leading, textWrap } = this.states;
    if (hasLineBreaks || exceedsWidth) {
      if (hasWidth) lines = this._lineate(textWrap, lines, width);
    }
    if (hasWidth && typeof height !== "undefined") {
      if (typeof leading === "undefined") {
        throw Error("leading is required if height is specified");
      }
      for (let i = 0; i < lines.length; i++) {
        let lh = leading * (i + 1);
        if (lh > height) {
          lines = lines.slice(0, i);
          break;
        }
      }
    }
    return lines;
  };
  Renderer.prototype._xAlignOffset = function(textAlign, width) {
    switch (textAlign) {
      case fn2.LEFT:
        return 0;
      case fn2.CENTER:
        return width / 2;
      case fn2.RIGHT:
        return width;
      case textCoreConstants.START:
        return 0;
      case textCoreConstants.END:
        throw new Error("textBounds: END not yet supported for textAlign");
      default:
        return 0;
    }
  };
  Renderer.prototype._rectModeAlign = function(bb, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          bb.x -= (width - bb.w) / 2;
          bb.y -= (height - bb.h) / 2;
          break;
        case fn2.CORNERS:
          bb.w += bb.x;
          bb.h += bb.y;
          break;
        case fn2.RADIUS:
          bb.x -= (width - bb.w) / 2;
          bb.y -= (height - bb.h) / 2;
          bb.w /= 2;
          bb.h /= 2;
          break;
      }
      return bb;
    }
  };
  Renderer.prototype._rectModeAlignRevert = function(bb, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          bb.x += (width - bb.w) / 2;
          bb.y += (height - bb.h) / 2;
          break;
        case fn2.CORNERS:
          bb.w -= bb.x;
          bb.h -= bb.y;
          break;
        case fn2.RADIUS:
          bb.x += (width - bb.w) / 2;
          bb.y += (height - bb.h) / 2;
          bb.w *= 2;
          bb.h *= 2;
          break;
      }
      return bb;
    }
  };
  Renderer.prototype._textWidthSingle = function(s) {
    let metrics = this.textDrawingContext().measureText(s);
    let abl = metrics.actualBoundingBoxLeft;
    let abr = metrics.actualBoundingBoxRight;
    return abr + abl;
  };
  Renderer.prototype._fontWidthSingle = function(s) {
    return this.textDrawingContext().measureText(s).width;
  };
  Renderer.prototype._textBoundsSingle = function(s, x = 0, y = 0) {
    let metrics = this.textDrawingContext().measureText(s);
    let asc = metrics.actualBoundingBoxAscent;
    let desc = metrics.actualBoundingBoxDescent;
    let abl = metrics.actualBoundingBoxLeft;
    let abr = metrics.actualBoundingBoxRight;
    return { x: x - abl, y: y - asc, w: abr + abl, h: asc + desc };
  };
  Renderer.prototype._fontBoundsSingle = function(s, x = 0, y = 0) {
    let metrics = this.textDrawingContext().measureText(s);
    let asc = metrics.fontBoundingBoxAscent;
    let desc = metrics.fontBoundingBoxDescent;
    x -= this._xAlignOffset(this.states.textAlign, metrics.width);
    return { x, y: y - asc, w: metrics.width, h: asc + desc };
  };
  Renderer.prototype._setTextSize = function(theSize) {
    if (typeof theSize === "string") {
      theSize = this._fontSizePx(theSize);
    }
    if (typeof theSize === "number") {
      if (this.states.textSize !== theSize) {
        this.states.setValue("textSize", theSize);
        if (!this.states.leadingSet) {
          this.states.setValue("textLeading", this.states.textSize * LeadingScale);
        }
        return true;
      }
    } else {
      console.warn("textSize: invalid size: " + theSize);
    }
    return false;
  };
  Renderer.prototype._lineate = function(textWrap, lines, maxWidth = Infinity, opts = {}) {
    let splitter = opts.splitChar ?? (textWrap === fn2.WORD ? " " : "");
    let line, testLine, testWidth, words, newLines = [];
    for (let lidx = 0; lidx < lines.length; lidx++) {
      line = "";
      words = lines[lidx].split(splitter);
      for (let widx = 0; widx < words.length; widx++) {
        testLine = `${line + words[widx]}` + splitter;
        testWidth = this._textWidthSingle(testLine);
        if (line.length > 0 && testWidth > maxWidth) {
          newLines.push(line.trim());
          line = `${words[widx]}` + splitter;
        } else {
          line = testLine;
        }
      }
      newLines.push(line.trim());
    }
    return newLines;
  };
  Renderer.prototype._splitOnBreaks = function(s) {
    if (!s || s.length === 0) return [""];
    return s.replace(TabsRe, "  ").split(LinebreakRe);
  };
  Renderer.prototype._parseFontFamily = function(familyStr) {
    let parts = familyStr.split(CommaDelimRe);
    let family = parts.map((part) => {
      part = part.trim();
      if ((part.indexOf(" ") > -1 || SpecialCharRe.test(part)) && !QuotedRe.test(part)) {
        part = `"${part}"`;
      }
      return part;
    }).join(", ");
    return family;
  };
  Renderer.prototype._applyFontString = function() {
    let {
      textFont,
      textSize,
      lineHeight,
      fontStyle,
      fontWeight,
      fontVariant
    } = this.states;
    let drawingContext = this.textDrawingContext();
    let family = this._parseFontFamily(textFont.family);
    let style = fontStyle !== fn2.NORMAL ? `${fontStyle} ` : "";
    let weight = fontWeight !== fn2.NORMAL ? `${fontWeight} ` : "";
    let variant = fontVariant !== fn2.NORMAL ? `${fontVariant} ` : "";
    let fsize = `${textSize}px` + (lineHeight !== fn2.NORMAL ? `/${lineHeight} ` : " ");
    let fontString = `${style}${variant}${weight}${fsize}${family}`.trim();
    drawingContext.font = fontString;
    if (drawingContext.font !== fontString) {
      let expected = fontString;
      let actual = drawingContext.font;
      if (expected !== actual) {
        return false;
      }
    }
    return true;
  };
  Renderer.prototype._applyTextProperties = function(debug = false) {
    this._applyFontString();
    let context2 = this.textDrawingContext();
    context2.direction = this.states.direction;
    context2.textAlign = this.states.textAlign;
    context2.textBaseline = this.states.textBaseline;
    let stretch = this.states.fontStretch;
    if (FontStretchKeys.includes(stretch) && context2.fontStretch !== stretch) {
      context2.fontStretch = stretch;
    }
    while (contextQueue?.length) {
      let [prop, val] = contextQueue.shift();
      if (debug) console.log('apply context property "' + prop + '" = "' + val + '"');
      context2[prop] = val;
      if (context2[prop] !== val) {
        console.warn(`Unable to set '${prop}' property on context2d. It may not be supported.`);
        console.log('Expected "' + val + '" but got: "' + context2[prop] + '"');
      }
    }
    return this._pInst;
  };
}
if (typeof p5 !== "undefined") {
  textCore(p5, p5.prototype);
}
function makeFilterShader(renderer2, operation, p53) {
  switch (operation) {
    case GRAY:
      return renderer2.baseFilterShader().modify(({ p5: p54 }) => {
        p54.getColor((inputs, canvasContent) => {
          const tex = p54.getTexture(canvasContent, inputs.texCoord);
          const gray = p54.dot(tex.rgb, p54.vec3(0.2126, 0.7152, 0.0722));
          return p54.vec4(gray, gray, gray, tex.a);
        });
      }, { p5: p53 });
    case INVERT:
      return renderer2.baseFilterShader().modify(({ p5: p54 }) => {
        p54.getColor((inputs, canvasContent) => {
          const color2 = p54.getTexture(canvasContent, inputs.texCoord);
          const invertedColor = p54.vec3(1) - color2.rgb;
          return p54.vec4(invertedColor, color2.a);
        });
      }, { p5: p53 });
    case THRESHOLD:
      return renderer2.baseFilterShader().modify(({ p5: p54 }) => {
        const filterParameter = p54.uniformFloat("filterParameter");
        p54.getColor((inputs, canvasContent) => {
          const color2 = p54.getTexture(canvasContent, inputs.texCoord);
          const gray = p54.dot(color2.rgb, p54.vec3(0.2126, 0.7152, 0.0722));
          const threshold = p54.floor(filterParameter * 255) / 255;
          const blackOrWhite = p54.step(threshold, gray);
          return p54.vec4(p54.vec3(blackOrWhite), color2.a);
        });
      }, { p5: p53 });
    case POSTERIZE:
      return renderer2.baseFilterShader().modify(({ p5: p54 }) => {
        const filterParameter = p54.uniformFloat("filterParameter");
        const quantize = (color2, n2) => {
          color2 = color2 * n2;
          color2 = p54.floor(color2);
          color2 = color2 / (n2 - 1);
          return color2;
        };
        p54.getColor((inputs, canvasContent) => {
          const color2 = p54.getTexture(canvasContent, inputs.texCoord);
          const restrictedColor = quantize(color2.rgb, filterParameter);
          return p54.vec4(restrictedColor, color2.a);
        });
      }, { p5: p53 });
    case BLUR:
      return renderer2.baseFilterShader().modify(({ p5: p54 }) => {
        const radius = p54.uniformFloat("radius");
        const direction = p54.uniformVec2("direction");
        const quadWeight = (x, e2) => {
          return p54.pow(e2 - p54.abs(x), 2);
        };
        const random2 = (p2) => {
          let p3 = p54.fract(p2.xyx * 0.1031);
          p3 += p54.dot(p3, p3.yzx + 33.33);
          return p54.fract((p3.x + p3.y) * p3.z);
        };
        p54.getColor((inputs, canvasContent) => {
          const uv = inputs.texCoord;
          const maxSamples = 64;
          let numSamples = p54.floor(radius * 7);
          if (p54.mod(numSamples, 2) == 0) {
            numSamples++;
          }
          let avg = p54.vec4(0);
          let total = 0;
          let spacing = 1;
          if (numSamples > maxSamples) {
            spacing = numSamples / maxSamples;
            numSamples = maxSamples;
          }
          const randomOffset = (spacing - 1) * p54.mix(-0.5, 0.5, random2(uv * inputs.canvasSize));
          for (let i = 0; i < numSamples; i++) {
            const sample = i * spacing - (numSamples - 1) * 0.5 * spacing + randomOffset;
            const sampleCoord = uv + p54.vec2(sample, sample) / inputs.canvasSize * direction;
            const weight = quadWeight(sample, (numSamples - 1) * 0.5 * spacing);
            const texSample = p54.getTexture(canvasContent, sampleCoord);
            avg += weight * texSample * p54.vec4(
              texSample.a,
              texSample.a,
              texSample.a,
              1
            );
            total += weight;
          }
          const blended = avg / total;
          return p54.vec4(
            blended.r / blended.a,
            blended.g / blended.a,
            blended.b / blended.a,
            blended.a
          );
        });
      }, { p5: p53 });
    case ERODE:
      return renderer2.baseFilterShader().modify(({ p5: p54 }) => {
        const luma = (color2) => {
          return p54.dot(color2.rgb, p54.vec3(0.2126, 0.7152, 0.0722));
        };
        p54.getColor((inputs, canvasContent) => {
          const uv = inputs.texCoord;
          let minColor = p54.getTexture(canvasContent, uv);
          let minLuma = luma(minColor);
          for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
              if (x != 0 || y != 0) {
                const offset2 = p54.vec2(x, y) * inputs.texelSize;
                const neighborColor = p54.getTexture(canvasContent, uv + offset2);
                const neighborLuma = luma(neighborColor);
                if (neighborLuma < minLuma) {
                  minLuma = neighborLuma;
                  minColor = neighborColor;
                }
              }
            }
          }
          return minColor;
        });
      }, { p5: p53 });
    case DILATE:
      return renderer2.baseFilterShader().modify(({ p5: p54 }) => {
        const luma = (color2) => {
          return p54.dot(color2.rgb, p54.vec3(0.2126, 0.7152, 0.0722));
        };
        p54.getColor((inputs, canvasContent) => {
          const uv = inputs.texCoord;
          let maxColor = p54.getTexture(canvasContent, uv);
          let maxLuma = luma(maxColor);
          for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
              if (x != 0 || y != 0) {
                const offset2 = p54.vec2(x, y) * inputs.texelSize;
                const neighborColor = p54.getTexture(canvasContent, uv + offset2);
                const neighborLuma = luma(neighborColor);
                if (neighborLuma > maxLuma) {
                  maxLuma = neighborLuma;
                  maxColor = neighborColor;
                }
              }
            }
          }
          return maxColor;
        });
      }, { p5: p53 });
    case OPAQUE:
      return renderer2.baseFilterShader().modify(({ p5: p54 }) => {
        p54.getColor((inputs, canvasContent) => {
          const color2 = p54.getTexture(canvasContent, inputs.texCoord);
          return p54.vec4(color2.rgb, 1);
        });
      }, { p5: p53 });
    default:
      throw new Error(`Unknown filter: ${operation}`);
  }
}
function getStrokeDefs(shaderConstant) {
  const STROKE_CAP_ENUM2 = {};
  const STROKE_JOIN_ENUM2 = {};
  let lineDefs2 = "";
  const defineStrokeCapEnum = function(key, val) {
    lineDefs2 += shaderConstant(`STROKE_CAP_${key}`, `${val}`, "u32");
    STROKE_CAP_ENUM2[constants[key]] = val;
  };
  const defineStrokeJoinEnum = function(key, val) {
    lineDefs2 += shaderConstant(`STROKE_JOIN_${key}`, `${val}`, "u32");
    STROKE_JOIN_ENUM2[constants[key]] = val;
  };
  defineStrokeCapEnum("ROUND", 0);
  defineStrokeCapEnum("PROJECT", 1);
  defineStrokeCapEnum("SQUARE", 2);
  defineStrokeJoinEnum("ROUND", 0);
  defineStrokeJoinEnum("MITER", 1);
  defineStrokeJoinEnum("BEVEL", 2);
  return { STROKE_CAP_ENUM: STROKE_CAP_ENUM2, STROKE_JOIN_ENUM: STROKE_JOIN_ENUM2, lineDefs: lineDefs2 };
}
class Shader {
  constructor(renderer2, vertSrc, fragSrc, options2 = {}) {
    this._renderer = renderer2;
    this._vertSrc = vertSrc;
    this._fragSrc = fragSrc;
    this._vertShader = -1;
    this._fragShader = -1;
    this._glProgram = 0;
    this._loadedAttributes = false;
    this.attributes = {};
    this._loadedUniforms = false;
    this.uniforms = {};
    this._bound = false;
    this.samplers = [];
    this.hooks = {
      // These should be passed in by `.modify()` instead of being manually
      // passed in.
      // Stores uniforms + default values.
      uniforms: options2.uniforms || {},
      // Stores custom uniform + helper declarations as a string.
      declarations: options2.declarations,
      // Stores an array of variable names + types passed between the vertex and fragment shader
      varyingVariables: options2.varyingVariables || [],
      // Stores helper functions to prepend to shaders.
      helpers: options2.helpers || {},
      // Stores the hook implementations
      vertex: options2.vertex || {},
      fragment: options2.fragment || {},
      // Stores whether or not the hook implementation has been modified
      // from the default. This is supplied automatically by calling
      // yourShader.modify(...).
      modified: {
        vertex: options2.modified && options2.modified.vertex || {},
        fragment: options2.modified && options2.modified.fragment || {}
      }
    };
  }
  hookTypes(hookName) {
    return this._renderer.getShaderHookTypes(this, hookName);
  }
  shaderSrc(src, shaderType) {
    return this._renderer.populateHooks(this, src, shaderType);
  }
  /**
   * Shaders are written in <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders">GLSL</a>, but
   * there are different versions of GLSL that it might be written in.
   *
   * Calling this method on a `p5.Shader` will return the GLSL version it uses, either `100 es` or `300 es`.
   * WebGL 1 shaders will only use `100 es`, and WebGL 2 shaders may use either.
   *
   * @returns {String} The GLSL version used by the shader.
   */
  version() {
    const match = /#version (.+)$/.exec(this.vertSrc());
    if (match) {
      return match[1];
    } else {
      return "100 es";
    }
  }
  vertSrc() {
    return this.shaderSrc(this._vertSrc, "vertex");
  }
  fragSrc() {
    return this.shaderSrc(this._fragSrc, "fragment");
  }
  /**
   * Logs the hooks available in this shader, and their current implementation.
   *
   * Each shader may let you override bits of its behavior. Each bit is called
   * a *hook.* A hook is either for the *vertex* shader, if it affects the
   * position of vertices, or in the *fragment* shader, if it affects the pixel
   * color. This method logs those values to the console, letting you know what
   * you are able to use in a call to
   * <a href="#/p5.Shader/modify">`modify()`</a>.
   *
   * For example, this shader will produce the following output:
   *
   * ```js
   * myShader = baseMaterialShader().modify({
   *   declarations: 'uniform float time;',
   *   'vec3 getWorldPosition': `(vec3 pos) {
   *     pos.y += 20. * sin(time * 0.001 + pos.x * 0.05);
   *     return pos;
   *   }`
   * });
   * myShader.inspectHooks();
   * ```
   *
   * ```
   * ==== Vertex shader hooks: ====
   * void beforeVertex() {}
   * vec3 getLocalPosition(vec3 position) { return position; }
   * [MODIFIED] vec3 getWorldPosition(vec3 pos) {
   *       pos.y += 20. * sin(time * 0.001 + pos.x * 0.05);
   *       return pos;
   *     }
   * vec3 getLocalNormal(vec3 normal) { return normal; }
   * vec3 getWorldNormal(vec3 normal) { return normal; }
   * vec2 getUV(vec2 uv) { return uv; }
   * vec4 getVertexColor(vec4 color) { return color; }
   * void afterVertex() {}
   *
   * ==== Fragment shader hooks: ====
   * void beforeFragment() {}
   * Inputs getPixelInputs(Inputs inputs) { return inputs; }
   * vec4 combineColors(ColorComponents components) {
   *                 vec4 color = vec4(0.);
   *                 color.rgb += components.diffuse * components.baseColor;
   *                 color.rgb += components.ambient * components.ambientColor;
   *                 color.rgb += components.specular * components.specularColor;
   *                 color.rgb += components.emissive;
   *                 color.a = components.opacity;
   *                 return color;
   *               }
   * vec4 getFinalColor(vec4 color) { return color; }
   * void afterFragment() {}
   * ```
   *
   * @beta
   */
  inspectHooks() {
    console.log("==== Vertex shader hooks: ====");
    for (const key in this.hooks.vertex) {
      console.log(
        (this.hooks.modified.vertex[key] ? "[MODIFIED] " : "") + key + this.hooks.vertex[key]
      );
    }
    console.log("");
    console.log("==== Fragment shader hooks: ====");
    for (const key in this.hooks.fragment) {
      console.log(
        (this.hooks.modified.fragment[key] ? "[MODIFIED] " : "") + key + this.hooks.fragment[key]
      );
    }
    console.log("");
    console.log("==== Helper functions: ====");
    for (const key in this.hooks.helpers) {
      console.log(key + this.hooks.helpers[key]);
    }
  }
  /**
   * Returns a new shader, based on the original, but with custom snippets
   * of shader code replacing default behaviour.
   *
   * Each shader may let you override bits of its behavior. Each bit is called
   * a *hook.* For example, a hook can let you adjust positions of vertices, or
   * the color of a pixel. You can inspect the different hooks available by calling
   * <a href="#/p5.Shader/inspectHooks">`yourShader.inspectHooks()`</a>. You can
   * also read the reference for the default material, normal material, color, line, and point shaders to
   * see what hooks they have available.
   *
   * `modify()` can be passed a function as a parameter. Inside, you can override hooks
   * by calling them as functions. Each hook will take in a callback that takes in inputs
   * and is expected to return an output. For example, here is a function that changes the
   * material color to red:
   *
   * ```js example
   * let myShader;
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myShader = baseMaterialShader().modify(() => {
   *     getPixelInputs((inputs) => {
   *       inputs.color = [inputs.texCoord, 0, 1];
   *       return inputs;
   *     });
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   noStroke();
   *   shader(myShader); // Apply the custom shader
   *   plane(width, height); // Draw a plane with the shader applied
   * }
   * ```
   *
   * In addition to calling hooks, you can create uniforms, which are special variables
   * used to pass data from p5.js into the shader. They can be created by calling `uniform` + the
   * type of the data, such as `uniformFloat` for a number of `uniformVector2` for a two-component vector.
   * They take in a function that returns the data for the variable. You can then reference these
   * variables in your hooks, and their values will update every time you apply
   * the shader with the result of your function.
   *
   * ```js example
   * let myShader;
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myShader = baseMaterialShader().modify(() => {
   *     // Get the current time from p5.js
   *     let t = uniformFloat(() => millis());
   *
   *     getPixelInputs((inputs) => {
   *       inputs.color = [
   *         inputs.texCoord,
   *         sin(t * 0.01) / 2 + 0.5,
   *         1,
   *       ];
   *       return inputs;
   *     });
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   noStroke(255);
   *   shader(myShader); // Apply the custom shader
   *   plane(width, height); // Draw a plane with the shader applied
   * }
   * ```
   *
   * p5.strands functions are special, since they get turned into a shader instead of being
   * run like the rest of your code. They only have access to p5.js functions, and variables
   * you declare inside the `modify` callback. If you need access to local variables, you
   * can pass them into `modify` with an optional second parameter, `variables`. These will
   * then be passed into your function as an argument. If you are
   * using instance mode, you will need to pass your sketch object in this way.
   *
   * If you are also using a build system for your sketch, variable names may be changed as
   * part of minification. When creating a uniform, you can pass the name of the uniform in
   * as a first parameter to ensure it doesn't get changed.
   *
   * ```js example
   * new p5((sketch) => {
   *   let myShader;
   *
   *   sketch.setup = function() {
   *     sketch.createCanvas(200, 200, sketch.WEBGL);
   *     myShader = sketch.baseMaterialShader().modify(({ sketch }) => {
   *       let b = uniformFloat('b');
   *       sketch.getPixelInputs((inputs) => {
   *         inputs.color = [inputs.texCoord, b, 1];
   *         return inputs;
   *       });
   *     }, { sketch });
   *   }
   *
   *   sketch.draw = function() {
   *     sketch.background(255);
   *     sketch.noStroke();
   *     myShader.setUniform('b', 0.5);
   *     sketch.shader(myShader); // Apply the custom shader
   *     sketch.plane(sketch.width, sketch.height); // Draw a plane with the shader applied
   *   }
   * });
   * ```
   *
   * You can also write GLSL directly in `modify` if you need direct access. To do so,
   * `modify()` takes one parameter, `hooks`, an object with the hooks you want
   * to override. Each key of the `hooks` object is the name
   * of a hook, and the value is a string with the GLSL code for your hook.
   *
   * If you supply functions that aren't existing hooks, they will get added at the start of
   * the shader as helper functions so that you can use them in your hooks.
   *
   * To add new <a href="#/p5.Shader/setUniform">uniforms</a> to your shader, you can pass in a `uniforms` object containing
   * the type and name of the uniform as the key, and a default value or function returning
   * a default value as its value. These will be automatically set when the shader is set
   * with `shader(yourShader)`.
   *
   * ```js example
   * let myShader;
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myShader = baseMaterialShader().modify({
   *     uniforms: {
   *       'float time': () => millis() // Uniform for time
   *     },
   *     'Vertex getWorldInputs': `(Vertex inputs) {
   *       inputs.position.y +=
   *         20. * sin(time * 0.001 + inputs.position.x * 0.05);
   *       return inputs;
   *     }`
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   shader(myShader); // Apply the custom shader
   *   lights();         // Enable lighting
   *   noStroke();       // Disable stroke
   *   fill('red');      // Set fill color to red
   *   sphere(50);       // Draw a sphere with the shader applied
   * }
   * ```
   *
   * You can also add a `declarations` key, where the value is a GLSL string declaring
   * custom uniform variables, globals, and functions shared
   * between hooks. To add declarations just in a vertex or fragment shader, add
   * `vertexDeclarations` and `fragmentDeclarations` keys.
   *
   * ```js example
   * let myShader;
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myShader = baseMaterialShader().modify({
   *     // Manually specifying a uniform
   *     declarations: 'uniform float time;',
   *     'Vertex getWorldInputs': `(Vertex inputs) {
   *       inputs.position.y +=
   *         20. * sin(time * 0.001 + inputs.position.x * 0.05);
   *       return inputs;
   *     }`
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   shader(myShader);
   *   myShader.setUniform('time', millis());
   *   lights();
   *   noStroke();
   *   fill('red');
   *   sphere(50);
   * }
   * ```
   *
   * @beta
   * @param {Function} callback A function with p5.strands code to modify the shader.
   * @param {Object} [variables] An optional object with local variables p5.strands
   * should have access to.
   * @returns {p5.Shader}
   */
  /**
   * @param {Object} [hooks] The hooks in the shader to replace.
   * @returns {p5.Shader}
   */
  modify(hooks2) {
    const newHooks = {
      vertex: {},
      fragment: {},
      helpers: {}
    };
    for (const key in hooks2) {
      if (key === "declarations") continue;
      if (key === "uniforms") continue;
      if (key === "varyingVariables") continue;
      if (key === "vertexDeclarations") {
        newHooks.vertex.declarations = (newHooks.vertex.declarations || "") + "\n" + hooks2[key];
      } else if (key === "fragmentDeclarations") {
        newHooks.fragment.declarations = (newHooks.fragment.declarations || "") + "\n" + hooks2[key];
      } else if (this.hooks.vertex[key]) {
        newHooks.vertex[key] = hooks2[key];
      } else if (this.hooks.fragment[key]) {
        newHooks.fragment[key] = hooks2[key];
      } else {
        newHooks.helpers[key] = hooks2[key];
      }
    }
    const modifiedVertex = Object.assign({}, this.hooks.modified.vertex);
    const modifiedFragment = Object.assign({}, this.hooks.modified.fragment);
    for (const key in newHooks.vertex || {}) {
      if (key === "declarations") continue;
      modifiedVertex[key] = true;
    }
    for (const key in newHooks.fragment || {}) {
      if (key === "declarations") continue;
      modifiedFragment[key] = true;
    }
    return new Shader(this._renderer, this._vertSrc, this._fragSrc, {
      declarations: (this.hooks.declarations || "") + "\n" + (hooks2.declarations || ""),
      uniforms: Object.assign({}, this.hooks.uniforms, hooks2.uniforms || {}),
      varyingVariables: (hooks2.varyingVariables || []).concat(this.hooks.varyingVariables || []),
      fragment: Object.assign({}, this.hooks.fragment, newHooks.fragment || {}),
      vertex: Object.assign({}, this.hooks.vertex, newHooks.vertex || {}),
      helpers: Object.assign({}, this.hooks.helpers, newHooks.helpers || {}),
      modified: {
        vertex: modifiedVertex,
        fragment: modifiedFragment
      }
    });
  }
  /**
   * Creates, compiles, and links the shader based on its
   * sources for the vertex and fragment shaders (provided
   * to the constructor). Populates known attributes and
   * uniforms from the shader.
   * @chainable
   * @private
   */
  init() {
    if (!this._initialized) {
      try {
        this._renderer._initShader(this);
      } catch (err) {
        throw new Error(
          `Whoops! Something went wrong initializing the shader:
${err.message || err}`
        );
      }
      this._loadAttributes();
      this._loadUniforms();
      this._renderer._finalizeShader(this);
      this._initialized = true;
    }
    return this;
  }
  /**
   * @private
   */
  setDefaultUniforms() {
    for (const key in this.hooks.uniforms) {
      const name = this._renderer.uniformNameFromHookKey(key);
      const initializer2 = this.hooks.uniforms[key];
      let value;
      if (initializer2 instanceof Function) {
        value = initializer2();
      } else {
        value = initializer2;
      }
      if (value !== void 0 && value !== null) {
        this.setUniform(name, value);
      }
    }
  }
  /**
   * Copies the shader from one drawing context to another.
   *
   * Each `p5.Shader` object must be compiled by calling
   * <a href="#/p5/shader">shader()</a> before it can run. Compilation happens
   * in a drawing context which is usually the main canvas or an instance of
   * <a href="#/p5.Graphics">p5.Graphics</a>. A shader can only be used in the
   * context where it was compiled. The `copyToContext()` method compiles the
   * shader again and copies it to another drawing context where it can be
   * reused.
   *
   * The parameter, `context`, is the drawing context where the shader will be
   * used. The shader can be copied to an instance of
   * <a href="#/p5.Graphics">p5.Graphics</a>, as in
   * `myShader.copyToContext(pg)`. The shader can also be copied from a
   * <a href="#/p5.Graphics">p5.Graphics</a> object to the main canvas using
   * the `p5.instance` variable, as in `myShader.copyToContext(p5.instance)`.
   *
   * Note: A <a href="#/p5.Shader">p5.Shader</a> object created with
   * <a href="#/p5/createShader">createShader()</a>,
   * <a href="#/p5/createFilterShader">createFilterShader()</a>, or
   * <a href="#/p5/loadShader">loadShader()</a>
   * can be used directly with a <a href="#/p5.Framebuffer">p5.Framebuffer</a>
   * object created with
   * <a href="#/p5/createFramebuffer">createFramebuffer()</a>. Both objects
   * have the same context as the main canvas.
   *
   * @param {p5|p5.Graphics} context WebGL context for the copied shader.
   * @returns {p5.Shader} new shader compiled for the target context.
   *
   * @example
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision mediump float;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vec2 uv = vTexCoord;
   *   vec3 color = vec3(uv.x, uv.y, min(uv.x + uv.y, 1.0));
   *   gl_FragColor = vec4(color, 1.0);\
   * }
   * `;
   *
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Shader object.
   *   let original = createShader(vertSrc, fragSrc);
   *
   *   // Compile the p5.Shader object.
   *   shader(original);
   *
   *   // Create a p5.Graphics object.
   *   pg = createGraphics(50, 50, WEBGL);
   *
   *   // Copy the original shader to the p5.Graphics object.
   *   let copied = original.copyToContext(pg);
   *
   *   // Apply the copied shader to the p5.Graphics object.
   *   pg.shader(copied);
   *
   *   // Style the display surface.
   *   pg.noStroke();
   *
   *   // Add a display surface for the shader.
   *   pg.plane(50, 50);
   *
   *   describe('A square with purple-blue gradient on its surface drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the p5.Graphics object to the main canvas.
   *   image(pg, -25, -25);
   * }
   * </code>
   * </div>
   *
   * <div class='notest'>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision mediump float;
   *
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vec2 uv = vTexCoord;
   *   vec3 color = vec3(uv.x, uv.y, min(uv.x + uv.y, 1.0));
   *   gl_FragColor = vec4(color, 1.0);
   * }
   * `;
   *
   * let copied;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Graphics object.
   *   let pg = createGraphics(25, 25, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   let original = pg.createShader(vertSrc, fragSrc);
   *
   *   // Compile the p5.Shader object.
   *   pg.shader(original);
   *
   *   // Copy the original shader to the main canvas.
   *   copied = original.copyToContext(p5.instance);
   *
   *   // Apply the copied shader to the main canvas.
   *   shader(copied);
   *
   *   describe('A rotating cube with a purple-blue gradient on its surface drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the x-, y-, and z-axes.
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   rotateZ(frameCount * 0.01);
   *
   *   // Draw the box.
   *   box(50);
   * }
   * </code>
   * </div>
   */
  copyToContext(context2) {
    const shader2 = new Shader(
      context2._renderer,
      this._vertSrc,
      this._fragSrc
    );
    shader2.ensureCompiledOnContext(context2._renderer);
    return shader2;
  }
  /**
   * @private
   */
  ensureCompiledOnContext(context2) {
    if (this._glProgram !== 0 && this._renderer !== context2) {
      throw new Error(
        "The shader being run is attached to a different context. Do you need to copy it to this context first with .copyToContext()?"
      );
    } else if (this._glProgram === 0) {
      this._renderer = context2?._renderer?.filterRenderer?._renderer || context2;
      this.init();
    }
  }
  /**
   * Queries the active attributes for this shader and loads
   * their names and locations into the attributes array.
   * @private
   */
  _loadAttributes() {
    if (this._loadedAttributes) {
      return;
    }
    this.attributes = this._renderer._getShaderAttributes(this);
    this._loadedAttributes = true;
  }
  /**
   * Queries the active uniforms for this shader and loads
   * their names and locations into the uniforms array.
   * @private
   */
  _loadUniforms() {
    if (this._loadedUniforms) {
      return;
    }
    this.uniforms = {};
    this.samplers = [];
    const uniformMetadata = this._renderer.getUniformMetadata(this);
    for (const meta of uniformMetadata) {
      const uniform = {
        ...meta,
        _cachedData: void 0
      };
      if (uniform.isSampler) {
        this.samplers.push(uniform);
      }
      this.uniforms[uniform.name] = uniform;
    }
    this._loadedUniforms = true;
  }
  /**
   * initializes (if needed) and binds the shader program.
   * @private
   */
  bindShader(shaderType, options2) {
    if (this.shaderType && this.shaderType !== shaderType) {
      throw new Error(
        `You've already used this shader as a ${this.shaderType} shader, but are now using it as a ${shaderType}.`
      );
    }
    this.shaderType = shaderType;
    this.init();
    if (!this._bound) {
      this.useProgram(options2);
      this._bound = true;
    }
  }
  /**
   * @chainable
   * @private
   */
  unbindShader() {
    if (this._bound) {
      this.unbindTextures();
      this._bound = false;
    }
    return this;
  }
  /**
   * @private
   */
  bindTextures() {
    const empty2 = this._renderer._getEmptyTexture();
    for (const uniform of this.samplers) {
      if (uniform.noData) continue;
      let tex = uniform.texture;
      if (tex === void 0 || // Make sure we unbind a framebuffer uniform if it's the same
      // framebuffer that is actvely being drawn to in order to
      // prevent a feedback cycle
      tex.isFramebufferTexture && !tex.src.framebuffer.antialias && tex.src.framebuffer === this._renderer.activeFramebuffer()) {
        uniform.texture = tex = empty2;
      }
      this._renderer._updateTexture(uniform, tex);
    }
  }
  /**
   * @private
   */
  unbindTextures() {
    for (const uniform of this.samplers) {
      if (uniform.texture?.isFramebufferTexture) {
        this._renderer._unbindFramebufferTexture(uniform);
      }
    }
  }
  /**
   * @chainable
   * @private
   */
  useProgram(options2) {
    if (this._renderer._curShader !== this) {
      this._renderer._useShader(this);
      this._renderer._curShader = this;
    }
    return this;
  }
  /**
   * Sets the shader’s uniform (global) variables.
   *
   * Shader programs run on the computer’s graphics processing unit (GPU).
   * They live in part of the computer’s memory that’s completely separate
   * from the sketch that runs them. Uniforms are global variables within a
   * shader program. They provide a way to pass values from a sketch running
   * on the CPU to a shader program running on the GPU.
   *
   * The first parameter, `uniformName`, is a string with the uniform’s name.
   * For the shader above, `uniformName` would be `'r'`.
   *
   * The second parameter, `data`, is the value that should be used to set the
   * uniform. For example, calling `myShader.setUniform('r', 0.5)` would set
   * the `r` uniform in the shader above to `0.5`. data should match the
   * uniform’s type. Numbers, strings, booleans, arrays, and many types of
   * images can all be passed to a shader with `setUniform()`.
   *
   * @chainable
   * @param {String} uniformName name of the uniform. Must match the name
   *                             used in the vertex and fragment shaders.
   * @param {Boolean|Number|Number[]|p5.Image|p5.Graphics|p5.MediaElement|p5.Texture}
   * data value to assign to the uniform. Must match the uniform’s data type.
   *
   * @example
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision mediump float;
   *
   * uniform float r;
   *
   * void main() {
   *   gl_FragColor = vec4(r, 1.0, 1.0, 1.0);
   * }
   * `;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   let myShader = createShader(vertSrc, fragSrc);
   *
   *   // Apply the p5.Shader object.
   *   shader(myShader);
   *
   *   // Set the r uniform to 0.5.
   *   myShader.setUniform('r', 0.5);
   *
   *   // Style the drawing surface.
   *   noStroke();
   *
   *   // Add a plane as a drawing surface for the shader.
   *   plane(100, 100);
   *
   *   describe('A cyan square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision mediump float;
   *
   * uniform float r;
   *
   * void main() {
   *   gl_FragColor = vec4(r, 1.0, 1.0, 1.0);
   * }
   * `;
   *
   * let myShader;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   myShader = createShader(vertSrc, fragSrc);
   *
   *   // Compile and apply the p5.Shader object.
   *   shader(myShader);
   *
   *   describe('A square oscillates color between cyan and white.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the drawing surface.
   *   noStroke();
   *
   *   // Update the r uniform.
   *   let nextR = 0.5 * (sin(frameCount * 0.01) + 1);
   *   myShader.setUniform('r', nextR);
   *
   *   // Add a plane as a drawing surface.
   *   plane(100, 100);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision highp float;
   * uniform vec2 p;
   * uniform float r;
   * const int numIterations = 500;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vec2 c = p + gl_FragCoord.xy * r;
   *   vec2 z = c;
   *   float n = 0.0;
   *
   *   for (int i = numIterations; i > 0; i--) {
   *     if (z.x * z.x + z.y * z.y > 4.0) {
   *       n = float(i) / float(numIterations);
   *       break;
   *     }
   *
   *     z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
   *   }
   *
   *   gl_FragColor = vec4(
   *     0.5 - cos(n * 17.0) / 2.0,
   *     0.5 - cos(n * 13.0) / 2.0,
   *     0.5 - cos(n * 23.0) / 2.0,
   *     1.0
   *   );
   * }
   * `;
   *
   * let mandelbrot;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   mandelbrot = createShader(vertSrc, fragSrc);
   *
   *   // Compile and apply the p5.Shader object.
   *   shader(mandelbrot);
   *
   *   // Set the shader uniform p to an array.
   *   // p is the center point of the Mandelbrot image.
   *   mandelbrot.setUniform('p', [-0.74364388703, 0.13182590421]);
   *
   *   describe('A fractal image zooms in and out of focus.');
   * }
   *
   * function draw() {
   *   // Set the shader uniform r to a value that oscillates
   *   // between 0 and 0.005.
   *   // r is the size of the image in Mandelbrot-space.
   *   let radius = 0.005 * (sin(frameCount * 0.01) + 1);
   *   mandelbrot.setUniform('r', radius);
   *
   *   // Style the drawing surface.
   *   noStroke();
   *
   *   // Add a plane as a drawing surface.
   *   plane(100, 100);
   * }
   * </code>
   * </div>
   */
  setUniform(uniformName, rawData) {
    this.init();
    const uniform = this.uniforms[uniformName];
    if (!uniform) {
      return;
    }
    const data2 = this._renderer._mapUniformData ? this._renderer._mapUniformData(uniform, rawData) : rawData;
    if (uniform.isArray) {
      if (uniform._cachedData && this._renderer._arraysEqual(uniform._cachedData, data2)) {
        return;
      } else {
        uniform._cachedData = data2.slice(0);
      }
    } else if (uniform._cachedData && uniform._cachedData === data2) {
      return;
    } else {
      if (Array.isArray(data2)) {
        uniform._cachedData = data2.slice(0);
      } else {
        uniform._cachedData = data2;
      }
    }
    this._renderer.updateUniformValue(this, uniform, data2);
  }
  /**
   * @chainable
   * @private
   */
  enableAttrib(attr, size, type2, normalized, stride, offset2) {
    if (attr) {
      if (typeof IS_MINIFIED === "undefined" && this.attributes[attr.name] !== attr) {
        console.warn(
          `The attribute "${attr.name}"passed to enableAttrib does not belong to this shader.`
        );
      }
      if (attr.location !== -1) {
        this._renderer._enableAttrib(this, attr, size, type2, normalized, stride, offset2);
      }
    }
    return this;
  }
}
function shader(p53, fn2) {
  p53.Shader = Shader;
}
if (typeof p5 !== "undefined") {
  shader(p5, p5.prototype);
}
function trigonometry(p53, fn2) {
  const DEGREES = fn2.DEGREES = "degrees";
  const RADIANS = fn2.RADIANS = "radians";
  fn2._angleMode = RADIANS;
  fn2.acos = function(ratio) {
    return this._fromRadians(Math.acos(ratio));
  };
  fn2.asin = function(ratio) {
    return this._fromRadians(Math.asin(ratio));
  };
  fn2.atan = function(ratio) {
    return this._fromRadians(Math.atan(ratio));
  };
  fn2.atan2 = function(y, x) {
    return this._fromRadians(Math.atan2(y, x));
  };
  fn2.cos = function(angle) {
    return Math.cos(this._toRadians(angle));
  };
  fn2.sin = function(angle) {
    return Math.sin(this._toRadians(angle));
  };
  fn2.tan = function(angle) {
    return Math.tan(this._toRadians(angle));
  };
  fn2.degrees = (angle) => angle * RAD_TO_DEG;
  fn2.radians = (angle) => angle * DEG_TO_RAD;
  fn2.angleMode = function(mode) {
    if (typeof mode === "undefined") {
      return this._angleMode;
    } else if (mode === DEGREES || mode === RADIANS) {
      const prevMode = this._angleMode;
      if (mode === prevMode) return;
      if (mode === RADIANS) {
        this.pRotationX = this.pRotationX * DEG_TO_RAD;
        this.pRotationY = this.pRotationY * DEG_TO_RAD;
        this.pRotationZ = this.pRotationZ * DEG_TO_RAD;
      } else {
        this.pRotationX = this.pRotationX * RAD_TO_DEG;
        this.pRotationY = this.pRotationY * RAD_TO_DEG;
        this.pRotationZ = this.pRotationZ * RAD_TO_DEG;
      }
      this._angleMode = mode;
    }
  };
  fn2._toRadians = function(angle) {
    if (this._angleMode === DEGREES) {
      return angle * DEG_TO_RAD;
    }
    return angle;
  };
  fn2._toDegrees = function(angle) {
    if (this._angleMode === RADIANS) {
      return angle * RAD_TO_DEG;
    }
    return angle;
  };
  fn2._fromRadians = function(angle) {
    if (this._angleMode === DEGREES) {
      return angle * RAD_TO_DEG;
    }
    return angle;
  };
  fn2._fromDegrees = function(angle) {
    if (this._angleMode === RADIANS) {
      return angle * DEG_TO_RAD;
    }
    return angle;
  };
}
if (typeof p5 !== "undefined") {
  trigonometry(p5, p5.prototype);
}
function image$1(p53, fn2) {
  fn2.createImage = function(width, height) {
    return new p53.Image(width, height);
  };
  fn2.saveCanvas = function(...args) {
    let htmlCanvas, filename, extension, temporaryGraphics;
    if (args[0] instanceof HTMLCanvasElement) {
      htmlCanvas = args[0];
      args.shift();
    } else if (args[0] instanceof Element) {
      htmlCanvas = args[0].elt;
      args.shift();
    } else if (args[0] instanceof Framebuffer$1) {
      const framebuffer2 = args[0];
      temporaryGraphics = this.createGraphics(
        framebuffer2.width,
        framebuffer2.height
      );
      temporaryGraphics.pixelDensity(framebuffer2.pixelDensity());
      framebuffer2.loadPixels();
      temporaryGraphics.loadPixels();
      temporaryGraphics.pixels.set(framebuffer2.pixels);
      temporaryGraphics.updatePixels();
      htmlCanvas = temporaryGraphics._renderer.canvas;
      args.shift();
    } else {
      htmlCanvas = this._curElement && this._curElement.elt;
    }
    if (args.length >= 1) {
      filename = args[0];
    }
    if (args.length >= 2) {
      extension = args[1];
    }
    extension = extension || fn2._checkFileExtension(filename, extension)[1] || "png";
    let mimeType;
    switch (extension) {
      default:
        mimeType = "image/png";
        break;
      case "webp":
        mimeType = "image/webp";
        break;
      case "jpeg":
      case "jpg":
        mimeType = "image/jpeg";
        break;
    }
    htmlCanvas.toBlob((blob) => {
      fn2.downloadFile(blob, filename, extension);
      if (temporaryGraphics) temporaryGraphics.remove();
    }, mimeType);
  };
  fn2.encodeAndDownloadGif = function(pImg, filename) {
    const props = pImg.gifProperties;
    let loopLimit = props.loopLimit;
    if (loopLimit === 1) {
      loopLimit = null;
    } else if (loopLimit === null) {
      loopLimit = 0;
    }
    const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
    const allFramesPixelColors = [];
    const paletteFreqsAndFrames = {};
    for (let i = 0; i < props.numFrames; i++) {
      const paletteSet = /* @__PURE__ */ new Set();
      const data2 = props.frames[i].image.data;
      const dataLength = data2.length;
      const pixelColors = new Uint32Array(pImg.width * pImg.height);
      for (let j2 = 0, k = 0; j2 < dataLength; j2 += 4, k++) {
        const r = data2[j2 + 0];
        const g2 = data2[j2 + 1];
        const b2 = data2[j2 + 2];
        const color2 = r << 16 | g2 << 8 | b2 << 0;
        paletteSet.add(color2);
        pixelColors[k] = color2;
      }
      const paletteStr = [...paletteSet].sort().toString();
      if (paletteFreqsAndFrames[paletteStr] === void 0) {
        paletteFreqsAndFrames[paletteStr] = { freq: 1, frames: [i] };
      } else {
        paletteFreqsAndFrames[paletteStr].freq += 1;
        paletteFreqsAndFrames[paletteStr].frames.push(i);
      }
      allFramesPixelColors.push(pixelColors);
    }
    let framesUsingGlobalPalette = [];
    const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a, b2) {
      return paletteFreqsAndFrames[b2].freq - paletteFreqsAndFrames[a].freq;
    });
    const globalPalette = palettesSortedByFreq[0].split(",").map((a) => parseInt(a));
    framesUsingGlobalPalette = framesUsingGlobalPalette.concat(
      paletteFreqsAndFrames[globalPalette].frames
    );
    const globalPaletteSet = new Set(globalPalette);
    for (let i = 1; i < palettesSortedByFreq.length; i++) {
      const palette = palettesSortedByFreq[i].split(",").map((a) => parseInt(a));
      const difference = palette.filter((x) => !globalPaletteSet.has(x));
      if (globalPalette.length + difference.length <= 256) {
        for (let j2 = 0; j2 < difference.length; j2++) {
          globalPalette.push(difference[j2]);
          globalPaletteSet.add(difference[j2]);
        }
        framesUsingGlobalPalette = framesUsingGlobalPalette.concat(
          paletteFreqsAndFrames[palettesSortedByFreq[i]].frames
        );
      }
    }
    framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
    const globalIndicesLookup = {};
    for (let i = 0; i < globalPalette.length; i++) {
      if (!globalIndicesLookup[globalPalette[i]]) {
        globalIndicesLookup[globalPalette[i]] = i;
      }
    }
    let powof2 = 1;
    while (powof2 < globalPalette.length) {
      powof2 <<= 1;
    }
    globalPalette.length = powof2;
    const opts = {
      loop: loopLimit,
      palette: new Uint32Array(globalPalette)
    };
    const gifWriter = new omggifExports.GifWriter(
      buffer,
      pImg.width,
      pImg.height,
      opts
    );
    let previousFrame = {};
    for (let i = 0; i < props.numFrames; i++) {
      const localPaletteRequired = !framesUsingGlobalPalette.has(i);
      const palette = localPaletteRequired ? [] : globalPalette;
      const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
      const colorIndicesLookup = {};
      const cannotBeTransparent = /* @__PURE__ */ new Set();
      allFramesPixelColors[i].forEach((color2, k) => {
        if (localPaletteRequired) {
          if (colorIndicesLookup[color2] === void 0) {
            colorIndicesLookup[color2] = palette.length;
            palette.push(color2);
          }
          pixelPaletteIndex[k] = colorIndicesLookup[color2];
        } else {
          pixelPaletteIndex[k] = globalIndicesLookup[color2];
        }
        if (i > 0) {
          if (allFramesPixelColors[i - 1][k] !== color2) {
            cannotBeTransparent.add(color2);
          }
        }
      });
      const frameOpts = {};
      const canBeTransparent = palette.filter((a) => !cannotBeTransparent.has(a));
      if (canBeTransparent.length > 0) {
        const transparent = canBeTransparent[0];
        const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
        if (i > 0) {
          for (let k = 0; k < allFramesPixelColors[i].length; k++) {
            if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {
              pixelPaletteIndex[k] = transparentIndex;
            }
          }
          frameOpts.transparent = transparentIndex;
          previousFrame.frameOpts.disposal = 1;
        }
      }
      frameOpts.delay = props.frames[i].delay / 10;
      if (localPaletteRequired) {
        let powof22 = 1;
        while (powof22 < palette.length) {
          powof22 <<= 1;
        }
        palette.length = powof22;
        frameOpts.palette = new Uint32Array(palette);
      }
      if (i > 0) {
        gifWriter.addFrame(
          0,
          0,
          pImg.width,
          pImg.height,
          previousFrame.pixelPaletteIndex,
          previousFrame.frameOpts
        );
      }
      previousFrame = {
        pixelPaletteIndex,
        frameOpts
      };
    }
    previousFrame.frameOpts.disposal = 1;
    gifWriter.addFrame(
      0,
      0,
      pImg.width,
      pImg.height,
      previousFrame.pixelPaletteIndex,
      previousFrame.frameOpts
    );
    const extension = "gif";
    const blob = new Blob([buffer.slice(0, gifWriter.end())], {
      type: "image/gif"
    });
    fn2.downloadFile(blob, filename, extension);
  };
  fn2.saveFrames = function(fName, ext, _duration, _fps, callback) {
    let duration2 = _duration || 3;
    duration2 = Math.max(Math.min(duration2, 15), 0);
    duration2 = duration2 * 1e3;
    let fps = _fps || 15;
    fps = Math.max(Math.min(fps, 22), 0);
    let count = 0;
    const makeFrame = fn2._makeFrame;
    const cnv = this._curElement.elt;
    let frames = [];
    const frameFactory = setInterval(() => {
      frames.push(makeFrame(fName + count, ext, cnv));
      count++;
    }, 1e3 / fps);
    setTimeout(() => {
      clearInterval(frameFactory);
      if (callback) {
        callback(frames);
      } else {
        for (const f of frames) {
          fn2.downloadFile(f.imageData, f.filename, f.ext);
        }
      }
      frames = [];
    }, duration2 + 0.01);
  };
  fn2._makeFrame = function(filename, extension, _cnv) {
    let cnv;
    if (this) {
      cnv = this._curElement.elt;
    } else {
      cnv = _cnv;
    }
    let mimeType;
    if (!extension) {
      extension = "png";
      mimeType = "image/png";
    } else {
      switch (extension.toLowerCase()) {
        case "png":
          mimeType = "image/png";
          break;
        case "jpeg":
          mimeType = "image/jpeg";
          break;
        case "jpg":
          mimeType = "image/jpeg";
          break;
        default:
          mimeType = "image/png";
          break;
      }
    }
    const downloadMime = "image/octet-stream";
    let imageData = cnv.toDataURL(mimeType);
    imageData = imageData.replace(mimeType, downloadMime);
    const thisFrame = {};
    thisFrame.imageData = imageData;
    thisFrame.filename = filename;
    thisFrame.ext = extension;
    return thisFrame;
  };
}
if (typeof p5 !== "undefined") {
  image$1(p5, p5.prototype);
}
class HTTPError extends Error {
  status;
  response;
  ok;
}
async function request(path2, type2) {
  try {
    const res = await fetch(path2);
    if (res.ok) {
      let data2;
      switch (type2) {
        case "json":
          data2 = await res.json();
          break;
        case "text":
          data2 = await res.text();
          break;
        case "arrayBuffer":
          data2 = await res.arrayBuffer();
          break;
        case "blob":
          data2 = await res.blob();
          break;
        case "bytes":
          if (res.bytes) {
            data2 = await res.bytes();
          } else {
            const d2 = await res.arrayBuffer();
            data2 = new Uint8Array(d2);
          }
          break;
        default:
          throw new Error("Unsupported response type");
      }
      return { data: data2, headers: res.headers };
    } else {
      const err = new HTTPError(res.statusText);
      err.status = res.status;
      err.response = res;
      err.ok = false;
      throw err;
    }
  } catch (err) {
    if (err instanceof TypeError) {
      console.log("You may have encountered a CORS error");
    } else if (err instanceof HTTPError) {
      console.log("You have encountered a HTTP error");
    } else if (err instanceof SyntaxError) {
      console.log("There is an error parsing the response to requested data structure");
    }
    throw err;
  }
}
function files(p53, fn2) {
  fn2.loadJSON = async function(path2, successCallback, errorCallback) {
    try {
      const { data: data2 } = await request(path2, "json");
      if (successCallback) return successCallback(data2);
      return data2;
    } catch (err) {
      p53._friendlyFileLoadError(5, path2);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadStrings = async function(path2, successCallback, errorCallback) {
    try {
      let { data: data2 } = await request(path2, "text");
      data2 = data2.split(/\r?\n/);
      if (successCallback) return successCallback(data2);
      return data2;
    } catch (err) {
      p53._friendlyFileLoadError(3, path2);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadTable = async function(path2, separator, header, successCallback, errorCallback) {
    if (typeof arguments[arguments.length - 1] === "function") {
      if (typeof arguments[arguments.length - 2] === "function") {
        successCallback = arguments[arguments.length - 2];
        errorCallback = arguments[arguments.length - 1];
      } else {
        successCallback = arguments[arguments.length - 1];
      }
    }
    if (typeof separator !== "string") separator = ",";
    if (typeof header === "function") header = false;
    try {
      let { data: data2 } = await request(path2, "text");
      let ret = new p53.Table();
      data2 = parse$3(data2, {
        separator
      });
      if (header) {
        ret.columns = data2.shift();
      } else {
        ret.columns = Array(data2[0].length).fill(null);
      }
      data2.forEach((line) => {
        const row = new p53.TableRow(line);
        ret.addRow(row);
      });
      if (successCallback) {
        return successCallback(ret);
      } else {
        return ret;
      }
    } catch (err) {
      p53._friendlyFileLoadError(2, path2);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadXML = async function(path2, successCallback, errorCallback) {
    try {
      const parser = new DOMParser();
      let { data: data2 } = await request(path2, "text");
      const parsedDOM = parser.parseFromString(data2, "application/xml");
      data2 = new p53.XML(parsedDOM);
      if (successCallback) return successCallback(data2);
      return data2;
    } catch (err) {
      p53._friendlyFileLoadError(1, path2);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadBytes = async function(path2, successCallback, errorCallback) {
    try {
      let { data: data2 } = await request(path2, "arrayBuffer");
      data2 = new Uint8Array(data2);
      if (successCallback) return successCallback(data2);
      return data2;
    } catch (err) {
      p53._friendlyFileLoadError(6, path2);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadBlob = async function(path2, successCallback, errorCallback) {
    try {
      const { data: data2 } = await request(path2, "blob");
      if (successCallback) return successCallback(data2);
      return data2;
    } catch (err) {
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.httpGet = async function(path2, datatype = "text", successCallback, errorCallback) {
    if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = "text";
    }
    return this.httpDo(path2, "GET", datatype, successCallback, errorCallback);
  };
  fn2.httpPost = async function(path2, data2, datatype = "text", successCallback, errorCallback) {
    if (typeof data2 === "function") {
      successCallback = data2;
      errorCallback = datatype;
      data2 = void 0;
      datatype = "text";
    } else if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = "text";
    }
    let reqData = data2;
    let contentType = "text/plain";
    if (data2 instanceof p53.XML) {
      reqData = data2.serialize();
      contentType = "application/xml";
    } else if (data2 instanceof p53.Image) {
      reqData = await data2.toBlob();
      contentType = "image/png";
    } else if (typeof data2 === "object") {
      reqData = JSON.stringify(data2);
      contentType = "application/json";
    }
    const requestOptions = {
      method: "POST",
      body: reqData,
      headers: {
        "Content-Type": contentType
      }
    };
    if (reqData) {
      requestOptions.body = reqData;
    }
    const req = new Request(path2, requestOptions);
    return this.httpDo(req, "POST", datatype, successCallback, errorCallback);
  };
  fn2.httpDo = async function(path2, method, datatype, successCallback, errorCallback) {
    if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = void 0;
    }
    if (!datatype) {
      const extension = typeof path2 === "string" ? path2.split(".").pop() : path2.url.split(".").pop();
      switch (extension) {
        case "json":
          datatype = "json";
          break;
        case "jpg":
        case "jpeg":
        case "png":
        case "webp":
        case "gif":
          datatype = "blob";
          break;
        case "xml":
        // NOTE: still need to normalize type handling/mapping
        // datatype = 'xml';
        case "txt":
        default:
          datatype = "text";
      }
    }
    const req = new Request(path2, {
      method
    });
    try {
      const { data: data2 } = await request(req, datatype);
      if (successCallback) {
        return successCallback(data2);
      } else {
        return data2;
      }
    } catch (err) {
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2._pWriters = [];
  fn2.createWriter = function(name, extension) {
    let newPW;
    for (const i in fn2._pWriters) {
      if (fn2._pWriters[i].name === name) {
        newPW = new p53.PrintWriter(name + this.millis(), extension);
        fn2._pWriters.push(newPW);
        return newPW;
      }
    }
    newPW = new p53.PrintWriter(name, extension);
    fn2._pWriters.push(newPW);
    return newPW;
  };
  p53.PrintWriter = function(filename, extension) {
    let self2 = this;
    this.name = filename;
    this.content = "";
    this.write = function(data2) {
      this.content += data2;
    };
    this.print = function(data2) {
      this.content += `${data2}
`;
    };
    this.clear = function() {
      this.content = "";
    };
    this.close = function() {
      const arr2 = [];
      arr2.push(this.content);
      fn2.writeFile(arr2, filename, extension);
      for (const i in fn2._pWriters) {
        if (fn2._pWriters[i].name === this.name) {
          fn2._pWriters.splice(i, 1);
        }
      }
      self2.clear();
      self2 = {};
    };
  };
  fn2.save = function(object2, _filename, _options) {
    const args = arguments;
    const cnv = this._curElement ? this._curElement.elt : this.elt;
    if (args.length === 0) {
      fn2.saveCanvas(cnv);
      return;
    } else if (args[0] instanceof Renderer || args[0] instanceof Graphics) {
      fn2.saveCanvas(args[0].canvas, args[1], args[2]);
      return;
    } else if (args.length === 1 && typeof args[0] === "string") {
      fn2.saveCanvas(cnv, args[0]);
    } else {
      const extension = _checkFileExtension(args[1], args[2])[1];
      switch (extension) {
        case "json":
          fn2.saveJSON(args[0], args[1], args[2]);
          return;
        case "txt":
          fn2.saveStrings(args[0], args[1], args[2]);
          return;
        // =================================================
        // OPTION 3: decide based on object...
        default:
          if (args[0] instanceof Array) {
            fn2.saveStrings(args[0], args[1], args[2]);
          } else if (args[0] instanceof p53.Table) {
            fn2.saveTable(args[0], args[1], args[2]);
          } else if (args[0] instanceof p53.Image) {
            fn2.saveCanvas(args[0].canvas, args[1]);
          } else if (args[0] instanceof p53.SoundFile) {
            fn2.saveSound(args[0], args[1], args[2], args[3]);
          }
      }
    }
  };
  fn2.saveJSON = function(json, filename, optimize) {
    let stringify2;
    if (optimize) {
      stringify2 = JSON.stringify(json);
    } else {
      stringify2 = JSON.stringify(json, void 0, 2);
    }
    this.saveStrings(stringify2.split("\n"), filename, "json");
  };
  fn2.saveStrings = function(list, filename, extension, isCRLF) {
    const ext = extension || "txt";
    const pWriter = new p53.PrintWriter(filename, ext);
    for (let item of list) {
      isCRLF ? pWriter.write(item + "\r\n") : pWriter.write(item + "\n");
    }
    pWriter.close();
    pWriter.clear();
  };
  function escapeHelper(content) {
    return content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  fn2.saveTable = function(table2, filename, options2) {
    let ext;
    if (options2 === void 0) {
      ext = filename.substring(filename.lastIndexOf(".") + 1, filename.length);
      if (ext === filename) ext = "csv";
    } else {
      ext = options2;
    }
    const pWriter = this.createWriter(filename, ext);
    const header = table2.columns;
    let sep = ",";
    if (ext === "tsv") {
      sep = "	";
    }
    if (ext !== "html") {
      const output2 = table2.toString(sep);
      pWriter.write(output2);
    } else {
      pWriter.print("<html>");
      pWriter.print("<head>");
      let str = '  <meta http-equiv="content-type" content';
      str += '="text/html;charset=utf-8" />';
      pWriter.print(str);
      pWriter.print("</head>");
      pWriter.print("<body>");
      pWriter.print("  <table>");
      if (header[0] !== "0") {
        pWriter.print("    <tr>");
        for (let k = 0; k < header.length; k++) {
          const e2 = escapeHelper(header[k]);
          pWriter.print(`      <td>${e2}`);
          pWriter.print("      </td>");
        }
        pWriter.print("    </tr>");
      }
      for (let row = 0; row < table2.rows.length; row++) {
        pWriter.print("    <tr>");
        for (let col = 0; col < table2.columns.length; col++) {
          const entry = table2.rows[row].getString(col);
          const htmlEntry = escapeHelper(entry);
          pWriter.print(`      <td>${htmlEntry}`);
          pWriter.print("      </td>");
        }
        pWriter.print("    </tr>");
      }
      pWriter.print("  </table>");
      pWriter.print("</body>");
      pWriter.print("</html>");
    }
    pWriter.close();
    pWriter.clear();
  };
  fn2.writeFile = function(dataToDownload, filename, extension) {
    let type2 = "application/octet-stream";
    if (fn2._isSafari()) {
      type2 = "text/plain";
    }
    const blob = new Blob(dataToDownload, {
      type: type2
    });
    fn2.downloadFile(blob, filename, extension);
  };
  fn2.downloadFile = downloadFile;
  fn2._checkFileExtension = _checkFileExtension;
  fn2._isSafari = function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  };
}
if (typeof p5 !== "undefined") {
  files(p5, p5.prototype);
}
function loadingDisplaying(p53, fn2) {
  fn2.loadImage = async function(path2, successCallback, failureCallback) {
    try {
      let pImg = new p53.Image(1, 1, this);
      const req = new Request(path2, {
        method: "GET",
        mode: "cors"
      });
      const { data: data2, headers } = await request(req, "bytes");
      const contentType = headers.get("content-type");
      if (contentType === null) {
        console.warn(
          "The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset."
        );
      }
      if (contentType && contentType.includes("image/gif")) {
        await _createGif(
          data2,
          pImg
        );
      } else {
        const blob = new Blob([data2]);
        const img = await createImageBitmap(blob);
        pImg.width = pImg.canvas.width = img.width;
        pImg.height = pImg.canvas.height = img.height;
        pImg.drawingContext.drawImage(img, 0, 0);
      }
      pImg.modified = true;
      if (successCallback) {
        return successCallback(pImg);
      } else {
        return pImg;
      }
    } catch (err) {
      p53._friendlyFileLoadError(0, path2);
      if (typeof failureCallback === "function") {
        return failureCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.saveGif = async function(fileName, duration2, options2 = {
    delay: 0,
    units: "seconds",
    silent: false,
    notificationDuration: 0,
    notificationID: "progressBar",
    reset: true
  }) {
    if (typeof fileName !== "string") {
      throw TypeError("fileName parameter must be a string");
    }
    if (typeof duration2 !== "number") {
      throw TypeError("Duration parameter must be a number");
    }
    const delay = options2 && options2.delay || 0;
    const units = options2 && options2.units || "seconds";
    const silent = options2 && options2.silent || false;
    const notificationDuration = options2 && options2.notificationDuration || 0;
    const notificationID = options2 && options2.notificationID || "progressBar";
    const resetAnimation = options2 && options2.reset !== void 0 ? options2.reset : true;
    if (typeof delay !== "number") {
      throw TypeError("Delay parameter must be a number");
    }
    if (units !== "seconds" && units !== "frames") {
      throw TypeError('Units parameter must be either "frames" or "seconds"');
    }
    if (typeof silent !== "boolean") {
      throw TypeError("Silent parameter must be a boolean");
    }
    if (typeof notificationDuration !== "number") {
      throw TypeError("Notification duration parameter must be a number");
    }
    if (typeof notificationID !== "string") {
      throw TypeError("Notification ID parameter must be a string");
    }
    this._recording = true;
    let _frameRate = this._targetFrameRate;
    if (_frameRate === Infinity || _frameRate === void 0 || _frameRate === 0) {
      _frameRate = 60;
    }
    let gifFrameDelay = 1 / _frameRate * 1e3;
    gifFrameDelay = gifFrameDelay < 20 ? 20 : gifFrameDelay;
    const nFrames = units === "seconds" ? duration2 * _frameRate : duration2;
    const nFramesDelay = units === "seconds" ? delay * _frameRate : delay;
    let frameIterator;
    let totalNumberOfFrames;
    if (resetAnimation) {
      frameIterator = nFramesDelay;
      this.frameCount = frameIterator;
      totalNumberOfFrames = nFrames + nFramesDelay;
    } else {
      frameIterator = this.frameCount + nFramesDelay;
      totalNumberOfFrames = frameIterator + nFrames;
    }
    const lastPixelDensity = this._renderer._pixelDensity;
    this.pixelDensity(1);
    let frames = [];
    if (document.getElementById(notificationID) !== null)
      document.getElementById(notificationID).remove();
    let p2;
    if (!silent) {
      p2 = this.createP("");
      p2.id(notificationID);
      p2.style("font-size", "16px");
      p2.style("font-family", "Montserrat");
      p2.style("background-color", "#ffffffa0");
      p2.style("padding", "8px");
      p2.style("border-radius", "10px");
      p2.position(0, 0);
    }
    let pixels2;
    let gl;
    if (this._renderer instanceof p53.RendererGL) {
      gl = this.drawingContext;
      pixels2 = new Uint8Array(
        gl.drawingBufferWidth * gl.drawingBufferHeight * 4
      );
    }
    this.noLoop();
    await new Promise(requestAnimationFrame);
    while (frameIterator < totalNumberOfFrames) {
      this.redraw();
      await new Promise(requestAnimationFrame);
      let data2 = void 0;
      if (this._renderer instanceof p53.RendererGL) {
        pixels2 = new Uint8Array(
          gl.drawingBufferWidth * gl.drawingBufferHeight * 4
        );
        gl.readPixels(
          0,
          0,
          gl.drawingBufferWidth,
          gl.drawingBufferHeight,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels2
        );
        data2 = _flipPixels(pixels2, this.width, this.height);
      } else {
        data2 = this.drawingContext.getImageData(0, 0, this.width, this.height).data;
      }
      frames.push(data2);
      frameIterator++;
      if (!silent) {
        p2.html(
          "Saved frame <b>" + frames.length.toString() + "</b> out of " + nFrames.toString()
        );
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    if (!silent) p2.html("Frames processed, generating color palette...");
    this.loop();
    this.pixelDensity(lastPixelDensity);
    const gif = ct();
    const globalPalette = _generateGlobalPalette(frames);
    const paletteCache = {};
    const getIndexedFrame = (frame) => {
      const length = frame.length / 4;
      const index = new Uint8Array(length);
      for (let i = 0; i < length; i++) {
        const key = frame[i * 4] << 24 | frame[i * 4 + 1] << 16 | frame[i * 4 + 2] << 8 | frame[i * 4 + 3];
        if (paletteCache[key] === void 0) {
          paletteCache[key] = W(
            globalPalette,
            frame.slice(i * 4, (i + 1) * 4)
          );
        }
        index[i] = paletteCache[key];
      }
      return index;
    };
    const transparentIndex = globalPalette.length - 1;
    let prevIndexedFrame = [];
    for (let i = 0; i < frames.length; i++) {
      const indexedFrame = getIndexedFrame(frames[i]);
      const originalIndexedFrame = indexedFrame.slice();
      if (i === 0) {
        gif.writeFrame(indexedFrame, this.width, this.height, {
          palette: globalPalette,
          delay: gifFrameDelay,
          dispose: 1
        });
      } else {
        for (let i2 = 0; i2 < indexedFrame.length; i2++) {
          if (indexedFrame[i2] === prevIndexedFrame[i2]) {
            indexedFrame[i2] = transparentIndex;
          }
        }
        gif.writeFrame(indexedFrame, this.width, this.height, {
          delay: gifFrameDelay,
          transparent: true,
          transparentIndex,
          dispose: 1
        });
      }
      prevIndexedFrame = originalIndexedFrame;
      if (!silent) {
        p2.html(
          "Rendered frame <b>" + i.toString() + "</b> out of " + nFrames.toString()
        );
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    gif.finish();
    const buffer = gif.bytesView();
    const extension = "gif";
    const blob = new Blob([buffer], {
      type: "image/gif"
    });
    frames = [];
    this._recording = false;
    this.loop();
    if (!silent) {
      p2.html("Done. Downloading your gif!🌸");
      if (notificationDuration > 0)
        setTimeout(() => p2.remove(), notificationDuration * 1e3);
    }
    fn2.downloadFile(blob, fileName, extension);
  };
  function _flipPixels(pixels2, width, height) {
    const halfHeight = parseInt(height / 2);
    const bytesPerRow = width * 4;
    const temp = new Uint8Array(width * 4);
    for (let y = 0; y < halfHeight; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;
      temp.set(pixels2.subarray(topOffset, topOffset + bytesPerRow));
      pixels2.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      pixels2.set(temp, bottomOffset);
    }
    return pixels2;
  }
  function _generateGlobalPalette(frames) {
    let allColors = new Uint8Array(frames.length * frames[0].length);
    for (let f = 0; f < frames.length; f++) {
      allColors.set(frames[f], f * frames[0].length);
    }
    let colorPalette = H(allColors, 256, {
      format: "rgba4444",
      oneBitAlpha: true
    });
    if (colorPalette.length === 256) {
      colorPalette[colorPalette.length - 1] = [
        Math.random() * 255,
        Math.random() * 255,
        Math.random() * 255,
        0
      ];
    } else {
      colorPalette.push([
        Math.random() * 255,
        Math.random() * 255,
        Math.random() * 255,
        0
      ]);
    }
    return colorPalette;
  }
  async function _createGif(arrayBuffer, pImg) {
    const gifReader = new omggifExports.GifReader(arrayBuffer);
    pImg.width = pImg.canvas.width = gifReader.width;
    pImg.height = pImg.canvas.height = gifReader.height;
    const frames = [];
    const numFrames = gifReader.numFrames();
    let framePixels = new Uint8ClampedArray(pImg.width * pImg.height * 4);
    const loadGIFFrameIntoImage = (frameNum, gifReader2) => {
      try {
        gifReader2.decodeAndBlitFrameRGBA(frameNum, framePixels);
      } catch (e2) {
        p53._friendlyFileLoadError(8, pImg.src);
        throw e2;
      }
    };
    for (let j2 = 0; j2 < numFrames; j2++) {
      const frameInfo = gifReader.frameInfo(j2);
      const prevFrameData = pImg.drawingContext.getImageData(
        0,
        0,
        pImg.width,
        pImg.height
      );
      framePixels = prevFrameData.data.slice();
      loadGIFFrameIntoImage(j2, gifReader);
      const imageData = new ImageData(framePixels, pImg.width, pImg.height);
      pImg.drawingContext.putImageData(imageData, 0, 0);
      let frameDelay = frameInfo.delay;
      if (frameDelay === 0) {
        frameDelay = 10;
      }
      frames.push({
        image: pImg.drawingContext.getImageData(0, 0, pImg.width, pImg.height),
        delay: frameDelay * 10
        //GIF stores delay in one-hundredth of a second, shift to ms
      });
      if (frameInfo.disposal === 2) {
        pImg.drawingContext.clearRect(
          frameInfo.x,
          frameInfo.y,
          frameInfo.width,
          frameInfo.height
        );
      } else if (frameInfo.disposal === 3) {
        pImg.drawingContext.putImageData(
          prevFrameData,
          0,
          0,
          frameInfo.x,
          frameInfo.y,
          frameInfo.width,
          frameInfo.height
        );
      }
    }
    let loopLimit = gifReader.loopCount();
    if (loopLimit === null) {
      loopLimit = 1;
    } else if (loopLimit === 0) {
      loopLimit = null;
    }
    pImg.drawingContext.putImageData(frames[0].image, 0, 0);
    if (frames.length > 1) {
      pImg.gifProperties = {
        displayIndex: 0,
        loopLimit,
        loopCount: 0,
        frames,
        numFrames,
        playing: true,
        timeDisplayed: 0,
        lastChangeTime: 0
      };
    }
    return pImg;
  }
  function _imageContain(xAlign, yAlign, dx, dy, dw, dh, sw, sh) {
    const r = Math.max(sw / dw, sh / dh);
    const [adjusted_dw, adjusted_dh] = [sw / r, sh / r];
    let x = dx;
    let y = dy;
    if (xAlign === CENTER) {
      x += (dw - adjusted_dw) / 2;
    } else if (xAlign === RIGHT) {
      x += dw - adjusted_dw;
    }
    if (yAlign === CENTER) {
      y += (dh - adjusted_dh) / 2;
    } else if (yAlign === BOTTOM) {
      y += dh - adjusted_dh;
    }
    return { x, y, w: adjusted_dw, h: adjusted_dh };
  }
  function _imageCover(xAlign, yAlign, dw, dh, sx, sy, sw, sh) {
    const r = Math.max(dw / sw, dh / sh);
    const [adjusted_sw, adjusted_sh] = [dw / r, dh / r];
    let x = sx;
    let y = sy;
    if (xAlign === CENTER) {
      x += (sw - adjusted_sw) / 2;
    } else if (xAlign === RIGHT) {
      x += sw - adjusted_sw;
    }
    if (yAlign === CENTER) {
      y += (sh - adjusted_sh) / 2;
    } else if (yAlign === BOTTOM) {
      y += sh - adjusted_sh;
    }
    return { x, y, w: adjusted_sw, h: adjusted_sh };
  }
  function _imageFit(fit, xAlign, yAlign, dx, dy, dw, dh, sx, sy, sw, sh) {
    if (fit === COVER) {
      const { x, y, w, h } = _imageCover(
        xAlign,
        yAlign,
        dw,
        dh,
        sx,
        sy,
        sw,
        sh
      );
      sx = x;
      sy = y;
      sw = w;
      sh = h;
    }
    if (fit === CONTAIN) {
      const { x, y, w, h } = _imageContain(
        xAlign,
        yAlign,
        dx,
        dy,
        dw,
        dh,
        sw,
        sh
      );
      dx = x;
      dy = y;
      dw = w;
      dh = h;
    }
    return { sx, sy, sw, sh, dx, dy, dw, dh };
  }
  function _sAssign(sVal, iVal) {
    if (sVal > 0 && sVal < iVal) {
      return sVal;
    } else {
      return iVal;
    }
  }
  fn2.image = function(img, dx, dy, dWidth, dHeight, sx, sy, sWidth, sHeight, fit, xAlign, yAlign) {
    let defW = img.width;
    let defH = img.height;
    yAlign = yAlign || CENTER;
    xAlign = xAlign || CENTER;
    if (img.elt) {
      defW = defW !== void 0 ? defW : img.elt.width;
      defH = defH !== void 0 ? defH : img.elt.height;
    }
    if (img.elt && img.elt.videoWidth && !img.canvas) {
      defW = defW !== void 0 ? defW : img.elt.videoWidth;
      defH = defH !== void 0 ? defH : img.elt.videoHeight;
    }
    let _dx = dx;
    let _dy = dy;
    let _dw = dWidth || defW;
    let _dh = dHeight || defH;
    let _sx = sx || 0;
    let _sy = sy || 0;
    let _sw = sWidth !== void 0 ? sWidth : defW;
    let _sh = sHeight !== void 0 ? sHeight : defH;
    _sw = _sAssign(_sw, defW);
    _sh = _sAssign(_sh, defH);
    let pd = 1;
    if (img.elt && !img.canvas && img.elt.style.width) {
      if (img.elt.videoWidth && !dWidth) {
        pd = img.elt.videoWidth;
      } else {
        pd = img.elt.width;
      }
      pd /= parseInt(img.elt.style.width, 10);
    }
    _sx *= pd;
    _sy *= pd;
    _sh *= pd;
    _sw *= pd;
    let vals = canvas.modeAdjust(
      _dx,
      _dy,
      _dw,
      _dh,
      this._renderer.states.imageMode
    );
    vals = _imageFit(
      fit,
      xAlign,
      yAlign,
      vals.x,
      vals.y,
      vals.w,
      vals.h,
      _sx,
      _sy,
      _sw,
      _sh
    );
    this._renderer.image(
      img,
      vals.sx,
      vals.sy,
      vals.sw,
      vals.sh,
      vals.dx,
      vals.dy,
      vals.dw,
      vals.dh
    );
  };
  fn2.tint = function(...args) {
    const c = this.color(...args);
    this._renderer.states.setValue("tint", c._getRGBA([255, 255, 255, 255]));
  };
  fn2.noTint = function() {
    this._renderer.states.setValue("tint", null);
  };
  fn2.imageMode = function(m) {
    if (m === CORNER || m === CORNERS || m === CENTER) {
      this._renderer.states.setValue("imageMode", m);
    }
  };
}
if (typeof p5 !== "undefined") {
  loadingDisplaying(p5, p5.prototype);
}
class Camera {
  constructor(renderer2) {
    this._renderer = renderer2;
    this.cameraType = "default";
    this.useLinePerspective = true;
    this.cameraMatrix = new Matrix(4);
    this.projMatrix = new Matrix(4);
    this.yScale = 1;
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Camera Projection Methods
  ////////////////////////////////////////////////////////////////////////////////
  /**
   * Sets a perspective projection for the camera.
   *
   * In a perspective projection, shapes that are further from the camera appear
   * smaller than shapes that are near the camera. This technique, called
   * foreshortening, creates realistic 3D scenes. It’s applied by default in new
   * `p5.Camera` objects.
   *
   * `myCamera.perspective()` changes the camera’s perspective by changing its
   * viewing frustum. The frustum is the volume of space that’s visible to the
   * camera. The frustum’s shape is a pyramid with its top cut off. The camera
   * is placed where the top of the pyramid should be and points towards the
   * base of the pyramid. It views everything within the frustum.
   *
   * The first parameter, `fovy`, is the camera’s vertical field of view. It’s
   * an angle that describes how tall or narrow a view the camera has. For
   * example, calling `myCamera.perspective(0.5)` sets the camera’s vertical
   * field of view to 0.5 radians. By default, `fovy` is calculated based on the
   * sketch’s height and the camera’s default z-coordinate, which is 800. The
   * formula for the default `fovy` is `2 * atan(height / 2 / 800)`.
   *
   * The second parameter, `aspect`, is the camera’s aspect ratio. It’s a number
   * that describes the ratio of the top plane’s width to its height. For
   * example, calling `myCamera.perspective(0.5, 1.5)` sets the camera’s field
   * of view to 0.5 radians and aspect ratio to 1.5, which would make shapes
   * appear thinner on a square canvas. By default, `aspect` is set to
   * `width / height`.
   *
   * The third parameter, `near`, is the distance from the camera to the near
   * plane. For example, calling `myCamera.perspective(0.5, 1.5, 100)` sets the
   * camera’s field of view to 0.5 radians, its aspect ratio to 1.5, and places
   * the near plane 100 pixels from the camera. Any shapes drawn less than 100
   * pixels from the camera won’t be visible. By default, `near` is set to
   * `0.1 * 800`, which is 1/10th the default distance between the camera and
   * the origin.
   *
   * The fourth parameter, `far`, is the distance from the camera to the far
   * plane. For example, calling `myCamera.perspective(0.5, 1.5, 100, 10000)`
   * sets the camera’s field of view to 0.5 radians, its aspect ratio to 1.5,
   * places the near plane 100 pixels from the camera, and places the far plane
   * 10,000 pixels from the camera. Any shapes drawn more than 10,000 pixels
   * from the camera won’t be visible. By default, `far` is set to `10 * 800`,
   * which is 10 times the default distance between the camera and the origin.
   *
   * @for p5.Camera
   * @param  {Number} [fovy]   camera frustum vertical field of view. Defaults to
   *                           `2 * atan(height / 2 / 800)`.
   * @param  {Number} [aspect] camera frustum aspect ratio. Defaults to
   *                           `width / height`.
   * @param  {Number} [near]   distance from the camera to the near clipping plane.
   *                           Defaults to `0.1 * 800`.
   * @param  {Number} [far]    distance from the camera to the far clipping plane.
   *                           Defaults to `10 * 800`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it at the top-right.
   *   cam2.camera(400, -400, 800);
   *
   *   // Set its fovy to 0.2.
   *   // Set its aspect to 1.5.
   *   // Set its near to 600.
   *   // Set its far to 1200.
   *   cam2.perspective(0.2, 1.5, 600, 1200);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe('A white cube on a gray background. The camera toggles between a frontal view and a skewed aerial view when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the box.
   *   box();
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it at the top-right.
   *   cam2.camera(400, -400, 800);
   *
   *   // Set its fovy to 0.2.
   *   // Set its aspect to 1.5.
   *   // Set its near to 600.
   *   // Set its far to 1200.
   *   cam2.perspective(0.2, 1.5, 600, 1200);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe('A white cube moves left and right on a gray background. The camera toggles between a frontal and a skewed aerial view when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin left and right.
   *   let x = 100 * sin(frameCount * 0.01);
   *   translate(x, 0, 0);
   *
   *   // Draw the box.
   *   box();
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  perspective(fovy, aspect, near, far) {
    const range2 = this._renderer.zClipRange();
    this.cameraType = arguments.length > 0 ? "custom" : "default";
    if (typeof fovy === "undefined") {
      fovy = this.defaultCameraFOV;
      this.cameraFOV = fovy;
    } else {
      this.cameraFOV = this._renderer._pInst._toRadians(fovy);
    }
    if (typeof aspect === "undefined") {
      aspect = this.defaultAspectRatio;
    }
    if (typeof near === "undefined") {
      near = this.defaultCameraNear;
    }
    if (typeof far === "undefined") {
      far = this.defaultCameraFar;
    }
    if (near <= 1e-4) {
      near = 0.01;
      console.log(
        "Avoid perspective near plane values close to or below 0. Setting value to 0.01."
      );
    }
    if (far < near) {
      console.log(
        "Perspective far plane value is less than near plane value. Nothing will be shown."
      );
    }
    this.aspectRatio = aspect;
    this.cameraNear = near;
    this.cameraFar = far;
    this.projMatrix = new Matrix(4);
    const f = 1 / Math.tan(this.cameraFOV / 2);
    const nf = 1 / (this.cameraNear - this.cameraFar);
    let A, B;
    if (range2[0] === 0) {
      A = far / (near - far);
      B = far * near / (near - far);
    } else {
      A = (far + near) * nf;
      B = 2 * far * near * nf;
    }
    this.projMatrix.set(
      f / aspect,
      0,
      0,
      0,
      0,
      -f * this.yScale,
      0,
      0,
      0,
      0,
      A,
      -1,
      0,
      0,
      B,
      0
    );
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
  }
  /**
   * Sets an orthographic projection for the camera.
   *
   * In an orthographic projection, shapes with the same size always appear the
   * same size, regardless of whether they are near or far from the camera.
   *
   * `myCamera.ortho()` changes the camera’s perspective by changing its viewing
   * frustum from a truncated pyramid to a rectangular prism. The frustum is the
   * volume of space that’s visible to the camera. The camera is placed in front
   * of the frustum and views everything within the frustum. `myCamera.ortho()`
   * has six optional parameters to define the viewing frustum.
   *
   * The first four parameters, `left`, `right`, `bottom`, and `top`, set the
   * coordinates of the frustum’s sides, bottom, and top. For example, calling
   * `myCamera.ortho(-100, 100, 200, -200)` creates a frustum that’s 200 pixels
   * wide and 400 pixels tall. By default, these dimensions are set based on
   * the sketch’s width and height, as in
   * `myCamera.ortho(-width / 2, width / 2, -height / 2, height / 2)`.
   *
   * The last two parameters, `near` and `far`, set the distance of the
   * frustum’s near and far plane from the camera. For example, calling
   * `myCamera.ortho(-100, 100, 200, -200, 50, 1000)` creates a frustum that’s
   * 200 pixels wide, 400 pixels tall, starts 50 pixels from the camera, and
   * ends 1,000 pixels from the camera. By default, `near` and `far` are set to
   * 0 and `max(width, height) + 800`, respectively.
   *
   * @for p5.Camera
   * @param  {Number} [left]   x-coordinate of the frustum’s left plane. Defaults to `-width / 2`.
   * @param  {Number} [right]  x-coordinate of the frustum’s right plane. Defaults to `width / 2`.
   * @param  {Number} [bottom] y-coordinate of the frustum’s bottom plane. Defaults to `height / 2`.
   * @param  {Number} [top]    y-coordinate of the frustum’s top plane. Defaults to `-height / 2`.
   * @param  {Number} [near]   z-coordinate of the frustum’s near plane. Defaults to 0.
   * @param  {Number} [far]    z-coordinate of the frustum’s far plane. Defaults to `max(width, height) + 800`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Apply an orthographic projection.
   *   cam2.ortho();
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe('A row of white cubes against a gray background. The camera toggles between a perspective and an orthographic projection when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -40);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Apply an orthographic projection.
   *   cam2.ortho();
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe('A row of white cubes slither like a snake against a gray background. The camera toggles between a perspective and an orthographic projection when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     push();
   *     // Calculate the box's coordinates.
   *     let x = 10 * sin(frameCount * 0.02 + i * 0.6);
   *     let z = -40 * i;
   *     // Translate the origin.
   *     translate(x, 0, z);
   *     // Draw the box.
   *     box(10);
   *     pop();
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  ortho(left, right, bottom, top, near, far) {
    const source = this.fbo || this._renderer;
    if (left === void 0) left = -source.width / 2;
    if (right === void 0) right = +source.width / 2;
    if (bottom === void 0) bottom = -source.height / 2;
    if (top === void 0) top = +source.height / 2;
    if (near === void 0) near = 0;
    if (far === void 0) far = Math.max(source.width, source.height) + 800;
    this.cameraNear = near;
    this.cameraFar = far;
    const w = right - left;
    const h = top - bottom;
    const d2 = far - near;
    const x = 2 / w;
    const y = 2 / h * this.yScale;
    const z = -2 / d2;
    const tx = -(right + left) / w;
    const ty = -(top + bottom) / h;
    const tz = -(far + near) / d2;
    this.projMatrix = new Matrix(4);
    this.projMatrix.set(
      x,
      0,
      0,
      0,
      0,
      -y,
      0,
      0,
      0,
      0,
      z,
      0,
      tx,
      ty,
      tz,
      1
    );
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
    this.cameraType = "custom";
  }
  /**
   * Sets the camera's frustum.
   *
   * In a frustum projection, shapes that are further from the camera appear
   * smaller than shapes that are near the camera. This technique, called
   * foreshortening, creates realistic 3D scenes.
   *
   * `myCamera.frustum()` changes the camera’s perspective by changing its
   * viewing frustum. The frustum is the volume of space that’s visible to the
   * camera. The frustum’s shape is a pyramid with its top cut off. The camera
   * is placed where the top of the pyramid should be and points towards the
   * base of the pyramid. It views everything within the frustum.
   *
   * The first four parameters, `left`, `right`, `bottom`, and `top`, set the
   * coordinates of the frustum’s sides, bottom, and top. For example, calling
   * `myCamera.frustum(-100, 100, 200, -200)` creates a frustum that’s 200
   * pixels wide and 400 pixels tall. By default, these coordinates are set
   * based on the sketch’s width and height, as in
   * `myCamera.frustum(-width / 20, width / 20, height / 20, -height / 20)`.
   *
   * The last two parameters, `near` and `far`, set the distance of the
   * frustum’s near and far plane from the camera. For example, calling
   * `myCamera.frustum(-100, 100, 200, -200, 50, 1000)` creates a frustum that’s
   * 200 pixels wide, 400 pixels tall, starts 50 pixels from the camera, and ends
   * 1,000 pixels from the camera. By default, near is set to `0.1 * 800`, which
   * is 1/10th the default distance between the camera and the origin. `far` is
   * set to `10 * 800`, which is 10 times the default distance between the
   * camera and the origin.
   *
   * @for p5.Camera
   * @param  {Number} [left]   x-coordinate of the frustum’s left plane. Defaults to `-width / 20`.
   * @param  {Number} [right]  x-coordinate of the frustum’s right plane. Defaults to `width / 20`.
   * @param  {Number} [bottom] y-coordinate of the frustum’s bottom plane. Defaults to `height / 20`.
   * @param  {Number} [top]    y-coordinate of the frustum’s top plane. Defaults to `-height / 20`.
   * @param  {Number} [near]   z-coordinate of the frustum’s near plane. Defaults to `0.1 * 800`.
   * @param  {Number} [far]    z-coordinate of the frustum’s far plane. Defaults to `10 * 800`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Adjust the frustum.
   *   // Center it.
   *   // Set its width and height to 20 pixels.
   *   // Place its near plane 300 pixels from the camera.
   *   // Place its far plane 350 pixels from the camera.
   *   cam2.frustum(-10, 10, -10, 10, 300, 350);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera zooms in on one cube when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 600);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -40);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  frustum(left, right, bottom, top, near, far) {
    if (left === void 0) left = -this._renderer.width * 0.05;
    if (right === void 0) right = +this._renderer.width * 0.05;
    if (bottom === void 0) bottom = +this._renderer.height * 0.05;
    if (top === void 0) top = -this._renderer.height * 0.05;
    if (near === void 0) near = this.defaultCameraNear;
    if (far === void 0) far = this.defaultCameraFar;
    this.cameraNear = near;
    this.cameraFar = far;
    const w = right - left;
    const h = top - bottom;
    const d2 = far - near;
    const x = +(2 * near) / w;
    const y = +(2 * near) / h * this.yScale;
    const z = -(2 * far * near) / d2;
    const tx = (right + left) / w;
    const ty = (top + bottom) / h;
    const tz = -(far + near) / d2;
    this.projMatrix = new Matrix(4);
    this.projMatrix.set(
      x,
      0,
      0,
      0,
      0,
      -y,
      0,
      0,
      tx,
      ty,
      tz,
      -1,
      0,
      0,
      z,
      0
    );
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
    this.cameraType = "custom";
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Camera Orientation Methods
  ////////////////////////////////////////////////////////////////////////////////
  /**
   * Rotate camera view about arbitrary axis defined by x,y,z
   * based on http://learnwebgl.brown37.net/07_cameras/camera_rotating_motion.html
   * @private
   */
  _rotateView(a, x, y, z) {
    let centerX = this.centerX;
    let centerY = this.centerY;
    let centerZ = this.centerZ;
    centerX -= this.eyeX;
    centerY -= this.eyeY;
    centerZ -= this.eyeZ;
    const rotation = new Matrix(4);
    rotation.rotate4x4(this._renderer._pInst._toRadians(a), x, y, z);
    const rotatedCenter = [
      centerX * rotation.mat4[0] + centerY * rotation.mat4[4] + centerZ * rotation.mat4[8],
      centerX * rotation.mat4[1] + centerY * rotation.mat4[5] + centerZ * rotation.mat4[9],
      centerX * rotation.mat4[2] + centerY * rotation.mat4[6] + centerZ * rotation.mat4[10]
    ];
    rotatedCenter[0] += this.eyeX;
    rotatedCenter[1] += this.eyeY;
    rotatedCenter[2] += this.eyeZ;
    this.camera(
      this.eyeX,
      this.eyeY,
      this.eyeZ,
      rotatedCenter[0],
      rotatedCenter[1],
      rotatedCenter[2],
      this.upX,
      this.upY,
      this.upZ
    );
  }
  /**
   * Rotates the camera in a clockwise/counter-clockwise direction.
   *
   * Rolling rotates the camera without changing its orientation. The rotation
   * happens in the camera’s "local" space.
   *
   * The parameter, `angle`, is the angle the camera should rotate. Passing a
   * positive angle, as in `myCamera.roll(0.001)`, rotates the camera in counter-clockwise direction.
   * Passing a negative angle, as in `myCamera.roll(-0.001)`, rotates the
   * camera in clockwise direction.
   *
   * Note: Angles are interpreted based on the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @method roll
   * @param {Number} angle amount to rotate camera in current
   * <a href="#/p5/angleMode">angleMode</a> units.
   * @example
   * <div>
   * <code>
   * let cam;
   * let delta = 0.01;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *   normalMaterial();
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Roll camera according to angle 'delta'
   *   cam.roll(delta);
   *
   *   translate(0, 0, 0);
   *   box(20);
   *   translate(0, 25, 0);
   *   box(20);
   *   translate(0, 26, 0);
   *   box(20);
   *   translate(0, 27, 0);
   *   box(20);
   *   translate(0, 28, 0);
   *   box(20);
   *   translate(0,29, 0);
   *   box(20);
   *   translate(0, 30, 0);
   *   box(20);
   * }
   * </code>
   * </div>
   *
   * @alt
   * camera view rotates in counter clockwise direction with vertically stacked boxes in front of it.
   */
  roll(amount) {
    const local = this._getLocalAxes();
    const axisQuaternion = Quat.fromAxisAngle(
      this._renderer._pInst._toRadians(amount),
      local.z[0],
      local.z[1],
      local.z[2]
    );
    const newUpVector = axisQuaternion.rotateVector(
      new Vector(this.upX, this.upY, this.upZ)
    );
    this.camera(
      this.eyeX,
      this.eyeY,
      this.eyeZ,
      this.centerX,
      this.centerY,
      this.centerZ,
      newUpVector.x,
      newUpVector.y,
      newUpVector.z
    );
  }
  /**
   * Rotates the camera left and right.
   *
   * Panning rotates the camera without changing its position. The rotation
   * happens in the camera’s "local" space.
   *
   * The parameter, `angle`, is the angle the camera should rotate. Passing a
   * positive angle, as in `myCamera.pan(0.001)`, rotates the camera to the
   * right. Passing a negative angle, as in `myCamera.pan(-0.001)`, rotates the
   * camera to the left.
   *
   * Note: Angles are interpreted based on the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param {Number} angle amount to rotate in the current
   *                       <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let delta = 0.001;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube goes in and out of view as the camera pans left and right.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Pan with the camera.
   *   cam.pan(delta);
   *
   *   // Switch directions every 120 frames.
   *   if (frameCount % 120 === 0) {
   *     delta *= -1;
   *   }
   *
   *   // Draw the box.
   *   box();
   * }
   * </code>
   * </div>
   */
  pan(amount) {
    const local = this._getLocalAxes();
    this._rotateView(amount, local.y[0], local.y[1], local.y[2]);
  }
  /**
   * Rotates the camera up and down.
   *
   * Tilting rotates the camera without changing its position. The rotation
   * happens in the camera’s "local" space.
   *
   * The parameter, `angle`, is the angle the camera should rotate. Passing a
   * positive angle, as in `myCamera.tilt(0.001)`, rotates the camera down.
   * Passing a negative angle, as in `myCamera.tilt(-0.001)`, rotates the camera
   * up.
   *
   * Note: Angles are interpreted based on the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param {Number} angle amount to rotate in the current
   *                       <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let delta = 0.001;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube goes in and out of view as the camera tilts up and down.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Pan with the camera.
   *   cam.tilt(delta);
   *
   *   // Switch directions every 120 frames.
   *   if (frameCount % 120 === 0) {
   *     delta *= -1;
   *   }
   *
   *   // Draw the box.
   *   box();
   * }
   * </code>
   * </div>
   */
  tilt(amount) {
    const local = this._getLocalAxes();
    this._rotateView(amount, local.x[0], local.x[1], local.x[2]);
  }
  /**
   * Points the camera at a location.
   *
   * `myCamera.lookAt()` changes the camera’s orientation without changing its
   * position.
   *
   * The parameters, `x`, `y`, and `z`, are the coordinates in "world" space
   * where the camera should point. For example, calling
   * `myCamera.lookAt(10, 20, 30)` points the camera at the coordinates
   * `(10, 20, 30)`.
   *
   * @for p5.Camera
   * @param {Number} x x-coordinate of the position where the camera should look in "world" space.
   * @param {Number} y y-coordinate of the position where the camera should look in "world" space.
   * @param {Number} z z-coordinate of the position where the camera should look in "world" space.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to look at a different cube.
   *
   * let cam;
   * let isLookingLeft = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(-30, 0, 0);
   *
   *   describe(
   *     'A red cube and a blue cube on a gray background. The camera switches focus between the cubes when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the box on the left.
   *   push();
   *   // Translate the origin to the left.
   *   translate(-30, 0, 0);
   *   // Style the box.
   *   fill(255, 0, 0);
   *   // Draw the box.
   *   box(20);
   *   pop();
   *
   *   // Draw the box on the right.
   *   push();
   *   // Translate the origin to the right.
   *   translate(30, 0, 0);
   *   // Style the box.
   *   fill(0, 0, 255);
   *   // Draw the box.
   *   box(20);
   *   pop();
   * }
   *
   * // Change the camera's focus when the user double-clicks.
   * function doubleClicked() {
   *   if (isLookingLeft === true) {
   *     cam.lookAt(30, 0, 0);
   *     isLookingLeft = false;
   *   } else {
   *     cam.lookAt(-30, 0, 0);
   *     isLookingLeft = true;
   *   }
   * }
   * </code>
   * </div>
   */
  lookAt(x, y, z) {
    this.camera(
      this.eyeX,
      this.eyeY,
      this.eyeZ,
      x,
      y,
      z,
      this.upX,
      this.upY,
      this.upZ
    );
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Camera Position Methods
  ////////////////////////////////////////////////////////////////////////////////
  /**
   * Sets the position and orientation of the camera.
   *
   * `myCamera.camera()` allows objects to be viewed from different angles. It
   * has nine parameters that are all optional.
   *
   * The first three parameters, `x`, `y`, and `z`, are the coordinates of the
   * camera’s position in "world" space. For example, calling
   * `myCamera.camera(0, 0, 0)` places the camera at the origin `(0, 0, 0)`. By
   * default, the camera is placed at `(0, 0, 800)`.
   *
   * The next three parameters, `centerX`, `centerY`, and `centerZ` are the
   * coordinates of the point where the camera faces in "world" space. For
   * example, calling `myCamera.camera(0, 0, 0, 10, 20, 30)` places the camera
   * at the origin `(0, 0, 0)` and points it at `(10, 20, 30)`. By default, the
   * camera points at the origin `(0, 0, 0)`.
   *
   * The last three parameters, `upX`, `upY`, and `upZ` are the components of
   * the "up" vector in "local" space. The "up" vector orients the camera’s
   * y-axis. For example, calling
   * `myCamera.camera(0, 0, 0, 10, 20, 30, 0, -1, 0)` places the camera at the
   * origin `(0, 0, 0)`, points it at `(10, 20, 30)`, and sets the "up" vector
   * to `(0, -1, 0)` which is like holding it upside-down. By default, the "up"
   * vector is `(0, 1, 0)`.
   *
   * @for p5.Camera
   * @param  {Number} [x]        x-coordinate of the camera. Defaults to 0.
   * @param  {Number} [y]        y-coordinate of the camera. Defaults to 0.
   * @param  {Number} [z]        z-coordinate of the camera. Defaults to 800.
   * @param  {Number} [centerX]  x-coordinate of the point the camera faces. Defaults to 0.
   * @param  {Number} [centerY]  y-coordinate of the point the camera faces. Defaults to 0.
   * @param  {Number} [centerZ]  z-coordinate of the point the camera faces. Defaults to 0.
   * @param  {Number} [upX]      x-component of the camera’s "up" vector. Defaults to 0.
   * @param  {Number} [upY]      x-component of the camera’s "up" vector. Defaults to 1.
   * @param  {Number} [upZ]      z-component of the camera’s "up" vector. Defaults to 0.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it at the top-right: (1200, -600, 100)
   *   // Point it at the row of boxes: (-10, -10, 400)
   *   // Set its "up" vector to the default: (0, 1, 0)
   *   cam2.camera(1200, -600, 100, -10, -10, 400, 0, 1, 0);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera toggles between a frontal and an aerial view when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -30);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it at the right: (1200, 0, 100)
   *   // Point it at the row of boxes: (-10, -10, 400)
   *   // Set its "up" vector to the default: (0, 1, 0)
   *   cam2.camera(1200, 0, 100, -10, -10, 400, 0, 1, 0);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera toggles between a static frontal view and an orbiting view when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Update cam2's position.
   *   let x = 1200 * cos(frameCount * 0.01);
   *   let y = -600 * sin(frameCount * 0.01);
   *   cam2.camera(x, y, 100, -10, -10, 400, 0, 1, 0);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -30);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
    if (typeof eyeX === "undefined") {
      eyeX = this.defaultEyeX;
      eyeY = this.defaultEyeY;
      eyeZ = this.defaultEyeZ;
      centerX = eyeX;
      centerY = eyeY;
      centerZ = 0;
      upX = 0;
      upY = 1;
      upZ = 0;
    }
    this.eyeX = eyeX;
    this.eyeY = eyeY;
    this.eyeZ = eyeZ;
    if (typeof centerX !== "undefined") {
      this.centerX = centerX;
      this.centerY = centerY;
      this.centerZ = centerZ;
    }
    if (typeof upX !== "undefined") {
      this.upX = upX;
      this.upY = upY;
      this.upZ = upZ;
    }
    const local = this._getLocalAxes();
    this.cameraMatrix.set(
      local.x[0],
      local.y[0],
      local.z[0],
      0,
      local.x[1],
      local.y[1],
      local.z[1],
      0,
      local.x[2],
      local.y[2],
      local.z[2],
      0,
      0,
      0,
      0,
      1
    );
    const tx = -eyeX;
    const ty = -eyeY;
    const tz = -eyeZ;
    this.cameraMatrix.translate([tx, ty, tz]);
    if (this._isActive()) {
      this._renderer.states.setValue("uViewMatrix", this._renderer.states.uViewMatrix.clone());
      this._renderer.states.uViewMatrix.set(this.cameraMatrix);
    }
    return this;
  }
  /**
   * Moves the camera along its "local" axes without changing its orientation.
   *
   * The parameters, `x`, `y`, and `z`, are the distances the camera should
   * move. For example, calling `myCamera.move(10, 20, 30)` moves the camera 10
   * pixels to the right, 20 pixels down, and 30 pixels backward in its "local"
   * space.
   *
   * @param {Number} x distance to move along the camera’s "local" x-axis.
   * @param {Number} y distance to move along the camera’s "local" y-axis.
   * @param {Number} z distance to move along the camera’s "local" z-axis.
   * @example
   * <div>
   * <code>
   * // Click the canvas to begin detecting key presses.
   *
   * let cam;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam = createCamera();
   *
   *   // Place the camera at the top-right.
   *   cam.setPosition(400, -400, 800);
   *
   *   // Point it at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   // Set the camera.
   *   setCamera(cam);
   *
   *   describe(
   *     'A white cube drawn against a gray background. The cube appears to move when the user presses certain keys.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Move the camera along its "local" axes
   *   // when the user presses certain keys.
   *
   *   // Move horizontally.
   *   if (keyIsDown(LEFT_ARROW)) {
   *     cam.move(-1, 0, 0);
   *   }
   *   if (keyIsDown(RIGHT_ARROW)) {
   *     cam.move(1, 0, 0);
   *   }
   *
   *   // Move vertically.
   *   if (keyIsDown(UP_ARROW)) {
   *     cam.move(0, -1, 0);
   *   }
   *   if (keyIsDown(DOWN_ARROW)) {
   *     cam.move(0, 1, 0);
   *   }
   *
   *   // Move in/out of the screen.
   *   if (keyIsDown('i')) {
   *     cam.move(0, 0, -1);
   *   }
   *   if (keyIsDown('o')) {
   *     cam.move(0, 0, 1);
   *   }
   *
   *   // Draw the box.
   *   box();
   * }
   * </code>
   * </div>
   */
  move(x, y, z) {
    const local = this._getLocalAxes();
    const dx = [local.x[0] * x, local.x[1] * x, local.x[2] * x];
    const dy = [local.y[0] * y, local.y[1] * y, local.y[2] * y];
    const dz = [local.z[0] * z, local.z[1] * z, local.z[2] * z];
    this.camera(
      this.eyeX + dx[0] + dy[0] + dz[0],
      this.eyeY + dx[1] + dy[1] + dz[1],
      this.eyeZ + dx[2] + dy[2] + dz[2],
      this.centerX + dx[0] + dy[0] + dz[0],
      this.centerY + dx[1] + dy[1] + dz[1],
      this.centerZ + dx[2] + dy[2] + dz[2],
      this.upX,
      this.upY,
      this.upZ
    );
  }
  /**
   * Sets the camera’s position in "world" space without changing its
   * orientation.
   *
   * The parameters, `x`, `y`, and `z`, are the coordinates where the camera
   * should be placed. For example, calling `myCamera.setPosition(10, 20, 30)`
   * places the camera at coordinates `(10, 20, 30)` in "world" space.
   *
   * @param {Number} x x-coordinate in "world" space.
   * @param {Number} y y-coordinate in "world" space.
   * @param {Number} z z-coordinate in "world" space.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it closer to the origin.
   *   cam2.setPosition(0, 0, 600);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera toggles the amount of zoom when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -30);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it closer to the origin.
   *   cam2.setPosition(0, 0, 600);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera toggles between a static view and a view that zooms in and out when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Update cam2's z-coordinate.
   *   let z = 100 * sin(frameCount * 0.01) + 700;
   *   cam2.setPosition(0, 0, z);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -30);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  setPosition(x, y, z) {
    const diffX = x - this.eyeX;
    const diffY = y - this.eyeY;
    const diffZ = z - this.eyeZ;
    this.camera(
      x,
      y,
      z,
      this.centerX + diffX,
      this.centerY + diffY,
      this.centerZ + diffZ,
      this.upX,
      this.upY,
      this.upZ
    );
  }
  /**
   * Sets the camera’s position, orientation, and projection by copying another
   * camera.
   *
   * The parameter, `cam`, is the `p5.Camera` object to copy. For example, calling
   * `cam2.set(cam1)` will set `cam2` using `cam1`’s configuration.
   *
   * @param {p5.Camera} cam camera to copy.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to "reset" the camera zoom.
   *
   * let cam1;
   * let cam2;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   cam1 = createCamera();
   *
   *   // Place the camera at the top-right.
   *   cam1.setPosition(400, -400, 800);
   *
   *   // Point it at the origin.
   *   cam1.lookAt(0, 0, 0);
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Copy cam1's configuration.
   *   cam2.set(cam1);
   *
   *   // Set the camera.
   *   setCamera(cam2);
   *
   *   describe(
   *     'A white cube drawn against a gray background. The camera slowly moves forward. The camera resets when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Update cam2's position.
   *   cam2.move(0, 0, -1);
   *
   *   // Draw the box.
   *   box();
   * }
   *
   * // "Reset" the camera when the user double-clicks.
   * function doubleClicked() {
   *   cam2.set(cam1);
   * }
   */
  set(cam) {
    const keyNamesOfThePropToCopy = [
      "eyeX",
      "eyeY",
      "eyeZ",
      "centerX",
      "centerY",
      "centerZ",
      "upX",
      "upY",
      "upZ",
      "cameraFOV",
      "aspectRatio",
      "cameraNear",
      "cameraFar",
      "cameraType",
      "yScale",
      "useLinePerspective"
    ];
    for (const keyName of keyNamesOfThePropToCopy) {
      this[keyName] = cam[keyName];
    }
    this.cameraMatrix = cam.cameraMatrix.copy();
    this.projMatrix = cam.projMatrix.copy();
    if (this._isActive()) {
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.setValue("uViewMatrix", this._renderer.states.uViewMatrix.clone());
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      this._renderer.states.uViewMatrix.set(this.cameraMatrix);
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
  }
  /**
   * Sets the camera’s position and orientation to values that are in-between
   * those of two other cameras.
   *
   * `myCamera.slerp()` uses spherical linear interpolation to calculate a
   * position and orientation that’s in-between two other cameras. Doing so is
   * helpful for transitioning smoothly between two perspectives.
   *
   * The first two parameters, `cam0` and `cam1`, are the `p5.Camera` objects
   * that should be used to set the current camera.
   *
   * The third parameter, `amt`, is the amount to interpolate between `cam0` and
   * `cam1`. 0.0 keeps the camera’s position and orientation equal to `cam0`’s,
   * 0.5 sets them halfway between `cam0`’s and `cam1`’s , and 1.0 sets the
   * position and orientation equal to `cam1`’s.
   *
   * For example, calling `myCamera.slerp(cam0, cam1, 0.1)` sets cam’s position
   * and orientation very close to `cam0`’s. Calling
   * `myCamera.slerp(cam0, cam1, 0.9)` sets cam’s position and orientation very
   * close to `cam1`’s.
   *
   * Note: All of the cameras must use the same projection.
   *
   * @param {p5.Camera} cam0 first camera.
   * @param {p5.Camera} cam1 second camera.
   * @param {Number} amt amount of interpolation between 0.0 (`cam0`) and 1.0 (`cam1`).
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let cam0;
   * let cam1;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the main camera.
   *   // Keep its default settings.
   *   cam = createCamera();
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam0 = createCamera();
   *
   *   // Create the second camera.
   *   cam1 = createCamera();
   *
   *   // Place it at the top-right.
   *   cam1.setPosition(400, -400, 800);
   *
   *   // Point it at the origin.
   *   cam1.lookAt(0, 0, 0);
   *
   *   // Set the current camera to cam.
   *   setCamera(cam);
   *
   *   describe('A white cube drawn against a gray background. The camera slowly oscillates between a frontal view and an aerial view.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the amount to interpolate between cam0 and cam1.
   *   let amt = 0.5 * sin(frameCount * 0.01) + 0.5;
   *
   *   // Update the main camera's position and orientation.
   *   cam.slerp(cam0, cam1, amt);
   *
   *   box();
   * }
   * </code>
   * </div>
   */
  slerp(cam0, cam1, amt) {
    if (amt === 0) {
      this.set(cam0);
      return;
    } else if (amt === 1) {
      this.set(cam1);
      return;
    }
    if (this.projMatrix.mat4[15] !== 0) {
      this.projMatrix.setElement(
        0,
        cam0.projMatrix.mat4[0] * Math.pow(cam1.projMatrix.mat4[0] / cam0.projMatrix.mat4[0], amt)
      );
      this.projMatrix.setElement(
        5,
        cam0.projMatrix.mat4[5] * Math.pow(cam1.projMatrix.mat4[5] / cam0.projMatrix.mat4[5], amt)
      );
      if (this._isActive()) {
        this._renderer.states.setValue("uPMatrix", this.projMatrix.clone());
      }
    }
    const eye0 = new Vector(cam0.eyeX, cam0.eyeY, cam0.eyeZ);
    const eye1 = new Vector(cam1.eyeX, cam1.eyeY, cam1.eyeZ);
    const center0 = new Vector(cam0.centerX, cam0.centerY, cam0.centerZ);
    const center1 = new Vector(cam1.centerX, cam1.centerY, cam1.centerZ);
    const dist0 = Vector.dist(eye0, center0);
    const dist1 = Vector.dist(eye1, center1);
    const lerpedDist = dist0 * Math.pow(dist1 / dist0, amt);
    const eyeDiff = Vector.sub(eye0, eye1);
    const diffDiff = eye0.copy().sub(eye1).sub(center0).add(center1);
    const divider = diffDiff.magSq();
    let ratio = 1;
    if (divider > 1e-6) {
      ratio = Vector.dot(eyeDiff, diffDiff) / divider;
      ratio = Math.max(0, Math.min(ratio, 1));
    }
    const lerpedMedium = Vector.lerp(
      Vector.lerp(eye0, center0, ratio),
      Vector.lerp(eye1, center1, ratio),
      amt
    );
    const rotMat0 = cam0.cameraMatrix.createSubMatrix3x3();
    const rotMat1 = cam1.cameraMatrix.createSubMatrix3x3();
    const front0 = rotMat0.row(2);
    const front1 = rotMat1.row(2);
    const up0 = rotMat0.row(1);
    const up1 = rotMat1.row(1);
    const newFront = new Vector();
    const newUp = new Vector();
    const newEye = new Vector();
    const newCenter = new Vector();
    const deltaRot = rotMat1.mult(rotMat0.copy().transpose());
    const diag = deltaRot.diagonal();
    let cosTheta = 0.5 * (diag[0] + diag[1] + diag[2] - 1);
    if (1 - cosTheta < 1e-7) {
      newFront.set(Vector.lerp(front0, front1, amt)).normalize();
      newEye.set(newFront).mult(ratio * lerpedDist).add(lerpedMedium);
      newCenter.set(newFront).mult((ratio - 1) * lerpedDist).add(lerpedMedium);
      newUp.set(Vector.lerp(up0, up1, amt)).normalize();
      this.camera(
        newEye.x,
        newEye.y,
        newEye.z,
        newCenter.x,
        newCenter.y,
        newCenter.z,
        newUp.x,
        newUp.y,
        newUp.z
      );
      return;
    }
    let a, b2, c, sinTheta;
    let invOneMinusCosTheta = 1 / (1 - cosTheta);
    const maxDiag = Math.max(diag[0], diag[1], diag[2]);
    const offDiagSum13 = deltaRot.mat3[1] + deltaRot.mat3[3];
    const offDiagSum26 = deltaRot.mat3[2] + deltaRot.mat3[6];
    const offDiagSum57 = deltaRot.mat3[5] + deltaRot.mat3[7];
    if (maxDiag === diag[0]) {
      a = Math.sqrt((diag[0] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= a;
      b2 = 0.5 * offDiagSum13 * invOneMinusCosTheta;
      c = 0.5 * offDiagSum26 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[7] - deltaRot.mat3[5]) / a;
    } else if (maxDiag === diag[1]) {
      b2 = Math.sqrt((diag[1] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= b2;
      c = 0.5 * offDiagSum57 * invOneMinusCosTheta;
      a = 0.5 * offDiagSum13 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[2] - deltaRot.mat3[6]) / b2;
    } else {
      c = Math.sqrt((diag[2] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= c;
      a = 0.5 * offDiagSum26 * invOneMinusCosTheta;
      b2 = 0.5 * offDiagSum57 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[3] - deltaRot.mat3[1]) / c;
    }
    const angle = amt * Math.atan2(sinTheta, cosTheta);
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const oneMinusCosAngle = 1 - cosAngle;
    const ab = a * b2;
    const bc = b2 * c;
    const ca = c * a;
    const lerpedRotMat = new Matrix([
      cosAngle + oneMinusCosAngle * a * a,
      oneMinusCosAngle * ab + sinAngle * c,
      oneMinusCosAngle * ca - sinAngle * b2,
      oneMinusCosAngle * ab - sinAngle * c,
      cosAngle + oneMinusCosAngle * b2 * b2,
      oneMinusCosAngle * bc + sinAngle * a,
      oneMinusCosAngle * ca + sinAngle * b2,
      oneMinusCosAngle * bc - sinAngle * a,
      cosAngle + oneMinusCosAngle * c * c
    ]);
    lerpedRotMat.multiplyVec(front0, newFront);
    newEye.set(newFront).mult(ratio * lerpedDist).add(lerpedMedium);
    newCenter.set(newFront).mult((ratio - 1) * lerpedDist).add(lerpedMedium);
    lerpedRotMat.multiplyVec(up0, newUp);
    this.camera(
      newEye.x,
      newEye.y,
      newEye.z,
      newCenter.x,
      newCenter.y,
      newCenter.z,
      newUp.x,
      newUp.y,
      newUp.z
    );
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Camera Helper Methods
  ////////////////////////////////////////////////////////////////////////////////
  // @TODO: combine this function with _setDefaultCamera to compute these values
  // as-needed
  _computeCameraDefaultSettings() {
    this.defaultAspectRatio = this._renderer.width / this._renderer.height;
    this.defaultEyeX = 0;
    this.defaultEyeY = 0;
    this.defaultEyeZ = 800;
    this.defaultCameraFOV = 2 * Math.atan(this._renderer.height / 2 / this.defaultEyeZ);
    this.defaultCenterX = 0;
    this.defaultCenterY = 0;
    this.defaultCenterZ = 0;
    this.defaultCameraNear = this.defaultEyeZ * this._renderer.defaultNearScale();
    this.defaultCameraFar = this.defaultEyeZ * this._renderer.defaultFarScale();
  }
  //detect if user didn't set the camera
  //then call this function below
  _setDefaultCamera() {
    this.cameraFOV = this.defaultCameraFOV;
    this.aspectRatio = this.defaultAspectRatio;
    this.eyeX = this.defaultEyeX;
    this.eyeY = this.defaultEyeY;
    this.eyeZ = this.defaultEyeZ;
    this.centerX = this.defaultCenterX;
    this.centerY = this.defaultCenterY;
    this.centerZ = this.defaultCenterZ;
    this.upX = 0;
    this.upY = 1;
    this.upZ = 0;
    this.cameraNear = this.defaultCameraNear;
    this.cameraFar = this.defaultCameraFar;
    this.perspective();
    this.camera();
    this.cameraType = "default";
  }
  _resize() {
    if (this.cameraType === "default") {
      this._computeCameraDefaultSettings();
      this.cameraFOV = this.defaultCameraFOV;
      this.aspectRatio = this.defaultAspectRatio;
      this.perspective();
    }
  }
  /**
   * Returns a copy of a camera.
   * @private
   */
  copy() {
    const _cam = new Camera(this._renderer);
    _cam.cameraFOV = this.cameraFOV;
    _cam.aspectRatio = this.aspectRatio;
    _cam.eyeX = this.eyeX;
    _cam.eyeY = this.eyeY;
    _cam.eyeZ = this.eyeZ;
    _cam.centerX = this.centerX;
    _cam.centerY = this.centerY;
    _cam.centerZ = this.centerZ;
    _cam.upX = this.upX;
    _cam.upY = this.upY;
    _cam.upZ = this.upZ;
    _cam.cameraNear = this.cameraNear;
    _cam.cameraFar = this.cameraFar;
    _cam.cameraType = this.cameraType;
    _cam.useLinePerspective = this.useLinePerspective;
    _cam.cameraMatrix = this.cameraMatrix.copy();
    _cam.projMatrix = this.projMatrix.copy();
    _cam.yScale = this.yScale;
    _cam.cameraType = this.cameraType;
    return _cam;
  }
  clone() {
    return this.copy();
  }
  /**
   * Returns a camera's local axes: left-right, up-down, and forward-backward,
   * as defined by vectors in world-space.
   * @private
   */
  _getLocalAxes() {
    let z0 = this.eyeX - this.centerX;
    let z1 = this.eyeY - this.centerY;
    let z2 = this.eyeZ - this.centerZ;
    const eyeDist = Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    if (eyeDist !== 0) {
      z0 /= eyeDist;
      z1 /= eyeDist;
      z2 /= eyeDist;
    }
    let y0 = this.upX;
    let y1 = this.upY;
    let y2 = this.upZ;
    let x0 = y1 * z2 - y2 * z1;
    let x1 = -y0 * z2 + y2 * z0;
    let x2 = y0 * z1 - y1 * z0;
    y0 = z1 * x2 - z2 * x1;
    y1 = -z0 * x2 + z2 * x0;
    y2 = z0 * x1 - z1 * x0;
    const xmag = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (xmag !== 0) {
      x0 /= xmag;
      x1 /= xmag;
      x2 /= xmag;
    }
    const ymag = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (ymag !== 0) {
      y0 /= ymag;
      y1 /= ymag;
      y2 /= ymag;
    }
    return {
      x: [x0, x1, x2],
      y: [y0, y1, y2],
      z: [z0, z1, z2]
    };
  }
  /**
   * Orbits the camera about center point. For use with orbitControl().
   * @private
   * @param {Number} dTheta change in spherical coordinate theta
   * @param {Number} dPhi change in spherical coordinate phi
   * @param {Number} dRadius change in radius
   */
  _orbit(dTheta, dPhi, dRadius) {
    const diffX = this.eyeX - this.centerX;
    const diffY = this.eyeY - this.centerY;
    const diffZ = this.eyeZ - this.centerZ;
    let camRadius = Math.hypot(diffX, diffY, diffZ);
    const front = new Vector(diffX, diffY, diffZ).normalize();
    const up = new Vector(this.upX, this.upY, this.upZ).normalize();
    const side = Vector.cross(up, front).normalize();
    const vertical = Vector.cross(side, up);
    camRadius *= Math.pow(10, dRadius);
    if (camRadius < this.cameraNear) {
      camRadius = this.cameraNear;
    }
    if (camRadius > this.cameraFar) {
      camRadius = this.cameraFar;
    }
    const camPhi = Math.acos(Math.max(-1, Math.min(1, Vector.dot(front, up)))) + dPhi;
    const camTheta = dTheta;
    if (camPhi <= 0 || camPhi >= Math.PI) {
      this.upX *= -1;
      this.upY *= -1;
      this.upZ *= -1;
    }
    up.mult(Math.cos(camPhi));
    vertical.mult(Math.cos(camTheta) * Math.sin(camPhi));
    side.mult(Math.sin(camTheta) * Math.sin(camPhi));
    front.set(up).add(vertical).add(side);
    this.eyeX = camRadius * front.x + this.centerX;
    this.eyeY = camRadius * front.y + this.centerY;
    this.eyeZ = camRadius * front.z + this.centerZ;
    this.camera(
      this.eyeX,
      this.eyeY,
      this.eyeZ,
      this.centerX,
      this.centerY,
      this.centerZ,
      this.upX,
      this.upY,
      this.upZ
    );
  }
  /**
   * Orbits the camera about center point. For use with orbitControl().
   * Unlike _orbit(), the direction of rotation always matches the direction of pointer movement.
   * @private
   * @param {Number} dx the x component of the rotation vector.
   * @param {Number} dy the y component of the rotation vector.
   * @param {Number} dRadius change in radius
   */
  _orbitFree(dx, dy, dRadius) {
    const diffX = this.eyeX - this.centerX;
    const diffY = this.eyeY - this.centerY;
    const diffZ = this.eyeZ - this.centerZ;
    let camRadius = Math.hypot(diffX, diffY, diffZ);
    const front = new Vector(diffX, diffY, diffZ).normalize();
    const up = new Vector(this.upX, this.upY, this.upZ);
    const side = Vector.cross(up, front).normalize();
    const down = Vector.cross(front, side);
    const directionAngle = Math.atan2(dy, dx);
    down.mult(Math.sin(directionAngle));
    side.mult(Math.cos(directionAngle)).add(down);
    const rotAngle = Math.sqrt(dx * dx + dy * dy);
    const axis = Vector.cross(front, side);
    camRadius *= Math.pow(10, dRadius);
    if (camRadius < this.cameraNear) {
      camRadius = this.cameraNear;
    }
    if (camRadius > this.cameraFar) {
      camRadius = this.cameraFar;
    }
    const c = Math.cos(rotAngle);
    const s = Math.sin(rotAngle);
    const dotFront = up.dot(front);
    const dotSide = up.dot(side);
    const ux = dotFront * c + dotSide * s;
    const uy = -dotFront * s + dotSide * c;
    const uz = up.dot(axis);
    up.x = ux * front.x + uy * side.x + uz * axis.x;
    up.y = ux * front.y + uy * side.y + uz * axis.y;
    up.z = ux * front.z + uy * side.z + uz * axis.z;
    side.mult(-s);
    front.mult(c).add(side).mult(camRadius);
    this.camera(
      front.x + this.centerX,
      front.y + this.centerY,
      front.z + this.centerZ,
      this.centerX,
      this.centerY,
      this.centerZ,
      up.x,
      up.y,
      up.z
    );
  }
  /**
   * Returns true if camera is currently attached to renderer.
   * @private
   */
  _isActive() {
    return this === this._renderer.states.curCamera;
  }
}
function camera(p53, fn2) {
  fn2.camera = function(...args) {
    this._assert3d("camera");
    this._renderer.camera(...args);
    return this;
  };
  fn2.perspective = function(...args) {
    this._assert3d("perspective");
    this._renderer.perspective(...args);
    return this;
  };
  fn2.linePerspective = function(enable) {
    if (!(this._renderer instanceof Renderer3D)) {
      throw new Error("linePerspective() must be called in WebGL mode.");
    }
    return this._renderer.linePerspective(enable);
  };
  fn2.ortho = function(...args) {
    this._assert3d("ortho");
    this._renderer.ortho(...args);
    return this;
  };
  fn2.frustum = function(...args) {
    this._assert3d("frustum");
    this._renderer.frustum(...args);
    return this;
  };
  fn2.createCamera = function() {
    this._assert3d("createCamera");
    return this._renderer.createCamera();
  };
  fn2.setCamera = function(cam) {
    this._renderer.setCamera(cam);
  };
  p53.Camera = Camera;
  Renderer3D.prototype.camera = function(...args) {
    this.states.setValue("curCamera", this.states.curCamera.clone());
    this.states.curCamera.camera(...args);
  };
  Renderer3D.prototype.perspective = function(...args) {
    this.states.setValue("curCamera", this.states.curCamera.clone());
    this.states.curCamera.perspective(...args);
  };
  Renderer3D.prototype.linePerspective = function(enable) {
    if (enable !== void 0) {
      this.states.setValue("curCamera", this.states.curCamera.clone());
      this.states.curCamera.useLinePerspective = enable;
    } else {
      return this.states.curCamera.useLinePerspective;
    }
  };
  Renderer3D.prototype.ortho = function(...args) {
    this.states.setValue("curCamera", this.states.curCamera.clone());
    this.states.curCamera.ortho(...args);
  };
  Renderer3D.prototype.frustum = function(...args) {
    this.states.setValue("curCamera", this.states.curCamera.clone());
    this.states.curCamera.frustum(...args);
  };
  Renderer3D.prototype.createCamera = function() {
    const _cam = new Camera(this);
    _cam._computeCameraDefaultSettings();
    _cam._setDefaultCamera();
    return _cam;
  };
  Renderer3D.prototype.setCamera = function(cam) {
    this.states.setValue("curCamera", cam);
    this.states.setValue("uPMatrix", this.states.uPMatrix.clone());
    this.states.uPMatrix.set(cam.projMatrix);
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(cam.cameraMatrix);
  };
}
if (typeof p5 !== "undefined") {
  camera(p5, p5.prototype);
}
const { STROKE_CAP_ENUM, STROKE_JOIN_ENUM } = getStrokeDefs(() => "");
class Renderer3D extends Renderer {
  constructor(pInst, w, h, isMainCanvas, elt) {
    super(pInst, w, h, isMainCanvas);
    this.canvas = this.elt = elt || document.createElement("canvas");
    this.contextReady = this.setupContext();
    if (this._isMainCanvas) {
      this._pInst._curElement = this;
      this._pInst.canvas = this.canvas;
    } else {
      this.canvas.style.display = "none";
    }
    this.elt.id = "defaultCanvas0";
    this.elt.classList.add("p5Canvas");
    this.wrappedElt = new Element(this.elt, this._pInst);
    for (const p2 of Object.getOwnPropertyNames(Element.prototype)) {
      if (p2 !== "constructor" && p2[0] !== "_") {
        Object.defineProperty(this, p2, {
          get() {
            return this.wrappedElt[p2];
          }
        });
      }
    }
    const dimensions = this._adjustDimensions(w, h);
    w = dimensions.adjustedWidth;
    h = dimensions.adjustedHeight;
    this.width = w;
    this.height = h;
    this.elt.width = w * this._pixelDensity;
    this.elt.height = h * this._pixelDensity;
    this.elt.style.width = `${w}px`;
    this.elt.style.height = `${h}px`;
    this._updateViewport();
    if (this._pInst._userNode) {
      this._pInst._userNode.appendChild(this.elt);
    } else {
      if (document.getElementsByTagName("main").length === 0) {
        let m = document.createElement("main");
        document.body.appendChild(m);
      }
      document.getElementsByTagName("main")[0].appendChild(this.elt);
    }
    this.isP3D = true;
    this.geometryBuilder = void 0;
    this.states.uModelMatrix = new Matrix(4);
    this.states.uViewMatrix = new Matrix(4);
    this.states.uPMatrix = new Matrix(4);
    this.mainCamera = new Camera(this);
    if (!this.states.curCamera) {
      this.states.curCamera = this.mainCamera;
    }
    this.states.uPMatrix.set(this.states.curCamera.projMatrix);
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    this.states.enableLighting = false;
    this.states.ambientLightColors = [];
    this.states.specularColors = [1, 1, 1];
    this.states.directionalLightDirections = [];
    this.states.directionalLightDiffuseColors = [];
    this.states.directionalLightSpecularColors = [];
    this.states.pointLightPositions = [];
    this.states.pointLightDiffuseColors = [];
    this.states.pointLightSpecularColors = [];
    this.states.spotLightPositions = [];
    this.states.spotLightDirections = [];
    this.states.spotLightDiffuseColors = [];
    this.states.spotLightSpecularColors = [];
    this.states.spotLightAngle = [];
    this.states.spotLightConc = [];
    this.states.activeImageLight = null;
    this.states.curFillColor = [1, 1, 1, 1];
    this.states.curAmbientColor = [1, 1, 1, 1];
    this.states.curSpecularColor = [0, 0, 0, 0];
    this.states.curEmissiveColor = [0, 0, 0, 0];
    this.states.curStrokeColor = [0, 0, 0, 1];
    this.states.curBlendMode = BLEND;
    this.states._hasSetAmbient = false;
    this.states._useSpecularMaterial = false;
    this.states._useEmissiveMaterial = false;
    this.states._useNormalMaterial = false;
    this.states._useShininess = 1;
    this.states._useMetalness = 0;
    this.states.tint = [255, 255, 255, 255];
    this.states.constantAttenuation = 1;
    this.states.linearAttenuation = 0;
    this.states.quadraticAttenuation = 0;
    this.states._currentNormal = new Vector(0, 0, 1);
    this.states.drawMode = FILL;
    this.states._tex = null;
    this.states.textureMode = IMAGE;
    this.states.textureWrapX = CLAMP;
    this.states.textureWrapY = CLAMP;
    this._isErasing = false;
    this._simpleLines = false;
    this._clipDepths = [];
    this._isClipApplied = false;
    this._stencilTestOn = false;
    this.mixedAmbientLight = [];
    this.mixedSpecularColor = [];
    this.diffusedTextures = /* @__PURE__ */ new Map();
    this.specularTextures = /* @__PURE__ */ new Map();
    this.preEraseBlend = void 0;
    this._cachedFillStyle = [1, 1, 1, 1];
    this._cachedStrokeStyle = [0, 0, 0, 1];
    this._isBlending = false;
    this._useLineColor = false;
    this._useVertexColor = false;
    this.registerEnabled = /* @__PURE__ */ new Set();
    this.mainCamera._computeCameraDefaultSettings();
    this.mainCamera._setDefaultCamera();
    this.filterCamera = new Camera(this);
    this.filterCamera._computeCameraDefaultSettings();
    this.filterCamera._setDefaultCamera();
    this.prevTouches = [];
    this.zoomVelocity = 0;
    this.rotateVelocity = new Vector(0, 0);
    this.moveVelocity = new Vector(0, 0);
    this.executeZoom = false;
    this.executeRotateAndMove = false;
    this._drawingFilter = false;
    this._drawingImage = false;
    this.specularShader = void 0;
    this.sphereMapping = void 0;
    this.diffusedShader = void 0;
    this._baseFilterShader = void 0;
    this._defaultLightShader = void 0;
    this._defaultImmediateModeShader = void 0;
    this._defaultNormalShader = void 0;
    this._defaultColorShader = void 0;
    this.states.userFillShader = void 0;
    this.states.userStrokeShader = void 0;
    this.states.userImageShader = void 0;
    this.states.curveDetail = 1 / 4;
    this.shapeBuilder = new ShapeBuilder(this);
    this.geometryBufferCache = new GeometryBufferCache(this);
    this.curStrokeCap = ROUND;
    this.curStrokeJoin = ROUND;
    this.textures = /* @__PURE__ */ new Map();
    this.framebuffers = /* @__PURE__ */ new Set();
    this.activeFramebuffers = [];
    this.states.filterShader = void 0;
    this.filterLayer = void 0;
    this.filterLayerTemp = void 0;
    this.defaultFilterShaders = {};
    this.fontInfos = {};
    this._curShader = void 0;
    this.drawShapeCount = 1;
    this.scratchMat3 = new Matrix(3);
    this._validateFaces = false;
    this.buffers = {
      fill: [
        new RenderBuffer(
          3,
          "vertices",
          "vertexBuffer",
          "aPosition",
          this,
          this._vToNArray
        ),
        new RenderBuffer(
          3,
          "vertexNormals",
          "normalBuffer",
          "aNormal",
          this,
          this._vToNArray
        ),
        new RenderBuffer(
          4,
          "vertexColors",
          "colorBuffer",
          "aVertexColor",
          this
        ).default((geometry2) => geometry2.vertices.flatMap(() => [-1, -1, -1, -1])),
        new RenderBuffer(
          3,
          "vertexAmbients",
          "ambientBuffer",
          "aAmbientColor",
          this
        ),
        new RenderBuffer(
          2,
          "uvs",
          "uvBuffer",
          "aTexCoord",
          this,
          (arr2) => arr2.flat()
        )
      ],
      stroke: [
        new RenderBuffer(
          4,
          "lineVertexColors",
          "lineColorBuffer",
          "aVertexColor",
          this
        ).default((geometry2) => geometry2.lineVertices.flatMap(() => [-1, -1, -1, -1])),
        new RenderBuffer(
          3,
          "lineVertices",
          "lineVerticesBuffer",
          "aPosition",
          this
        ),
        new RenderBuffer(
          3,
          "lineTangentsIn",
          "lineTangentsInBuffer",
          "aTangentIn",
          this
        ),
        new RenderBuffer(
          3,
          "lineTangentsOut",
          "lineTangentsOutBuffer",
          "aTangentOut",
          this
        ),
        new RenderBuffer(1, "lineSides", "lineSidesBuffer", "aSide", this)
      ],
      text: [
        new RenderBuffer(
          3,
          "vertices",
          "vertexBuffer",
          "aPosition",
          this,
          this._vToNArray
        ),
        new RenderBuffer(
          2,
          "uvs",
          "uvBuffer",
          "aTexCoord",
          this,
          (arr2) => arr2.flat()
        )
      ],
      user: []
    };
  }
  //This is helper function to reset the context anytime the attributes
  //are changed with setAttributes()
  async _resetContext(options2, callback, ctor = Renderer3D) {
    const w = this.width;
    const h = this.height;
    const defaultId = this.canvas.id;
    const isPGraphics = this._pInst instanceof Graphics;
    const prevStyle = {
      position: this.canvas.style.position,
      top: this.canvas.style.top,
      left: this.canvas.style.left
    };
    if (isPGraphics) {
      const pg = this._pInst;
      pg.canvas.parentNode.removeChild(pg.canvas);
      pg.canvas = document.createElement("canvas");
      const node = pg._pInst._userNode || document.body;
      node.appendChild(pg.canvas);
      Element.call(pg, pg.canvas, pg._pInst);
      pg.width = w;
      pg.height = h;
    } else {
      let c = this.canvas;
      if (c) {
        c.parentNode.removeChild(c);
      }
      c = document.createElement("canvas");
      c.id = defaultId;
      if (this._pInst._userNode) {
        this._pInst._userNode.appendChild(c);
      } else {
        document.body.appendChild(c);
      }
      this._pInst.canvas = c;
      this.canvas = c;
      this.canvas.style.position = prevStyle.position;
      this.canvas.style.top = prevStyle.top;
      this.canvas.style.left = prevStyle.left;
    }
    const renderer2 = new ctor(
      this._pInst,
      w,
      h,
      !isPGraphics,
      this._pInst.canvas
    );
    this._pInst._renderer = renderer2;
    renderer2._applyDefaults();
    if (renderer2.contextReady) {
      await renderer2.contextReady;
    }
    if (typeof callback === "function") {
      setTimeout(() => {
        callback.apply(window._renderer, options2);
      }, 0);
    }
  }
  remove() {
    this.wrappedElt.remove();
    this.wrappedElt = null;
    this.canvas = null;
    this.elt = null;
  }
  //////////////////////////////////////////////
  // Geometry Building
  //////////////////////////////////////////////
  /**
   * Starts creating a new p5.Geometry. Subsequent shapes drawn will be added
   * to the geometry and then returned when
   * <a href="#/p5/endGeometry">endGeometry()</a> is called. One can also use
   * <a href="#/p5/buildGeometry">buildGeometry()</a> to pass a function that
   * draws shapes.
   *
   * If you need to draw complex shapes every frame which don't change over time,
   * combining them upfront with `beginGeometry()` and `endGeometry()` and then
   * drawing that will run faster than repeatedly drawing the individual pieces.
   * @private
   */
  beginGeometry() {
    if (this.geometryBuilder) {
      throw new Error(
        "It looks like `beginGeometry()` is being called while another p5.Geometry is already being build."
      );
    }
    this.geometryBuilder = new GeometryBuilder(this);
    this.geometryBuilder.prevFillColor = this.states.fillColor;
    this.fill(new Color([-1, -1, -1, -1]));
  }
  /**
   * Finishes creating a new <a href="#/p5.Geometry">p5.Geometry</a> that was
   * started using <a href="#/p5/beginGeometry">beginGeometry()</a>. One can also
   * use <a href="#/p5/buildGeometry">buildGeometry()</a> to pass a function that
   * draws shapes.
   * @private
   *
   * @returns {p5.Geometry} The model that was built.
   */
  endGeometry() {
    if (!this.geometryBuilder) {
      throw new Error(
        "Make sure you call beginGeometry() before endGeometry()!"
      );
    }
    const geometry2 = this.geometryBuilder.finish();
    if (this.geometryBuilder.prevFillColor) {
      this.fill(this.geometryBuilder.prevFillColor);
    } else {
      this.noFill();
    }
    this.geometryBuilder = void 0;
    return geometry2;
  }
  /**
   * Creates a new <a href="#/p5.Geometry">p5.Geometry</a> that contains all
   * the shapes drawn in a provided callback function. The returned combined shape
   * can then be drawn all at once using <a href="#/p5/model">model()</a>.
   *
   * If you need to draw complex shapes every frame which don't change over time,
   * combining them with `buildGeometry()` once and then drawing that will run
   * faster than repeatedly drawing the individual pieces.
   *
   * One can also draw shapes directly between
   * <a href="#/p5/beginGeometry">beginGeometry()</a> and
   * <a href="#/p5/endGeometry">endGeometry()</a> instead of using a callback
   * function.
   * @param {Function} callback A function that draws shapes.
   * @returns {p5.Geometry} The model that was built from the callback function.
   */
  buildGeometry(callback) {
    this.beginGeometry();
    callback();
    return this.endGeometry();
  }
  //////////////////////////////////////////////
  // Shape drawing
  //////////////////////////////////////////////
  beginShape(...args) {
    super.beginShape(...args);
  }
  curveDetail(d2) {
    if (d2 === void 0) {
      return this.states.curveDetail;
    } else {
      this.states.setValue("curveDetail", d2);
    }
  }
  drawShape(shape2) {
    const visitor = new PrimitiveToVerticesConverter({
      curveDetail: this.states.curveDetail
    });
    shape2.accept(visitor);
    this.shapeBuilder.constructFromContours(shape2, visitor.contours);
    if (this.geometryBuilder) {
      this.geometryBuilder.addImmediate(
        this.shapeBuilder.geometry,
        this.shapeBuilder.shapeMode,
        { validateFaces: this._validateFaces }
      );
    } else if (this.states.fillColor || this.states.strokeColor) {
      this._drawGeometry(this.shapeBuilder.geometry, {
        mode: this.shapeBuilder.shapeMode,
        count: this.drawShapeCount
      });
    }
    this.drawShapeCount = 1;
  }
  endShape(mode, count) {
    this.drawShapeCount = count;
    super.endShape(mode, count);
  }
  vertexProperty(...args) {
    this.currentShape.vertexProperty(...args);
  }
  normal(xorv, y, z) {
    if (xorv instanceof Vector) {
      this.states.setValue("_currentNormal", xorv);
    } else {
      this.states.setValue("_currentNormal", new Vector(xorv, y, z));
    }
    this.updateShapeVertexProperties();
  }
  model(model, count = 1) {
    if (model.vertices.length > 0) {
      if (this.geometryBuilder) {
        this.geometryBuilder.addRetained(model);
      } else {
        if (!this.geometryInHash(model.gid)) {
          model._edgesToVertices();
          this._getOrMakeCachedBuffers(model);
        }
        this._drawGeometry(model, { count });
      }
    }
  }
  _getOrMakeCachedBuffers(geometry2) {
    return this.geometryBufferCache.ensureCached(geometry2);
  }
  //////////////////////////////////////////////
  // Rendering
  //////////////////////////////////////////////
  _drawGeometry(geometry2, { mode = TRIANGLES, count = 1 } = {}) {
    for (const propName in geometry2.userVertexProperties) {
      const prop = geometry2.userVertexProperties[propName];
      this.buffers.user.push(
        new RenderBuffer(
          prop.getDataSize(),
          prop.getSrcName(),
          prop.getDstName(),
          prop.getName(),
          this
        )
      );
    }
    if (this.states.fillColor && geometry2.vertices.length >= 3 && ![LINES, POINTS].includes(mode)) {
      this._drawFills(geometry2, { mode, count });
    }
    if (this.states.strokeColor && geometry2.lineVertices.length >= 1) {
      this._drawStrokes(geometry2, { count });
    }
    this.buffers.user = [];
  }
  _drawFills(geometry2, { count, mode } = {}) {
    this._useVertexColor = geometry2.vertexColors.length > 0 && !geometry2.vertexColors.isDefault;
    const shader2 = !this._drawingFilter && this.states.userFillShader ? this.states.userFillShader : this._getFillShader();
    shader2.bindShader("fill");
    this._setGlobalUniforms(shader2);
    this._setFillUniforms(shader2);
    shader2.bindTextures();
    for (const buff of this.buffers.fill) {
      buff._prepareBuffer(geometry2, shader2);
    }
    this._prepareUserAttributes(geometry2, shader2);
    this._disableRemainingAttributes(shader2);
    this._applyColorBlend(
      this.states.curFillColor,
      geometry2.hasFillTransparency()
    );
    this._drawBuffers(geometry2, { mode, count });
    shader2.unbindShader();
  }
  _drawStrokes(geometry2, { count } = {}) {
    this._useLineColor = geometry2.vertexStrokeColors.length > 0;
    const shader2 = this._getStrokeShader();
    shader2.bindShader("stroke");
    this._setGlobalUniforms(shader2);
    this._setStrokeUniforms(shader2);
    shader2.bindTextures();
    for (const buff of this.buffers.stroke) {
      buff._prepareBuffer(geometry2, shader2);
    }
    this._prepareUserAttributes(geometry2, shader2);
    this._disableRemainingAttributes(shader2);
    this._applyColorBlend(
      this.states.curStrokeColor,
      geometry2.hasStrokeTransparency()
    );
    this._drawBuffers(geometry2, { count });
    shader2.unbindShader();
  }
  _prepareUserAttributes(geometry2, shader2) {
    for (const buff of this.buffers.user) {
      if (!this._pInst.constructor.disableFriendleErrors) {
        const prop = geometry2.userVertexProperties[buff.attr];
        if (prop) {
          const adjustedLength = prop.getSrcArray().length / prop.getDataSize();
          if (adjustedLength > geometry2.vertices.length) {
            this._pInst.constructor._friendlyError(
              `One of the geometries has a custom vertex property '${prop.getName()}' with more values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`,
              "vertexProperty()"
            );
          } else if (adjustedLength < geometry2.vertices.length) {
            this._pInst.constructor._friendlyError(
              `One of the geometries has a custom vertex property '${prop.getName()}' with fewer values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`,
              "vertexProperty()"
            );
          }
        }
      }
      buff._prepareBuffer(geometry2, shader2);
    }
  }
  _drawGeometryScaled(model, scaleX, scaleY, scaleZ) {
    let originalModelMatrix = this.states.uModelMatrix;
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    try {
      this.states.uModelMatrix.scale(scaleX, scaleY, scaleZ);
      if (this.geometryBuilder) {
        this.geometryBuilder.addRetained(model);
      } else {
        this._drawGeometry(model);
      }
    } finally {
      this.states.setValue("uModelMatrix", originalModelMatrix);
    }
  }
  _update() {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.reset();
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    this.states.setValue("ambientLightColors", []);
    this.states.setValue("specularColors", [1, 1, 1]);
    this.states.setValue("directionalLightDirections", []);
    this.states.setValue("directionalLightDiffuseColors", []);
    this.states.setValue("directionalLightSpecularColors", []);
    this.states.setValue("pointLightPositions", []);
    this.states.setValue("pointLightDiffuseColors", []);
    this.states.setValue("pointLightSpecularColors", []);
    this.states.setValue("spotLightPositions", []);
    this.states.setValue("spotLightDirections", []);
    this.states.setValue("spotLightDiffuseColors", []);
    this.states.setValue("spotLightSpecularColors", []);
    this.states.setValue("spotLightAngle", []);
    this.states.setValue("spotLightConc", []);
    this.states.setValue("enableLighting", false);
    this.states.setValue("tint", [255, 255, 255, 255]);
    this._resetBuffersBeforeDraw();
  }
  background(...args) {
    const a0 = args[0];
    const isImageLike = a0 != null && typeof a0 === "object" && typeof a0.width === "number" && typeof a0.height === "number" && (a0.canvas != null || a0.elt != null);
    if (isImageLike) {
      this._pInst.clear();
      this._pInst.push();
      this._pInst.resetMatrix();
      this._pInst.imageMode(CENTER);
      this._pInst.image(a0, 0, 0, this._pInst.width, this._pInst.height);
      this._pInst.pop();
      return;
    }
    const _col = this._pInst.color(...args);
    this.clear(..._col._getRGBA());
  }
  //////////////////////////////////////////////
  // Positioning
  //////////////////////////////////////////////
  get uModelMatrix() {
    return this.states.uModelMatrix;
  }
  get uViewMatrix() {
    return this.states.uViewMatrix;
  }
  get uPMatrix() {
    return this.states.uPMatrix;
  }
  get uMVMatrix() {
    const m = this.uModelMatrix.copy();
    m.mult(this.uViewMatrix);
    return m;
  }
  /**
   * Get a matrix from world-space to screen-space
   */
  getWorldToScreenMatrix() {
    const modelMatrix = this.states.uModelMatrix;
    const viewMatrix = this.states.uViewMatrix;
    const projectionMatrix = this.states.uPMatrix;
    const projectedToScreenMatrix = new Matrix(4);
    projectedToScreenMatrix.scale(this.width, this.height, 1);
    projectedToScreenMatrix.translate([0.5, 0.5, 0.5]);
    projectedToScreenMatrix.scale(0.5, -0.5, 0.5);
    const modelViewMatrix = modelMatrix.copy().mult(viewMatrix);
    const modelViewProjectionMatrix = modelViewMatrix.mult(projectionMatrix);
    const worldToScreenMatrix = modelViewProjectionMatrix.mult(projectedToScreenMatrix);
    return worldToScreenMatrix;
  }
  //////////////////////////////////////////////
  // COLOR
  //////////////////////////////////////////////
  /**
   * Basic fill material for geometry with a given color
   * @param  {Number|Number[]|String|p5.Color} v1  gray value,
   * red or hue value (depending on the current color mode),
   * or color Array, or CSS color string
   * @param  {Number}            [v2] green or saturation value
   * @param  {Number}            [v3] blue or brightness value
   * @param  {Number}            [a]  opacity
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   fill(100, 100, 240);
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   box(75, 75, 75);
   * }
   * </code>
   * </div>
   *
   * @alt
   * black canvas with purple cube spinning
   */
  fill(...args) {
    super.fill(...args);
    const color2 = this.states.fillColor;
    this.states.setValue("curFillColor", color2._array);
    this.states.setValue("drawMode", FILL);
    this.states.setValue("_useNormalMaterial", false);
    this.states.setValue("_tex", null);
  }
  /**
   * Basic stroke material for geometry with a given color
   * @param  {Number|Number[]|String|p5.Color} v1  gray value,
   * red or hue value (depending on the current color mode),
   * or color Array, or CSS color string
   * @param  {Number}            [v2] green or saturation value
   * @param  {Number}            [v3] blue or brightness value
   * @param  {Number}            [a]  opacity
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   * }
   *
   * function draw() {
   *   background(0);
   *   stroke(240, 150, 150);
   *   fill(100, 100, 240);
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   box(75, 75, 75);
   * }
   * </code>
   * </div>
   *
   * @alt
   * black canvas with purple cube with pink outline spinning
   */
  stroke(...args) {
    super.stroke(...args);
    this.states.setValue("curStrokeColor", this.states.strokeColor._array);
  }
  getCommonVertexProperties() {
    return {
      ...super.getCommonVertexProperties(),
      stroke: this.states.strokeColor,
      fill: this.states.fillColor,
      normal: this.states._currentNormal
    };
  }
  getSupportedIndividualVertexProperties() {
    return {
      textureCoordinates: true
    };
  }
  strokeCap(cap) {
    this.curStrokeCap = cap;
  }
  strokeJoin(join) {
    this.curStrokeJoin = join;
  }
  getFilterLayer() {
    if (!this.filterLayer) {
      this.filterLayer = new Framebuffer$1(this);
    }
    return this.filterLayer;
  }
  getFilterLayerTemp() {
    if (!this.filterLayerTemp) {
      this.filterLayerTemp = new Framebuffer$1(this);
    }
    return this.filterLayerTemp;
  }
  matchSize(fboToMatch, target) {
    if (fboToMatch.width !== target.width || fboToMatch.height !== target.height) {
      fboToMatch.resize(target.width, target.height);
    }
    if (fboToMatch.pixelDensity() !== target.pixelDensity()) {
      fboToMatch.pixelDensity(target.pixelDensity());
    }
  }
  filter(...args) {
    let fbo = this.getFilterLayer();
    let filterParameter = void 0;
    let operation = void 0;
    if (typeof args[0] === "string") {
      operation = args[0];
      let useDefaultParam = operation in filterParamDefaults && args[1] === void 0;
      filterParameter = useDefaultParam ? filterParamDefaults[operation] : args[1];
      if (!(operation in this.defaultFilterShaders)) {
        this.defaultFilterShaders[operation] = this._makeFilterShader(fbo.renderer, operation);
      }
      this.states.setValue(
        "filterShader",
        this.defaultFilterShaders[operation]
      );
    } else {
      this.states.setValue("filterShader", args[0]);
    }
    const target = this.activeFramebuffer() || this;
    this.matchSize(fbo, target);
    fbo.draw(() => this.clear());
    let texelSize = [
      1 / (target.width * target.pixelDensity()),
      1 / (target.height * target.pixelDensity())
    ];
    if (operation === BLUR) {
      const tmp = this.getFilterLayerTemp();
      this.matchSize(tmp, target);
      this.push();
      this.states.setValue("strokeColor", null);
      this.blendMode(BLEND);
      this.shader(this.states.filterShader);
      this.states.filterShader.setUniform("texelSize", texelSize);
      this.states.filterShader.setUniform("canvasSize", [
        target.width,
        target.height
      ]);
      this.states.filterShader.setUniform(
        "radius",
        Math.max(1, filterParameter)
      );
      tmp.draw(() => {
        this.states.filterShader.setUniform("direction", [1, 0]);
        this.states.filterShader.setUniform("tex0", target);
        this.clear();
        this.shader(this.states.filterShader);
        this.noLights();
        this.plane(target.width, target.height);
      });
      fbo.draw(() => {
        this.states.filterShader.setUniform("direction", [0, 1]);
        this.states.filterShader.setUniform("tex0", tmp);
        this.clear();
        this.shader(this.states.filterShader);
        this.noLights();
        this.plane(target.width, target.height);
      });
      this.pop();
    } else {
      fbo.draw(() => {
        this.states.setValue("strokeColor", null);
        this.blendMode(BLEND);
        this.shader(this.states.filterShader);
        this.states.filterShader.setUniform("tex0", target);
        this.states.filterShader.setUniform("texelSize", texelSize);
        this.states.filterShader.setUniform("canvasSize", [
          target.width,
          target.height
        ]);
        this.states.filterShader.setUniform("filterParameter", filterParameter);
        this.noLights();
        this.plane(target.width, target.height);
      });
    }
    this.push();
    this.states.setValue("strokeColor", null);
    this.clear();
    this.push();
    this.states.setValue("imageMode", CORNER);
    this.blendMode(BLEND);
    target.filterCamera._resize();
    this.setCamera(target.filterCamera);
    this.resetMatrix();
    this._drawingFilter = true;
    this.image(
      fbo,
      0,
      0,
      fbo.width,
      fbo.height,
      -target.width / 2,
      -target.height / 2,
      target.width,
      target.height
    );
    this._drawingFilter = false;
    this.clearDepth();
    this.pop();
    this.pop();
  }
  // Pass this off to the host instance so that we can treat a renderer and a
  // framebuffer the same in filter()
  pixelDensity(newDensity) {
    if (newDensity) {
      return this._pInst.pixelDensity(newDensity);
    }
    return this._pInst.pixelDensity();
  }
  blendMode(mode) {
    if (mode === DARKEST || mode === LIGHTEST || mode === ADD || mode === BLEND || mode === SUBTRACT || mode === SCREEN || mode === EXCLUSION || mode === REPLACE || mode === MULTIPLY || mode === REMOVE)
      this.states.setValue("curBlendMode", mode);
    else if (mode === BURN || mode === OVERLAY || mode === HARD_LIGHT || mode === SOFT_LIGHT || mode === DODGE) {
      console.warn(
        "BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode."
      );
    }
  }
  erase(opacityFill, opacityStroke) {
    if (!this._isErasing) {
      this.preEraseBlend = this.states.curBlendMode;
      this._isErasing = true;
      this.blendMode(REMOVE);
      this._cachedFillStyle = this.states.curFillColor.slice();
      this.states.setValue("curFillColor", [1, 1, 1, opacityFill / 255]);
      this._cachedStrokeStyle = this.states.curStrokeColor.slice();
      this.states.setValue("curStrokeColor", [1, 1, 1, opacityStroke / 255]);
    }
  }
  noErase() {
    if (this._isErasing) {
      this.states.setValue("curFillColor", this._cachedFillStyle.slice());
      this.states.setValue("curStrokeColor", this._cachedStrokeStyle.slice());
      this.states.setValue("curBlendMode", this.preEraseBlend);
      this.blendMode(this.preEraseBlend);
      this._isErasing = false;
      this._applyBlendMode();
    }
  }
  _applyBlendMode() {
  }
  drawTarget() {
    return this.activeFramebuffers[this.activeFramebuffers.length - 1] || this;
  }
  beginClip(options2 = {}) {
    super.beginClip(options2);
    this.drawTarget()._isClipApplied = true;
    this._applyClip();
    this.push();
    this.resetShader();
    if (this.states.fillColor) this.fill(0, 0);
    if (this.states.strokeColor) this.stroke(0, 0);
  }
  endClip() {
    this.pop();
    this._unapplyClip();
    this._clipDepths.push(this._pushPopDepth);
    super.endClip();
  }
  _clearClip() {
    this._clearClipBuffer();
    if (this._clipDepths.length > 0) {
      this._clipDepths.pop();
    }
    this.drawTarget()._isClipApplied = false;
  }
  /**
   * @private
   * @returns {p5.Framebuffer} A p5.Framebuffer set to match the size and settings
   * of the renderer's canvas. It will be created if it does not yet exist, and
   * reused if it does.
   */
  _getTempFramebuffer() {
    if (!this._tempFramebuffer) {
      this._tempFramebuffer = new Framebuffer$1(this, {
        format: UNSIGNED_BYTE,
        useDepth: this._pInst._glAttributes.depth,
        depthFormat: UNSIGNED_INT,
        antialias: this._pInst._glAttributes.antialias
      });
    }
    return this._tempFramebuffer;
  }
  //////////////////////////////////////////////
  // HASH | for geometry
  //////////////////////////////////////////////
  geometryInHash(gid) {
    return this.geometryBufferCache.isCached(gid);
  }
  /**
   * [resize description]
   * @private
   * @param  {Number} w [description]
   * @param  {Number} h [description]
   */
  resize(w, h) {
    super.resize(w, h);
    const props = {};
    for (const key in this.drawingContext) {
      const val = this.drawingContext[key];
      if (typeof val !== "object" && typeof val !== "function") {
        props[key] = val;
      }
    }
    const dimensions = this._adjustDimensions(w, h);
    w = dimensions.adjustedWidth;
    h = dimensions.adjustedHeight;
    this.width = w;
    this.height = h;
    this.canvas.width = w * this._pixelDensity;
    this.canvas.height = h * this._pixelDensity;
    this.canvas.style.width = `${w}px`;
    this.canvas.style.height = `${h}px`;
    this._updateViewport();
    this._updateSize();
    this.mainCamera._resize();
    if (this.states.curCamera !== this.mainCamera) {
      this.states.curCamera._resize();
    }
    if (typeof this.pixels !== "undefined") {
      this._createPixelsArray();
    }
    for (const framebuffer2 of this.framebuffers) {
      this.flushDraw?.();
      framebuffer2._canvasSizeChanged();
    }
    this.flushDraw?.();
    for (const savedKey in props) {
      try {
        this.drawingContext[savedKey] = props[savedKey];
      } catch (err) {
      }
    }
  }
  applyMatrix(a, b2, c, d2, e2, f) {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    if (arguments.length === 16) {
      Matrix.prototype.apply.apply(this.states.uModelMatrix, arguments);
    } else {
      this.states.uModelMatrix.apply([
        a,
        b2,
        0,
        0,
        c,
        d2,
        0,
        0,
        0,
        0,
        1,
        0,
        e2,
        f,
        0,
        1
      ]);
    }
  }
  /**
   * [translate description]
   * @private
   * @param  {Number} x [description]
   * @param  {Number} y [description]
   * @param  {Number} z [description]
   * @chainable
   * @todo implement handle for components or vector as args
   */
  translate(x, y, z) {
    if (x instanceof Vector) {
      z = x.z;
      y = x.y;
      x = x.x;
    }
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.translate([x, y, z]);
    return this;
  }
  /**
   * Scales the Model View Matrix by a vector
   * @private
   * @param  {Number | p5.Vector | Array} x [description]
   * @param  {Number} [y] y-axis scalar
   * @param  {Number} [z] z-axis scalar
   * @chainable
   */
  scale(x, y, z) {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.scale(x, y, z);
    return this;
  }
  rotate(rad, axis) {
    if (typeof axis === "undefined") {
      return this.rotateZ(rad);
    }
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    Matrix.prototype.rotate4x4.apply(this.states.uModelMatrix, arguments);
    return this;
  }
  rotateX(rad) {
    this.rotate(rad, 1, 0, 0);
    return this;
  }
  rotateY(rad) {
    this.rotate(rad, 0, 1, 0);
    return this;
  }
  rotateZ(rad) {
    this.rotate(rad, 0, 0, 1);
    return this;
  }
  pop(...args) {
    if (this._clipDepths.length > 0 && this._pushPopDepth === this._clipDepths[this._clipDepths.length - 1]) {
      this._clearClip();
    }
    super.pop(...args);
    this._applyStencilTestIfClipping();
  }
  resetMatrix() {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.reset();
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    return this;
  }
  //////////////////////////////////////////////
  // SHADER
  //////////////////////////////////////////////
  _getStrokeShader() {
    const stroke = this.states.userStrokeShader;
    if (stroke) {
      return stroke;
    }
    return this._getLineShader();
  }
  /*
   * This method will handle both image shaders and
   * fill shaders, returning the appropriate shader
   * depending on the current context (image or shape).
   */
  _getFillShader() {
    if (this._drawingImage) {
      if (this.states.userImageShader && !this._drawingFilter) {
        return this.states.userImageShader;
      } else {
        return this._getLightShader();
      }
    } else if (this.states.userFillShader) {
      return this.states.userFillShader;
    } else if (this.states._useNormalMaterial) {
      return this._getNormalShader();
    } else if (this.states.enableLighting || this.states._tex) {
      return this._getLightShader();
    }
    return this._getColorShader();
  }
  baseMaterialShader() {
    return this._getLightShader();
  }
  baseNormalShader() {
    return this._getNormalShader();
  }
  baseColorShader() {
    return this._getColorShader();
  }
  baseStrokeShader() {
    return this._getLineShader();
  }
  /**
   * @private
   * @returns {p5.Framebuffer|null} The currently active framebuffer, or null if
   * the main canvas is the current draw target.
   */
  activeFramebuffer() {
    return this.activeFramebuffers[this.activeFramebuffers.length - 1] || null;
  }
  createFramebuffer(options2) {
    return new Framebuffer$1(this, options2);
  }
  _setGlobalUniforms(shader2) {
    const modelMatrix = this.states.uModelMatrix;
    const viewMatrix = this.states.uViewMatrix;
    const projectionMatrix = this.states.uPMatrix;
    const modelViewMatrix = modelMatrix.copy().mult(viewMatrix);
    shader2.setUniform(
      "uPerspective",
      this.states.curCamera.useLinePerspective ? 1 : 0
    );
    shader2.setUniform("uViewMatrix", viewMatrix.mat4);
    shader2.setUniform("uProjectionMatrix", projectionMatrix.mat4);
    shader2.setUniform("uModelMatrix", modelMatrix.mat4);
    shader2.setUniform("uModelViewMatrix", modelViewMatrix.mat4);
    if (shader2.uniforms.uModelViewProjectionMatrix) {
      const modelViewProjectionMatrix = modelViewMatrix.copy();
      modelViewProjectionMatrix.mult(projectionMatrix);
      shader2.setUniform(
        "uModelViewProjectionMatrix",
        modelViewProjectionMatrix.mat4
      );
    }
    if (shader2.uniforms.uNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(modelViewMatrix);
      shader2.setUniform("uNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uModelNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(this.states.uModelMatrix);
      shader2.setUniform("uModelNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uCameraNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
      shader2.setUniform("uCameraNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uCameraRotation) {
      this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
      shader2.setUniform("uCameraRotation", this.scratchMat3.mat3);
    }
    shader2.setUniform("uViewport", this._viewport);
  }
  _setStrokeUniforms(strokeShader) {
    strokeShader.setUniform("uSimpleLines", this._simpleLines);
    strokeShader.setUniform("uUseLineColor", this._useLineColor);
    strokeShader.setUniform("uMaterialColor", this.states.curStrokeColor);
    strokeShader.setUniform("uStrokeWeight", this.states.strokeWeight);
    strokeShader.setUniform("uStrokeCap", STROKE_CAP_ENUM[this.curStrokeCap]);
    strokeShader.setUniform(
      "uStrokeJoin",
      STROKE_JOIN_ENUM[this.curStrokeJoin]
    );
  }
  _setFillUniforms(fillShader) {
    this.mixedSpecularColor = [...this.states.curSpecularColor];
    const empty2 = this._getEmptyTexture();
    if (this.states._useMetalness > 0) {
      this.mixedSpecularColor = this.mixedSpecularColor.map(
        (mixedSpecularColor, index) => this.states.curFillColor[index] * this.states._useMetalness + mixedSpecularColor * (1 - this.states._useMetalness)
      );
    }
    fillShader.setUniform("uUseVertexColor", this._useVertexColor);
    fillShader.setUniform("uMaterialColor", this.states.curFillColor);
    fillShader.setUniform("isTexture", !!this.states._tex);
    fillShader.setUniform("uSampler", this.states._tex || empty2);
    fillShader.setUniform("uTint", this.states.tint);
    fillShader.setUniform("uHasSetAmbient", this.states._hasSetAmbient);
    fillShader.setUniform("uAmbientMatColor", this.states.curAmbientColor);
    fillShader.setUniform("uSpecularMatColor", this.mixedSpecularColor);
    fillShader.setUniform("uEmissiveMatColor", this.states.curEmissiveColor);
    fillShader.setUniform("uSpecular", this.states._useSpecularMaterial);
    fillShader.setUniform("uEmissive", this.states._useEmissiveMaterial);
    fillShader.setUniform("uShininess", this.states._useShininess);
    fillShader.setUniform("uMetallic", this.states._useMetalness);
    this._setImageLightUniforms(fillShader);
    fillShader.setUniform("uUseLighting", this.states.enableLighting);
    const pointLightCount = this.states.pointLightDiffuseColors.length / 3;
    fillShader.setUniform("uPointLightCount", pointLightCount);
    fillShader.setUniform(
      "uPointLightLocation",
      this.states.pointLightPositions
    );
    fillShader.setUniform(
      "uPointLightDiffuseColors",
      this.states.pointLightDiffuseColors
    );
    fillShader.setUniform(
      "uPointLightSpecularColors",
      this.states.pointLightSpecularColors
    );
    const directionalLightCount = this.states.directionalLightDiffuseColors.length / 3;
    fillShader.setUniform("uDirectionalLightCount", directionalLightCount);
    fillShader.setUniform(
      "uLightingDirection",
      this.states.directionalLightDirections
    );
    fillShader.setUniform(
      "uDirectionalDiffuseColors",
      this.states.directionalLightDiffuseColors
    );
    fillShader.setUniform(
      "uDirectionalSpecularColors",
      this.states.directionalLightSpecularColors
    );
    let mixedAmbientLight = [0, 0, 0];
    for (let i = 0; i < this.states.ambientLightColors.length; i += 3) {
      for (let off = 0; off < 3; off++) {
        if (this.states._useMetalness > 0) {
          mixedAmbientLight[off] += Math.max(
            0,
            this.states.ambientLightColors[i + off] - this.states._useMetalness
          );
        } else {
          mixedAmbientLight[off] += this.states.ambientLightColors[i + off];
        }
      }
    }
    fillShader.setUniform("uAmbientColor", mixedAmbientLight);
    const spotLightCount = this.states.spotLightDiffuseColors.length / 3;
    fillShader.setUniform("uSpotLightCount", spotLightCount);
    fillShader.setUniform("uSpotLightAngle", this.states.spotLightAngle);
    fillShader.setUniform("uSpotLightConc", this.states.spotLightConc);
    fillShader.setUniform(
      "uSpotLightDiffuseColors",
      this.states.spotLightDiffuseColors
    );
    fillShader.setUniform(
      "uSpotLightSpecularColors",
      this.states.spotLightSpecularColors
    );
    fillShader.setUniform("uSpotLightLocation", this.states.spotLightPositions);
    fillShader.setUniform(
      "uSpotLightDirection",
      this.states.spotLightDirections
    );
    fillShader.setUniform(
      "uConstantAttenuation",
      this.states.constantAttenuation
    );
    fillShader.setUniform("uLinearAttenuation", this.states.linearAttenuation);
    fillShader.setUniform(
      "uQuadraticAttenuation",
      this.states.quadraticAttenuation
    );
  }
  // getting called from _setFillUniforms
  _setImageLightUniforms(shader2) {
    shader2.setUniform("uUseImageLight", this.states.activeImageLight != null);
    if (this.states.activeImageLight) {
      let diffusedLight = this.getDiffusedTexture(this.states.activeImageLight);
      shader2.setUniform("environmentMapDiffused", diffusedLight);
      let specularLight = this.getSpecularTexture(this.states.activeImageLight);
      shader2.setUniform("environmentMapSpecular", specularLight);
    } else {
      shader2.setUniform("environmentMapDiffused", this._getEmptyTexture());
      shader2.setUniform("environmentMapSpecular", this._getEmptyTexture());
    }
  }
  /**
   * @private
   * Note: DO NOT CALL THIS while in the middle of binding another texture,
   * since it will change the texture binding in order to allocate the empty
   * texture! Grab its value beforehand!
   */
  _getEmptyTexture() {
    if (!this._emptyTexture) {
      const im = new Image(1, 1);
      im.set(0, 0, 255);
      this._emptyTexture = new Texture(this, im);
    }
    return this._emptyTexture;
  }
  getTexture(input) {
    let src = input;
    if (src instanceof Framebuffer$1) {
      src = src.color;
    }
    const texture2 = this.textures.get(src);
    if (texture2) {
      return texture2;
    }
    const tex = new Texture(this, src);
    this.textures.set(src, tex);
    return tex;
  }
  //////////////////////////////////////////////
  // Buffers
  //////////////////////////////////////////////
  _normalizeBufferData(values, type2 = Float32Array) {
    if (!values) return null;
    if (values instanceof DataArray) {
      return values.dataArray();
    }
    if (values instanceof type2) {
      return values;
    }
    return new type2(values);
  }
  ///////////////////////////////
  //// UTILITY FUNCTIONS
  //////////////////////////////
  _arraysEqual(a, b2) {
    const aLength = a.length;
    if (aLength !== b2.length) return false;
    return a.every((ai, i) => ai === b2[i]);
  }
  _isTypedArray(arr2) {
    return [
      Float32Array,
      Float64Array,
      Int16Array,
      Uint16Array,
      Uint32Array
    ].some((x) => arr2 instanceof x);
  }
  /**
   * turn a p5.Vector Array into a one dimensional number array
   * @private
   * @param  {p5.Vector[]} arr  an array of p5.Vector
   * @return {Number[]}     a one dimensional array of numbers
   * [p5.Vector(1, 2, 3), p5.Vector(4, 5, 6)] ->
   * [1, 2, 3, 4, 5, 6]
   */
  _vToNArray(arr2) {
    return arr2.flatMap((item) => [item.x, item.y, item.z]);
  }
  ///////////////////////////////
  //// TEXT SUPPORT METHODS
  //////////////////////////////
  _beforeDrawText() {
  }
  _afterDrawText() {
  }
  textCanvas() {
    if (!this._textCanvas) {
      this._textCanvas = document.createElement("canvas");
      this._textCanvas.width = 1;
      this._textCanvas.height = 1;
      this._textCanvas.style.display = "none";
      this.canvas.parentElement.insertBefore(this._textCanvas, this.canvas);
    }
    return this._textCanvas;
  }
  textDrawingContext() {
    if (!this._textDrawingContext) {
      const textCanvas = this.textCanvas();
      this._textDrawingContext = textCanvas.getContext("2d");
    }
    return this._textDrawingContext;
  }
  _positionLines(x, y, width, height, lines) {
    let { textLeading, textAlign } = this.states;
    const widths = lines.map((line) => this._fontWidthSingle(line));
    let adjustedX, lineData = new Array(lines.length);
    let adjustedW = typeof width === "undefined" ? Math.max(0, ...widths) : width;
    let adjustedH = typeof height === "undefined" ? 0 : height;
    for (let i = 0; i < lines.length; i++) {
      switch (textAlign) {
        case textCoreConstants.START:
          throw new Error("textBounds: START not yet supported for textAlign");
        // default to LEFT
        case LEFT:
          adjustedX = x;
          break;
        case CENTER:
          adjustedX = x + (adjustedW - widths[i]) / 2 - adjustedW / 2 + (width || 0) / 2;
          break;
        case RIGHT:
          adjustedX = x + adjustedW - widths[i] - adjustedW + (width || 0);
          break;
        case textCoreConstants.END:
          throw new Error("textBounds: END not yet supported for textAlign");
        default:
          adjustedX = x;
          break;
      }
      lineData[i] = { text: lines[i], x: adjustedX, y: y + i * textLeading };
    }
    return this._yAlignOffset(lineData, adjustedH);
  }
  _verticalAlignFont = function() {
    const ctx = this.textDrawingContext();
    const metrics = ctx.measureText("X");
    return -metrics.alphabeticBaseline || -metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
  };
  _yAlignOffset(dataArr, height) {
    if (typeof height === "undefined") {
      throw Error("_yAlignOffset: height is required");
    }
    let { textLeading, textBaseline, textSize, textFont } = this.states;
    let yOff = 0, numLines = dataArr.length;
    let totalHeight = textSize * numLines + (textLeading - textSize) * (numLines - 1);
    switch (textBaseline) {
      // drawingContext ?
      case TOP:
        yOff = this._verticalAlignFont();
        break;
      case BASELINE:
        break;
      case textCoreConstants._CTX_MIDDLE:
        yOff = (-totalHeight + textSize + (height || 0)) / 2 + this._verticalAlignFont() + this._middleAlignOffset();
        break;
      case BOTTOM:
        yOff = -(totalHeight - textSize) + (height || 0);
        break;
      default:
        console.warn(`${textBaseline} is not supported in WebGL mode.`);
        break;
    }
    dataArr.forEach((ele) => ele.y += yOff);
    return dataArr;
  }
  _makeFilterShader(renderer2, operation) {
    const p53 = this._pInst;
    return makeFilterShader(this, operation, p53);
  }
  /*
   * As part of imageLight(): we need to create a texture representing
   * the diffused light hitting an object from each angle. This will
   * accumulate light from angles in a hemisphere, weighted according to
   * how head-on the light angle is.
   *
   * This method returns a p5.Framebuffer that stores these values, mapping
   * an angle to each pixel. This creates and caches textures for reuse, since
   * creating this texture is somewhat expensive.
   */
  makeDiffusedTexture(input) {
    if (this.diffusedTextures.get(input) != null) {
      return this.diffusedTextures.get(input);
    }
    let newFramebuffer;
    let smallWidth = 200;
    let width = smallWidth;
    let height = Math.floor(smallWidth * (input.height / input.width));
    newFramebuffer = new Framebuffer$1(this, {
      width,
      height,
      density: 1
    });
    if (!this.diffusedShader) {
      this.diffusedShader = this._createImageLightShader("diffused");
    }
    newFramebuffer.draw(() => {
      this.shader(this.diffusedShader);
      this._setImageLightShaderUniforms(this.diffusedShader, input);
      this.states.setValue("strokeColor", null);
      this.noLights();
      this.plane(width, height);
    });
    this.diffusedTextures.set(input, newFramebuffer);
    return newFramebuffer;
  }
  getDiffusedTexture(input) {
    return this.diffusedTextures.get(input);
  }
  /*
   * used in imageLight,
   * To create a texture from the input non blurry image, if it doesn't already exist
   * Creating 8 different levels of textures according to different
   * sizes and storing them in `levels` array
   * Creating a new Mipmap texture with that `levels` array
   * Storing the texture for input image in map called `specularTextures`
   * maps the input Image to a p5.MipmapTexture
   */
  makeSpecularTexture(input) {
    if (this.specularTextures.get(input) != null) {
      return this.specularTextures.get(input);
    }
    const size = 512;
    let tex;
    let count = Math.floor(Math.log2(size)) + 1;
    if (!this.specularShader) {
      this.specularShader = this._createImageLightShader("specular");
    }
    const mipmapData = this._prepareMipmapData(size, count);
    const framebuffer2 = new Framebuffer$1(this, {
      width: size,
      height: size,
      density: 1
    });
    let mipLevel = 0;
    for (let w = size; w >= 1; w /= 2) {
      framebuffer2.resize(w, w);
      let currCount = Math.log(w) / Math.log(2);
      let roughness = 1 - currCount / count;
      framebuffer2.draw(() => {
        this.shader(this.specularShader);
        this.clear();
        this._setImageLightShaderUniforms(
          this.specularShader,
          input,
          roughness
        );
        this.states.setValue("strokeColor", null);
        this.noLights();
        this.plane(w, w);
      });
      this._accumulateMipLevel(framebuffer2, mipmapData, mipLevel, w, w);
      mipLevel++;
    }
    framebuffer2.remove();
    tex = this._finalizeMipmapTexture(mipmapData);
    this.specularTextures.set(input, tex);
    return tex;
  }
  getSpecularTexture(input) {
    return this.specularTextures.get(input);
  }
  _getSphereMapping(img) {
    if (!this.sphereMapping) {
      const p53 = this._pInst;
      this.sphereMapping = this.baseFilterShader().modify(({ p5: p54 }) => {
        const uEnvMap = p54.uniformTexture("uEnvMap");
        const uFovY = p54.uniformFloat("uFovY");
        const uAspect = p54.uniformFloat("uAspect");
        const uN1 = p54.uniformVec3("uN1");
        const uN2 = p54.uniformVec3("uN2");
        const uN3 = p54.uniformVec3("uN3");
        p54.getColor((inputs) => {
          const uFovX = uFovY * uAspect;
          const angleY = p54.mix(uFovY / 2, -uFovY / 2, inputs.texCoord.y);
          const angleX = p54.mix(uFovX / 2, -uFovX / 2, inputs.texCoord.x);
          let rotatedNormal = p54.normalize([angleX, angleY, 1]);
          rotatedNormal = [
            // Don't mind me, just doing matrix vector multiplication...
            p54.dot(rotatedNormal, uN1),
            p54.dot(rotatedNormal, uN2),
            p54.dot(rotatedNormal, uN3)
          ];
          const temp = rotatedNormal.z;
          rotatedNormal.z = rotatedNormal.x;
          rotatedNormal.x = -temp;
          const suv = [
            p54.atan(rotatedNormal.z, rotatedNormal.x) / (2 * p54.PI) + 0.5,
            0.5 + 0.5 * -rotatedNormal.y
          ];
          return p54.getTexture(uEnvMap, suv);
        });
      }, { p5: p53 });
    }
    this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
    this.scratchMat3.invert(this.scratchMat3);
    this.sphereMapping.setUniform("uFovY", this.states.curCamera.cameraFOV);
    this.sphereMapping.setUniform("uAspect", this.states.curCamera.aspectRatio);
    const m = this.scratchMat3.mat3;
    this.sphereMapping.setUniform("uN1", [m[0], m[3], m[6]]);
    this.sphereMapping.setUniform("uN2", [m[1], m[4], m[7]]);
    this.sphereMapping.setUniform("uN3", [m[2], m[5], m[8]]);
    this.sphereMapping.setUniform("uEnvMap", img);
    return this.sphereMapping;
  }
  /*
   * Abstract methods to be implemented by specific renderers
   */
  _createImageLightShader(type2) {
    throw new Error(
      "_createImageLightShader must be implemented by the renderer"
    );
  }
  _setImageLightShaderUniforms(shader2, input, roughness) {
    shader2.setUniform("environmentMap", input);
    if (roughness !== void 0) {
      shader2.setUniform("roughness", roughness);
    }
  }
  _createMipmapTexture(levels) {
    throw new Error("_createMipmapTexture must be implemented by the renderer");
  }
  _prepareMipmapData(size, mipLevels) {
    throw new Error("_prepareMipmapData must be implemented by the renderer");
  }
  _accumulateMipLevel(framebuffer2, mipmapData, mipLevel, width, height) {
    throw new Error("_accumulateMipLevel must be implemented by the renderer");
  }
  _finalizeMipmapTexture(mipmapData) {
    throw new Error(
      "_finalizeMipmapTexture must be implemented by the renderer"
    );
  }
  remove() {
    if (this._textCanvas) {
      this._textCanvas.parentElement.removeChild(this._textCanvas);
    }
    super.remove();
  }
}
function renderer3D(p53, fn2) {
  p53.Renderer3D = Renderer3D;
}
if (typeof p5 !== "undefined") {
  renderer3D(p5, p5.prototype);
}
function primitives3D(p53, fn2) {
  fn2.strokeMode = function(mode) {
    if (mode === void 0) {
      return this._renderer._simpleLines ? SIMPLE : FULL;
    } else if (mode === SIMPLE) {
      this._renderer._simpleLines = true;
    } else if (mode === FULL) {
      this._renderer._simpleLines = false;
    } else {
      throw Error("no such parameter");
    }
  };
  fn2.buildGeometry = function(callback) {
    return this._renderer.buildGeometry(callback);
  };
  fn2.freeGeometry = function(geometry2) {
    this._renderer.geometryBufferCache.freeBuffers(geometry2.gid);
  };
  fn2.plane = function(width = 50, height = width, detailX = 1, detailY = 1) {
    this._assert3d("plane");
    this._renderer.plane(width, height, detailX, detailY);
    return this;
  };
  fn2.box = function(width, height, depth, detailX, detailY) {
    this._assert3d("box");
    this._renderer.box(width, height, depth, detailX, detailY);
    return this;
  };
  fn2.sphere = function(radius = 50, detailX = 24, detailY = 16) {
    this._assert3d("sphere");
    this._renderer.sphere(radius, detailX, detailY);
    return this;
  };
  fn2.cylinder = function(radius = 50, height = radius, detailX = 24, detailY = 1, bottomCap = true, topCap = true) {
    this._assert3d("cylinder");
    this._renderer.cylinder(
      radius,
      height,
      detailX,
      detailY,
      bottomCap,
      topCap
    );
    return this;
  };
  fn2.cone = function(radius = 50, height = radius, detailX = 24, detailY = 1, cap = true) {
    this._assert3d("cone");
    this._renderer.cone(radius, height, detailX, detailY, cap);
    return this;
  };
  fn2.ellipsoid = function(radiusX = 50, radiusY = radiusX, radiusZ = radiusX, detailX = 24, detailY = 16) {
    this._assert3d("ellipsoid");
    this._renderer.ellipsoid(radiusX, radiusY, radiusZ, detailX, detailY);
    return this;
  };
  fn2.torus = function(radius, tubeRadius, detailX, detailY) {
    this._assert3d("torus");
    this._renderer.torus(radius, tubeRadius, detailX, detailY);
    return this;
  };
  Renderer3D.prototype.point = function(x, y, z = 0) {
    this.beginShape(POINTS);
    this.vertex(x, y, z);
    this.endShape();
    return this;
  };
  Renderer3D.prototype.triangle = function(args) {
    const x1 = args[0], y1 = args[1];
    const x2 = args[2], y2 = args[3];
    const x3 = args[4], y3 = args[5];
    const gid = "tri";
    if (!this.geometryInHash(gid)) {
      const _triangle = function() {
        const vertices = [];
        vertices.push(new Vector(0, 0, 0));
        vertices.push(new Vector(1, 0, 0));
        vertices.push(new Vector(0, 1, 0));
        this.edges = [[0, 1], [1, 2], [2, 0]];
        this.vertices = vertices;
        this.faces = [[0, 1, 2]];
        this.uvs = [0, 0, 1, 0, 1, 1];
      };
      const triGeom = new Geometry(1, 1, _triangle, this);
      triGeom._edgesToVertices();
      triGeom.computeNormals();
      triGeom.gid = gid;
      this.geometryBufferCache.ensureCached(triGeom);
    }
    const uModelMatrix = this.states.uModelMatrix.copy();
    try {
      const orientation = Math.sign(x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3);
      const mult = new Matrix([
        x2 - x1,
        y2 - y1,
        0,
        0,
        // the resulting unit X-axis
        x3 - x1,
        y3 - y1,
        0,
        0,
        // the resulting unit Y-axis
        0,
        0,
        orientation,
        0,
        // the resulting unit Z-axis (Reflect the specified order of vertices)
        x1,
        y1,
        0,
        1
        // the resulting origin
      ]).mult(this.states.uModelMatrix);
      this.states.setValue("uModelMatrix", mult);
      this.model(this.geometryBufferCache.getGeometryByID(gid));
    } finally {
      this.states.setValue("uModelMatrix", uModelMatrix);
    }
    return this;
  };
  Renderer3D.prototype.ellipse = function(args) {
    this.arc(
      args[0],
      args[1],
      args[2],
      args[3],
      0,
      TWO_PI,
      OPEN,
      args[4]
    );
  };
  Renderer3D.prototype.arc = function(...args) {
    const x = args[0];
    const y = args[1];
    const width = args[2];
    const height = args[3];
    const start2 = args[4];
    const stop = args[5];
    const mode = args[6];
    const detail = args[7] || 25;
    let shape2;
    let gid;
    if (Math.abs(stop - start2) >= TWO_PI) {
      shape2 = "ellipse";
      gid = `${shape2}|${detail}|`;
    } else {
      shape2 = "arc";
      gid = `${shape2}|${start2}|${stop}|${mode}|${detail}|`;
    }
    if (!this.geometryInHash(gid)) {
      const _arc = function() {
        if (start2.toFixed(10) !== stop.toFixed(10)) {
          if (mode === PIE || typeof mode === "undefined") {
            this.vertices.push(new Vector(0.5, 0.5, 0));
            this.uvs.push([0.5, 0.5]);
          }
          for (let i = 0; i <= detail; i++) {
            const u = i / detail;
            const theta = (stop - start2) * u + start2;
            const _x = 0.5 + Math.cos(theta) / 2;
            const _y = 0.5 + Math.sin(theta) / 2;
            this.vertices.push(new Vector(_x, _y, 0));
            this.uvs.push([_x, _y]);
            if (i < detail - 1) {
              this.faces.push([0, i + 1, i + 2]);
              this.edges.push([i + 1, i + 2]);
            }
          }
          switch (mode) {
            case PIE:
              this.faces.push([
                0,
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([0, 1]);
              this.edges.push([
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([0, this.vertices.length - 1]);
              break;
            case CHORD:
              this.edges.push([0, 1]);
              this.edges.push([0, this.vertices.length - 1]);
              break;
            case OPEN:
              this.edges.push([0, 1]);
              break;
            default:
              this.faces.push([
                0,
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
          }
        }
      };
      const arcGeom = new Geometry(detail, 1, _arc, this);
      arcGeom.computeNormals();
      if (detail <= 50) {
        arcGeom._edgesToVertices(arcGeom);
      } else if (this.states.strokeColor) {
        console.log(
          `Cannot apply a stroke to an ${shape2} with more than 50 detail`
        );
      }
      arcGeom.gid = gid;
      this.geometryBufferCache.ensureCached(arcGeom);
    }
    const uModelMatrix = this.states.uModelMatrix;
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    try {
      this.states.uModelMatrix.translate([x, y, 0]);
      this.states.uModelMatrix.scale(width, height, 1);
      this.model(this.geometryBufferCache.getGeometryByID(gid));
    } finally {
      this.states.setValue("uModelMatrix", uModelMatrix);
    }
    return this;
  };
  Renderer3D.prototype.rect = function(args) {
    const x = args[0];
    const y = args[1];
    const width = args[2];
    const height = args[3];
    if (typeof args[4] === "undefined") {
      const perPixelLighting = this._pInst._glAttributes?.perPixelLighting ?? true;
      const detailX = args[4] || (perPixelLighting ? 1 : 24);
      const detailY = args[5] || (perPixelLighting ? 1 : 16);
      const gid = `rect|${detailX}|${detailY}`;
      if (!this.geometryInHash(gid)) {
        const _rect = function() {
          for (let i = 0; i <= this.detailY; i++) {
            const v = i / this.detailY;
            for (let j2 = 0; j2 <= this.detailX; j2++) {
              const u = j2 / this.detailX;
              const p2 = new Vector(u, v, 0);
              this.vertices.push(p2);
              this.uvs.push(u, v);
            }
          }
          if (detailX > 0 && detailY > 0) {
            this.edges = [
              [0, detailX],
              [detailX, (detailX + 1) * (detailY + 1) - 1],
              [(detailX + 1) * (detailY + 1) - 1, (detailX + 1) * detailY],
              [(detailX + 1) * detailY, 0]
            ];
          }
        };
        const rectGeom = new Geometry(detailX, detailY, _rect, this);
        rectGeom.computeFaces().computeNormals()._edgesToVertices();
        rectGeom.gid = gid;
        this.geometryBufferCache.ensureCached(rectGeom);
      }
      const uModelMatrix = this.states.uModelMatrix;
      this.states.setValue("uModelMatrix", this.states.uModelMatrix.copy());
      try {
        this.states.uModelMatrix.translate([x, y, 0]);
        this.states.uModelMatrix.scale(width, height, 1);
        this.model(this.geometryBufferCache.getGeometryByID(gid));
      } finally {
        this.states.setValue("uModelMatrix", uModelMatrix);
      }
    } else {
      let tl = args[4];
      let tr = typeof args[5] === "undefined" ? tl : args[5];
      let br = typeof args[6] === "undefined" ? tr : args[6];
      let bl = typeof args[7] === "undefined" ? br : args[7];
      let a = x;
      let b2 = y;
      let c = width;
      let d2 = height;
      c += a;
      d2 += b2;
      if (a > c) {
        const temp = a;
        a = c;
        c = temp;
      }
      if (b2 > d2) {
        const temp = b2;
        b2 = d2;
        d2 = temp;
      }
      const maxRounding = Math.min((c - a) / 2, (d2 - b2) / 2);
      if (tl > maxRounding) tl = maxRounding;
      if (tr > maxRounding) tr = maxRounding;
      if (br > maxRounding) br = maxRounding;
      if (bl > maxRounding) bl = maxRounding;
      let x1 = a;
      let y1 = b2;
      let x2 = c;
      let y2 = d2;
      const prevMode = this.states.textureMode;
      this.states.setValue("textureMode", NORMAL);
      const prevOrder = this.bezierOrder();
      this.bezierOrder(2);
      this.beginShape();
      const addUVs = (x3, y3) => [x3, y3, 0, (x3 - x1) / width, (y3 - y1) / height];
      if (tr !== 0) {
        this.vertex(...addUVs(x2 - tr, y1));
        this.bezierVertex(...addUVs(x2, y1));
        this.bezierVertex(...addUVs(x2, y1 + tr));
      } else {
        this.vertex(...addUVs(x2, y1));
      }
      if (br !== 0) {
        this.vertex(...addUVs(x2, y2 - br));
        this.bezierVertex(...addUVs(x2, y2));
        this.bezierVertex(...addUVs(x2 - br, y2));
      } else {
        this.vertex(...addUVs(x2, y2));
      }
      if (bl !== 0) {
        this.vertex(...addUVs(x1 + bl, y2));
        this.bezierVertex(...addUVs(x1, y2));
        this.bezierVertex(...addUVs(x1, y2 - bl));
      } else {
        this.vertex(...addUVs(x1, y2));
      }
      if (tl !== 0) {
        this.vertex(...addUVs(x1, y1 + tl));
        this.bezierVertex(...addUVs(x1, y1));
        this.bezierVertex(...addUVs(x1 + tl, y1));
      } else {
        this.vertex(...addUVs(x1, y1));
      }
      this.endShape(CLOSE);
      this.states.setValue("textureMode", prevMode);
      this.bezierOrder(prevOrder);
    }
    return this;
  };
  Renderer3D.prototype.quad = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, detailX = 2, detailY = 2) {
    const gid = `quad|${x1}|${y1}|${z1}|${x2}|${y2}|${z2}|${x3}|${y3}|${z3}|${x4}|${y4}|${z4}|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const quadGeom = new Geometry(detailX, detailY, function() {
        let xRes = 1 / (this.detailX - 1);
        let yRes = 1 / (this.detailY - 1);
        for (let y = 0; y < this.detailY; y++) {
          for (let x = 0; x < this.detailX; x++) {
            let pctx = x * xRes;
            let pcty = y * yRes;
            let linePt0x = (1 - pcty) * x1 + pcty * x4;
            let linePt0y = (1 - pcty) * y1 + pcty * y4;
            let linePt0z = (1 - pcty) * z1 + pcty * z4;
            let linePt1x = (1 - pcty) * x2 + pcty * x3;
            let linePt1y = (1 - pcty) * y2 + pcty * y3;
            let linePt1z = (1 - pcty) * z2 + pcty * z3;
            let ptx = (1 - pctx) * linePt0x + pctx * linePt1x;
            let pty = (1 - pctx) * linePt0y + pctx * linePt1y;
            let ptz = (1 - pctx) * linePt0z + pctx * linePt1z;
            this.vertices.push(new Vector(ptx, pty, ptz));
            this.uvs.push([pctx, pcty]);
          }
        }
      }, this);
      quadGeom.faces = [];
      for (let y = 0; y < detailY - 1; y++) {
        for (let x = 0; x < detailX - 1; x++) {
          let pt0 = x + y * detailX;
          let pt1 = x + 1 + y * detailX;
          let pt2 = x + 1 + (y + 1) * detailX;
          let pt3 = x + (y + 1) * detailX;
          quadGeom.faces.push([pt0, pt1, pt2]);
          quadGeom.faces.push([pt0, pt2, pt3]);
        }
      }
      quadGeom.computeNormals();
      quadGeom.edges.length = 0;
      const vertexOrder = [0, 2, 3, 1];
      for (let i = 0; i < vertexOrder.length; i++) {
        const startVertex = vertexOrder[i];
        const endVertex = vertexOrder[(i + 1) % vertexOrder.length];
        quadGeom.edges.push([startVertex, endVertex]);
      }
      quadGeom._edgesToVertices();
      quadGeom.gid = gid;
      this.geometryBufferCache.ensureCached(quadGeom);
    }
    this.model(this.geometryBufferCache.getGeometryByID(gid));
    return this;
  };
  Renderer3D.prototype.bezier = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    if (arguments.length === 8) {
      y4 = y3;
      x4 = x3;
      y3 = z2;
      x3 = y2;
      y2 = x2;
      x2 = z1;
      z1 = z2 = z3 = z4 = 0;
    }
    this.bezierOrder();
    this.bezierOrder(3);
    this.beginShape();
    this.vertex(x1, y1, z1);
    this.bezierVertex(x2, y2, z2);
    this.bezierVertex(x3, y3, z3);
    this.bezierVertex(x4, y4, z4);
    this.endShape();
  };
  Renderer3D.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    if (arguments.length === 8) {
      x4 = x3;
      y4 = y3;
      x3 = y2;
      y3 = x2;
      x2 = z1;
      y2 = x2;
      z1 = z2 = z3 = z4 = 0;
    }
    this.beginShape();
    this.splineVertex(x1, y1, z1);
    this.splineVertex(x2, y2, z2);
    this.splineVertex(x3, y3, z3);
    this.splineVertex(x4, y4, z4);
    this.endShape();
  };
  Renderer3D.prototype.line = function(...args) {
    if (args.length === 6) {
      this.beginShape(LINES);
      this.vertex(args[0], args[1], args[2]);
      this.vertex(args[3], args[4], args[5]);
      this.endShape();
    } else if (args.length === 4) {
      this.beginShape(LINES);
      this.vertex(args[0], args[1], 0);
      this.vertex(args[2], args[3], 0);
      this.endShape();
    }
    return this;
  };
  Renderer3D.prototype.image = function(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    if (this._isErasing) {
      this.blendMode(this._cachedBlendMode);
    }
    this.push();
    this.noLights();
    this.states.setValue("strokeColor", null);
    this.texture(img);
    this.states.setValue("textureMode", NORMAL);
    let u0 = 0;
    if (sx <= img.width) {
      u0 = sx / img.width;
    }
    let u1 = 1;
    if (sx + sWidth <= img.width) {
      u1 = (sx + sWidth) / img.width;
    }
    let v0 = 0;
    if (sy <= img.height) {
      v0 = sy / img.height;
    }
    let v1 = 1;
    if (sy + sHeight <= img.height) {
      v1 = (sy + sHeight) / img.height;
    }
    this._drawingImage = true;
    this.beginShape();
    this.vertex(dx, dy, 0, u0, v0);
    this.vertex(dx + dWidth, dy, 0, u1, v0);
    this.vertex(dx + dWidth, dy + dHeight, 0, u1, v1);
    this.vertex(dx, dy + dHeight, 0, u0, v1);
    this.endShape(CLOSE);
    this._drawingImage = false;
    this.pop();
    if (this._isErasing) {
      this.blendMode(REMOVE);
    }
  };
  const _truncatedCone = function(bottomRadius, topRadius, height, detailX, detailY, bottomCap, topCap) {
    bottomRadius = bottomRadius <= 0 ? 1 : bottomRadius;
    topRadius = topRadius < 0 ? 0 : topRadius;
    height = height <= 0 ? bottomRadius : height;
    detailX = detailX < 3 ? 3 : detailX;
    detailY = detailY < 1 ? 1 : detailY;
    bottomCap = bottomCap === void 0 ? true : bottomCap;
    topCap = topCap === void 0 ? topRadius !== 0 : topCap;
    const start2 = bottomCap ? -2 : 0;
    const end = detailY + (topCap ? 2 : 0);
    const slant = Math.atan2(bottomRadius - topRadius, height);
    const sinSlant = Math.sin(slant);
    const cosSlant = Math.cos(slant);
    let yy, ii, jj;
    for (yy = start2; yy <= end; ++yy) {
      let v = yy / detailY;
      let y = height * v;
      let ringRadius;
      if (yy < 0) {
        y = 0;
        v = 0;
        ringRadius = bottomRadius;
      } else if (yy > detailY) {
        y = height;
        v = 1;
        ringRadius = topRadius;
      } else {
        ringRadius = bottomRadius + (topRadius - bottomRadius) * v;
      }
      if (yy === -2 || yy === detailY + 2) {
        ringRadius = 0;
      }
      y -= height / 2;
      for (ii = 0; ii < detailX; ++ii) {
        const u = ii / (detailX - 1);
        const ur = 2 * Math.PI * u;
        const sur = Math.sin(ur);
        const cur = Math.cos(ur);
        this.vertices.push(new Vector(sur * ringRadius, y, cur * ringRadius));
        let vertexNormal;
        if (yy < 0) {
          vertexNormal = new Vector(0, -1, 0);
        } else if (yy > detailY && topRadius) {
          vertexNormal = new Vector(0, 1, 0);
        } else {
          vertexNormal = new Vector(sur * cosSlant, sinSlant, cur * cosSlant);
        }
        this.vertexNormals.push(vertexNormal);
        this.uvs.push(u, v);
      }
    }
    let startIndex = 0;
    if (bottomCap) {
      for (jj = 0; jj < detailX; ++jj) {
        const nextjj = (jj + 1) % detailX;
        this.faces.push([
          startIndex + jj,
          startIndex + detailX + nextjj,
          startIndex + detailX + jj
        ]);
      }
      startIndex += detailX * 2;
    }
    for (yy = 0; yy < detailY; ++yy) {
      for (ii = 0; ii < detailX; ++ii) {
        const nextii = (ii + 1) % detailX;
        this.faces.push([
          startIndex + ii,
          startIndex + nextii,
          startIndex + detailX + nextii
        ]);
        this.faces.push([
          startIndex + ii,
          startIndex + detailX + nextii,
          startIndex + detailX + ii
        ]);
      }
      startIndex += detailX;
    }
    if (topCap) {
      startIndex += detailX;
      for (ii = 0; ii < detailX; ++ii) {
        this.faces.push([
          startIndex + ii,
          startIndex + (ii + 1) % detailX,
          startIndex + detailX
        ]);
      }
    }
  };
  Renderer3D.prototype.plane = function(width = 50, height = width, detailX = 1, detailY = 1) {
    const gid = `plane|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _plane = function() {
        let u, v, p2;
        for (let i = 0; i <= this.detailY; i++) {
          v = i / this.detailY;
          for (let j2 = 0; j2 <= this.detailX; j2++) {
            u = j2 / this.detailX;
            p2 = new Vector(u - 0.5, v - 0.5, 0);
            this.vertices.push(p2);
            this.uvs.push(u, v);
          }
        }
      };
      const planeGeom = new Geometry(detailX, detailY, _plane, this);
      planeGeom.computeFaces().computeNormals();
      if (detailX <= 1 && detailY <= 1) {
        planeGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on plane objects with more than 1 detailX or 1 detailY"
        );
      }
      planeGeom.gid = gid;
      this.geometryBufferCache.ensureCached(planeGeom);
    }
    this._drawGeometryScaled(
      this.geometryBufferCache.getGeometryByID(gid),
      width,
      height,
      1
    );
  };
  Renderer3D.prototype.box = function(width = 50, height = width, depth = height, detailX, detailY) {
    const perPixelLighting = this.attributes && this.attributes.perPixelLighting;
    if (typeof detailX === "undefined") {
      detailX = perPixelLighting ? 1 : 4;
    }
    if (typeof detailY === "undefined") {
      detailY = perPixelLighting ? 1 : 4;
    }
    const gid = `box|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _box = function() {
        const cubeIndices = [
          [0, 4, 2, 6],
          // -1, 0, 0],// -x
          [1, 3, 5, 7],
          // +1, 0, 0],// +x
          [0, 1, 4, 5],
          // 0, -1, 0],// -y
          [2, 6, 3, 7],
          // 0, +1, 0],// +y
          [0, 2, 1, 3],
          // 0, 0, -1],// -z
          [4, 5, 6, 7]
          // 0, 0, +1] // +z
        ];
        this.edges = [
          [0, 1],
          [1, 3],
          [3, 2],
          [6, 7],
          [8, 9],
          [9, 11],
          [14, 15],
          [16, 17],
          [17, 19],
          [18, 19],
          [20, 21],
          [22, 23]
        ];
        cubeIndices.forEach((cubeIndex, i) => {
          const v = i * 4;
          for (let j2 = 0; j2 < 4; j2++) {
            const d2 = cubeIndex[j2];
            const octant = new Vector(
              ((d2 & 1) * 2 - 1) / 2,
              ((d2 & 2) - 1) / 2,
              ((d2 & 4) / 2 - 1) / 2
            );
            this.vertices.push(octant);
            this.uvs.push(j2 & 1, (j2 & 2) / 2);
          }
          this.faces.push([v, v + 1, v + 2]);
          this.faces.push([v + 2, v + 1, v + 3]);
        });
      };
      const boxGeom = new Geometry(detailX, detailY, _box, this);
      boxGeom.computeNormals();
      if (detailX <= 4 && detailY <= 4) {
        boxGeom._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on box objects with more than 4 detailX or 4 detailY"
        );
      }
      boxGeom.gid = gid;
      this.geometryBufferCache.ensureCached(boxGeom);
    }
    this._drawGeometryScaled(
      this.geometryBufferCache.getGeometryByID(gid),
      width,
      height,
      depth
    );
  };
  Renderer3D.prototype.sphere = function(radius = 50, detailX = 24, detailY = 16) {
    this.ellipsoid(radius, radius, radius, detailX, detailY);
  };
  Renderer3D.prototype.ellipsoid = function(radiusX = 50, radiusY = radiusX, radiusZ = radiusX, detailX = 24, detailY = 16) {
    const gid = `ellipsoid|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _ellipsoid = function() {
        for (let i = 0; i <= this.detailY; i++) {
          const v = i / this.detailY;
          const phi = Math.PI * v - Math.PI / 2;
          const cosPhi = Math.cos(phi);
          const sinPhi = Math.sin(phi);
          for (let j2 = 0; j2 <= this.detailX; j2++) {
            const u = j2 / this.detailX;
            const theta = 2 * Math.PI * u;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            const p2 = new p53.Vector(
              cosPhi * sinTheta,
              sinPhi,
              cosPhi * cosTheta
            );
            this.vertices.push(p2);
            this.vertexNormals.push(p2);
            this.uvs.push(u, v);
          }
        }
      };
      const ellipsoidGeom = new Geometry(detailX, detailY, _ellipsoid, this);
      ellipsoidGeom.computeFaces();
      if (detailX <= 24 && detailY <= 24) {
        ellipsoidGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on ellipsoids with more than 24 detailX or 24 detailY"
        );
      }
      ellipsoidGeom.gid = gid;
      this.geometryBufferCache.ensureCached(ellipsoidGeom);
    }
    this._drawGeometryScaled(
      this.geometryBufferCache.getGeometryByID(gid),
      radiusX,
      radiusY,
      radiusZ
    );
  };
  Renderer3D.prototype.cylinder = function(radius = 50, height = radius, detailX = 24, detailY = 1, bottomCap = true, topCap = true) {
    const gid = `cylinder|${detailX}|${detailY}|${bottomCap}|${topCap}`;
    if (!this.geometryInHash(gid)) {
      const cylinderGeom = new p53.Geometry(detailX, detailY, function() {
        _truncatedCone.call(
          this,
          1,
          1,
          1,
          detailX,
          detailY,
          bottomCap,
          topCap
        );
      }, this);
      if (detailX <= 24 && detailY <= 16) {
        cylinderGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on cylinder objects with more than 24 detailX or 16 detailY"
        );
      }
      cylinderGeom.gid = gid;
      this.geometryBufferCache.ensureCached(cylinderGeom);
    }
    this._drawGeometryScaled(
      this.geometryBufferCache.getGeometryByID(gid),
      radius,
      height,
      radius
    );
  };
  Renderer3D.prototype.cone = function(radius = 50, height = radius, detailX = 24, detailY = 1, cap = true) {
    const gid = `cone|${detailX}|${detailY}|${cap}`;
    if (!this.geometryInHash(gid)) {
      const coneGeom = new Geometry(detailX, detailY, function() {
        _truncatedCone.call(
          this,
          1,
          0,
          1,
          detailX,
          detailY,
          cap,
          false
        );
      }, this);
      if (detailX <= 24 && detailY <= 16) {
        coneGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on cone objects with more than 24 detailX or 16 detailY"
        );
      }
      coneGeom.gid = gid;
      this.geometryBufferCache.ensureCached(coneGeom);
    }
    this._drawGeometryScaled(
      this.geometryBufferCache.getGeometryByID(gid),
      radius,
      height,
      radius
    );
  };
  Renderer3D.prototype.torus = function(radius = 50, tubeRadius = 10, detailX = 24, detailY = 16) {
    if (radius === 0) {
      return;
    }
    if (tubeRadius === 0) {
      return;
    }
    const tubeRatio = (tubeRadius / radius).toPrecision(4);
    const gid = `torus|${tubeRatio}|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _torus = function() {
        for (let i = 0; i <= this.detailY; i++) {
          const v = i / this.detailY;
          const phi = 2 * Math.PI * v;
          const cosPhi = Math.cos(phi);
          const sinPhi = Math.sin(phi);
          const r = 1 + tubeRatio * cosPhi;
          for (let j2 = 0; j2 <= this.detailX; j2++) {
            const u = j2 / this.detailX;
            const theta = 2 * Math.PI * u;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            const p2 = new Vector(
              r * cosTheta,
              r * sinTheta,
              tubeRatio * sinPhi
            );
            const n2 = new Vector(cosPhi * cosTheta, cosPhi * sinTheta, sinPhi);
            this.vertices.push(p2);
            this.vertexNormals.push(n2);
            this.uvs.push(u, v);
          }
        }
      };
      const torusGeom = new Geometry(detailX, detailY, _torus, this);
      torusGeom.computeFaces();
      if (detailX <= 24 && detailY <= 16) {
        torusGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw strokes on torus object with more than 24 detailX or 16 detailY"
        );
      }
      torusGeom.gid = gid;
      this.geometryBufferCache.ensureCached(torusGeom);
    }
    this._drawGeometryScaled(
      this.geometryBufferCache.getGeometryByID(gid),
      radius,
      radius,
      radius
    );
  };
  fn2.curveDetail = function(d2) {
    if (!(this._renderer instanceof Renderer3D)) {
      throw new Error(
        "curveDetail() only works in WebGL mode. Did you mean to call createCanvas(width, height, WEBGL)?"
      );
    }
    return this._renderer.curveDetail(d2);
  };
}
if (typeof p5 !== "undefined") {
  primitives3D(p5, p5.prototype);
}
function light(p53, fn2) {
  fn2.ambientLight = function(v1, v2, v3, a) {
    this._assert3d("ambientLight");
    this._renderer.ambientLight(...arguments);
    return this;
  };
  fn2.specularColor = function(v1, v2, v3) {
    this._assert3d("specularColor");
    this._renderer.specularColor(...arguments);
    return this;
  };
  fn2.directionalLight = function(v1, v2, v3, x, y, z) {
    this._assert3d("directionalLight");
    this._renderer.directionalLight(...arguments);
    return this;
  };
  fn2.pointLight = function(v1, v2, v3, x, y, z) {
    this._assert3d("pointLight");
    this._renderer.pointLight(...arguments);
    return this;
  };
  fn2.imageLight = function(img) {
    this._renderer.imageLight(img);
  };
  fn2.panorama = function(img) {
    this.filter(this._renderer._getSphereMapping(img));
  };
  fn2.lights = function() {
    this._assert3d("lights");
    this._renderer.lights();
    return this;
  };
  fn2.lightFalloff = function(constantAttenuation, linearAttenuation, quadraticAttenuation) {
    this._assert3d("lightFalloff");
    this._renderer.lightFalloff(
      constantAttenuation,
      linearAttenuation,
      quadraticAttenuation
    );
    return this;
  };
  fn2.spotLight = function(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration) {
    this._assert3d("spotLight");
    this._renderer.spotLight(...arguments);
    return this;
  };
  fn2.noLights = function(...args) {
    this._assert3d("noLights");
    this._renderer.noLights();
    return this;
  };
  Renderer3D.prototype.ambientLight = function(v1, v2, v3, a) {
    const color2 = this._pInst.color(...arguments);
    this.states.setValue("ambientLightColors", [...this.states.ambientLightColors]);
    this.states.ambientLightColors.push(
      color2._array[0],
      color2._array[1],
      color2._array[2]
    );
    this.states.setValue("enableLighting", true);
  };
  Renderer3D.prototype.specularColor = function(v1, v2, v3) {
    const color2 = this._pInst.color(...arguments);
    this.states.setValue("specularColors", [
      color2._array[0],
      color2._array[1],
      color2._array[2]
    ]);
  };
  Renderer3D.prototype.directionalLight = function(v1, v2, v3, x, y, z) {
    let color2;
    if (v1 instanceof Color) {
      color2 = v1;
    } else {
      color2 = this._pInst.color(v1, v2, v3);
    }
    let _x, _y, _z;
    const v = arguments[arguments.length - 1];
    if (typeof v === "number") {
      _x = arguments[arguments.length - 3];
      _y = arguments[arguments.length - 2];
      _z = arguments[arguments.length - 1];
    } else {
      _x = v.x;
      _y = v.y;
      _z = v.z;
    }
    const l = Math.sqrt(_x * _x + _y * _y + _z * _z);
    this.states.setValue("directionalLightDirections", [...this.states.directionalLightDirections]);
    this.states.directionalLightDirections.push(_x / l, _y / l, _z / l);
    this.states.setValue("directionalLightDiffuseColors", [...this.states.directionalLightDiffuseColors]);
    this.states.directionalLightDiffuseColors.push(
      color2._array[0],
      color2._array[1],
      color2._array[2]
    );
    this.states.setValue("directionalLightSpecularColors", [...this.states.directionalLightSpecularColors]);
    Array.prototype.push.apply(
      this.states.directionalLightSpecularColors,
      this.states.specularColors
    );
    this.states.setValue("enableLighting", true);
  };
  Renderer3D.prototype.pointLight = function(v1, v2, v3, x, y, z) {
    let color2;
    if (v1 instanceof Color) {
      color2 = v1;
    } else {
      color2 = this._pInst.color(v1, v2, v3);
    }
    let _x, _y, _z;
    const v = arguments[arguments.length - 1];
    if (typeof v === "number") {
      _x = arguments[arguments.length - 3];
      _y = arguments[arguments.length - 2];
      _z = arguments[arguments.length - 1];
    } else {
      _x = v.x;
      _y = v.y;
      _z = v.z;
    }
    this.states.setValue("pointLightPositions", [...this.states.pointLightPositions]);
    this.states.pointLightPositions.push(_x, _y, _z);
    this.states.setValue("pointLightDiffuseColors", [...this.states.pointLightDiffuseColors]);
    this.states.pointLightDiffuseColors.push(
      color2._array[0],
      color2._array[1],
      color2._array[2]
    );
    this.states.setValue("pointLightSpecularColors", [...this.states.pointLightSpecularColors]);
    Array.prototype.push.apply(
      this.states.pointLightSpecularColors,
      this.states.specularColors
    );
    this.states.setValue("enableLighting", true);
  };
  Renderer3D.prototype.imageLight = function(img) {
    this.states.setValue("activeImageLight", img);
    this.states.setValue("enableLighting", true);
    this.makeDiffusedTexture(img);
    this.makeSpecularTexture(img);
  };
  Renderer3D.prototype.lights = function() {
    const grayColor = this._pInst.color("rgb(128,128,128)");
    this.ambientLight(grayColor);
    this.directionalLight(grayColor, 0, 0, -1);
  };
  Renderer3D.prototype.lightFalloff = function(constantAttenuation, linearAttenuation, quadraticAttenuation) {
    if (constantAttenuation < 0) {
      constantAttenuation = 0;
      console.warn(
        "Value of constant argument in lightFalloff() should be never be negative. Set to 0."
      );
    }
    if (linearAttenuation < 0) {
      linearAttenuation = 0;
      console.warn(
        "Value of linear argument in lightFalloff() should be never be negative. Set to 0."
      );
    }
    if (quadraticAttenuation < 0) {
      quadraticAttenuation = 0;
      console.warn(
        "Value of quadratic argument in lightFalloff() should be never be negative. Set to 0."
      );
    }
    if (constantAttenuation === 0 && (linearAttenuation === 0 && quadraticAttenuation === 0)) {
      constantAttenuation = 1;
      console.warn(
        "Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1."
      );
    }
    this.states.setValue("constantAttenuation", constantAttenuation);
    this.states.setValue("linearAttenuation", linearAttenuation);
    this.states.setValue("quadraticAttenuation", quadraticAttenuation);
  };
  Renderer3D.prototype.spotLight = function(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration) {
    if (this.states.spotLightDiffuseColors.length / 3 >= 4) return;
    let color2, position, direction;
    const length = arguments.length;
    switch (length) {
      case 11:
      case 10:
        color2 = this._pInst.color(v1, v2, v3);
        position = new Vector(x, y, z);
        direction = new Vector(nx, ny, nz);
        break;
      case 9:
        if (v1 instanceof Color) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
          angle = ny;
          concentration = nz;
        } else if (x instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
          angle = ny;
          concentration = nz;
        } else if (nx instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
          angle = ny;
          concentration = nz;
        } else {
          color2 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = new Vector(nx, ny, nz);
        }
        break;
      case 8:
        if (v1 instanceof Color) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
          angle = ny;
        } else if (x instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
          angle = ny;
        } else {
          color2 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
          angle = ny;
        }
        break;
      case 7:
        if (v1 instanceof Color && v2 instanceof Vector) {
          color2 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
          angle = z;
          concentration = nx;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
          angle = z;
          concentration = nx;
        } else if (x instanceof Vector && y instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
          angle = z;
          concentration = nx;
        } else if (v1 instanceof Color) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
        } else if (x instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
        } else {
          color2 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
        }
        break;
      case 6:
        if (x instanceof Vector && y instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
          angle = z;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
          angle = z;
        } else if (v1 instanceof Color && v2 instanceof Vector) {
          color2 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
          angle = z;
        }
        break;
      case 5:
        if (v1 instanceof Color && v2 instanceof Vector && v3 instanceof Vector) {
          color2 = v1;
          position = v2;
          direction = v3;
          angle = x;
          concentration = y;
        } else if (x instanceof Vector && y instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
        } else if (v1 instanceof Color && v2 instanceof Vector) {
          color2 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
        }
        break;
      case 4:
        color2 = v1;
        position = v2;
        direction = v3;
        angle = x;
        break;
      case 3:
        color2 = v1;
        position = v2;
        direction = v3;
        break;
      default:
        console.warn(
          `Sorry, input for spotlight() is not in prescribed format. Too ${length < 3 ? "few" : "many"} arguments were provided`
        );
        return;
    }
    this.states.setValue("spotLightDiffuseColors", [
      ...this.states.spotLightDiffuseColors,
      color2._array[0],
      color2._array[1],
      color2._array[2]
    ]);
    this.states.setValue("spotLightSpecularColors", [
      ...this.states.spotLightSpecularColors,
      ...this.states.specularColors
    ]);
    this.states.setValue("spotLightPositions", [
      ...this.states.spotLightPositions,
      position.x,
      position.y,
      position.z
    ]);
    direction.normalize();
    this.states.setValue("spotLightDirections", [
      ...this.states.spotLightDirections,
      direction.x,
      direction.y,
      direction.z
    ]);
    if (angle === void 0) {
      angle = Math.PI / 3;
    }
    if (concentration !== void 0 && concentration < 1) {
      concentration = 1;
      console.warn(
        "Value of concentration needs to be greater than 1. Setting it to 1"
      );
    } else if (concentration === void 0) {
      concentration = 100;
    }
    angle = this._pInst._toRadians(angle);
    this.states.setValue("spotLightAngle", [...this.states.spotLightAngle, Math.cos(angle)]);
    this.states.setValue("spotLightConc", [...this.states.spotLightConc, concentration]);
    this.states.setValue("enableLighting", true);
  };
  Renderer3D.prototype.noLights = function() {
    this.states.setValue("activeImageLight", null);
    this.states.setValue("enableLighting", false);
    this.states.setValue("ambientLightColors", []);
    this.states.setValue("specularColors", [1, 1, 1]);
    this.states.setValue("directionalLightDirections", []);
    this.states.setValue("directionalLightDiffuseColors", []);
    this.states.setValue("directionalLightSpecularColors", []);
    this.states.setValue("pointLightPositions", []);
    this.states.setValue("pointLightDiffuseColors", []);
    this.states.setValue("pointLightSpecularColors", []);
    this.states.setValue("spotLightPositions", []);
    this.states.setValue("spotLightDirections", []);
    this.states.setValue("spotLightDiffuseColors", []);
    this.states.setValue("spotLightSpecularColors", []);
    this.states.setValue("spotLightAngle", []);
    this.states.setValue("spotLightConc", []);
    this.states.setValue("constantAttenuation", 1);
    this.states.setValue("linearAttenuation", 0);
    this.states.setValue("quadraticAttenuation", 0);
    this.states.setValue("_useShininess", 1);
    this.states.setValue("_useMetalness", 0);
  };
}
if (typeof p5 !== "undefined") {
  light(p5, p5.prototype);
}
function material(p53, fn2) {
  fn2.loadShader = async function(vertFilename, fragFilename, successCallback, failureCallback) {
    const loadedShader = new Shader();
    try {
      loadedShader._vertSrc = (await request(vertFilename, "text")).data;
      loadedShader._fragSrc = (await request(fragFilename, "text")).data;
      if (successCallback) {
        return successCallback(loadedShader);
      } else {
        return loadedShader;
      }
    } catch (err) {
      if (failureCallback) {
        return failureCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.createShader = function(vertSrc, fragSrc, options2) {
    return new Shader(this._renderer, vertSrc, fragSrc, options2);
  };
  fn2.loadFilterShader = async function(fragFilename, successCallback, failureCallback) {
    try {
      const fragSrc = await this.loadStrings(fragFilename);
      const fragString = await fragSrc.join("\n");
      const loadedShader = this.createFilterShader(fragString, true);
      if (successCallback) {
        successCallback(loadedShader);
      }
      return loadedShader;
    } catch (err) {
      if (failureCallback) {
        failureCallback(err);
      } else {
        console.error(err);
      }
    }
  };
  fn2.createFilterShader = function(fragSrc, skipContextCheck = false) {
    let defaultVertV1 = `
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      attribute vec3 aPosition;
      // texcoords only come from p5 to vertex shader
      // so pass texcoords on to the fragment shader in a varying variable
      attribute vec2 aTexCoord;
      varying vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;
    let defaultVertV2 = `#version 300 es
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      in vec3 aPosition;
      in vec2 aTexCoord;
      out vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;
    let vertSrc = fragSrc.includes("#version 300 es") ? defaultVertV2 : defaultVertV1;
    const shader2 = new Shader(this._renderer, vertSrc, fragSrc);
    if (!skipContextCheck) {
      if (this._renderer.GL) {
        shader2.ensureCompiledOnContext(this._renderer);
      } else {
        shader2.ensureCompiledOnContext(this);
      }
    }
    return shader2;
  };
  fn2.shader = function(s) {
    this._assert3d("shader");
    this._renderer.shader(s);
    return this;
  };
  fn2.strokeShader = function(s) {
    this._assert3d("strokeShader");
    this._renderer.strokeShader(s);
    return this;
  };
  fn2.imageShader = function(s) {
    this._assert3d("imageShader");
    this._renderer.imageShader(s);
    return this;
  };
  fn2.baseMaterialShader = function() {
    this._assert3d("baseMaterialShader");
    return this._renderer.baseMaterialShader();
  };
  fn2.baseFilterShader = function() {
    return (this._renderer.filterRenderer || this._renderer).baseFilterShader();
  };
  fn2.baseNormalShader = function() {
    this._assert3d("baseNormalShader");
    return this._renderer.baseNormalShader();
  };
  fn2.baseColorShader = function() {
    this._assert3d("baseColorShader");
    return this._renderer.baseColorShader();
  };
  fn2.baseStrokeShader = function() {
    this._assert3d("baseStrokeShader");
    return this._renderer.baseStrokeShader();
  };
  fn2.resetShader = function() {
    this._renderer.resetShader();
    return this;
  };
  fn2.texture = function(tex) {
    this._assert3d("texture");
    if (tex.gifProperties) {
      tex._animateGif(this);
    }
    this._renderer.texture(tex);
    return this;
  };
  fn2.textureMode = function(mode) {
    if (mode !== IMAGE && mode !== NORMAL) {
      console.warn(
        `You tried to set ${mode} textureMode only supports IMAGE & NORMAL `
      );
    } else {
      this._renderer.states.setValue("textureMode", mode);
    }
  };
  fn2.textureWrap = function(wrapX, wrapY = wrapX) {
    this._renderer.states.setValue("textureWrapX", wrapX);
    this._renderer.states.setValue("textureWrapY", wrapY);
    for (const texture2 of this._renderer.textures.values()) {
      texture2.setWrapMode(wrapX, wrapY);
    }
  };
  fn2.normalMaterial = function(...args) {
    this._assert3d("normalMaterial");
    this._renderer.normalMaterial(...args);
    return this;
  };
  fn2.ambientMaterial = function(v1, v2, v3) {
    this._assert3d("ambientMaterial");
    const color2 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("_hasSetAmbient", true);
    this._renderer.states.setValue("curAmbientColor", color2._array);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    if (!this._renderer.states.fillColor) {
      this._renderer.states.setValue("fillColor", new Color([1, 1, 1]));
    }
    return this;
  };
  fn2.emissiveMaterial = function(v1, v2, v3, a) {
    this._assert3d("emissiveMaterial");
    const color2 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("curEmissiveColor", color2._array);
    this._renderer.states.setValue("_useEmissiveMaterial", true);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    return this;
  };
  fn2.specularMaterial = function(v1, v2, v3, alpha) {
    this._assert3d("specularMaterial");
    const color2 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("curSpecularColor", color2._array);
    this._renderer.states.setValue("_useSpecularMaterial", true);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    return this;
  };
  fn2.shininess = function(shine) {
    this._assert3d("shininess");
    this._renderer.shininess(shine);
    return this;
  };
  fn2.metalness = function(metallic) {
    this._assert3d("metalness");
    this._renderer.metalness(metallic);
    return this;
  };
  Renderer3D.prototype.shader = function(s) {
    this.states.setValue("userFillShader", s);
    this.states.setValue("_useNormalMaterial", false);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  Renderer3D.prototype.strokeShader = function(s) {
    this.states.setValue("userStrokeShader", s);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  Renderer3D.prototype.imageShader = function(s) {
    this.states.setValue("userImageShader", s);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  Renderer3D.prototype.resetShader = function() {
    this.states.setValue("userFillShader", null);
    this.states.setValue("userStrokeShader", null);
    this.states.setValue("userImageShader", null);
  };
  Renderer3D.prototype.texture = function(tex) {
    this.states.setValue("drawMode", TEXTURE);
    this.states.setValue("_useNormalMaterial", false);
    this.states.setValue("_tex", tex);
    this.states.setValue("fillColor", new Color([1, 1, 1]));
  };
  Renderer3D.prototype.normalMaterial = function(...args) {
    this.states.setValue("drawMode", FILL);
    this.states.setValue("_useSpecularMaterial", false);
    this.states.setValue("_useEmissiveMaterial", false);
    this.states.setValue("_useNormalMaterial", true);
    this.states.setValue("curFillColor", [1, 1, 1, 1]);
    this.states.setValue("fillColor", new Color([1, 1, 1]));
    this.states.setValue("strokeColor", null);
  };
  Renderer3D.prototype.shininess = function(shine) {
    if (shine < 1) {
      shine = 1;
    }
    this.states.setValue("_useShininess", shine);
  };
  Renderer3D.prototype.metalness = function(metallic) {
    const metalMix = 1 - Math.exp(-metallic / 100);
    this.states.setValue("_useMetalness", metalMix);
  };
}
if (typeof p5 !== "undefined") {
  loading(p5, p5.prototype);
}
class Graphics {
  constructor(w, h, renderer2, pInst, canvas2) {
    const r = renderer2 || P2D;
    this._pInst = pInst;
    this._renderer = new renderers[r](this, w, h, false, canvas2);
    this._initializeInstanceVariables(this);
    this._renderer._applyDefaults();
    return this;
  }
  // This is to correctly extend the p5.Element interface
  get elt() {
    return this.canvas;
  }
  get deltaTime() {
    return this._pInst.deltaTime;
  }
  get canvas() {
    return this._renderer?.canvas;
  }
  get drawingContext() {
    return this._renderer.drawingContext;
  }
  get width() {
    return this._renderer?.width;
  }
  get height() {
    return this._renderer?.height;
  }
  get pixels() {
    return this._renderer?.pixels;
  }
  pixelDensity(val) {
    let returnValue;
    if (typeof val === "number") {
      if (val !== this._renderer._pixelDensity) {
        this._renderer._pixelDensity = val;
      }
      returnValue = this;
      this.resizeCanvas(this.width, this.height, true);
    } else {
      returnValue = this._renderer._pixelDensity;
    }
    return returnValue;
  }
  resizeCanvas(w, h) {
    this._renderer.resize(w, h);
  }
  /**
   * Resets the graphics buffer's transformations and lighting.
   *
   * By default, the main canvas resets certain transformation and lighting
   * values each time <a href="#/p5/draw">draw()</a> executes. `p5.Graphics`
   * objects must reset these values manually by calling `myGraphics.reset()`.
   *
   *
   * @example
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object.
   *   pg = createGraphics(60, 60);
   *
   *   describe('A white circle moves downward slowly within a dark square. The circle resets at the top of the dark square when the user presses the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the p5.Graphics object's coordinate system.
   *   // The translation accumulates; the white circle moves.
   *   pg.translate(0, 0.1);
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(100);
   *   pg.circle(30, 0, 10);
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 20, 20);
   *
   *   // Translate the main canvas' coordinate system.
   *   // The translation doesn't accumulate; the dark
   *   // square is always in the same place.
   *   translate(0, 0.1);
   *
   *   // Reset the p5.Graphics object when the
   *   // user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     pg.reset();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object.
   *   pg = createGraphics(60, 60);
   *
   *   describe('A white circle at the center of a dark gray square. The image is drawn on a light gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the p5.Graphics object's coordinate system.
   *   pg.translate(30, 30);
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(100);
   *   pg.circle(0, 0, 10);
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 20, 20);
   *
   *   // Reset the p5.Graphics object automatically.
   *   pg.reset();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object using WebGL mode.
   *   pg = createGraphics(100, 100, WEBGL);
   *
   *   describe("A sphere lit from above with a red light. The sphere's surface becomes glossy while the user clicks and holds the mouse.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Add a red point light from the top-right.
   *   pg.pointLight(255, 0, 0, 50, -100, 50);
   *
   *   // Style the sphere.
   *   // It should appear glossy when the
   *   // lighting values are reset.
   *   pg.noStroke();
   *   pg.specularMaterial(255);
   *   pg.shininess(100);
   *
   *   // Draw the sphere.
   *   pg.sphere(30);
   *
   *   // Display the p5.Graphics object.
   *   image(pg, -50, -50);
   *
   *   // Reset the p5.Graphics object when
   *   // the user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     pg.reset();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object using WebGL mode.
   *   pg = createGraphics(100, 100, WEBGL);
   *
   *   describe('A sphere with a glossy surface is lit from the top-right by a red light.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Add a red point light from the top-right.
   *   pg.pointLight(255, 0, 0, 50, -100, 50);
   *
   *   // Style the sphere.
   *   pg.noStroke();
   *   pg.specularMaterial(255);
   *   pg.shininess(100);
   *
   *   // Draw the sphere.
   *   pg.sphere(30);
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 0, 0);
   *
   *   // Reset the p5.Graphics object automatically.
   *   pg.reset();
   * }
   * </code>
   * </div>
   */
  reset() {
    this._renderer.resetMatrix();
    if (this._renderer.isP3D) {
      this._renderer._update();
    }
  }
  /**
   * Removes the graphics buffer from the web page.
   *
   * Calling `myGraphics.remove()` removes the graphics buffer's
   * `&lt;canvas&gt;` element from the web page. The graphics buffer also uses
   * a bit of memory on the CPU that can be freed like so:
   *
   * ```js
   * // Remove the graphics buffer from the web page.
   * myGraphics.remove();
   *
   * // Delete the graphics buffer from CPU memory.
   * myGraphics = undefined;
   * ```
   *
   * Note: All variables that reference the graphics buffer must be assigned
   * the value `undefined` to delete the graphics buffer from CPU memory. If any
   * variable still refers to the graphics buffer, then it won't be garbage
   * collected.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to remove the p5.Graphics object.
   *
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object.
   *   pg = createGraphics(60, 60);
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(100);
   *   pg.circle(30, 30, 20);
   *
   *   describe('A white circle at the center of a dark gray square disappears when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Display the p5.Graphics object if
   *   // it's available.
   *   if (pg) {
   *     image(pg, 20, 20);
   *   }
   * }
   *
   * // Remove the p5.Graphics object when the
   * // the user double-clicks.
   * function doubleClicked() {
   *   // Remove the p5.Graphics object from the web page.
   *   pg.remove();
   *   pg = undefined;
   * }
   * </code>
   * </div>
   */
  remove() {
    this._renderer.remove();
    this._renderer = void 0;
  }
  /**
   * Creates a new <a href="#/p5.Framebuffer">p5.Framebuffer</a> object with
   * the same WebGL context as the graphics buffer.
   *
   * <a href="#/p5.Framebuffer">p5.Framebuffer</a> objects are separate drawing
   * surfaces that can be used as textures in WebGL mode. They're similar to
   * <a href="#/p5.Graphics">p5.Graphics</a> objects and generally run much
   * faster when used as textures. Creating a
   * <a href="#/p5.Framebuffer">p5.Framebuffer</a> object in the same context
   * as the graphics buffer makes this speedup possible.
   *
   * The parameter, `options`, is optional. An object can be passed to configure
   * the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. The available
   * properties are:
   *
   * - `format`: data format of the texture, either `UNSIGNED_BYTE`, `FLOAT`, or `HALF_FLOAT`. Default is `UNSIGNED_BYTE`.
   * - `channels`: whether to store `RGB` or `RGBA` color channels. Default is to match the graphics buffer which is `RGBA`.
   * - `depth`: whether to include a depth buffer. Default is `true`.
   * - `depthFormat`: data format of depth information, either `UNSIGNED_INT` or `FLOAT`. Default is `FLOAT`.
   * - `stencil`: whether to include a stencil buffer for masking. `depth` must be `true` for this feature to work. Defaults to the value of `depth` which is `true`.
   * - `antialias`: whether to perform anti-aliasing. If set to `true`, as in `{ antialias: true }`, 2 samples will be used by default. The number of samples can also be set, as in `{ antialias: 4 }`. Default is to match <a href="#/p5/setAttributes">setAttributes()</a> which is `false` (`true` in Safari).
   * - `width`: width of the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. Default is to always match the graphics buffer width.
   * - `height`: height of the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. Default is to always match the graphics buffer height.
   * - `density`: pixel density of the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. Default is to always match the graphics buffer pixel density.
   * - `textureFiltering`: how to read values from the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. Either `LINEAR` (nearby pixels will be interpolated) or `NEAREST` (no interpolation). Generally, use `LINEAR` when using the texture as an image and `NEAREST` if reading the texture as data. Default is `LINEAR`.
   *
   * If the `width`, `height`, or `density` attributes are set, they won't
   * automatically match the graphics buffer and must be changed manually.
   *
   * @param {Object} [options] configuration options.
   * @param {UNSIGNED_BYTE|FLOAT|HALF_FLOAT} [options.format=UNSIGNED_BYTE] The data format of the texture.
   * @param {RGB|RGBA} [options.channels=RGBA] What color channels to include in the texture.
   * @param {Boolean} [options.depth=true] Whether to store depth information in the framebuffer.
   * @param {UNSIGNED_INT|FLOAT} [options.depthFormat=FLOAT] The format to store depth values in.
   * @param {Boolean} [options.stencil=true] Whether to include a stencil buffer (required for clipping.)
   * @param {Boolean|Number} [options.antialias] Whether to antialias when drawing to this framebuffer. Either a boolean, or the number of antialias samples to use.
   * @param {Number} [options.width] The width of the framebuffer. By default, it will match the main canvas.
   * @param {Number} [options.height] The height of the framebuffer. By default, it will match the main canvas.
   * @param {Number} [options.density] The pixel density of the framebuffer. By default, it will match the main canvas.
   * @param {LINEAR|NEAREST} [options.textureFiltering=LINEAR] The strategy used when reading values in the framebuffer in between pixels.
   * @return {p5.Framebuffer} new framebuffer.
   *
   * @example
   * <div>
   * <code>
   * // Click and hold a mouse button to change shapes.
   *
   * let pg;
   * let torusLayer;
   * let boxLayer;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object using WebGL mode.
   *   pg = createGraphics(100, 100, WEBGL);
   *
   *   // Create the p5.Framebuffer objects.
   *   torusLayer = pg.createFramebuffer();
   *   boxLayer = pg.createFramebuffer();
   *
   *   describe('A grid of white toruses rotating against a dark gray background. The shapes become boxes while the user holds a mouse button.');
   * }
   *
   * function draw() {
   *   // Update and draw the layers offscreen.
   *   drawTorus();
   *   drawBox();
   *
   *   // Choose the layer to display.
   *   let layer;
   *   if (mouseIsPressed === true) {
   *     layer = boxLayer;
   *   } else {
   *     layer = torusLayer;
   *   }
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(50);
   *
   *   // Iterate from left to right.
   *   for (let x = -50; x < 50; x += 25) {
   *     // Iterate from top to bottom.
   *     for (let y = -50; y < 50; y += 25) {
   *       // Draw the layer to the p5.Graphics object
   *       pg.image(layer, x, y, 25, 25);
   *     }
   *   }
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 0, 0);
   * }
   *
   * // Update and draw the torus layer offscreen.
   * function drawTorus() {
   *   // Start drawing to the torus p5.Framebuffer.
   *   torusLayer.begin();
   *
   *   // Clear the drawing surface.
   *   pg.clear();
   *
   *   // Turn on the lights.
   *   pg.lights();
   *
   *   // Rotate the coordinate system.
   *   pg.rotateX(frameCount * 0.01);
   *   pg.rotateY(frameCount * 0.01);
   *
   *   // Style the torus.
   *   pg.noStroke();
   *
   *   // Draw the torus.
   *   pg.torus(20);
   *
   *   // Start drawing to the torus p5.Framebuffer.
   *   torusLayer.end();
   * }
   *
   * // Update and draw the box layer offscreen.
   * function drawBox() {
   *   // Start drawing to the box p5.Framebuffer.
   *   boxLayer.begin();
   *
   *   // Clear the drawing surface.
   *   pg.clear();
   *
   *   // Turn on the lights.
   *   pg.lights();
   *
   *   // Rotate the coordinate system.
   *   pg.rotateX(frameCount * 0.01);
   *   pg.rotateY(frameCount * 0.01);
   *
   *   // Style the box.
   *   pg.noStroke();
   *
   *   // Draw the box.
   *   pg.box(30);
   *
   *   // Start drawing to the box p5.Framebuffer.
   *   boxLayer.end();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and hold a mouse button to change shapes.
   *
   * let pg;
   * let torusLayer;
   * let boxLayer;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create an options object.
   *   let options = { width: 25, height: 25 };
   *
   *   // Create a p5.Graphics object using WebGL mode.
   *   pg = createGraphics(100, 100, WEBGL);
   *
   *   // Create the p5.Framebuffer objects.
   *   // Use options for configuration.
   *   torusLayer = pg.createFramebuffer(options);
   *   boxLayer = pg.createFramebuffer(options);
   *
   *   describe('A grid of white toruses rotating against a dark gray background. The shapes become boxes while the user holds a mouse button.');
   * }
   *
   * function draw() {
   *   // Update and draw the layers offscreen.
   *   drawTorus();
   *   drawBox();
   *
   *   // Choose the layer to display.
   *   let layer;
   *   if (mouseIsPressed === true) {
   *     layer = boxLayer;
   *   } else {
   *     layer = torusLayer;
   *   }
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(50);
   *
   *   // Iterate from left to right.
   *   for (let x = -50; x < 50; x += 25) {
   *     // Iterate from top to bottom.
   *     for (let y = -50; y < 50; y += 25) {
   *       // Draw the layer to the p5.Graphics object
   *       pg.image(layer, x, y);
   *     }
   *   }
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 0, 0);
   * }
   *
   * // Update and draw the torus layer offscreen.
   * function drawTorus() {
   *   // Start drawing to the torus p5.Framebuffer.
   *   torusLayer.begin();
   *
   *   // Clear the drawing surface.
   *   pg.clear();
   *
   *   // Turn on the lights.
   *   pg.lights();
   *
   *   // Rotate the coordinate system.
   *   pg.rotateX(frameCount * 0.01);
   *   pg.rotateY(frameCount * 0.01);
   *
   *   // Style the torus.
   *   pg.noStroke();
   *
   *   // Draw the torus.
   *   pg.torus(5, 2.5);
   *
   *   // Start drawing to the torus p5.Framebuffer.
   *   torusLayer.end();
   * }
   *
   * // Update and draw the box layer offscreen.
   * function drawBox() {
   *   // Start drawing to the box p5.Framebuffer.
   *   boxLayer.begin();
   *
   *   // Clear the drawing surface.
   *   pg.clear();
   *
   *   // Turn on the lights.
   *   pg.lights();
   *
   *   // Rotate the coordinate system.
   *   pg.rotateX(frameCount * 0.01);
   *   pg.rotateY(frameCount * 0.01);
   *
   *   // Style the box.
   *   pg.noStroke();
   *
   *   // Draw the box.
   *   pg.box(7.5);
   *
   *   // Start drawing to the box p5.Framebuffer.
   *   boxLayer.end();
   * }
   * </code>
   * </div>
   */
  createFramebuffer(options2) {
    return new Framebuffer$1(this._renderer, options2);
  }
  _assert3d(name) {
    if (!this._renderer.isP3D)
      throw new Error(
        `${name}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`
      );
  }
  _initializeInstanceVariables() {
    this._accessibleOutputs = {
      text: false,
      grid: false,
      textLabel: false,
      gridLabel: false
    };
    this._styles = [];
    this._downKeys = {};
  }
}
function graphics(p53, fn2) {
  p53.Graphics = Graphics;
  primitives(p53, p53.Graphics.prototype);
  attributes(p53, p53.Graphics.prototype);
  curves(p53, p53.Graphics.prototype);
  vertex(p53, p53.Graphics.prototype);
  customShapes(p53, p53.Graphics.prototype);
  setting(p53, p53.Graphics.prototype);
  loadingDisplaying(p53, p53.Graphics.prototype);
  image$1(p53, p53.Graphics.prototype);
  pixels(p53, p53.Graphics.prototype);
  transform$1(p53, p53.Graphics.prototype);
  primitives3D(p53, p53.Graphics.prototype);
  light(p53, p53.Graphics.prototype);
  material(p53, p53.Graphics.prototype);
  creatingReading(p53, p53.Graphics.prototype);
  trigonometry(p53, p53.Graphics.prototype);
}
class Texture {
  constructor(renderer2, obj, settings = {}) {
    this._renderer = renderer2;
    this.src = obj;
    this.format = settings.format || "rgba8unorm";
    this.minFilter = settings.minFilter || LINEAR;
    this.magFilter = settings.magFilter || LINEAR;
    this.wrapS = settings.wrapS || renderer2.states.textureWrapX;
    this.wrapT = settings.wrapT || renderer2.states.textureWrapY;
    this.dataType = settings.dataType || "uint8";
    this.textureHandle = null;
    this._detectSourceType();
    const textureData = this._getTextureDataFromSource();
    this.width = textureData.width;
    this.height = textureData.height;
    this.init(textureData);
  }
  /*
    const support = checkWebGLCapabilities(renderer);
    if (this.glFormat === gl.HALF_FLOAT && !support.halfFloat) {
      console.log('This device does not support dataType HALF_FLOAT. Falling back to FLOAT.');
      this.glDataType = gl.FLOAT;
    }
    if (
      this.glFormat === gl.HALF_FLOAT &&
      (this.glMinFilter === gl.LINEAR || this.glMagFilter === gl.LINEAR) &&
      !support.halfFloatLinear
    ) {
      console.log('This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.');
      if (this.glMinFilter === gl.LINEAR) this.glMinFilter = gl.NEAREST;
      if (this.glMagFilter === gl.LINEAR) this.glMagFilter = gl.NEAREST;
    }
    if (this.glFormat === gl.FLOAT && !support.float) {
      console.log('This device does not support dataType FLOAT. Falling back to UNSIGNED_BYTE.');
      this.glDataType = gl.UNSIGNED_BYTE;
    }
    if (
      this.glFormat === gl.FLOAT &&
      (this.glMinFilter === gl.LINEAR || this.glMagFilter === gl.LINEAR) &&
      !support.floatLinear
    ) {
      console.log('This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.');
      if (this.glMinFilter === gl.LINEAR) this.glMinFilter = gl.NEAREST;
      if (this.glMagFilter === gl.LINEAR) this.glMagFilter = gl.NEAREST;
    }
  }*/
  _detectSourceType() {
    const obj = this.src;
    this.isFramebufferTexture = obj instanceof FramebufferTexture;
    this.isSrcP5Image = obj instanceof Image;
    this.isSrcP5Graphics = obj instanceof Graphics;
    this.isSrcP5Renderer = obj instanceof Renderer;
    this.isImageData = typeof ImageData !== "undefined" && obj instanceof ImageData;
    this.isSrcMediaElement = typeof MediaElement !== "undefined" && obj instanceof MediaElement;
    this.isSrcHTMLElement = typeof Element !== "undefined" && obj instanceof Element && !this.isSrcMediaElement && !this.isSrcP5Graphics && !this.isSrcP5Renderer;
  }
  remove() {
    if (this.textureHandle) {
      this._renderer.deleteTexture(this.textureHandle);
      this.textureHandle = null;
    }
  }
  _getTextureDataFromSource() {
    let textureData;
    if (this.isFramebufferTexture) {
      textureData = this.src.rawTexture();
    } else if (this.isSrcP5Image) {
      textureData = this.src.canvas;
    } else if (this.isSrcMediaElement || this.isSrcHTMLElement) {
      if (this.src._ensureCanvas) {
        this.src._ensureCanvas();
      }
      textureData = this.src.elt;
    } else if (this.isSrcP5Graphics || this.isSrcP5Renderer) {
      textureData = this.src.canvas;
    } else if (this.isImageData) {
      textureData = this.src;
    }
    return textureData;
  }
  /**
   * Initializes common texture parameters, creates a gl texture,
   * tries to upload the texture for the first time if data is
   * already available.
   */
  init(textureData) {
    if (!this.isFramebufferTexture) {
      this.textureHandle = this._renderer.createTexture({
        format: this.format,
        dataType: this.dataType,
        width: textureData.width,
        height: textureData.height
      });
    } else {
      this.textureHandle = this._renderer.createFramebufferTextureHandle(this.src);
    }
    this._renderer.setTextureParams(this, {
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      wrapS: this.wrapS,
      wrapT: this.wrapT
    });
    this.bindTexture();
    if (this._shouldDeferUpload()) {
      this._renderer.uploadTextureFromData(
        this.textureHandle,
        new Uint8Array(1, 1, 1, 1),
        1,
        1
      );
    } else if (!this.isFramebufferTexture) {
      this._renderer.uploadTextureFromSource(
        this.textureHandle,
        textureData
      );
    }
    this.unbindTexture();
  }
  _shouldDeferUpload() {
    return this.width === 0 || this.height === 0 || this.isSrcMediaElement && !this.src.loadedmetadata;
  }
  /**
   * Checks if the source data for this texture has changed (if it's
   * easy to do so) and reuploads the texture if necessary. If it's not
   * possible or to expensive to do a calculation to determine wheter or
   * not the data has occurred, this method simply re-uploads the texture.
   */
  update() {
    const textureData = this._getTextureDataFromSource();
    if (!textureData) return false;
    let updated = false;
    if (this._shouldUpdate(textureData)) {
      this.bindTexture();
      this._renderer.uploadTextureFromSource(this.textureHandle, textureData);
      updated = true;
    }
    return updated;
  }
  _shouldUpdate(textureData) {
    const data2 = this.src;
    if (data2.width === 0 || data2.height === 0) {
      return false;
    }
    if (this.isFramebufferTexture) {
      this.src.update();
      return false;
    }
    let updated = false;
    if (textureData.width !== this.width || textureData.height !== this.height) {
      updated = true;
      this.width = textureData.width || data2.width;
      this.height = textureData.height || data2.height;
      if (this.isSrcP5Image) {
        data2.setModified(false);
      } else if (this.isSrcMediaElement || this.isSrcHTMLElement) {
        data2.setModified && data2.setModified(true);
      }
    } else if (this.isSrcP5Image) {
      if (data2.isModified()) {
        updated = true;
        data2.setModified(false);
      }
    } else if (this.isSrcMediaElement) {
      if (data2.isModified()) {
        updated = true;
        data2.setModified(false);
      } else if (data2.loadedmetadata) {
        if (this._videoPrevUpdateTime !== data2.time()) {
          this._videoPrevUpdateTime = data2.time();
          updated = true;
        }
      }
    } else if (this.isImageData) {
      if (data2._dirty) {
        data2._dirty = false;
        updated = true;
      }
    } else {
      updated = true;
    }
    return updated;
  }
  bindTexture() {
    this._renderer.bindTexture(this);
    return this;
  }
  unbindTexture() {
    this._renderer.unbindTexture();
  }
  getTexture() {
    if (this.isFramebufferTexture) {
      return this.src.rawTexture();
    } else {
      return this.textureHandle;
    }
  }
  getSampler() {
    return this._renderer.getSampler(this);
  }
  setInterpolation(minFilter, magFilter) {
    this.minFilter = minFilter;
    this.magFilter = magFilter;
    this._renderer.setTextureParams(this);
  }
  setWrapMode(wrapX, wrapY) {
    this.wrapS = wrapX;
    this.wrapT = wrapY;
    this._renderer.setTextureParams(this);
  }
}
class MipmapTexture extends Texture {
  constructor(renderer2, levels, settings = {}) {
    const mipmapSettings = {
      minFilter: LINEAR,
      magFilter: LINEAR,
      ...settings
    };
    super(renderer2, levels, mipmapSettings);
    this.levels = levels;
  }
  _getTextureDataFromSource() {
    return this.src;
  }
  init(levels) {
    if (Array.isArray(levels)) {
      const firstLevel = levels[0];
      this.width = firstLevel.width;
      this.height = firstLevel.height;
      this.textureHandle = this._renderer.createMipmapTextureHandle({
        levels,
        format: this.format,
        dataType: this.dataType,
        width: this.width,
        height: this.height
      });
    } else {
      this.width = levels.size;
      this.height = levels.size;
      this.textureHandle = this._renderer.createMipmapTextureHandle({
        gpuTexture: levels.gpuTexture,
        format: levels.format,
        dataType: "uint8",
        width: this.width,
        height: this.height
      });
    }
    this._renderer.setTextureParams(this, {
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      wrapS: this.wrapS,
      wrapT: this.wrapT
    });
  }
  update() {
  }
}
function texture(p53, fn2) {
  p53.Texture = Texture;
  p53.MipmapTexture = MipmapTexture;
}
if (typeof p5 !== "undefined") {
  texture(p5, p5.prototype);
}
function readPixelsWebGL(pixels2, gl, framebuffer2, x, y, width, height, format, type2, flipY) {
  const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer2);
  const channels = format === gl.RGBA ? 4 : 3;
  const len = width * height * channels;
  const TypedArrayClass = type2 === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
  if (!(pixels2 instanceof TypedArrayClass) || pixels2.length !== len) {
    pixels2 = new TypedArrayClass(len);
  }
  gl.readPixels(
    x,
    flipY ? flipY - y - height : y,
    width,
    height,
    format,
    type2,
    pixels2
  );
  gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
  if (flipY) {
    const halfHeight = Math.floor(height / 2);
    const tmpRow = new TypedArrayClass(width * channels);
    for (let y2 = 0; y2 < halfHeight; y2++) {
      const topOffset = y2 * width * 4;
      const bottomOffset = (height - y2 - 1) * width * 4;
      tmpRow.set(pixels2.subarray(topOffset, topOffset + width * 4));
      pixels2.copyWithin(topOffset, bottomOffset, bottomOffset + width * 4);
      pixels2.set(tmpRow, bottomOffset);
    }
  }
  return pixels2;
}
function readPixelWebGL(gl, framebuffer2, x, y, format, type2, flipY) {
  const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer2);
  const channels = format === gl.RGBA ? 4 : 3;
  const TypedArrayClass = type2 === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
  const pixels2 = new TypedArrayClass(channels);
  gl.readPixels(x, flipY ? flipY - y - 1 : y, 1, 1, format, type2, pixels2);
  gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
  return Array.from(pixels2);
}
function setWebGLTextureParams(texture2, gl, webglVersion) {
  texture2.bindTexture();
  const glMinFilter = texture2.minFilter === NEAREST ? gl.NEAREST : texture2.minFilter === LINEAR_MIPMAP ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR;
  const glMagFilter = texture2.magFilter === NEAREST ? gl.NEAREST : gl.LINEAR;
  const isPowerOfTwo = (x) => (x & x - 1) === 0;
  const textureData = texture2._getTextureDataFromSource();
  let wrapWidth;
  let wrapHeight;
  if (textureData.naturalWidth && textureData.naturalHeight) {
    wrapWidth = textureData.naturalWidth;
    wrapHeight = textureData.naturalHeight;
  } else {
    wrapWidth = texture2.width;
    wrapHeight = texture2.height;
  }
  const widthPowerOfTwo = isPowerOfTwo(wrapWidth);
  const heightPowerOfTwo = isPowerOfTwo(wrapHeight);
  let glWrapS, glWrapT;
  if (texture2.wrapS === REPEAT) {
    if (webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
      glWrapS = gl.REPEAT;
    } else {
      console.warn(
        "You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"
      );
      glWrapS = gl.CLAMP_TO_EDGE;
    }
  } else if (texture2.wrapS === MIRROR) {
    if (webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
      glWrapS = gl.MIRRORED_REPEAT;
    } else {
      console.warn(
        "You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"
      );
      glWrapS = gl.CLAMP_TO_EDGE;
    }
  } else {
    glWrapS = gl.CLAMP_TO_EDGE;
  }
  if (texture2.wrapT === REPEAT) {
    if (webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
      glWrapT = gl.REPEAT;
    } else {
      console.warn(
        "You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"
      );
      glWrapT = gl.CLAMP_TO_EDGE;
    }
  } else if (texture2.wrapT === MIRROR) {
    if (webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
      glWrapT = gl.MIRRORED_REPEAT;
    } else {
      console.warn(
        "You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"
      );
      glWrapT = gl.CLAMP_TO_EDGE;
    }
  } else {
    glWrapT = gl.CLAMP_TO_EDGE;
  }
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glMinFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glMagFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, glWrapS);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, glWrapT);
  texture2.unbindTexture();
}
function setWebGLUniformValue(shader2, uniform, data2, getTexture, gl) {
  const location2 = uniform.location;
  shader2.useProgram();
  switch (uniform.type) {
    case gl.BOOL:
      if (data2 === true) {
        gl.uniform1i(location2, 1);
      } else {
        gl.uniform1i(location2, 0);
      }
      break;
    case gl.INT:
      if (uniform.size > 1) {
        data2.length && gl.uniform1iv(location2, data2);
      } else {
        gl.uniform1i(location2, data2);
      }
      break;
    case gl.FLOAT:
      if (uniform.size > 1) {
        data2.length && gl.uniform1fv(location2, data2);
      } else {
        gl.uniform1f(location2, data2);
      }
      break;
    case gl.FLOAT_MAT3:
      gl.uniformMatrix3fv(location2, false, data2);
      break;
    case gl.FLOAT_MAT4:
      gl.uniformMatrix4fv(location2, false, data2);
      break;
    case gl.FLOAT_VEC2:
      if (uniform.size > 1) {
        data2.length && gl.uniform2fv(location2, data2);
      } else {
        gl.uniform2f(location2, data2[0], data2[1]);
      }
      break;
    case gl.FLOAT_VEC3:
      if (uniform.size > 1) {
        data2.length && gl.uniform3fv(location2, data2);
      } else {
        gl.uniform3f(location2, data2[0], data2[1], data2[2]);
      }
      break;
    case gl.FLOAT_VEC4:
      if (uniform.size > 1) {
        data2.length && gl.uniform4fv(location2, data2);
      } else {
        gl.uniform4f(location2, data2[0], data2[1], data2[2], data2[3]);
      }
      break;
    case gl.INT_VEC2:
      if (uniform.size > 1) {
        data2.length && gl.uniform2iv(location2, data2);
      } else {
        gl.uniform2i(location2, data2[0], data2[1]);
      }
      break;
    case gl.INT_VEC3:
      if (uniform.size > 1) {
        data2.length && gl.uniform3iv(location2, data2);
      } else {
        gl.uniform3i(location2, data2[0], data2[1], data2[2]);
      }
      break;
    case gl.INT_VEC4:
      if (uniform.size > 1) {
        data2.length && gl.uniform4iv(location2, data2);
      } else {
        gl.uniform4i(location2, data2[0], data2[1], data2[2], data2[3]);
      }
      break;
    case gl.SAMPLER_2D:
      if (typeof data2 == "number") {
        if (data2 < gl.TEXTURE0 || data2 > gl.TEXTURE31 || data2 !== Math.ceil(data2)) {
          console.log(
            "🌸 p5.js says: You're trying to use a number as the data for a texture.Please use a texture."
          );
          return this;
        }
        gl.activeTexture(data2);
        gl.uniform1i(location2, data2);
      } else {
        gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
        uniform.texture = data2 instanceof Texture ? data2 : getTexture(data2);
        gl.uniform1i(location2, uniform.samplerIndex);
        if (uniform.texture.src.gifProperties) {
          uniform.texture.src._animateGif(this._pInst);
        }
      }
      break;
    case gl.SAMPLER_CUBE:
    case gl.SAMPLER_3D:
    case gl.SAMPLER_2D_SHADOW:
    case gl.SAMPLER_2D_ARRAY:
    case gl.SAMPLER_2D_ARRAY_SHADOW:
    case gl.SAMPLER_CUBE_SHADOW:
    case gl.INT_SAMPLER_2D:
    case gl.INT_SAMPLER_3D:
    case gl.INT_SAMPLER_CUBE:
    case gl.INT_SAMPLER_2D_ARRAY:
    case gl.UNSIGNED_INT_SAMPLER_2D:
    case gl.UNSIGNED_INT_SAMPLER_3D:
    case gl.UNSIGNED_INT_SAMPLER_CUBE:
    case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
      if (typeof data2 !== "number") {
        break;
      }
      if (data2 < gl.TEXTURE0 || data2 > gl.TEXTURE31 || data2 !== Math.ceil(data2)) {
        console.log(
          "🌸 p5.js says: You're trying to use a number as the data for a texture.Please use a texture."
        );
        break;
      }
      gl.activeTexture(data2);
      gl.uniform1i(location2, data2);
      break;
  }
}
function getWebGLUniformMetadata(shader2, gl) {
  const program = shader2._glProgram;
  const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  const result = [];
  let samplerIndex = 0;
  for (let i = 0; i < numUniforms; ++i) {
    const uniformInfo = gl.getActiveUniform(program, i);
    const uniform = {};
    uniform.location = gl.getUniformLocation(program, uniformInfo.name);
    uniform.size = uniformInfo.size;
    let uniformName = uniformInfo.name;
    if (uniformInfo.size > 1) {
      uniformName = uniformName.substring(0, uniformName.indexOf("[0]"));
    }
    uniform.name = uniformName;
    uniform.type = uniformInfo.type;
    uniform._cachedData = void 0;
    if (uniform.type === gl.SAMPLER_2D) {
      uniform.isSampler = true;
      uniform.samplerIndex = samplerIndex;
      samplerIndex++;
    }
    uniform.isArray = uniformInfo.size > 1 || uniform.type === gl.FLOAT_MAT3 || uniform.type === gl.FLOAT_MAT4 || uniform.type === gl.FLOAT_VEC2 || uniform.type === gl.FLOAT_VEC3 || uniform.type === gl.FLOAT_VEC4 || uniform.type === gl.INT_VEC2 || uniform.type === gl.INT_VEC4 || uniform.type === gl.INT_VEC3;
    result.push(uniform);
  }
  return result;
}
function getWebGLShaderAttributes(shader2, gl) {
  const attributes2 = {};
  const numAttributes = gl.getProgramParameter(
    shader2._glProgram,
    gl.ACTIVE_ATTRIBUTES
  );
  for (let i = 0; i < numAttributes; ++i) {
    const attributeInfo = gl.getActiveAttrib(shader2._glProgram, i);
    const name = attributeInfo.name;
    const location2 = gl.getAttribLocation(shader2._glProgram, name);
    const attribute = {};
    attribute.name = name;
    attribute.location = location2;
    attribute.index = i;
    attribute.type = attributeInfo.type;
    attribute.size = attributeInfo.size;
    attributes2[name] = attribute;
  }
  return attributes2;
}
function populateGLSLHooks(shader2, src, shaderType) {
  const main = "void main";
  if (!src.includes(main)) return src;
  let [preMain, postMain] = src.split(main);
  let hooks2 = "";
  let defines = "";
  for (const key in shader2.hooks.uniforms) {
    hooks2 += `uniform ${key};
`;
  }
  if (shader2.hooks.declarations) {
    hooks2 += shader2.hooks.declarations + "\n";
  }
  if (shader2.hooks[shaderType].declarations) {
    hooks2 += shader2.hooks[shaderType].declarations + "\n";
  }
  if (shader2.hooks.varyingVariables && shader2.hooks.varyingVariables.length > 0) {
    for (const varyingVar of shader2.hooks.varyingVariables) {
      if (shaderType === "vertex") {
        hooks2 += `OUT ${varyingVar};
`;
      } else if (shaderType === "fragment") {
        hooks2 += `IN ${varyingVar};
`;
      }
    }
  }
  for (const hookDef in shader2.hooks.helpers) {
    hooks2 += `${hookDef}${shader2.hooks.helpers[hookDef]}
`;
  }
  for (const hookDef in shader2.hooks[shaderType]) {
    if (hookDef === "declarations") continue;
    const [hookType, hookName] = hookDef.split(" ");
    if (shader2.hooks.modified.vertex[hookDef] || shader2.hooks.modified.fragment[hookDef]) {
      defines += "#define AUGMENTED_HOOK_" + hookName + "\n";
    }
    hooks2 += hookType + " HOOK_" + hookName + shader2.hooks[shaderType][hookDef] + "\n";
  }
  if (preMain.indexOf("#define HOOK_DEFINES") !== -1) {
    preMain = preMain.replace("#define HOOK_DEFINES", "\n" + defines + "\n");
    defines = "";
  }
  return preMain + "\n" + defines + hooks2 + main + postMain;
}
function checkWebGLCapabilities({ GL, webglVersion }) {
  const gl = GL;
  const supportsFloat = webglVersion === WEBGL2 ? gl.getExtension("EXT_color_buffer_float") && gl.getExtension("EXT_float_blend") : gl.getExtension("OES_texture_float");
  const supportsFloatLinear = supportsFloat && gl.getExtension("OES_texture_float_linear");
  const supportsHalfFloat = webglVersion === WEBGL2 ? gl.getExtension("EXT_color_buffer_float") : gl.getExtension("OES_texture_half_float");
  const supportsHalfFloatLinear = supportsHalfFloat && gl.getExtension("OES_texture_half_float_linear");
  return {
    float: supportsFloat,
    floatLinear: supportsFloatLinear,
    halfFloat: supportsHalfFloat,
    halfFloatLinear: supportsHalfFloatLinear
  };
}
const constrain = (n2, low, high) => Math.max(Math.min(n2, high), low);
class FramebufferCamera extends Camera {
  constructor(framebuffer2) {
    super(framebuffer2.renderer);
    this.fbo = framebuffer2;
    this.yScale = framebuffer2.renderer.framebufferYScale();
  }
  _computeCameraDefaultSettings() {
    super._computeCameraDefaultSettings();
    this.defaultAspectRatio = this.fbo.width / this.fbo.height;
    this.defaultCameraFOV = 2 * Math.atan(this.fbo.height / 2 / this.defaultEyeZ);
  }
  copy() {
    const _cam = super.copy();
    _cam.fbo = this.fbo;
    return _cam;
  }
}
class FramebufferTexture {
  constructor(framebuffer2, property) {
    this.framebuffer = framebuffer2;
    this.property = property;
  }
  get width() {
    return this.framebuffer.width * this.framebuffer.density;
  }
  get height() {
    return this.framebuffer.height * this.framebuffer.density;
  }
  update() {
    this.framebuffer._update(this.property);
  }
  rawTexture() {
    return { texture: this.framebuffer[this.property] };
  }
}
let Framebuffer$1 = class Framebuffer2 {
  constructor(renderer2, settings = {}) {
    this.renderer = renderer2;
    this.renderer.framebuffers.add(this);
    this._isClipApplied = false;
    this.dirty = { colorTexture: false, depthTexture: false };
    this.pixels = [];
    this.format = settings.format || UNSIGNED_BYTE;
    this.channels = settings.channels || (this.renderer.defaultFramebufferAlpha() ? RGBA : RGB);
    this.useDepth = settings.depth === void 0 ? true : settings.depth;
    this.depthFormat = settings.depthFormat || FLOAT;
    this.textureFiltering = settings.textureFiltering || LINEAR;
    if (settings.antialias === void 0) {
      this.antialiasSamples = this.renderer.defaultFramebufferAntialias() ? 2 : 0;
    } else if (typeof settings.antialias === "number") {
      this.antialiasSamples = settings.antialias;
    } else {
      this.antialiasSamples = settings.antialias ? 2 : 0;
    }
    this.antialias = this.antialiasSamples > 0;
    if (this.antialias && !this.renderer.supportsFramebufferAntialias()) {
      console.warn("Framebuffer antialiasing is unsupported in this context");
      this.antialias = false;
    }
    this.density = settings.density || this.renderer._pixelDensity;
    if (settings.width && settings.height) {
      const dimensions = this.renderer._adjustDimensions(settings.width, settings.height);
      this.width = dimensions.adjustedWidth;
      this.height = dimensions.adjustedHeight;
      this._autoSized = false;
    } else {
      if (settings.width === void 0 !== (settings.height === void 0)) {
        console.warn(
          "Please supply both width and height for a framebuffer to give it a size. Only one was given, so the framebuffer will match the size of its canvas."
        );
      }
      this.width = this.renderer.width;
      this.height = this.renderer.height;
      this._autoSized = true;
    }
    this.renderer.validateFramebufferFormats(this);
    if (settings.stencil && !this.useDepth) {
      console.warn("A stencil buffer can only be used if also using depth. Since the framebuffer has no depth buffer, the stencil buffer will be ignored.");
    }
    this.useStencil = this.useDepth && (settings.stencil === void 0 ? true : settings.stencil);
    this.renderer.createFramebufferResources(this);
    this._recreateTextures();
    this.defaultCamera = this.createCamera();
    this.filterCamera = this.createCamera();
    this.draw(() => this.renderer.clear());
  }
  /**
   * Resizes the framebuffer to a given width and height.
   *
   * The parameters, `width` and `height`, set the dimensions of the
   * framebuffer. For example, calling `myBuffer.resize(300, 500)` resizes
   * the framebuffer to 300×500 pixels, then sets `myBuffer.width` to 300
   * and `myBuffer.height` 500.
   *
   * @param {Number} width width of the framebuffer.
   * @param {Number} height height of the framebuffer.
   *
   * @example
   * <div>
   * <code>
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('A multicolor sphere on a white surface. The image grows larger or smaller when the user moves the mouse, revealing a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.begin();
   *   background(255);
   *   normalMaterial();
   *   sphere(20);
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object.
   *   image(myBuffer, -50, -50);
   * }
   *
   * // Resize the p5.Framebuffer object when the
   * // user moves the mouse.
   * function mouseMoved() {
   *   myBuffer.resize(mouseX, mouseY);
   * }
   * </code>
   * </div>
   */
  resize(width, height) {
    this._autoSized = false;
    const dimensions = this.renderer._adjustDimensions(width, height);
    width = dimensions.adjustedWidth;
    height = dimensions.adjustedHeight;
    this.width = width;
    this.height = height;
    this._handleResize();
  }
  /**
   * Sets the framebuffer's pixel density or returns its current density.
   *
   * Computer displays are grids of little lights called pixels. A display's
   * pixel density describes how many pixels it packs into an area. Displays
   * with smaller pixels have a higher pixel density and create sharper
   * images.
   *
   * The parameter, `density`, is optional. If a number is passed, as in
   * `myBuffer.pixelDensity(1)`, it sets the framebuffer's pixel density. By
   * default, the framebuffer's pixel density will match that of the canvas
   * where it was created. All canvases default to match the display's pixel
   * density.
   *
   * Calling `myBuffer.pixelDensity()` without an argument returns its current
   * pixel density.
   *
   * @param {Number} [density] pixel density to set.
   * @returns {Number} current pixel density.
   *
   * @example
   * <div>
   * <code>
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe("A white circle on a gray canvas. The circle's edge become fuzzy while the user presses and holds the mouse.");
   * }
   *
   * function draw() {
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.begin();
   *   background(200);
   *   circle(0, 0, 40);
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object.
   *   image(myBuffer, -50, -50);
   * }
   *
   * // Decrease the pixel density when the user
   * // presses the mouse.
   * function mousePressed() {
   *   myBuffer.pixelDensity(1);
   * }
   *
   * // Increase the pixel density when the user
   * // releases the mouse.
   * function mouseReleased() {
   *   myBuffer.pixelDensity(2);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myBuffer;
   * let myFont;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   myFont = await loadFont('assets/inconsolata.otf');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   // Get the p5.Framebuffer object's pixel density.
   *   let d = myBuffer.pixelDensity();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont(myFont);
   *   textSize(16);
   *   fill(0);
   *
   *   // Display the pixel density.
   *   text(`Density: ${d}`, 0, 0);
   *
   *   describe(`The text "Density: ${d}" written in black on a gray background.`);
   * }
   * </code>
   * </div>
   */
  pixelDensity(density) {
    if (density) {
      this._autoSized = false;
      this.density = density;
      this._handleResize();
    } else {
      return this.density;
    }
  }
  /**
   * Toggles the framebuffer's autosizing mode or returns the current mode.
   *
   * By default, the framebuffer automatically resizes to match the canvas
   * that created it. Calling `myBuffer.autoSized(false)` disables this
   * behavior and calling `myBuffer.autoSized(true)` re-enables it.
   *
   * Calling `myBuffer.autoSized()` without an argument returns `true` if
   * the framebuffer automatically resizes and `false` if not.
   *
   * @param {Boolean} [autoSized] whether to automatically resize the framebuffer to match the canvas.
   * @returns {Boolean} current autosize setting.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle the autosizing mode.
   *
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('A multicolor sphere on a gray background. The image resizes when the user moves the mouse.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.begin();
   *   background(200);
   *   normalMaterial();
   *   sphere(width / 4);
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object.
   *   image(myBuffer, -width / 2, -height / 2);
   * }
   *
   * // Resize the canvas when the user moves the mouse.
   * function mouseMoved() {
   *   let w = constrain(mouseX, 0, 100);
   *   let h = constrain(mouseY, 0, 100);
   *   resizeCanvas(w, h);
   * }
   *
   * // Toggle autoSizing when the user double-clicks.
   * // Note: opened an issue to fix(?) this.
   * function doubleClicked() {
   *   let isAuto = myBuffer.autoSized();
   *   myBuffer.autoSized(!isAuto);
   * }
   * </code>
   * </div>
   */
  autoSized(autoSized) {
    if (autoSized === void 0) {
      return this._autoSized;
    } else {
      this._autoSized = autoSized;
      this._handleResize();
    }
  }
  /**
   * Checks the capabilities of the current WebGL environment to see if the
   * settings supplied by the user are capable of being fulfilled. If they
   * are not, warnings will be logged and the settings will be changed to
   * something close that can be fulfilled.
   *
   * @private
   */
  _checkIfFormatsAvailable() {
    const gl = this.gl;
    if (this.useDepth && this.renderer.webglVersion === WEBGL && !gl.getExtension("WEBGL_depth_texture")) {
      console.warn(
        "Unable to create depth textures in this environment. Falling back to a framebuffer without depth."
      );
      this.useDepth = false;
    }
    if (this.useDepth && this.renderer.webglVersion === WEBGL && this.depthFormat === FLOAT) {
      console.warn(
        "FLOAT depth format is unavailable in WebGL 1. Defaulting to UNSIGNED_INT."
      );
      this.depthFormat = UNSIGNED_INT;
    }
    if (![
      UNSIGNED_BYTE,
      FLOAT,
      HALF_FLOAT
    ].includes(this.format)) {
      console.warn(
        "Unknown Framebuffer format. Please use UNSIGNED_BYTE, FLOAT, or HALF_FLOAT. Defaulting to UNSIGNED_BYTE."
      );
      this.format = UNSIGNED_BYTE;
    }
    if (this.useDepth && ![
      UNSIGNED_INT,
      FLOAT
    ].includes(this.depthFormat)) {
      console.warn(
        "Unknown Framebuffer depth format. Please use UNSIGNED_INT or FLOAT. Defaulting to FLOAT."
      );
      this.depthFormat = FLOAT;
    }
    const support = checkWebGLCapabilities(this.renderer);
    if (!support.float && this.format === FLOAT) {
      console.warn(
        "This environment does not support FLOAT textures. Falling back to UNSIGNED_BYTE."
      );
      this.format = UNSIGNED_BYTE;
    }
    if (this.useDepth && !support.float && this.depthFormat === FLOAT) {
      console.warn(
        "This environment does not support FLOAT depth textures. Falling back to UNSIGNED_INT."
      );
      this.depthFormat = UNSIGNED_INT;
    }
    if (!support.halfFloat && this.format === HALF_FLOAT) {
      console.warn(
        "This environment does not support HALF_FLOAT textures. Falling back to UNSIGNED_BYTE."
      );
      this.format = UNSIGNED_BYTE;
    }
    if (this.channels === RGB && [FLOAT, HALF_FLOAT].includes(this.format)) {
      console.warn(
        "FLOAT and HALF_FLOAT formats do not work cross-platform with only RGB channels. Falling back to RGBA."
      );
      this.channels = RGBA;
    }
  }
  _deleteTextures() {
    this.renderer.deleteFramebufferTextures(this);
  }
  /**
   * Creates new textures and renderbuffers given the current size of the
   * framebuffer.
   *
   * @private
   */
  _recreateTextures() {
    this._updateSize();
    this.renderer.recreateFramebufferTextures(this);
    if (this.useDepth) {
      this.depth = new FramebufferTexture(this, "depthTexture");
      const depthFilter = NEAREST;
      this.depthP5Texture = new Texture(
        this.renderer,
        this.depth,
        {
          minFilter: depthFilter,
          magFilter: depthFilter
        }
      );
      this.renderer.textures.set(this.depth, this.depthP5Texture);
    }
    this.color = new FramebufferTexture(this, "colorTexture");
    const filter = this.textureFiltering === LINEAR ? LINEAR : NEAREST;
    this.colorP5Texture = new Texture(
      this.renderer,
      this.color,
      {
        minFilter: filter,
        magFilter: filter
      }
    );
    this.renderer.textures.set(this.color, this.colorP5Texture);
  }
  /**
   * A method that will be called when recreating textures. If the framebuffer
   * is auto-sized, it will update its width, height, and density properties.
   *
   * @private
   */
  _updateSize() {
    if (this._autoSized) {
      this.width = this.renderer.width;
      this.height = this.renderer.height;
      this.density = this.renderer._pixelDensity;
    }
  }
  /**
   * Called when the canvas that the framebuffer is attached to resizes. If the
   * framebuffer is auto-sized, it will update its textures to match the new
   * size.
   *
   * @private
   */
  _canvasSizeChanged() {
    if (this._autoSized) {
      this._handleResize();
    }
  }
  /**
   * Called when the size of the framebuffer has changed (either by being
   * manually updated or from auto-size updates when its canvas changes size.)
   * Old textures and renderbuffers will be deleted, and then recreated with the
   * new size.
   *
   * @private
   */
  _handleResize() {
    this._deleteTextures();
    this._recreateTextures();
    this.defaultCamera._resize();
  }
  /**
   * Creates a new
   * <a href="#/p5.Camera">p5.Camera</a> object to use with the framebuffer.
   *
   * The new camera is initialized with a default position `(0, 0, 800)` and a
   * default perspective projection. Its properties can be controlled with
   * <a href="#/p5.Camera">p5.Camera</a> methods such as `myCamera.lookAt(0, 0, 0)`.
   *
   * Framebuffer cameras should be created between calls to
   * <a href="#/p5.Framebuffer/begin">myBuffer.begin()</a> and
   * <a href="#/p5.Framebuffer/end">myBuffer.end()</a> like so:
   *
   * ```js
   * let myCamera;
   *
   * myBuffer.begin();
   *
   * // Create the camera for the framebuffer.
   * myCamera = myBuffer.createCamera();
   *
   * myBuffer.end();
   * ```
   *
   * Calling <a href="#/p5/setCamera">setCamera()</a> updates the
   * framebuffer's projection using the camera.
   * <a href="#/p5/resetMatrix">resetMatrix()</a> must also be called for the
   * view to change properly:
   *
   * ```js
   * myBuffer.begin();
   *
   * // Set the camera for the framebuffer.
   * setCamera(myCamera);
   *
   * // Reset all transformations.
   * resetMatrix();
   *
   * // Draw stuff...
   *
   * myBuffer.end();
   * ```
   *
   * @returns {p5.Camera} new camera.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let myBuffer;
   * let cam1;
   * let cam2;
   * let usingCam1 = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   // Create the cameras between begin() and end().
   *   myBuffer.begin();
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = myBuffer.createCamera();
   *
   *   // Create the second camera.
   *   // Place it at the top-left.
   *   // Point it at the origin.
   *   cam2 = myBuffer.createCamera();
   *   cam2.setPosition(400, -400, 800);
   *   cam2.lookAt(0, 0, 0);
   *
   *   myBuffer.end();
   *
   *   describe(
   *     'A white cube on a gray background. The camera toggles between frontal and aerial views when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.begin();
   *   background(200);
   *
   *   // Set the camera.
   *   if (usingCam1 === true) {
   *     setCamera(cam1);
   *   } else {
   *     setCamera(cam2);
   *   }
   *
   *   // Reset all transformations.
   *   resetMatrix();
   *
   *   // Draw the box.
   *   box();
   *
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object.
   *   image(myBuffer, -50, -50);
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (usingCam1 === true) {
   *     usingCam1 = false;
   *   } else {
   *     usingCam1 = true;
   *   }
   * }
   * </code>
   * </div>
   */
  createCamera() {
    const cam = new FramebufferCamera(this);
    cam._computeCameraDefaultSettings();
    cam._setDefaultCamera();
    return cam;
  }
  /**
   * Deletes the framebuffer from GPU memory.
   *
   * Calling `myBuffer.remove()` frees the GPU memory used by the framebuffer.
   * The framebuffer also uses a bit of memory on the CPU which can be freed
   * like so:
   *
   * ```js
   * // Delete the framebuffer from GPU memory.
   * myBuffer.remove();
   *
   * // Delete the framebuffer from CPU memory.
   * myBuffer = undefined;
   * ```
   *
   * Note: All variables that reference the framebuffer must be assigned
   * the value `undefined` to delete the framebuffer from CPU memory. If any
   * variable still refers to the framebuffer, then it won't be garbage
   * collected.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to remove the p5.Framebuffer object.
   *
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create an options object.
   *   let options = { width: 60, height: 60 };
   *
   *   // Create a p5.Framebuffer object and
   *   // configure it using options.
   *   myBuffer = createFramebuffer(options);
   *
   *   describe('A white circle at the center of a dark gray square disappears when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Display the p5.Framebuffer object if
   *   // it's available.
   *   if (myBuffer) {
   *     // Draw to the p5.Framebuffer object.
   *     myBuffer.begin();
   *     background(100);
   *     circle(0, 0, 20);
   *     myBuffer.end();
   *
   *     image(myBuffer, -30, -30);
   *   }
   * }
   *
   * // Remove the p5.Framebuffer object when the
   * // the user double-clicks.
   * function doubleClicked() {
   *   // Delete the framebuffer from GPU memory.
   *   myBuffer.remove();
   *
   *   // Delete the framebuffer from CPU memory.
   *   myBuffer = undefined;
   * }
   * </code>
   * </div>
   */
  remove() {
    this._deleteTextures();
    this.renderer.deleteFramebufferResources(this);
    this.renderer.framebuffers.delete(this);
  }
  /**
   * Begins drawing shapes to the framebuffer.
   *
   * `myBuffer.begin()` and <a href="#/p5.Framebuffer/end">myBuffer.end()</a>
   * allow shapes to be drawn to the framebuffer. `myBuffer.begin()` begins
   * drawing to the framebuffer and
   * <a href="#/p5.Framebuffer/end">myBuffer.end()</a> stops drawing to the
   * framebuffer. Changes won't be visible until the framebuffer is displayed
   * as an image or texture.
   *
   * @example
   * <div>
   * <code>
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('An empty gray canvas. The canvas gets darker and a rotating, multicolor torus appears while the user presses and holds the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Start drawing to the p5.Framebuffer object.
   *   myBuffer.begin();
   *
   *   background(50);
   *   rotateY(frameCount * 0.01);
   *   normalMaterial();
   *   torus(30);
   *
   *   // Stop drawing to the p5.Framebuffer object.
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object while
   *   // the user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     image(myBuffer, -50, -50);
   *   }
   * }
   * </code>
   * </div>
   */
  begin() {
    this.prevFramebuffer = this.renderer.activeFramebuffer();
    if (this.prevFramebuffer) {
      this.prevFramebuffer._beforeEnd();
    }
    this.renderer.activeFramebuffers.push(this);
    this._beforeBegin();
    this.renderer.push();
    this.renderer.states.setValue("curCamera", this.defaultCamera);
    this.renderer.states.setValue("uPMatrix", this.renderer.states.uPMatrix.clone());
    this.renderer.states.uPMatrix.set(this.defaultCamera.projMatrix);
    this.renderer.states.setValue("uViewMatrix", this.renderer.states.uViewMatrix.clone());
    this.renderer.states.uViewMatrix.set(this.defaultCamera.cameraMatrix);
    this.renderer.resetMatrix();
    this.renderer.states.uViewMatrix.set(this.renderer.states.curCamera.cameraMatrix);
    this.renderer.states.uModelMatrix.reset();
    this.renderer._applyStencilTestIfClipping();
  }
  /**
   * When making a p5.Framebuffer active so that it may be drawn to, this method
   * returns the underlying WebGL framebuffer that needs to be active to
   * support this. Antialiased framebuffers first write to a multisampled
   * renderbuffer, while other framebuffers can write directly to their main
   * framebuffers.
   *
   * @private
   */
  _framebufferToBind() {
    return this.renderer.getFramebufferToBind(this);
  }
  /**
   * Ensure all readable textures are up-to-date.
   * @private
   * @param {'colorTexutre'|'depthTexture'} property The property to update
   */
  _update(property) {
    if (this.dirty[property]) {
      this.renderer.updateFramebufferTexture(this, property);
      this.dirty[property] = false;
    }
  }
  /**
   * Ensures that the framebuffer is ready to be drawn to
   *
   * @private
   */
  _beforeBegin() {
    this.renderer.bindFramebuffer(this);
    this.renderer.viewport(
      this.width * this.density,
      this.height * this.density
    );
    if (this.renderer.flushDraw) {
      this.renderer.flushDraw();
    }
  }
  /**
   * Ensures that the framebuffer is ready to be read by other framebuffers.
   *
   * @private
   */
  _beforeEnd() {
    if (this.antialias) {
      this.dirty = { colorTexture: true, depthTexture: true };
    }
    if (this.renderer.flushDraw) {
      this.renderer.flushDraw();
    }
  }
  /**
   * Stops drawing shapes to the framebuffer.
   *
   * <a href="#/p5.Framebuffer/begin">myBuffer.begin()</a> and `myBuffer.end()`
   * allow shapes to be drawn to the framebuffer.
   * <a href="#/p5.Framebuffer/begin">myBuffer.begin()</a> begins drawing to
   * the framebuffer and `myBuffer.end()` stops drawing to the framebuffer.
   * Changes won't be visible until the framebuffer is displayed as an image
   * or texture.
   *
   * @example
   * <div>
   * <code>
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('An empty gray canvas. The canvas gets darker and a rotating, multicolor torus appears while the user presses and holds the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Start drawing to the p5.Framebuffer object.
   *   myBuffer.begin();
   *
   *   background(50);
   *   rotateY(frameCount * 0.01);
   *   normalMaterial();
   *   torus(30);
   *
   *   // Stop drawing to the p5.Framebuffer object.
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object while
   *   // the user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     image(myBuffer, -50, -50);
   *   }
   * }
   * </code>
   * </div>
   */
  end() {
    this.renderer.pop();
    const fbo = this.renderer.activeFramebuffers.pop();
    if (fbo !== this) {
      throw new Error("It looks like you've called end() while another Framebuffer is active.");
    }
    this._beforeEnd();
    if (this.prevFramebuffer) {
      this.prevFramebuffer._beforeBegin();
    } else {
      this.renderer.bindFramebuffer(null);
      this.renderer.viewport(
        this.renderer._origViewport.width,
        this.renderer._origViewport.height
      );
    }
    this.renderer._applyStencilTestIfClipping();
  }
  /**
   * Draws to the framebuffer by calling a function that contains drawing
   * instructions.
   *
   * The parameter, `callback`, is a function with the drawing instructions
   * for the framebuffer. For example, calling `myBuffer.draw(myFunction)`
   * will call a function named `myFunction()` to draw to the framebuffer.
   * Doing so has the same effect as the following:
   *
   * ```js
   * myBuffer.begin();
   * myFunction();
   * myBuffer.end();
   * ```
   *
   * @param {Function} callback function that draws to the framebuffer.
   *
   * @example
   * <div>
   * <code>
   * // Click the canvas to display the framebuffer.
   *
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('An empty gray canvas. The canvas gets darker and a rotating, multicolor torus appears while the user presses and holds the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.draw(bagel);
   *
   *   // Display the p5.Framebuffer object while
   *   // the user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     image(myBuffer, -50, -50);
   *   }
   * }
   *
   * // Draw a rotating, multicolor torus.
   * function bagel() {
   *   background(50);
   *   rotateY(frameCount * 0.01);
   *   normalMaterial();
   *   torus(30);
   * }
   * </code>
   * </div>
   */
  draw(callback) {
    this.begin();
    callback();
    this.end();
  }
  /**
   * Loads the current value of each pixel in the framebuffer into its
   * <a href="#/p5.Framebuffer/pixels">pixels</a> array.
   *
   * `myBuffer.loadPixels()` must be called before reading from or writing to
   * <a href="#/p5.Framebuffer/pixels">myBuffer.pixels</a>.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Framebuffer object.
   *   let myBuffer = createFramebuffer();
   *
   *   // Load the pixels array.
   *   myBuffer.loadPixels();
   *
   *   // Get the number of pixels in the
   *   // top half of the framebuffer.
   *   let numPixels = myBuffer.pixels.length / 2;
   *
   *   // Set the framebuffer's top half to pink.
   *   for (let i = 0; i < numPixels; i += 4) {
   *     myBuffer.pixels[i] = 255;
   *     myBuffer.pixels[i + 1] = 102;
   *     myBuffer.pixels[i + 2] = 204;
   *     myBuffer.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the pixels array.
   *   myBuffer.updatePixels();
   *
   *   // Draw the p5.Framebuffer object to the canvas.
   *   image(myBuffer, -50, -50);
   *
   *   describe('A pink rectangle above a gray rectangle.');
   * }
   * </code>
   * </div>
   */
  loadPixels() {
    this._update("colorTexture");
    const result = this.renderer.readFramebufferPixels(this);
    if (result && typeof result.then === "function") {
      return result.then((pixels2) => {
        this.pixels = pixels2;
        return pixels2;
      });
    } else {
      this.pixels = result;
      return result;
    }
  }
  /**
   * Gets a pixel or a region of pixels from the framebuffer.
   *
   * `myBuffer.get()` is easy to use but it's not as fast as
   * <a href="#/p5.Framebuffer/pixels">myBuffer.pixels</a>. Use
   * <a href="#/p5.Framebuffer/pixels">myBuffer.pixels</a> to read many pixel
   * values.
   *
   * The version of `myBuffer.get()` with no parameters returns the entire
   * framebuffer as a a <a href="#/p5.Image">p5.Image</a> object.
   *
   * The version of `myBuffer.get()` with two parameters interprets them as
   * coordinates. It returns an array with the `[R, G, B, A]` values of the
   * pixel at the given point.
   *
   * The version of `myBuffer.get()` with four parameters interprets them as
   * coordinates and dimensions. It returns a subsection of the framebuffer as
   * a <a href="#/p5.Image">p5.Image</a> object. The first two parameters are
   * the coordinates for the upper-left corner of the subsection. The last two
   * parameters are the width and height of the subsection.
   *
   * @param  {Number} x x-coordinate of the pixel. Defaults to 0.
   * @param  {Number} y y-coordinate of the pixel. Defaults to 0.
   * @param  {Number} w width of the subsection to be returned.
   * @param  {Number} h height of the subsection to be returned.
   * @return {p5.Image} subsection as a <a href="#/p5.Image">p5.Image</a> object.
   */
  /**
   * @return {p5.Image} entire framebuffer as a <a href="#/p5.Image">p5.Image</a> object.
   */
  /**
   * @param  {Number} x
   * @param  {Number} y
   * @return {Number[]}  color of the pixel at `(x, y)` as an array of color values `[R, G, B, A]`.
   */
  get(x, y, w, h) {
    this._update("colorTexture");
    if (x === void 0 && y === void 0) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    } else if (w === void 0 && h === void 0) {
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
        console.warn(
          "The x and y values passed to p5.Framebuffer.get are outside of its range and will be clamped."
        );
        x = constrain(x, 0, this.width - 1);
        y = constrain(y, 0, this.height - 1);
      }
      return this.renderer.readFramebufferPixel(this, x * this.density, y * this.density);
    }
    x = constrain(x, 0, this.width - 1);
    y = constrain(y, 0, this.height - 1);
    w = constrain(w, 1, this.width - x);
    h = constrain(h, 1, this.height - y);
    return this.renderer.readFramebufferRegion(this, x, y, w, h);
  }
  /**
   * Updates the framebuffer with the RGBA values in the
   * <a href="#/p5.Framebuffer/pixels">pixels</a> array.
   *
   * `myBuffer.updatePixels()` only needs to be called after changing values
   * in the <a href="#/p5.Framebuffer/pixels">myBuffer.pixels</a> array. Such
   * changes can be made directly after calling
   * <a href="#/p5.Framebuffer/loadPixels">myBuffer.loadPixels()</a>.
   *
   * @method updatePixels
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Framebuffer object.
   *   let myBuffer = createFramebuffer();
   *
   *   // Load the pixels array.
   *   myBuffer.loadPixels();
   *
   *   // Get the number of pixels in the
   *   // top half of the framebuffer.
   *   let numPixels = myBuffer.pixels.length / 2;
   *
   *   // Set the framebuffer's top half to pink.
   *   for (let i = 0; i < numPixels; i += 4) {
   *     myBuffer.pixels[i] = 255;
   *     myBuffer.pixels[i + 1] = 102;
   *     myBuffer.pixels[i + 2] = 204;
   *     myBuffer.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the pixels array.
   *   myBuffer.updatePixels();
   *
   *   // Draw the p5.Framebuffer object to the canvas.
   *   image(myBuffer, -50, -50);
   *
   *   describe('A pink rectangle above a gray rectangle.');
   * }
   * </code>
   * </div>
   */
  updatePixels() {
    this.renderer.updateFramebufferPixels(this);
  }
};
function framebuffer(p53, fn2) {
  p53.FramebufferCamera = FramebufferCamera;
  p53.FramebufferTexture = FramebufferTexture;
  p53.Framebuffer = Framebuffer$1;
}
if (typeof p5 !== "undefined") {
  framebuffer(p5, p5.prototype);
}
let renderers;
function rendering(p53, fn2) {
  if (!p53.renderers) {
    p53.renderers = {};
  }
  renderers = p53.renderers;
  fn2.createCanvas = function(w, h, renderer2, ...args) {
    let selectedRenderer = P2D;
    if (Reflect.ownKeys(renderers).includes(renderer2)) {
      selectedRenderer = renderer2;
    } else {
      args.unshift(renderer2);
    }
    if (this._renderer) this._renderer.remove();
    this._renderer = new renderers[selectedRenderer](this, w, h, true, ...args);
    this._defaultGraphicsCreated = true;
    this._elements.push(this._renderer);
    this._renderer._applyDefaults();
    if (!Object.hasOwn(this, "pixels")) {
      Object.defineProperty(this, "pixels", {
        get() {
          return this._renderer?.pixels;
        }
      });
    }
    if (this._renderer.contextReady) {
      return this._renderer.contextReady.then(() => this._renderer);
    } else {
      return this._renderer;
    }
  };
  fn2.resizeCanvas = function(w, h, noRedraw) {
    if (this._renderer) {
      this._renderer.resize(w, h);
      if (!noRedraw) {
        this.redraw();
      }
    }
    if (this._addAccsOutput()) {
      this._updateAccsOutput();
    }
  };
  fn2.noCanvas = function() {
    if (this.canvas) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
  };
  fn2.createGraphics = function(w, h, ...args) {
    if (args[0] instanceof HTMLCanvasElement) {
      args[1] = args[0];
      args[0] = P2D;
    }
    return new p53.Graphics(w, h, args[0], this, args[1]);
  };
  fn2.createFramebuffer = function(options2) {
    return new Framebuffer$1(this._renderer, options2);
  };
  fn2.clearDepth = function(depth) {
    this._assert3d("clearDepth");
    this._renderer.clearDepth(depth);
  };
}
if (typeof p5 !== "undefined") {
  rendering(p5, p5.prototype);
}
var filterBaseFrag = "precision highp float;\n\nuniform sampler2D tex0;\nuniform vec2 canvasSize;\nuniform vec2 texelSize;\n\nIN vec2 vTexCoord;\n\nstruct FilterInputs {\n  vec2 texCoord;\n  vec2 canvasSize;\n  vec2 texelSize;\n};\n\nvoid main(void) {\n  FilterInputs inputs;\n  inputs.texCoord = vTexCoord;\n  inputs.canvasSize = canvasSize;\n  inputs.texelSize = texelSize;\n  OUT_COLOR = HOOK_getColor(inputs, tex0);\n  OUT_COLOR.rgb *= outColor.a;\n}\n";
var filterBaseVert = "precision highp int;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nIN vec3 aPosition;\nIN vec2 aTexCoord;\nOUT vec2 vTexCoord;\n\nvoid main() {\n  // transferring texcoords for the frag shader\n  vTexCoord = aTexCoord;\n\n  // copy position with a fourth coordinate for projection (1.0 is normal)\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // project to 3D space\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n}\n";
var webgl2CompatibilityShader = "#ifdef WEBGL2\n\n#define IN in\n#define OUT out\n\n#ifdef FRAGMENT_SHADER\nout vec4 outColor;\n#define OUT_COLOR outColor\n#endif\n#define TEXTURE texture\n\n#else\n\n#ifdef FRAGMENT_SHADER\n#define IN varying\n#else\n#define IN attribute\n#endif\n#define OUT varying\n#define TEXTURE texture2D\n\n#ifdef FRAGMENT_SHADER\n#define OUT_COLOR gl_FragColor\n#endif\n\n#endif\n\n#ifdef FRAGMENT_SHADER\nvec4 getTexture(in sampler2D content, vec2 coord) {\n  vec4 color = TEXTURE(content, coord);\n  if (color.a > 0.) color.rgb /= color.a;\n  return color;\n}\n#endif\n";
var noiseGLSL = "// Based on https://github.com/stegu/webgl-noise/blob/22434e04d7753f7e949e8d724ab3da2864c17a0f/src/noise3D.glsl\n// MIT licensed, adapted for p5.strands\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat baseNoise(vec3 v)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n          i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n        dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat noise(vec3 st, int octaves, float ampFalloff) {\n  float result = 0.0;\n  float amplitude = 1.0;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 8; i++) {\n    if (i >= octaves) break;\n    result += amplitude * baseNoise(st * frequency);\n    frequency *= 2.0;\n    amplitude *= ampFalloff;\n  }\n\n  return result;\n}\n";
const NodeType = {
  OPERATION: "operation",
  LITERAL: "literal",
  VARIABLE: "variable",
  CONSTANT: "constant",
  STRUCT: "struct",
  PHI: "phi",
  STATEMENT: "statement",
  ASSIGNMENT: "assignment"
};
const NodeTypeToName = Object.fromEntries(
  Object.entries(NodeType).map(([key, val]) => [val, key])
);
const NodeTypeRequiredFields = {
  [NodeType.OPERATION]: ["opCode", "dependsOn", "dimension", "baseType"],
  [NodeType.LITERAL]: ["value", "dimension", "baseType"],
  [NodeType.VARIABLE]: ["identifier", "dimension", "baseType"],
  [NodeType.CONSTANT]: ["value", "dimension", "baseType"],
  [NodeType.STRUCT]: [""],
  [NodeType.PHI]: ["dependsOn", "phiBlocks", "dimension", "baseType"],
  [NodeType.STATEMENT]: ["statementType"],
  [NodeType.ASSIGNMENT]: ["dependsOn"]
};
const StatementType = {
  DISCARD: "discard",
  BREAK: "break",
  EARLY_RETURN: "early_return",
  EXPRESSION: "expression",
  // Used when we want to output a single expression as a statement, e.g. a for loop condition
  EMPTY: "empty"
  // Used for empty statements like ; in for loops
};
const BaseType = {
  FLOAT: "float",
  INT: "int",
  BOOL: "bool",
  MAT: "mat",
  DEFER: "defer",
  SAMPLER2D: "sampler2D",
  SAMPLER: "sampler"
};
const BasePriority = {
  [BaseType.FLOAT]: 3,
  [BaseType.INT]: 2,
  [BaseType.BOOL]: 1,
  [BaseType.MAT]: 0,
  [BaseType.DEFER]: -1,
  [BaseType.SAMPLER2D]: -10,
  [BaseType.SAMPLER]: -11
};
const DataType = {
  float1: { fnName: "float", baseType: BaseType.FLOAT, dimension: 1, priority: 3 },
  float2: { fnName: "vec2", baseType: BaseType.FLOAT, dimension: 2, priority: 3 },
  float3: { fnName: "vec3", baseType: BaseType.FLOAT, dimension: 3, priority: 3 },
  float4: { fnName: "vec4", baseType: BaseType.FLOAT, dimension: 4, priority: 3 },
  int1: { fnName: "int", baseType: BaseType.INT, dimension: 1, priority: 2 },
  int2: { fnName: "ivec2", baseType: BaseType.INT, dimension: 2, priority: 2 },
  int3: { fnName: "ivec3", baseType: BaseType.INT, dimension: 3, priority: 2 },
  int4: { fnName: "ivec4", baseType: BaseType.INT, dimension: 4, priority: 2 },
  bool1: { fnName: "bool", baseType: BaseType.BOOL, dimension: 1, priority: 1 },
  bool2: { fnName: "bvec2", baseType: BaseType.BOOL, dimension: 2, priority: 1 },
  bool3: { fnName: "bvec3", baseType: BaseType.BOOL, dimension: 3, priority: 1 },
  bool4: { fnName: "bvec4", baseType: BaseType.BOOL, dimension: 4, priority: 1 },
  mat2: { fnName: "mat2x2", baseType: BaseType.MAT, dimension: 2, priority: 0 },
  mat3: { fnName: "mat3x3", baseType: BaseType.MAT, dimension: 3, priority: 0 },
  mat4: { fnName: "mat4x4", baseType: BaseType.MAT, dimension: 4, priority: 0 },
  defer: { fnName: null, baseType: BaseType.DEFER, dimension: null, priority: -1 },
  sampler2D: { fnName: "sampler2D", baseType: BaseType.SAMPLER2D, dimension: 1, priority: -10 },
  sampler: { fnName: "sampler", baseType: BaseType.SAMPLER, dimension: 1, priority: -11 }
};
const structType = function(hookType) {
  let T2 = hookType.type === void 0 ? hookType : hookType.type;
  const structType2 = {
    name: hookType.name,
    properties: [],
    typeName: T2.typeName
  };
  for (const prop of T2.properties) {
    const propType = prop.type.dataType;
    structType2.properties.push(
      { name: prop.name, dataType: propType }
    );
  }
  return structType2;
};
function isStructType(typeInfo) {
  return !!(typeInfo && typeInfo.properties);
}
const GenType = {
  FLOAT: { baseType: BaseType.FLOAT, dimension: null, priority: 3 },
  INT: { baseType: BaseType.INT, dimension: null, priority: 2 },
  BOOL: { baseType: BaseType.BOOL, dimension: null, priority: 1 }
};
function typeEquals(nodeA, nodeB) {
  return nodeA.dimension === nodeB.dimension && nodeA.baseType === nodeB.baseType;
}
const TypeInfoFromGLSLName = Object.fromEntries(
  Object.values(DataType).filter((info) => info.fnName !== null).map((info) => [info.fnName, info])
);
const OpCode = {
  Binary: {
    ADD: 0,
    SUBTRACT: 1,
    MULTIPLY: 2,
    DIVIDE: 3,
    MODULO: 4,
    EQUAL: 5,
    NOT_EQUAL: 6,
    GREATER_THAN: 7,
    GREATER_EQUAL: 8,
    LESS_THAN: 9,
    LESS_EQUAL: 10,
    LOGICAL_AND: 11,
    LOGICAL_OR: 12,
    MEMBER_ACCESS: 13
  },
  Unary: {
    LOGICAL_NOT: 100,
    NEGATE: 101,
    PLUS: 102,
    SWIZZLE: 103
  },
  Nary: {
    FUNCTION_CALL: 200,
    CONSTRUCTOR: 201
  }
};
const OperatorTable = [
  { arity: "unary", name: "not", symbol: "!", opCode: OpCode.Unary.LOGICAL_NOT },
  { arity: "unary", name: "neg", symbol: "-", opCode: OpCode.Unary.NEGATE },
  { arity: "unary", name: "plus", symbol: "+", opCode: OpCode.Unary.PLUS },
  { arity: "binary", name: "add", symbol: "+", opCode: OpCode.Binary.ADD },
  { arity: "binary", name: "sub", symbol: "-", opCode: OpCode.Binary.SUBTRACT },
  { arity: "binary", name: "mult", symbol: "*", opCode: OpCode.Binary.MULTIPLY },
  { arity: "binary", name: "div", symbol: "/", opCode: OpCode.Binary.DIVIDE },
  { arity: "binary", name: "mod", symbol: "%", opCode: OpCode.Binary.MODULO },
  { arity: "binary", name: "equalTo", symbol: "==", opCode: OpCode.Binary.EQUAL },
  { arity: "binary", name: "notEqual", symbol: "!=", opCode: OpCode.Binary.NOT_EQUAL },
  { arity: "binary", name: "greaterThan", symbol: ">", opCode: OpCode.Binary.GREATER_THAN },
  { arity: "binary", name: "greaterEqual", symbol: ">=", opCode: OpCode.Binary.GREATER_EQUAL },
  { arity: "binary", name: "lessThan", symbol: "<", opCode: OpCode.Binary.LESS_THAN },
  { arity: "binary", name: "lessEqual", symbol: "<=", opCode: OpCode.Binary.LESS_EQUAL },
  { arity: "binary", name: "and", symbol: "&&", opCode: OpCode.Binary.LOGICAL_AND },
  { arity: "binary", name: "or", symbol: "||", opCode: OpCode.Binary.LOGICAL_OR }
];
const OpCodeToSymbol = {};
const UnarySymbolToName = {};
for (const { symbol, opCode, name, arity } of OperatorTable) {
  OpCodeToSymbol[opCode] = symbol;
  if (arity === "unary") {
    UnarySymbolToName[symbol] = name;
  }
}
const BlockType = {
  GLOBAL: "global",
  FUNCTION: "function",
  BRANCH: "branch",
  IF_COND: "if_cond",
  IF_BODY: "if_body",
  ELSE_COND: "else_cond",
  SCOPE_START: "scope_start",
  SCOPE_END: "scope_end",
  FOR: "for",
  MERGE: "merge",
  DEFAULT: "default"
};
Object.fromEntries(
  Object.entries(BlockType).map(([key, val]) => [val, key])
);
function internalError(errorMessage) {
  const prefixedMessage = `[p5.strands internal error]: ${errorMessage}`;
  throw new Error(prefixedMessage);
}
function userError(errorType, errorMessage) {
  const prefixedMessage = `[p5.strands ${errorType}]: ${errorMessage}`;
  throw new Error(prefixedMessage);
}
function createDirectedAcyclicGraph() {
  const graph = {
    nextID: 0,
    cache: /* @__PURE__ */ new Map(),
    nodeTypes: [],
    baseTypes: [],
    dimensions: [],
    opCodes: [],
    values: [],
    identifiers: [],
    phiBlocks: [],
    dependsOn: [],
    usedBy: [],
    statementTypes: [],
    swizzles: []
  };
  return graph;
}
function getOrCreateNode(graph, node) {
  const id = createNode(graph, node);
  return id;
}
function createNodeData(data2 = {}) {
  const node = {
    nodeType: data2.nodeType ?? null,
    baseType: data2.baseType ?? null,
    dimension: data2.dimension ?? null,
    opCode: data2.opCode ?? null,
    value: data2.value ?? null,
    identifier: data2.identifier ?? null,
    statementType: data2.statementType ?? null,
    swizzle: data2.swizzle ?? null,
    dependsOn: Array.isArray(data2.dependsOn) ? data2.dependsOn : [],
    usedBy: Array.isArray(data2.usedBy) ? data2.usedBy : [],
    phiBlocks: Array.isArray(data2.phiBlocks) ? data2.phiBlocks : []
  };
  validateNode(node);
  return node;
}
function getNodeDataFromID(graph, id) {
  return {
    id,
    nodeType: graph.nodeTypes[id],
    opCode: graph.opCodes[id],
    value: graph.values[id],
    identifier: graph.identifiers[id],
    dependsOn: graph.dependsOn[id],
    usedBy: graph.usedBy[id],
    phiBlocks: graph.phiBlocks[id],
    dimension: graph.dimensions[id],
    baseType: graph.baseTypes[id],
    statementType: graph.statementTypes[id],
    swizzle: graph.swizzles[id]
  };
}
function extractNodeTypeInfo(dag, nodeID) {
  return {
    baseType: dag.baseTypes[nodeID],
    dimension: dag.dimensions[nodeID],
    priority: BasePriority[dag.baseTypes[nodeID]]
  };
}
function createNode(graph, node) {
  const id = graph.nextID++;
  graph.nodeTypes[id] = node.nodeType;
  graph.opCodes[id] = node.opCode;
  graph.values[id] = node.value;
  graph.identifiers[id] = node.identifier;
  graph.dependsOn[id] = node.dependsOn.slice();
  graph.usedBy[id] = node.usedBy;
  graph.phiBlocks[id] = node.phiBlocks.slice();
  graph.baseTypes[id] = node.baseType;
  graph.dimensions[id] = node.dimension;
  graph.statementTypes[id] = node.statementType;
  graph.swizzles[id] = node.swizzle;
  for (const dep of node.dependsOn) {
    if (!Array.isArray(graph.usedBy[dep])) {
      graph.usedBy[dep] = [];
    }
    graph.usedBy[dep].push(id);
  }
  return id;
}
function validateNode(node) {
  const nodeType = node.nodeType;
  const requiredFields = NodeTypeRequiredFields[nodeType];
  if (requiredFields.length === 2) {
    internalError(`Required fields for node type '${NodeTypeToName[nodeType]}' not defined. Please add them to the utils.js file in p5.strands!`);
  }
  const missingFields = [];
  for (const field of requiredFields) {
    if (node[field] === null) {
      missingFields.push(field);
    }
  }
  if (node.dependsOn?.some((v) => v === void 0)) {
    throw new Error("Undefined dependency!");
  }
  if (missingFields.length > 0) {
    internalError(`Missing fields ${missingFields.join(", ")} for a node type '${NodeTypeToName[nodeType]}'.`);
  }
}
function createControlFlowGraph() {
  return {
    // graph structure
    blockTypes: [],
    incomingEdges: [],
    outgoingEdges: [],
    blockInstructions: [],
    // runtime data for constructing graph
    nextID: 0,
    blockStack: [],
    blockOrder: [],
    blockConditions: {},
    currentBlock: -1
  };
}
function pushBlock(graph, blockID) {
  graph.blockStack.push(blockID);
  graph.blockOrder.push(blockID);
  graph.currentBlock = blockID;
}
function popBlock(graph) {
  graph.blockStack.pop();
  const len = graph.blockStack.length;
  graph.currentBlock = graph.blockStack[len - 1];
}
function pushBlockForModification(graph, blockID) {
  graph.blockStack.push(blockID);
  graph.currentBlock = blockID;
}
function createBasicBlock(graph, blockType) {
  const id = graph.nextID++;
  graph.blockTypes[id] = blockType;
  graph.incomingEdges[id] = [];
  graph.outgoingEdges[id] = [];
  graph.blockInstructions[id] = [];
  return id;
}
function addEdge(graph, from, to2) {
  graph.outgoingEdges[from].push(to2);
  graph.incomingEdges[to2].push(from);
}
function recordInBasicBlock(graph, blockID, nodeID) {
  if (nodeID === void 0) {
    internalError("undefined nodeID in `recordInBasicBlock()`");
  }
  if (blockID === void 0) {
    internalError("undefined blockID in `recordInBasicBlock()");
  }
  graph.blockInstructions[blockID] = graph.blockInstructions[blockID] || [];
  graph.blockInstructions[blockID].push(nodeID);
}
function sortCFG(adjacencyList, start2) {
  const visited = /* @__PURE__ */ new Set();
  const postOrder = [];
  function dfs(v) {
    if (visited.has(v)) {
      return;
    }
    visited.add(v);
    for (let w of adjacencyList[v].sort((a, b2) => b2 - a) || []) {
      dfs(w);
    }
    postOrder.push(v);
  }
  dfs(start2);
  return postOrder.reverse();
}
const builtInGLSLFunctions = {
  //////////// Trigonometry //////////
  acos: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  acosh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  asin: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  asinh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  atan: [
    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }
  ],
  atanh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  cos: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  cosh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  degrees: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  radians: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  sin: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  sinh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  tan: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  tanh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  ////////// Mathematics //////////
  abs: [
    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT], returnType: GenType.INT, isp5Function: true }
  ],
  ceil: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  clamp: [
    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.FLOAT, DataType.float1, DataType.float1], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.INT, GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: false },
    { params: [GenType.INT, DataType.int1, DataType.int1], returnType: GenType.INT, isp5Function: false }
  ],
  dFdx: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  dFdy: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  exp: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  exp2: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  floor: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  fma: [{ params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  fract: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  fwidth: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  inversesqrt: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  // "isinf": [{}],
  // "isnan": [{}],
  log: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  log2: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  max: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: true },
    { params: [GenType.INT, DataType.int1], returnType: GenType.INT, isp5Function: true }
  ],
  min: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: true },
    { params: [GenType.INT, DataType.int1], returnType: GenType.INT, isp5Function: true }
  ],
  mix: [
    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.FLOAT, GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.FLOAT, GenType.FLOAT, GenType.BOOL], returnType: GenType.FLOAT, isp5Function: false }
  ],
  mod: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: true }
  ],
  // "modf": [{}],
  pow: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  round: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  roundEven: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  sign: [
    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.INT], returnType: GenType.INT, isp5Function: false }
  ],
  smoothstep: [
    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false },
    { params: [DataType.float1, DataType.float1, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }
  ],
  sqrt: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  step: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  trunc: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  ////////// Vector //////////
  cross: [{ params: [DataType.float3, DataType.float3], returnType: DataType.float3, isp5Function: true }],
  distance: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: DataType.float1, isp5Function: true }],
  dot: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: DataType.float1, isp5Function: true }],
  equal: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.BOOL, isp5Function: false },
    { params: [GenType.INT, GenType.INT], returnType: GenType.BOOL, isp5Function: false },
    { params: [GenType.BOOL, GenType.BOOL], returnType: GenType.BOOL, isp5Function: false }
  ],
  faceforward: [{ params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  length: [{ params: [GenType.FLOAT], returnType: DataType.float1, isp5Function: false }],
  normalize: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  notEqual: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.BOOL, isp5Function: false },
    { params: [GenType.INT, GenType.INT], returnType: GenType.BOOL, isp5Function: false },
    { params: [GenType.BOOL, GenType.BOOL], returnType: GenType.BOOL, isp5Function: false }
  ],
  reflect: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  refract: [{ params: [GenType.FLOAT, GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: false }]
};
const strandsBuiltinFunctions = {
  ...builtInGLSLFunctions
};
class StrandsNode {
  constructor(id, dimension, strandsContext) {
    this.id = id;
    this.strandsContext = strandsContext;
    this.dimension = dimension;
    this.isStrandsNode = true;
    const dag = this.strandsContext.dag;
    const nodeData = getNodeDataFromID(dag, this.id);
    if (nodeData && nodeData.identifier) {
      this._originalIdentifier = nodeData.identifier;
    }
    if (nodeData) {
      this._originalBaseType = nodeData.baseType;
      this._originalDimension = nodeData.dimension;
    }
  }
  copy() {
    return createStrandsNode(this.id, this.dimension, this.strandsContext);
  }
  typeInfo() {
    return {
      baseType: this._originalBaseType || BaseType.FLOAT,
      dimension: this.dimension
    };
  }
  bridge(value) {
    const { dag, cfg } = this.strandsContext;
    const orig = getNodeDataFromID(dag, this.id);
    const baseType = orig?.baseType ?? BaseType.FLOAT;
    let newValueID;
    if (value instanceof StrandsNode) {
      newValueID = value.id;
    } else {
      const newVal = primitiveConstructorNode(
        this.strandsContext,
        { baseType, dimension: this.dimension },
        value
      );
      newValueID = newVal.id;
    }
    if (this._originalIdentifier) {
      const { id: targetVarID } = variableNode(
        this.strandsContext,
        { baseType: this._originalBaseType, dimension: this._originalDimension },
        this._originalIdentifier
      );
      const assignmentNode = createNodeData({
        nodeType: NodeType.ASSIGNMENT,
        dependsOn: [targetVarID, newValueID],
        phiBlocks: []
      });
      const assignmentID = getOrCreateNode(dag, assignmentNode);
      recordInBasicBlock(cfg, cfg.currentBlock, assignmentID);
      this.strandsContext.globalAssignments.push(assignmentID);
      const variableNodeData = createNodeData({
        nodeType: NodeType.VARIABLE,
        baseType: this._originalBaseType,
        dimension: this._originalDimension,
        identifier: this._originalIdentifier
      });
      const variableID = getOrCreateNode(dag, variableNodeData);
      this.id = variableID;
    } else {
      this.id = newValueID;
    }
    return this;
  }
  bridgeSwizzle(swizzlePattern, value) {
    const { dag, cfg } = this.strandsContext;
    const orig = getNodeDataFromID(dag, this.id);
    const baseType = orig?.baseType ?? BaseType.FLOAT;
    let newValueID;
    if (value instanceof StrandsNode) {
      newValueID = value.id;
    } else {
      const newVal = primitiveConstructorNode(
        this.strandsContext,
        { baseType, dimension: this.dimension },
        value
      );
      newValueID = newVal.id;
    }
    if (this._originalIdentifier) {
      const { id: targetVarID } = variableNode(
        this.strandsContext,
        { baseType: this._originalBaseType, dimension: this._originalDimension },
        this._originalIdentifier
      );
      const swizzleNode2 = createNodeData({
        nodeType: NodeType.OPERATION,
        opCode: OpCode.Unary.SWIZZLE,
        baseType: this._originalBaseType,
        dimension: swizzlePattern.length,
        // xyz = 3, xy = 2, etc.
        swizzle: swizzlePattern,
        dependsOn: [targetVarID]
      });
      const swizzleID = getOrCreateNode(dag, swizzleNode2);
      const assignmentNode = createNodeData({
        nodeType: NodeType.ASSIGNMENT,
        dependsOn: [swizzleID, newValueID],
        phiBlocks: []
      });
      const assignmentID = getOrCreateNode(dag, assignmentNode);
      recordInBasicBlock(cfg, cfg.currentBlock, assignmentID);
      this.strandsContext.globalAssignments.push(assignmentID);
      const variableNodeData = createNodeData({
        nodeType: NodeType.VARIABLE,
        baseType: this._originalBaseType,
        dimension: this._originalDimension,
        identifier: this._originalIdentifier
      });
      const variableID = getOrCreateNode(dag, variableNodeData);
      this.id = variableID;
    } else {
      this.id = newValueID;
    }
    return this;
  }
  getValue() {
    if (this._originalIdentifier) {
      const { id, dimension } = variableNode(
        this.strandsContext,
        { baseType: this._originalBaseType, dimension: this._originalDimension },
        this._originalIdentifier
      );
      return createStrandsNode(id, dimension, this.strandsContext);
    }
    return this;
  }
}
function createStrandsNode(id, dimension, strandsContext, onRebind) {
  return new Proxy(
    new StrandsNode(id, dimension, strandsContext),
    swizzleTrap(id, dimension, strandsContext, onRebind)
  );
}
function scalarLiteralNode(strandsContext, typeInfo, value) {
  const { cfg, dag } = strandsContext;
  let { dimension, baseType } = typeInfo;
  if (dimension !== 1) {
    internalError("Created a scalar literal node with dimension > 1.");
  }
  const nodeData = createNodeData({
    nodeType: NodeType.LITERAL,
    dimension,
    baseType,
    value
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension };
}
function variableNode(strandsContext, typeInfo, identifier) {
  const { cfg, dag } = strandsContext;
  const { dimension, baseType } = typeInfo;
  const nodeData = createNodeData({
    nodeType: NodeType.VARIABLE,
    dimension,
    baseType,
    identifier
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension };
}
function unaryOpNode(strandsContext, nodeOrValue, opCode) {
  const { dag, cfg } = strandsContext;
  let dependsOn;
  let node;
  if (nodeOrValue instanceof StrandsNode) {
    node = nodeOrValue;
  } else {
    const { id: id2, dimension } = primitiveConstructorNode(strandsContext, { baseType: BaseType.FLOAT, dimension: null }, nodeOrValue);
    node = createStrandsNode(id2, dimension, strandsContext);
  }
  dependsOn = [node.id];
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode,
    dependsOn,
    baseType: dag.baseTypes[node.id],
    dimension: node.dimension
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: node.dimension };
}
function binaryOpNode(strandsContext, leftStrandsNode, rightArg, opCode) {
  const { dag, cfg } = strandsContext;
  let rightStrandsNode;
  if (rightArg[0] instanceof StrandsNode && rightArg.length === 1) {
    rightStrandsNode = rightArg[0];
  } else {
    const { id: id2, dimension } = primitiveConstructorNode(strandsContext, { baseType: BaseType.FLOAT, dimension: null }, rightArg);
    rightStrandsNode = createStrandsNode(id2, dimension, strandsContext);
  }
  let finalLeftNodeID = leftStrandsNode.id;
  let finalRightNodeID = rightStrandsNode.id;
  const leftType = extractNodeTypeInfo(dag, leftStrandsNode.id);
  const rightType = extractNodeTypeInfo(dag, rightStrandsNode.id);
  const cast = { node: null, toType: leftType };
  const bothDeferred = leftType.baseType === rightType.baseType && leftType.baseType === BaseType.DEFER;
  if (bothDeferred) {
    cast.toType.baseType = BaseType.FLOAT;
    if (leftType.dimension === rightType.dimension) {
      cast.toType.dimension = leftType.dimension;
    } else if (leftType.dimension === 1 && rightType.dimension > 1) {
      cast.toType.dimension = rightType.dimension;
    } else if (rightType.dimension === 1 && leftType.dimension > 1) {
      cast.toType.dimension = leftType.dimension;
    } else {
      userError(
        "type error",
        `You have tried to perform a binary operation:
${leftType.baseType + leftType.dimension} ${OpCodeToSymbol[opCode]} ${rightType.baseType + rightType.dimension}
It's only possible to operate on two nodes with the same dimension, or a scalar value and a vector.`
      );
    }
    const l = primitiveConstructorNode(strandsContext, cast.toType, leftStrandsNode);
    const r = primitiveConstructorNode(strandsContext, cast.toType, rightStrandsNode);
    finalLeftNodeID = l.id;
    finalRightNodeID = r.id;
  } else if (leftType.baseType !== rightType.baseType || leftType.dimension !== rightType.dimension) {
    if (leftType.dimension === 1 && rightType.dimension > 1) {
      cast.node = leftStrandsNode;
      cast.toType = rightType;
    } else if (rightType.dimension === 1 && leftType.dimension > 1) {
      cast.node = rightStrandsNode;
      cast.toType = leftType;
    } else if (leftType.priority > rightType.priority) {
      cast.node = rightStrandsNode;
      cast.toType = leftType;
    } else if (rightType.priority > leftType.priority) {
      cast.node = leftStrandsNode;
      cast.toType = rightType;
    } else {
      userError("type error", `A vector of length ${leftType.dimension} operated with a vector of length ${rightType.dimension} is not allowed.`);
    }
    const casted = primitiveConstructorNode(strandsContext, cast.toType, cast.node);
    if (cast.node === leftStrandsNode) {
      leftStrandsNode = createStrandsNode(casted.id, casted.dimension, strandsContext);
      finalLeftNodeID = leftStrandsNode.id;
    } else {
      rightStrandsNode = createStrandsNode(casted.id, casted.dimension, strandsContext);
      finalRightNodeID = rightStrandsNode.id;
    }
  }
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode,
    dependsOn: [finalLeftNodeID, finalRightNodeID],
    baseType: cast.toType.baseType,
    dimension: cast.toType.dimension
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: nodeData.dimension };
}
function structInstanceNode(strandsContext, structTypeInfo, identifier, dependsOn) {
  const { cfg, dag } = strandsContext;
  if (dependsOn.length === 0) {
    for (const prop of structTypeInfo.properties) {
      const typeInfo = prop.dataType;
      const nodeData2 = createNodeData({
        nodeType: NodeType.VARIABLE,
        baseType: typeInfo.baseType,
        dimension: typeInfo.dimension,
        identifier: `${identifier}.${prop.name}`
      });
      const componentID = getOrCreateNode(dag, nodeData2);
      recordInBasicBlock(cfg, cfg.currentBlock, componentID);
      dependsOn.push(componentID);
    }
  }
  const nodeData = createNodeData({
    nodeType: NodeType.VARIABLE,
    dimension: structTypeInfo.properties.length,
    baseType: structTypeInfo.typeName,
    identifier,
    dependsOn
  });
  const structID = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, structID);
  return { id: structID, dimension: 0, components: dependsOn };
}
function mapPrimitiveDepsToIDs(strandsContext, typeInfo, dependsOn) {
  const inputs = Array.isArray(dependsOn) ? dependsOn : [dependsOn];
  const mappedDependencies = [];
  let { dimension, baseType } = typeInfo;
  const dag = strandsContext.dag;
  let calculatedDimensions = 0;
  let originalNodeID = null;
  for (const dep of inputs.flat(Infinity)) {
    if (dep && dep.isStrandsNode) {
      const node = getNodeDataFromID(dag, dep.id);
      originalNodeID = dep.id;
      baseType = node.baseType;
      if (node.opCode === OpCode.Nary.CONSTRUCTOR) {
        for (const inner of node.dependsOn) {
          mappedDependencies.push(inner);
        }
      } else {
        mappedDependencies.push(dep.id);
      }
      calculatedDimensions += node.dimension;
      continue;
    } else if (typeof dep === "number") {
      const { id, dimension: dimension2 } = scalarLiteralNode(strandsContext, { dimension: 1, baseType }, dep);
      mappedDependencies.push(id);
      calculatedDimensions += dimension2;
      continue;
    } else {
      userError("type error", `You've tried to construct a scalar or vector type with a non-numeric value: ${dep}`);
    }
  }
  if (dimension === null) {
    dimension = calculatedDimensions;
  } else if (dimension > calculatedDimensions && calculatedDimensions === 1) {
    calculatedDimensions = dimension;
  } else if (calculatedDimensions !== 1 && calculatedDimensions !== dimension) {
    userError("type error", `You've tried to construct a ${baseType + dimension} with ${calculatedDimensions} components`);
  }
  const inferredTypeInfo = {
    dimension,
    baseType,
    priority: BasePriority[baseType]
  };
  return { originalNodeID, mappedDependencies, inferredTypeInfo };
}
function constructTypeFromIDs(strandsContext, typeInfo, strandsNodesArray) {
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode: OpCode.Nary.CONSTRUCTOR,
    dimension: typeInfo.dimension,
    baseType: typeInfo.baseType,
    dependsOn: strandsNodesArray
  });
  const id = getOrCreateNode(strandsContext.dag, nodeData);
  return id;
}
function primitiveConstructorNode(strandsContext, typeInfo, dependsOn) {
  const cfg = strandsContext.cfg;
  const { mappedDependencies, inferredTypeInfo } = mapPrimitiveDepsToIDs(strandsContext, typeInfo, dependsOn);
  const finalType = {
    baseType: typeInfo.baseType,
    dimension: inferredTypeInfo.dimension
  };
  const id = constructTypeFromIDs(strandsContext, finalType, mappedDependencies);
  if (typeInfo.baseType !== BaseType.DEFER) {
    recordInBasicBlock(cfg, cfg.currentBlock, id);
  }
  return { id, dimension: finalType.dimension, components: mappedDependencies };
}
function structConstructorNode(strandsContext, structTypeInfo, rawUserArgs) {
  const { cfg, dag } = strandsContext;
  const { identifer, properties } = structTypeInfo;
  if (!(rawUserArgs.length === properties.length)) {
    userError(
      "type error",
      `You've tried to construct a ${structTypeInfo.typeName} struct with ${rawUserArgs.length} properties, but it expects ${properties.length} properties.
The properties it expects are:
${properties.map((prop) => prop.name + " " + prop.DataType.baseType + prop.DataType.dimension)}`
    );
  }
  const dependsOn = [];
  for (let i = 0; i < properties.length; i++) {
    const expectedProperty = properties[i];
    const { originalNodeID, mappedDependencies } = mapPrimitiveDepsToIDs(strandsContext, expectedProperty.dataType, rawUserArgs[i]);
    if (originalNodeID) {
      dependsOn.push(originalNodeID);
    } else {
      dependsOn.push(
        constructTypeFromIDs(strandsContext, expectedProperty.dataType, mappedDependencies)
      );
    }
  }
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode: OpCode.Nary.CONSTRUCTOR,
    dimension: properties.length,
    baseType: structTypeInfo.typeName,
    dependsOn
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: properties.length, components: structTypeInfo.components };
}
function functionCallNode(strandsContext, functionName, rawUserArgs, { overloads: rawOverloads } = {}) {
  const { cfg, dag } = strandsContext;
  const overloads = rawOverloads || strandsBuiltinFunctions[functionName];
  const preprocessedArgs = rawUserArgs.map((rawUserArg) => mapPrimitiveDepsToIDs(strandsContext, DataType.defer, rawUserArg));
  const matchingArgsCounts = overloads.filter((overload) => overload.params.length === preprocessedArgs.length);
  if (matchingArgsCounts.length === 0) {
    const argsLengthSet = /* @__PURE__ */ new Set();
    const argsLengthArr = [];
    overloads.forEach((overload) => argsLengthSet.add(overload.params.length));
    argsLengthSet.forEach((len) => argsLengthArr.push(`${len}`));
    const argsLengthStr = argsLengthArr.join(", or ");
    userError("parameter validation error", `Function '${functionName}' has ${overloads.length} variants which expect ${argsLengthStr} arguments, but ${preprocessedArgs.length} arguments were provided.`);
  }
  const isGeneric = (T2) => T2.dimension === null;
  let bestOverload = null;
  let bestScore = 0;
  let inferredReturnType = null;
  let inferredDimension = null;
  for (const overload of matchingArgsCounts) {
    let isValid = true;
    let similarity = 0;
    for (let i = 0; i < preprocessedArgs.length; i++) {
      const preArg = preprocessedArgs[i];
      const argType = preArg.inferredTypeInfo;
      const expectedType = overload.params[i];
      let dimension = expectedType.dimension;
      if (isGeneric(expectedType)) {
        if (inferredDimension === null || inferredDimension === 1) {
          inferredDimension = argType.dimension;
        }
        if (inferredDimension !== argType.dimension && !(argType.dimension === 1 && inferredDimension >= 1)) {
          isValid = false;
        }
        dimension = inferredDimension;
      } else {
        if (argType.dimension > dimension) {
          isValid = false;
        }
      }
      if (argType.baseType === expectedType.baseType) {
        similarity += 2;
      } else if (expectedType.priority > argType.priority) {
        similarity += 1;
      }
    }
    if (isValid && (!bestOverload || similarity > bestScore)) {
      bestOverload = overload;
      bestScore = similarity;
      inferredReturnType = { ...overload.returnType };
      if (isGeneric(inferredReturnType)) {
        inferredReturnType.dimension = inferredDimension;
      }
    }
  }
  if (bestOverload === null) {
    userError("parameter validation", `No matching overload for ${functionName} was found!`);
  }
  let dependsOn = [];
  for (let i = 0; i < bestOverload.params.length; i++) {
    const arg = preprocessedArgs[i];
    const paramType = { ...bestOverload.params[i] };
    if (isGeneric(paramType)) {
      paramType.dimension = inferredDimension;
    }
    if (arg.originalNodeID && typeEquals(arg.inferredTypeInfo, paramType)) {
      dependsOn.push(arg.originalNodeID);
    } else {
      const castedArgID = constructTypeFromIDs(strandsContext, paramType, arg.mappedDependencies);
      recordInBasicBlock(cfg, cfg.currentBlock, castedArgID);
      dependsOn.push(castedArgID);
    }
  }
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode: OpCode.Nary.FUNCTION_CALL,
    identifier: functionName,
    dependsOn,
    baseType: inferredReturnType.baseType,
    dimension: inferredReturnType.dimension
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: inferredReturnType.dimension };
}
function statementNode(strandsContext, statementType) {
  const { dag, cfg } = strandsContext;
  const nodeData = createNodeData({
    nodeType: NodeType.STATEMENT,
    statementType
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return id;
}
function swizzleNode(strandsContext, parentNode, swizzle) {
  const { dag, cfg } = strandsContext;
  const baseType = dag.baseTypes[parentNode.id];
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    baseType,
    dimension: swizzle.length,
    opCode: OpCode.Unary.SWIZZLE,
    dependsOn: [parentNode.id],
    swizzle
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: swizzle.length };
}
function swizzleTrap(id, dimension, strandsContext, onRebind) {
  const swizzleSets = [
    ["x", "y", "z", "w"],
    ["r", "g", "b", "a"],
    ["s", "t", "p", "q"]
  ].map((s) => s.slice(0, dimension));
  const trap = {
    get(target, property, receiver) {
      if (property in target) {
        return Reflect.get(...arguments);
      } else {
        for (const set2 of swizzleSets) {
          if ([...property.toString()].every((char) => set2.includes(char))) {
            const swizzle = [...property].map((char) => {
              const index = set2.indexOf(char);
              return swizzleSets[0][index];
            }).join("");
            const node = swizzleNode(strandsContext, target, swizzle);
            return createStrandsNode(node.id, node.dimension, strandsContext);
          }
        }
      }
    },
    set(target, property, value, receiver) {
      for (const swizzleSet of swizzleSets) {
        const chars = [...property];
        const valid = chars.every((c) => swizzleSet.includes(c)) && new Set(chars).size === chars.length && target.dimension >= chars.length;
        if (!valid) continue;
        const dim = target.dimension;
        const lanes = new Array(dim);
        for (let i = 0; i < dim; i++) {
          const { id: id2, dimension: dimension2 } = swizzleNode(strandsContext, target, "xyzw"[i]);
          lanes[i] = createStrandsNode(id2, dimension2, strandsContext);
        }
        let scalars = [];
        if (value instanceof StrandsNode) {
          if (value.dimension === 1) {
            scalars = Array(chars.length).fill(value);
          } else if (value.dimension === chars.length) {
            for (let k = 0; k < chars.length; k++) {
              const { id: id2, dimension: dimension2 } = swizzleNode(strandsContext, value, "xyzw"[k]);
              scalars.push(createStrandsNode(id2, dimension2, strandsContext));
            }
          } else {
            userError("type error", `Swizzle assignment: RHS vector does not match LHS vector (need ${chars.length}, got ${value.dimension}).`);
          }
        } else if (Array.isArray(value)) {
          const flat = value.flat(Infinity);
          if (flat.length === 1) {
            scalars = Array(chars.length).fill(flat[0]);
          } else if (flat.length === chars.length) {
            scalars = flat;
          } else {
            userError("type error", `Swizzle assignment: RHS length ${flat.length} does not match ${chars.length}.`);
          }
        } else if (typeof value === "number") {
          scalars = Array(chars.length).fill(value);
        } else {
          userError("type error", `Unsupported RHS for swizzle assignment: ${value}`);
        }
        for (let j2 = 0; j2 < chars.length; j2++) {
          const canonicalIndex = swizzleSet.indexOf(chars[j2]);
          lanes[canonicalIndex] = scalars[j2];
        }
        const orig = getNodeDataFromID(strandsContext.dag, target.id);
        const baseType = orig?.baseType ?? BaseType.FLOAT;
        const { id: newID } = primitiveConstructorNode(
          strandsContext,
          { baseType, dimension: dim },
          lanes
        );
        target.id = newID;
        if (typeof onRebind === "function") {
          onRebind(newID);
        }
        return true;
      }
      return Reflect.set(...arguments);
    }
  };
  return trap;
}
function shouldCreateTemp(dag, nodeID) {
  const nodeType = dag.nodeTypes[nodeID];
  if (nodeType !== NodeType.OPERATION) return false;
  if (dag.baseTypes[nodeID] === BaseType.SAMPLER2D) return false;
  const uses = dag.usedBy[nodeID] || [];
  return uses.length > 1;
}
const TypeNames = {
  "float1": "float",
  "float2": "vec2",
  "float3": "vec3",
  "float4": "vec4",
  "int1": "int",
  "int2": "ivec2",
  "int3": "ivec3",
  "int4": "ivec4",
  "bool1": "bool",
  "bool2": "bvec2",
  "bool3": "bvec3",
  "bool4": "bvec4",
  "mat2": "mat2x2",
  "mat3": "mat3x3",
  "mat4": "mat4x4"
};
const cfgHandlers = {
  [BlockType.DEFAULT]: (blockID, strandsContext, generationContext) => {
    const { dag, cfg } = strandsContext;
    const instructions = cfg.blockInstructions[blockID] || [];
    for (const nodeID of instructions) {
      const nodeType = dag.nodeTypes[nodeID];
      if (shouldCreateTemp(dag, nodeID)) {
        const declaration = glslBackend.generateDeclaration(generationContext, dag, nodeID);
        generationContext.write(declaration);
      }
      if (nodeType === NodeType.STATEMENT) {
        glslBackend.generateStatement(generationContext, dag, nodeID);
      }
      if (nodeType === NodeType.ASSIGNMENT) {
        glslBackend.generateAssignment(generationContext, dag, nodeID);
        generationContext.visitedNodes.add(nodeID);
      }
    }
  },
  [BlockType.BRANCH](blockID, strandsContext, generationContext) {
    const { dag, cfg } = strandsContext;
    const blockInstructions = cfg.blockInstructions[blockID] || [];
    for (const nodeID of blockInstructions) {
      const node = getNodeDataFromID(dag, nodeID);
      if (node.nodeType === NodeType.PHI) {
        const dependsOn = node.dependsOn || [];
        if (dependsOn.length > 0) {
          const firstDependency = dependsOn[0];
          const existingTempName = generationContext.tempNames[firstDependency];
          if (existingTempName) {
            generationContext.tempNames[nodeID] = existingTempName;
            continue;
          }
        }
        const tmp = `T${generationContext.nextTempID++}`;
        generationContext.tempNames[nodeID] = tmp;
        const T2 = extractNodeTypeInfo(dag, nodeID);
        const typeName = glslBackend.getTypeName(T2.baseType, T2.dimension);
        generationContext.write(`${typeName} ${tmp};`);
      }
    }
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.IF_COND](blockID, strandsContext, generationContext) {
    const { dag, cfg } = strandsContext;
    const conditionID = cfg.blockConditions[blockID];
    const condExpr = glslBackend.generateExpression(generationContext, dag, conditionID);
    generationContext.write(`if (${condExpr})`);
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.ELSE_COND](blockID, strandsContext, generationContext) {
    generationContext.write(`else`);
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.IF_BODY](blockID, strandsContext, generationContext) {
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
    this.assignPhiNodeValues(blockID, strandsContext, generationContext);
  },
  [BlockType.SCOPE_START](blockID, strandsContext, generationContext) {
    generationContext.write(`{`);
    generationContext.indent++;
  },
  [BlockType.SCOPE_END](blockID, strandsContext, generationContext) {
    generationContext.indent--;
    generationContext.write(`}`);
  },
  [BlockType.MERGE](blockID, strandsContext, generationContext) {
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.FUNCTION](blockID, strandsContext, generationContext) {
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.FOR](blockID, strandsContext, generationContext) {
    const { dag, cfg } = strandsContext;
    const instructions = cfg.blockInstructions[blockID] || [];
    generationContext.write(`for (`);
    const originalSuppressSemicolon = generationContext.suppressSemicolon;
    for (let i = 0; i < instructions.length; i++) {
      const nodeID = instructions[i];
      const node = getNodeDataFromID(dag, nodeID);
      const isLast = i === instructions.length - 1;
      generationContext.suppressSemicolon = isLast;
      if (shouldCreateTemp(dag, nodeID)) {
        const declaration = glslBackend.generateDeclaration(generationContext, dag, nodeID);
        generationContext.write(declaration);
      }
      if (node.nodeType === NodeType.STATEMENT) {
        glslBackend.generateStatement(generationContext, dag, nodeID);
      }
      if (node.nodeType === NodeType.ASSIGNMENT) {
        glslBackend.generateAssignment(generationContext, dag, nodeID);
        generationContext.visitedNodes.add(nodeID);
      }
    }
    generationContext.suppressSemicolon = originalSuppressSemicolon;
    generationContext.write(`)`);
  },
  assignPhiNodeValues(blockID, strandsContext, generationContext) {
    const { dag, cfg } = strandsContext;
    const successors = cfg.outgoingEdges[blockID] || [];
    for (const successorBlockID of successors) {
      const instructions = cfg.blockInstructions[successorBlockID] || [];
      for (const nodeID of instructions) {
        const node = getNodeDataFromID(dag, nodeID);
        if (node.nodeType === NodeType.PHI) {
          const branchIndex = node.phiBlocks?.indexOf(blockID);
          if (branchIndex !== -1 && branchIndex < node.dependsOn.length) {
            const sourceNodeID = node.dependsOn[branchIndex];
            const tempName = generationContext.tempNames[nodeID];
            if (tempName && sourceNodeID !== null) {
              const sourceExpr = glslBackend.generateExpression(generationContext, dag, sourceNodeID);
              generationContext.write(`${tempName} = ${sourceExpr};`);
            }
          }
        }
      }
    }
  }
};
const glslBackend = {
  hookEntry(hookType) {
    const firstLine = `(${hookType.parameters.flatMap((param) => {
      return `${param.qualifiers?.length ? param.qualifiers.join(" ") : ""}${param.type.typeName} ${param.name}`;
    }).join(", ")}) {`;
    return firstLine;
  },
  getTypeName(baseType, dimension) {
    const primitiveTypeName = TypeNames[baseType + dimension];
    if (!primitiveTypeName) {
      return baseType;
    }
    return primitiveTypeName;
  },
  generateHookUniformKey(name, typeInfo) {
    return `${this.getTypeName(typeInfo.baseType, typeInfo.dimension)} ${name}`;
  },
  generateVaryingVariable(varName, typeInfo) {
    return `${typeInfo.fnName} ${varName}`;
  },
  generateLocalDeclaration(varName, typeInfo) {
    const typeName = typeInfo.fnName;
    return `${typeName} ${varName};`;
  },
  generateStatement(generationContext, dag, nodeID) {
    const node = getNodeDataFromID(dag, nodeID);
    const semicolon = generationContext.suppressSemicolon ? "" : ";";
    if (node.statementType === StatementType.DISCARD) {
      generationContext.write(`discard${semicolon}`);
    } else if (node.statementType === StatementType.BREAK) {
      generationContext.write(`break${semicolon}`);
    } else if (node.statementType === StatementType.EXPRESSION) {
      const exprNodeID = node.dependsOn[0];
      const expr = this.generateExpression(generationContext, dag, exprNodeID);
      generationContext.write(`${expr}${semicolon}`);
    } else if (node.statementType === StatementType.EMPTY) {
      generationContext.write(semicolon);
    } else if (node.statementType === StatementType.EARLY_RETURN) {
      const exprNodeID = node.dependsOn[0];
      const expr = this.generateExpression(generationContext, dag, exprNodeID);
      generationContext.write(`return ${expr}${semicolon}`);
    }
  },
  generateAssignment(generationContext, dag, nodeID) {
    const node = getNodeDataFromID(dag, nodeID);
    const targetNodeID = node.dependsOn[0];
    const sourceNodeID = node.dependsOn[1];
    const targetExpr = this.generateExpression(generationContext, dag, targetNodeID);
    const sourceExpr = this.generateExpression(generationContext, dag, sourceNodeID);
    const semicolon = generationContext.suppressSemicolon ? "" : ";";
    if (targetExpr && sourceExpr && targetExpr !== sourceExpr) {
      generationContext.write(`${targetExpr} = ${sourceExpr}${semicolon}`);
    }
  },
  generateDeclaration(generationContext, dag, nodeID) {
    const expr = this.generateExpression(generationContext, dag, nodeID);
    const tmp = `T${generationContext.nextTempID++}`;
    generationContext.tempNames[nodeID] = tmp;
    const T2 = extractNodeTypeInfo(dag, nodeID);
    const typeName = this.getTypeName(T2.baseType, T2.dimension);
    return `${typeName} ${tmp} = ${expr};`;
  },
  generateReturnStatement(strandsContext, generationContext, rootNodeID, returnType) {
    const dag = strandsContext.dag;
    const rootNode = getNodeDataFromID(dag, rootNodeID);
    if (isStructType(returnType)) {
      const structTypeInfo = returnType;
      for (let i = 0; i < structTypeInfo.properties.length; i++) {
        const prop = structTypeInfo.properties[i];
        const val = this.generateExpression(generationContext, dag, rootNode.dependsOn[i]);
        if (prop.name !== val) {
          generationContext.write(
            `${rootNode.identifier}.${prop.name} = ${val};`
          );
        }
      }
    }
    generationContext.write(`return ${this.generateExpression(generationContext, dag, rootNodeID)};`);
  },
  generateExpression(generationContext, dag, nodeID) {
    const node = getNodeDataFromID(dag, nodeID);
    if (generationContext.tempNames?.[nodeID]) {
      return generationContext.tempNames[nodeID];
    }
    switch (node.nodeType) {
      case NodeType.LITERAL:
        if (node.baseType === BaseType.FLOAT) {
          return node.value.toFixed(4);
        } else {
          return node.value;
        }
      case NodeType.VARIABLE:
        if (generationContext.shaderContext && generationContext.strandsContext?.sharedVariables?.has(node.identifier)) {
          const sharedVar = generationContext.strandsContext.sharedVariables.get(node.identifier);
          if (generationContext.shaderContext === "vertex") {
            sharedVar.usedInVertex = true;
          } else if (generationContext.shaderContext === "fragment") {
            sharedVar.usedInFragment = true;
          }
        }
        return node.identifier;
      case NodeType.OPERATION:
        const useParantheses = node.usedBy.length > 0;
        if (node.opCode === OpCode.Nary.CONSTRUCTOR) {
          if (node.baseType === BaseType.SAMPLER2D) {
            return this.generateExpression(generationContext, dag, node.dependsOn[0]);
          }
          const T2 = this.getTypeName(node.baseType, node.dimension);
          const deps = node.dependsOn.map((dep) => this.generateExpression(generationContext, dag, dep));
          return `${T2}(${deps.join(", ")})`;
        }
        if (node.opCode === OpCode.Nary.FUNCTION_CALL) {
          const functionArgs = node.dependsOn.map((arg) => this.generateExpression(generationContext, dag, arg));
          return `${node.identifier}(${functionArgs.join(", ")})`;
        }
        if (node.opCode === OpCode.Binary.MEMBER_ACCESS) {
          const [lID, rID] = node.dependsOn;
          const lName = this.generateExpression(generationContext, dag, lID);
          const rName = this.generateExpression(generationContext, dag, rID);
          return `${lName}.${rName}`;
        }
        if (node.opCode === OpCode.Unary.SWIZZLE) {
          const parentID = node.dependsOn[0];
          const parentExpr = this.generateExpression(generationContext, dag, parentID);
          return `${parentExpr}.${node.swizzle}`;
        }
        if (node.dependsOn.length === 2) {
          const [lID, rID] = node.dependsOn;
          const left = this.generateExpression(generationContext, dag, lID);
          const right = this.generateExpression(generationContext, dag, rID);
          if (node.opCode === OpCode.Binary.MODULO) {
            const leftNode = getNodeDataFromID(dag, lID);
            const rightNode = getNodeDataFromID(dag, rID);
            if (leftNode.baseType === BaseType.FLOAT || rightNode.baseType === BaseType.FLOAT) {
              return `mod(${left}, ${right})`;
            }
            return `(${left} % ${right})`;
          }
          const opSym = OpCodeToSymbol[node.opCode];
          if (useParantheses) {
            return `(${left} ${opSym} ${right})`;
          } else {
            return `${left} ${opSym} ${right}`;
          }
        }
        if (node.opCode === OpCode.Unary.LOGICAL_NOT || node.opCode === OpCode.Unary.NEGATE || node.opCode === OpCode.Unary.PLUS) {
          const [i] = node.dependsOn;
          const val = this.generateExpression(generationContext, dag, i);
          const sym = OpCodeToSymbol[node.opCode];
          return `${sym}${val}`;
        }
      case NodeType.PHI:
        if (node.identifier) {
          return node.identifier;
        }
        if (generationContext.tempNames?.[nodeID]) {
          return generationContext.tempNames[nodeID];
        } else {
          const validInputs = node.dependsOn.filter((id) => id !== null);
          if (validInputs.length > 0) {
            return this.generateExpression(generationContext, dag, validInputs[0]);
          } else {
            throw new Error(`No valid inputs for node`);
          }
        }
      case NodeType.ASSIGNMENT:
        internalError(`ASSIGNMENT nodes should not be used as expressions`);
      default:
        internalError(`${NodeTypeToName[node.nodeType]} code generation not implemented yet`);
    }
  },
  generateBlock(blockID, strandsContext, generationContext) {
    const type2 = strandsContext.cfg.blockTypes[blockID];
    const handler2 = cfgHandlers[type2] || cfgHandlers[BlockType.DEFAULT];
    handler2.call(cfgHandlers, blockID, strandsContext, generationContext);
  },
  createGetTextureCall(strandsContext, args) {
    const { id, dimension } = functionCallNode(strandsContext, "getTexture", args, {
      overloads: [{
        params: [DataType.sampler2D, DataType.float2],
        returnType: DataType.float4
      }]
    });
    return { id, dimension };
  },
  instanceIdReference() {
    return "gl_InstanceID";
  }
};
function getShaderHookTypes(shader2, hookName) {
  let fullSrc = shader2._vertSrc;
  let body = shader2.hooks.vertex[hookName];
  if (!body) {
    body = shader2.hooks.fragment[hookName];
    fullSrc = shader2._fragSrc;
  }
  if (!body) {
    throw new Error(`Can't find hook ${hookName}!`);
  }
  const nameParts = hookName.split(/\s+/g);
  const functionName = nameParts.pop();
  const returnType = nameParts.pop();
  const returnQualifiers = [...nameParts];
  const parameterMatch = /\(([^\)]*)\)/.exec(body);
  if (!parameterMatch) {
    throw new Error(`Couldn't find function parameters in hook body:
${body}`);
  }
  const structProperties = (structName) => {
    const structDefMatch = new RegExp(`struct\\s+${structName}\\s*{([^}]*)}`).exec(fullSrc);
    if (!structDefMatch) return void 0;
    const properties = [];
    for (const defSrc of structDefMatch[1].split(";")) {
      const parts = defSrc.trim().split(/\s+|,/g);
      const typeName = parts.shift();
      const names = [...parts];
      const typeProperties = structProperties(typeName);
      for (const name of names) {
        const dataType2 = TypeInfoFromGLSLName[typeName] || null;
        properties.push({
          name,
          type: {
            typeName,
            qualifiers: [],
            properties: typeProperties,
            dataType: dataType2
          }
        });
      }
    }
    return properties;
  };
  const parameters = parameterMatch[1].split(",").map((paramString) => {
    const parts = paramString.trim().split(/\s+/g);
    const name = parts.pop();
    const typeName = parts.pop();
    const qualifiers = [...parts];
    const properties = structProperties(typeName);
    const dataType2 = TypeInfoFromGLSLName[typeName] || null;
    return {
      name,
      type: {
        typeName,
        qualifiers,
        properties,
        dataType: dataType2
      }
    };
  });
  const dataType = TypeInfoFromGLSLName[returnType] || null;
  return {
    name: functionName,
    returnType: {
      typeName: returnType,
      qualifiers: returnQualifiers,
      properties: structProperties(returnType),
      dataType
    },
    parameters
  };
}
class FilterRenderer2D {
  /**
   * Creates a new FilterRenderer2D instance.
   * @param {p5} parentRenderer - The p5.js instance.
   */
  constructor(parentRenderer) {
    this.parentRenderer = parentRenderer;
    this.canvas = document.createElement("canvas");
    this.canvas.width = parentRenderer.width;
    this.canvas.height = parentRenderer.height;
    let webglVersion = WEBGL2;
    this.gl = this.canvas.getContext("webgl2");
    if (!this.gl) {
      webglVersion = WEBGL;
      this.gl = this.canvas.getContext("webgl");
    }
    if (!this.gl) {
      console.error("WebGL not supported, cannot apply filter.");
      return;
    }
    this.textures = /* @__PURE__ */ new Map();
    this._renderer = {
      GL: this.gl,
      registerEnabled: /* @__PURE__ */ new Set(),
      _curShader: null,
      _emptyTexture: null,
      webglVersion,
      states: {
        textureWrapX: CLAMP,
        textureWrapY: CLAMP
      },
      _arraysEqual: (a, b2) => JSON.stringify(a) === JSON.stringify(b2),
      _getEmptyTexture: () => {
        if (!this._emptyTexture) {
          const im = new Image(1, 1);
          im.set(0, 0, 255);
          this._emptyTexture = new Texture(this._renderer, im);
        }
        return this._emptyTexture;
      },
      _initShader: (shader2) => {
        const gl = this.gl;
        const vertShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertShader, shader2.vertSrc());
        gl.compileShader(vertShader);
        if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
          throw new Error(`Yikes! An error occurred compiling the vertex shader: ${gl.getShaderInfoLog(vertShader)}`);
        }
        const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragShader, shader2.fragSrc());
        gl.compileShader(fragShader);
        if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
          throw new Error(`Darn! An error occurred compiling the fragment shader: ${gl.getShaderInfoLog(fragShader)}`);
        }
        const program = gl.createProgram();
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          throw new Error(
            `Snap! Error linking shader program: ${gl.getProgramInfoLog(program)}`
          );
        }
        shader2._glProgram = program;
        shader2._vertShader = vertShader;
        shader2._fragShader = fragShader;
      },
      getTexture: (input) => {
        let src = input;
        if (src instanceof Framebuffer) {
          src = src.color;
        }
        const texture2 = this.textures.get(src);
        if (texture2) {
          return texture2;
        }
        const tex = new Texture(this._renderer, src);
        this.textures.set(src, tex);
        return tex;
      },
      populateHooks: (shader2, src, shaderType) => {
        return populateGLSLHooks(shader2, src, shaderType);
      },
      _getShaderAttributes: (shader2) => {
        return getWebGLShaderAttributes(shader2, this.gl);
      },
      getUniformMetadata: (shader2) => {
        return getWebGLUniformMetadata(shader2, this.gl);
      },
      _finalizeShader: () => {
      },
      _useShader: (shader2) => {
        this.gl.useProgram(shader2._glProgram);
      },
      bindTexture: (tex) => {
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex.getTexture().texture);
      },
      unbindTexture: () => {
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
      },
      _unbindFramebufferTexture: (uniform) => {
        const gl = this.gl;
        const empty2 = this._getEmptyTexture();
        gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
        empty2.bindTexture();
        gl.uniform1i(uniform.location, uniform.samplerIndex);
      },
      createTexture: ({ width, height, format, dataType }) => {
        const gl = this.gl;
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          width,
          height,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          null
        );
        return { texture: tex, glFormat: gl.RGBA, glDataType: gl.UNSIGNED_BYTE };
      },
      uploadTextureFromSource: ({ texture: texture2, glFormat, glDataType }, source) => {
        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture2);
        gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, glFormat, glDataType, source);
      },
      uploadTextureFromData: ({ texture: texture2, glFormat, glDataType }, data2, width, height) => {
        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture2);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          glFormat,
          width,
          height,
          0,
          glFormat,
          glDataType,
          data2
        );
      },
      setTextureParams: (texture2) => {
        return setWebGLTextureParams(texture2, this.gl, this._renderer.webglVersion);
      },
      updateUniformValue: (shader2, uniform, data2) => {
        return setWebGLUniformValue(
          shader2,
          uniform,
          data2,
          (tex) => this._renderer.getTexture(tex),
          this.gl
        );
      },
      _enableAttrib: (_shader, attr, size, type2, normalized, stride, offset2) => {
        const loc = attr.location;
        const gl = this.gl;
        if (!this._renderer.registerEnabled.has(loc)) {
          gl.enableVertexAttribArray(loc);
          this._renderer.registerEnabled.add(loc);
        }
        gl.vertexAttribPointer(
          loc,
          size,
          type2 || gl.FLOAT,
          normalized || false,
          stride || 0,
          offset2 || 0
        );
      },
      _disableRemainingAttributes: (shader2) => {
        for (const location2 of this._renderer.registerEnabled.values()) {
          if (!Object.keys(shader2.attributes).some(
            (key) => shader2.attributes[key].location === location2
          )) {
            this.gl.disableVertexAttribArray(location2);
            this._renderer.registerEnabled.delete(location2);
          }
        }
      },
      _updateTexture: (uniform, tex) => {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
        tex.bindTexture();
        tex.update();
        gl.uniform1i(uniform.location, uniform.samplerIndex);
      },
      baseFilterShader: () => this.baseFilterShader(),
      strandsBackend: glslBackend,
      getShaderHookTypes: (shader2, hookName) => getShaderHookTypes(shader2, hookName),
      uniformNameFromHookKey: (key) => key.slice(key.indexOf(" ") + 1)
    };
    this._baseFilterShader = void 0;
    this.filterShaders = {};
    this.operation = null;
    this.filterParameter = 1;
    this.customShader = null;
    this._shader = null;
    this.vertexBuffer = this.gl.createBuffer();
    this.texcoordBuffer = this.gl.createBuffer();
    this.vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    this.texcoords = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
    this._bindBufferData(
      this.vertexBuffer,
      this.gl.ARRAY_BUFFER,
      this.vertices
    );
    this._bindBufferData(
      this.texcoordBuffer,
      this.gl.ARRAY_BUFFER,
      this.texcoords
    );
  }
  _webGL2CompatibilityPrefix(shaderType, floatPrecision) {
    let code2 = "";
    if (this._renderer.webglVersion === WEBGL2) {
      code2 += "#version 300 es\n#define WEBGL2\n";
    }
    if (shaderType === "vert") {
      code2 += "#define VERTEX_SHADER\n";
    } else if (shaderType === "frag") {
      code2 += "#define FRAGMENT_SHADER\n";
    }
    if (floatPrecision) {
      code2 += `precision ${floatPrecision} float;
`;
    }
    return code2;
  }
  baseFilterShader() {
    if (!this._baseFilterShader) {
      this._baseFilterShader = new Shader(
        this._renderer,
        this._webGL2CompatibilityPrefix("vert", "highp") + webgl2CompatibilityShader + filterBaseVert,
        this._webGL2CompatibilityPrefix("frag", "highp") + webgl2CompatibilityShader + filterBaseFrag,
        {
          vertex: {},
          fragment: {
            "vec4 getColor": `(FilterInputs inputs, in sampler2D canvasContent) {
              return getTexture(canvasContent, inputs.texCoord);
            }`
          }
        }
      );
    }
    return this._baseFilterShader;
  }
  getNoiseShaderSnippet() {
    return noiseGLSL;
  }
  /**
   * Set the current filter operation and parameter. If a customShader is provided,
   * that overrides the operation-based shader.
   * @param {String} operation - The filter operation type (e.g., constants.BLUR).
   * @param {Number} filterParameter - The strength of the filter.
   * @param {p5.Shader} customShader - Optional custom shader.
   */
  setOperation(operation, filterParameter, customShader = null) {
    this.operation = operation;
    this.filterParameter = filterParameter;
    let useDefaultParam = operation in filterParamDefaults && filterParameter === void 0;
    if (useDefaultParam) {
      this.filterParameter = filterParamDefaults[operation];
    }
    this.customShader = customShader;
    this._initializeShader();
  }
  /**
   * Initializes or retrieves the shader program for the current operation.
   * If a customShader is provided, that is used.
   * Otherwise, returns a cached shader if available, or creates a new one, caches it, and sets it as current.
   */
  _initializeShader() {
    if (this.customShader) {
      this._shader = this.customShader;
      return;
    }
    if (!this.operation) {
      console.error("No operation set for FilterRenderer2D, cannot initialize shader.");
      return;
    }
    if (this.filterShaders[this.operation]) {
      this._shader = this.filterShaders[this.operation];
      return;
    }
    const newShader = makeFilterShader(this._renderer, this.operation, this.parentRenderer._pInst);
    this.filterShaders[this.operation] = newShader;
    this._shader = newShader;
  }
  /**
   * Binds a buffer to the drawing context
   * when passed more than two arguments it also updates or initializes
   * the data associated with the buffer
   */
  _bindBufferData(buffer, target, values) {
    const gl = this.gl;
    gl.bindBuffer(target, buffer);
    gl.bufferData(target, values, gl.STATIC_DRAW);
  }
  get canvasTexture() {
    if (!this._canvasTexture) {
      this._canvasTexture = new Texture(this._renderer, this.parentRenderer.wrappedElt);
    }
    return this._canvasTexture;
  }
  /**
   * Prepares and runs the full-screen quad draw call.
   */
  _renderPass() {
    const gl = this.gl;
    this._shader.bindShader("fill");
    const pixelDensity = this.parentRenderer.pixelDensity ? this.parentRenderer.pixelDensity() : 1;
    const texelSize = [
      1 / (this.parentRenderer.width * pixelDensity),
      1 / (this.parentRenderer.height * pixelDensity)
    ];
    const canvasTexture = this.canvasTexture;
    this._shader.setUniform("tex0", canvasTexture);
    this._shader.setUniform("texelSize", texelSize);
    this._shader.setUniform("canvasSize", [this.parentRenderer.width, this.parentRenderer.height]);
    this._shader.setUniform("radius", Math.max(1, this.filterParameter));
    this._shader.setUniform("filterParameter", this.filterParameter);
    this._shader.setDefaultUniforms();
    this.parentRenderer.states.setValue("rectMode", CORNER);
    this.parentRenderer.states.setValue("imageMode", CORNER);
    this.parentRenderer.blendMode(BLEND);
    this.parentRenderer.resetMatrix();
    const identityMatrix = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    this._shader.setUniform("uModelViewMatrix", identityMatrix);
    this._shader.setUniform("uProjectionMatrix", identityMatrix);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    this._shader.enableAttrib(this._shader.attributes.aPosition, 2);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
    this._shader.enableAttrib(this._shader.attributes.aTexCoord, 2);
    this._shader.bindTextures();
    this._renderer._disableRemainingAttributes(this._shader);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    this._shader.unbindShader();
  }
  /**
   * Applies the current filter operation. If the filter requires multiple passes (e.g. blur),
   * it handles those internally. Make sure setOperation() has been called before applyFilter().
   */
  applyFilter() {
    if (!this._shader) {
      console.error("Cannot apply filter: shader not initialized.");
      return;
    }
    this.parentRenderer.push();
    this.parentRenderer.resetMatrix();
    if (this.operation === BLUR && !this.customShader) {
      this._shader.setUniform("direction", [1, 0]);
      this._renderPass();
      this.parentRenderer.clear();
      this.parentRenderer.drawingContext.drawImage(
        this.canvas,
        0,
        0,
        this.parentRenderer.width,
        this.parentRenderer.height
      );
      this._shader.setUniform("direction", [0, 1]);
      this._renderPass();
      this.parentRenderer.clear();
      this.parentRenderer.drawingContext.drawImage(
        this.canvas,
        0,
        0,
        this.parentRenderer.width,
        this.parentRenderer.height
      );
    } else {
      this._renderPass();
      this.parentRenderer.clear();
      this.parentRenderer.blendMode(BLEND);
      this.parentRenderer.drawingContext.drawImage(
        this.canvas,
        0,
        0,
        this.parentRenderer.width,
        this.parentRenderer.height
      );
    }
    this.parentRenderer.pop();
  }
}
const styleEmpty = "rgba(0,0,0,0)";
class Renderer2D extends Renderer {
  constructor(pInst, w, h, isMainCanvas, elt, attributes2 = {}) {
    super(pInst, w, h, isMainCanvas);
    this.canvas = this.elt = elt || document.createElement("canvas");
    if (isMainCanvas) {
      this._pInst._curElement = this;
      this._pInst.canvas = this.canvas;
    } else {
      this.canvas.style.display = "none";
    }
    this.elt.id = "defaultCanvas0";
    this.elt.classList.add("p5Canvas");
    for (const p2 of Object.getOwnPropertyNames(Element.prototype)) {
      if (p2 !== "constructor" && p2[0] !== "_") {
        Object.defineProperty(this, p2, {
          get() {
            return this.wrappedElt[p2];
          }
        });
      }
    }
    this.elt.width = w * this._pixelDensity;
    this.elt.height = h * this._pixelDensity;
    this.elt.style.width = `${w}px`;
    this.elt.style.height = `${h}px`;
    if (this._pInst._userNode) {
      this._pInst._userNode.appendChild(this.elt);
    } else {
      if (document.getElementsByTagName("main").length === 0) {
        let m = document.createElement("main");
        document.body.appendChild(m);
      }
      document.getElementsByTagName("main")[0].appendChild(this.elt);
    }
    this.drawingContext = this.canvas.getContext("2d", attributes2);
    if (attributes2.colorSpace === "display-p3") {
      this.states.colorMode = RGBHDR;
    }
    this.scale(this._pixelDensity, this._pixelDensity);
    this.wrappedElt = new Element(this.elt, this._pInst);
    this.clipPath = null;
  }
  get filterRenderer() {
    if (!this._filterRenderer) {
      this._filterRenderer = new FilterRenderer2D(this);
    }
    return this._filterRenderer;
  }
  remove() {
    this.wrappedElt.remove();
    this.wrappedElt = null;
    this.canvas = null;
    this.elt = null;
  }
  getFilterGraphicsLayer() {
    if (!this.filterGraphicsLayer) {
      const pInst = this._pInst;
      this.filterGraphicsLayer = new Graphics(
        this.width,
        this.height,
        WEBGL,
        pInst
      );
    }
    if (this.filterGraphicsLayer.width !== this.width || this.filterGraphicsLayer.height !== this.height) {
      this.filterGraphicsLayer.resizeCanvas(this.width, this.height);
    }
    if (this.filterGraphicsLayer.pixelDensity() !== this._pInst.pixelDensity()) {
      this.filterGraphicsLayer.pixelDensity(this._pInst.pixelDensity());
    }
    return this.filterGraphicsLayer;
  }
  _applyDefaults() {
    this.states.setValue("_cachedFillStyle", void 0);
    this.states.setValue("_cachedStrokeStyle", void 0);
    this._cachedBlendMode = BLEND;
    this._setFill(_DEFAULT_FILL);
    this._setStroke(_DEFAULT_STROKE);
    this.drawingContext.lineCap = ROUND;
    this.drawingContext.font = "normal 12px sans-serif";
  }
  resize(w, h) {
    super.resize(w, h);
    const props = {};
    for (const key in this.drawingContext) {
      const val = this.drawingContext[key];
      if (typeof val !== "object" && typeof val !== "function") {
        props[key] = val;
      }
    }
    this.canvas.width = w * this._pixelDensity;
    this.canvas.height = h * this._pixelDensity;
    this.canvas.style.width = `${w}px`;
    this.canvas.style.height = `${h}px`;
    this.drawingContext.scale(
      this._pixelDensity,
      this._pixelDensity
    );
    for (const savedKey in props) {
      try {
        this.drawingContext[savedKey] = props[savedKey];
      } catch (err) {
      }
    }
  }
  //////////////////////////////////////////////
  // COLOR | Setting
  //////////////////////////////////////////////
  background(...args) {
    this.push();
    this.resetMatrix();
    if (args[0] instanceof Image) {
      if (args[1] >= 0) {
        const img = args[0];
        this.drawingContext.globalAlpha = args[1] / 255;
        this._pInst.image(img, 0, 0, this.width, this.height);
      } else {
        this._pInst.image(args[0], 0, 0, this.width, this.height);
      }
    } else {
      const color2 = this._pInst.color(...args);
      if (this._pInst._addAccsOutput?.()) {
        this._pInst._accsBackground?.(color2._getRGBA([255, 255, 255, 255]));
      }
      const newFill = color2.toString();
      this._setFill(newFill);
      if (this._isErasing) {
        this.blendMode(this._cachedBlendMode);
      }
      this.drawingContext.fillRect(0, 0, this.width, this.height);
      if (this._isErasing) {
        this._pInst.erase();
      }
    }
    this.pop();
  }
  clear() {
    this.drawingContext.save();
    this.resetMatrix();
    this.drawingContext.clearRect(0, 0, this.width, this.height);
    this.drawingContext.restore();
  }
  fill(...args) {
    super.fill(...args);
    const color2 = this.states.fillColor;
    this._setFill(color2.toString());
    if (this._pInst._addAccsOutput?.()) {
      this._pInst._accsCanvasColors?.("fill", color2._getRGBA([255, 255, 255, 255]));
    }
  }
  stroke(...args) {
    super.stroke(...args);
    const color2 = this.states.strokeColor;
    this._setStroke(color2.toString());
    if (this._pInst._addAccsOutput?.()) {
      this._pInst._accsCanvasColors?.("stroke", color2._getRGBA([255, 255, 255, 255]));
    }
  }
  erase(opacityFill, opacityStroke) {
    if (!this._isErasing) {
      this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
      const newFill = this._pInst.color(255, opacityFill).toString();
      this.drawingContext.fillStyle = newFill;
      this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
      const newStroke = this._pInst.color(255, opacityStroke).toString();
      this.drawingContext.strokeStyle = newStroke;
      const tempBlendMode = this._cachedBlendMode;
      this.blendMode(REMOVE);
      this._cachedBlendMode = tempBlendMode;
      this._isErasing = true;
    }
  }
  noErase() {
    if (this._isErasing) {
      this.drawingContext.fillStyle = this.states._cachedFillStyle;
      this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
      this.blendMode(this._cachedBlendMode);
      this._isErasing = false;
    }
  }
  drawShape(shape2) {
    const visitor = new PrimitiveToPath2DConverter({
      strokeWeight: this.states.strokeWeight
    });
    shape2.accept(visitor);
    if (this._clipping) {
      this.clipPath.addPath(visitor.path);
      this.clipPath.closePath();
    } else {
      if (this.states.fillColor) {
        this.drawingContext.fill(visitor.path);
      }
      if (this.states.strokeColor) {
        this.drawingContext.stroke(visitor.path);
      }
    }
  }
  beginClip(options2 = {}) {
    super.beginClip(options2);
    this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
    const newFill = this._pInst.color(255, 0).toString();
    this.drawingContext.fillStyle = newFill;
    this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
    const newStroke = this._pInst.color(255, 0).toString();
    this.drawingContext.strokeStyle = newStroke;
    const tempBlendMode = this._cachedBlendMode;
    this.blendMode(BLEND);
    this._cachedBlendMode = tempBlendMode;
    this.clipPath = new Path2D();
    this._clipBaseTransform = this.drawingContext.getTransform();
    if (this._clipInvert) {
      this.clipPath.moveTo(
        -2 * this.width,
        -2 * this.height
      );
      this.clipPath.lineTo(
        -2 * this.width,
        2 * this.height
      );
      this.clipPath.lineTo(
        2 * this.width,
        2 * this.height
      );
      this.clipPath.lineTo(
        2 * this.width,
        -2 * this.height
      );
      this.clipPath.closePath();
    }
  }
  endClip() {
    const savedTransform = this.drawingContext.getTransform();
    this.drawingContext.setTransform(this._clipBaseTransform);
    this.drawingContext.clip(this.clipPath);
    this.drawingContext.setTransform(savedTransform);
    this.clipPath = null;
    super.endClip();
    this.drawingContext.fillStyle = this.states._cachedFillStyle;
    this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
    this.blendMode(this._cachedBlendMode);
  }
  //////////////////////////////////////////////
  // IMAGE | Loading & Displaying
  //////////////////////////////////////////////
  image(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    let cnv;
    if (img.gifProperties) {
      img._animateGif(this._pInst);
    }
    try {
      if (img instanceof MediaElement) {
        img._ensureCanvas();
      }
      if (this.states.tint && img.canvas) {
        cnv = this._getTintedImageCanvas(img);
      }
      if (!cnv) {
        cnv = img.canvas || img.elt;
      }
      let s = 1;
      if (img.width && img.width > 0) {
        s = cnv.width / img.width;
      }
      if (this._isErasing) {
        this.blendMode(this._cachedBlendMode);
      }
      this.drawingContext.drawImage(
        cnv,
        s * sx,
        s * sy,
        s * sWidth,
        s * sHeight,
        dx,
        dy,
        dWidth,
        dHeight
      );
      if (this._isErasing) {
        this._pInst.erase();
      }
    } catch (e2) {
      if (e2.name !== "NS_ERROR_NOT_AVAILABLE") {
        throw e2;
      }
    }
  }
  _getTintedImageCanvas(img) {
    if (!img.canvas) {
      return img;
    }
    if (!img.tintCanvas) {
      img.tintCanvas = document.createElement("canvas");
    }
    if (img.tintCanvas.width !== img.canvas.width) {
      img.tintCanvas.width = img.canvas.width;
    }
    if (img.tintCanvas.height !== img.canvas.height) {
      img.tintCanvas.height = img.canvas.height;
    }
    const ctx = img.tintCanvas.getContext("2d");
    ctx.save();
    ctx.clearRect(0, 0, img.canvas.width, img.canvas.height);
    if (this.states.tint[0] < 255 || this.states.tint[1] < 255 || this.states.tint[2] < 255) {
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "luminosity";
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "color";
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "multiply";
      ctx.fillStyle = `rgb(${this.states.tint.slice(0, 3).join(", ")})`;
      ctx.fillRect(0, 0, img.canvas.width, img.canvas.height);
      ctx.globalCompositeOperation = "destination-in";
      ctx.globalAlpha = this.states.tint[3] / 255;
      ctx.drawImage(img.canvas, 0, 0);
    } else {
      ctx.globalAlpha = this.states.tint[3] / 255;
      ctx.drawImage(img.canvas, 0, 0);
    }
    ctx.restore();
    return img.tintCanvas;
  }
  //////////////////////////////////////////////
  // IMAGE | Pixels
  //////////////////////////////////////////////
  blendMode(mode) {
    if (mode === SUBTRACT) {
      console.warn("blendMode(SUBTRACT) only works in WEBGL mode.");
    } else if (mode === BLEND || mode === REMOVE || mode === DARKEST || mode === LIGHTEST || mode === DIFFERENCE || mode === MULTIPLY || mode === EXCLUSION || mode === SCREEN || mode === REPLACE || mode === OVERLAY || mode === HARD_LIGHT || mode === SOFT_LIGHT || mode === DODGE || mode === BURN || mode === ADD) {
      this._cachedBlendMode = mode;
      this.drawingContext.globalCompositeOperation = mode;
    } else {
      throw new Error(`Mode ${mode} not recognized.`);
    }
  }
  blend(...args) {
    const currBlend = this.drawingContext.globalCompositeOperation;
    const blendMode = args[args.length - 1];
    const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
    this.drawingContext.globalCompositeOperation = blendMode;
    p5$2.prototype.copy.apply(this, copyArgs);
    this.drawingContext.globalCompositeOperation = currBlend;
  }
  // p5.Renderer2D.prototype.get = p5.Renderer.prototype.get;
  // .get() is not overridden
  // x,y are canvas-relative (pre-scaled by _pixelDensity)
  _getPixel(x, y) {
    let imageData, index;
    imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
    index = 0;
    return [
      imageData[index + 0],
      imageData[index + 1],
      imageData[index + 2],
      imageData[index + 3]
    ];
  }
  loadPixels() {
    const pd = this._pixelDensity;
    const w = this.width * pd;
    const h = this.height * pd;
    const imageData = this.drawingContext.getImageData(0, 0, w, h);
    this.imageData = imageData;
    this.pixels = imageData.data;
  }
  set(x, y, imgOrCol) {
    x = Math.floor(x);
    y = Math.floor(y);
    if (imgOrCol instanceof Graphics || imgOrCol instanceof Image) {
      this.drawingContext.save();
      this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
      this.drawingContext.scale(
        this._pixelDensity,
        this._pixelDensity
      );
      const width = imgOrCol.width;
      const height = imgOrCol.height;
      this.drawingContext.clearRect(x, y, width, height);
      this.drawingContext.drawImage(imgOrCol.canvas, x, y, width, height);
    } else {
      let r = 0, g2 = 0, b2 = 0, a = 0;
      let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);
      if (!this.imageData) {
        this.loadPixels();
      }
      if (typeof imgOrCol === "number") {
        if (idx < this.pixels.length) {
          r = imgOrCol;
          g2 = imgOrCol;
          b2 = imgOrCol;
          a = 255;
        }
      } else if (Array.isArray(imgOrCol)) {
        if (imgOrCol.length < 4) {
          throw new Error("pixel array must be of the form [R, G, B, A]");
        }
        if (idx < this.pixels.length) {
          r = imgOrCol[0];
          g2 = imgOrCol[1];
          b2 = imgOrCol[2];
          a = imgOrCol[3];
        }
      } else if (imgOrCol instanceof p5$2.Color) {
        if (idx < this.pixels.length) {
          [r, g2, b2, a] = imgOrCol._getRGBA([255, 255, 255, 255]);
        }
      }
      for (let i = 0; i < this._pixelDensity; i++) {
        for (let j2 = 0; j2 < this._pixelDensity; j2++) {
          idx = 4 * ((y * this._pixelDensity + j2) * this.width * this._pixelDensity + (x * this._pixelDensity + i));
          this.pixels[idx] = r;
          this.pixels[idx + 1] = g2;
          this.pixels[idx + 2] = b2;
          this.pixels[idx + 3] = a;
        }
      }
    }
  }
  updatePixels(x, y, w, h) {
    const pd = this._pixelDensity;
    if (x === void 0 && y === void 0 && w === void 0 && h === void 0) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    }
    x *= pd;
    y *= pd;
    w *= pd;
    h *= pd;
    if (this.gifProperties) {
      this.gifProperties.frames[this.gifProperties.displayIndex].image = this.imageData;
    }
    this.drawingContext.putImageData(this.imageData, 0, 0, x, y, w, h);
  }
  //////////////////////////////////////////////
  // SHAPE | 2D Primitives
  //////////////////////////////////////////////
  /*
   * This function requires that:
   *
   *   0 <= start < TWO_PI
   *
   *   start <= stop < start + TWO_PI
   */
  arc(x, y, w, h, start2, stop, mode) {
    const ctx = this.drawingContext;
    const centerX = x + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
    if (this._clipping) {
      const tempPath = new Path2D();
      tempPath.ellipse(centerX, centerY, radiusX, radiusY, 0, start2, stop);
      const currentTransform = this.drawingContext.getTransform();
      const clipBaseTransform = this._clipBaseTransform.inverse();
      const relativeTransform = clipBaseTransform.multiply(currentTransform);
      this.clipPath.addPath(tempPath, relativeTransform);
      return this;
    }
    const createPieSlice = !(mode === CHORD || mode === OPEN || (stop - start2) % TWO_PI === 0);
    if (this.states.fillColor) {
      ctx.beginPath();
      ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start2, stop);
      if (createPieSlice) ctx.lineTo(centerX, centerY);
      ctx.closePath();
      ctx.fill();
    }
    if (this.states.strokeColor) {
      ctx.beginPath();
      ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start2, stop);
      if (mode === PIE && createPieSlice) {
        ctx.lineTo(centerX, centerY);
      }
      if (mode === PIE || mode === CHORD) {
        ctx.closePath();
      }
      ctx.stroke();
    }
    return this;
  }
  ellipse(args) {
    const ctx = this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    const x = parseFloat(args[0]), y = parseFloat(args[1]), w = parseFloat(args[2]), h = parseFloat(args[3]);
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    const centerX = x + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
    if (this._clipping) {
      const tempPath = new Path2D();
      tempPath.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
      const currentTransform = this.drawingContext.getTransform();
      const clipBaseTransform = this._clipBaseTransform.inverse();
      const relativeTransform = clipBaseTransform.multiply(currentTransform);
      this.clipPath.addPath(tempPath, relativeTransform);
      return this;
    }
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
    ctx.closePath();
    if (doFill) {
      ctx.fill();
    }
    if (doStroke) {
      ctx.stroke();
    }
    return this;
  }
  line(x1, y1, x2, y2) {
    const ctx = this.drawingContext;
    if (!this.states.strokeColor) {
      return this;
    } else if (this._getStroke() === styleEmpty) {
      return this;
    }
    if (this._clipping) {
      const tempPath = new Path2D();
      tempPath.moveTo(x1, y1);
      tempPath.lineTo(x2, y2);
      const currentTransform = this.drawingContext.getTransform();
      const clipBaseTransform = this._clipBaseTransform.inverse();
      const relativeTransform = clipBaseTransform.multiply(currentTransform);
      this.clipPath.addPath(tempPath, relativeTransform);
      return this;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    return this;
  }
  point(x, y) {
    const ctx = this.drawingContext;
    if (!this.states.strokeColor) {
      return this;
    } else if (this._getStroke() === styleEmpty) {
      return this;
    }
    const s = this._getStroke();
    const f = this._getFill();
    if (this._clipping) {
      const tempPath = new Path2D();
      const drawingContextWidth = this.drawingContext.lineWidth;
      tempPath.arc(x, y, drawingContextWidth / 2, 0, TWO_PI);
      const currentTransform = this.drawingContext.getTransform();
      const clipBaseTransform = this._clipBaseTransform.inverse();
      const relativeTransform = clipBaseTransform.multiply(currentTransform);
      this.clipPath.addPath(tempPath, relativeTransform);
      return this;
    }
    this._setFill(s);
    ctx.beginPath();
    ctx.arc(x, y, ctx.lineWidth / 2, 0, TWO_PI, false);
    ctx.fill();
    this._setFill(f);
    return this;
  }
  quad(x1, y1, x2, y2, x3, y3, x4, y4) {
    const ctx = this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (this._clipping) {
      const tempPath = new Path2D();
      tempPath.moveTo(x1, y1);
      tempPath.lineTo(x2, y2);
      tempPath.lineTo(x3, y3);
      tempPath.lineTo(x4, y4);
      tempPath.closePath();
      const currentTransform = this.drawingContext.getTransform();
      const clipBaseTransform = this._clipBaseTransform.inverse();
      const relativeTransform = clipBaseTransform.multiply(currentTransform);
      this.clipPath.addPath(tempPath, relativeTransform);
      return this;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.lineTo(x4, y4);
    ctx.closePath();
    if (doFill) {
      ctx.fill();
    }
    if (doStroke) {
      ctx.stroke();
    }
    return this;
  }
  rect(args) {
    const x = args[0];
    const y = args[1];
    const w = args[2];
    const h = args[3];
    let tl = args[4];
    let tr = args[5];
    let br = args[6];
    let bl = args[7];
    const ctx = this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (this._clipping) {
      const tempPath = new Path2D();
      if (typeof tl === "undefined") {
        tempPath.rect(x, y, w, h);
      } else {
        tempPath.roundRect(x, y, w, h, [tl, tr, br, bl]);
      }
      const currentTransform = this.drawingContext.getTransform();
      const clipBaseTransform = this._clipBaseTransform.inverse();
      const relativeTransform = clipBaseTransform.multiply(currentTransform);
      this.clipPath.addPath(tempPath, relativeTransform);
      return this;
    }
    ctx.beginPath();
    if (typeof tl === "undefined") {
      ctx.rect(x, y, w, h);
    } else {
      if (typeof tr === "undefined") {
        tr = tl;
      }
      if (typeof br === "undefined") {
        br = tr;
      }
      if (typeof bl === "undefined") {
        bl = br;
      }
      const absW = Math.abs(w);
      const absH = Math.abs(h);
      const hw = absW / 2;
      const hh = absH / 2;
      if (absW < 2 * tl) {
        tl = hw;
      }
      if (absH < 2 * tl) {
        tl = hh;
      }
      if (absW < 2 * tr) {
        tr = hw;
      }
      if (absH < 2 * tr) {
        tr = hh;
      }
      if (absW < 2 * br) {
        br = hw;
      }
      if (absH < 2 * br) {
        br = hh;
      }
      if (absW < 2 * bl) {
        bl = hw;
      }
      if (absH < 2 * bl) {
        bl = hh;
      }
      ctx.roundRect(x, y, w, h, [tl, tr, br, bl]);
    }
    if (doFill) {
      ctx.fill();
    }
    if (doStroke) {
      ctx.stroke();
    }
    return this;
  }
  triangle(args) {
    const ctx = this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    const x1 = args[0], y1 = args[1];
    const x2 = args[2], y2 = args[3];
    const x3 = args[4], y3 = args[5];
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (this._clipping) {
      const tempPath = new Path2D();
      tempPath.moveTo(x1, y1);
      tempPath.lineTo(x2, y2);
      tempPath.lineTo(x3, y3);
      tempPath.closePath();
      const currentTransform = this.drawingContext.getTransform();
      const clipBaseTransform = this._clipBaseTransform.inverse();
      const relativeTransform = clipBaseTransform.multiply(currentTransform);
      this.clipPath.addPath(tempPath, relativeTransform);
      return this;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
    if (doFill) {
      ctx.fill();
    }
    if (doStroke) {
      ctx.stroke();
    }
    return this;
  }
  //////////////////////////////////////////////
  // SHAPE | Attributes
  //////////////////////////////////////////////
  strokeCap(cap) {
    if (cap === ROUND || cap === SQUARE || cap === PROJECT) {
      this.drawingContext.lineCap = cap;
    }
    return this;
  }
  strokeJoin(join) {
    if (join === ROUND || join === BEVEL || join === MITER) {
      this.drawingContext.lineJoin = join;
    }
    return this;
  }
  strokeWeight(w) {
    super.strokeWeight(w);
    if (typeof w === "undefined" || w === 0) {
      this.drawingContext.lineWidth = 1e-4;
    } else {
      this.drawingContext.lineWidth = w;
    }
    return this;
  }
  _getFill() {
    if (!this.states._cachedFillStyle) {
      this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
    }
    return this.states._cachedFillStyle;
  }
  _setFill(fillStyle) {
    if (fillStyle !== this.states._cachedFillStyle) {
      this.drawingContext.fillStyle = fillStyle;
      this.states.setValue("_cachedFillStyle", fillStyle);
    }
  }
  _getStroke() {
    if (!this.states._cachedStrokeStyle) {
      this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
    }
    return this.states._cachedStrokeStyle;
  }
  _setStroke(strokeStyle) {
    if (strokeStyle !== this.states._cachedStrokeStyle) {
      this.drawingContext.strokeStyle = strokeStyle;
      this.states.setValue("_cachedStrokeStyle", strokeStyle);
    }
  }
  //////////////////////////////////////////////
  // TRANSFORM
  //////////////////////////////////////////////
  applyMatrix(a, b2, c, d2, e2, f) {
    this.drawingContext.transform(a, b2, c, d2, e2, f);
  }
  getWorldToScreenMatrix() {
    let domMatrix = new DOMMatrix().scale(1 / this._pixelDensity).multiply(this.drawingContext.getTransform());
    return new Matrix(domMatrix.toFloat32Array());
  }
  resetMatrix() {
    this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
    this.drawingContext.scale(
      this._pixelDensity,
      this._pixelDensity
    );
    return this;
  }
  rotate(rad) {
    this.drawingContext.rotate(rad);
  }
  scale(x, y) {
    this.drawingContext.scale(x, y);
    return this;
  }
  translate(x, y) {
    if (x instanceof p5$2.Vector) {
      y = x.y;
      x = x.x;
    }
    this.drawingContext.translate(x, y);
    return this;
  }
  //////////////////////////////////////////////
  // TYPOGRAPHY (see src/type/textCore.js)
  //////////////////////////////////////////////
  //////////////////////////////////////////////
  // STRUCTURE
  //////////////////////////////////////////////
  // a push() operation is in progress.
  // the renderer should return a 'style' object that it wishes to
  // store on the push stack.
  // derived renderers should call the base class' push() method
  // to fetch the base style object.
  push() {
    this.drawingContext.save();
    return super.push();
  }
  // a pop() operation is in progress
  // the renderer is passed the 'style' object that it returned
  // from its push() method.
  // derived renderers should pass this object to their base
  // class' pop method
  pop(style) {
    this.drawingContext.restore();
    super.pop(style);
  }
  // Text support methods
  textCanvas() {
    return this.canvas;
  }
  textDrawingContext() {
    return this.drawingContext;
  }
  _renderText(text2, x, y, maxY, minY) {
    let states = this.states;
    let context2 = this.textDrawingContext();
    if (y < minY || y >= maxY) {
      return;
    }
    this.push();
    if (states.strokeColor && states.strokeSet) {
      context2.strokeText(text2, x, y);
    }
    if (!this._clipping && states.fillColor) {
      if (!states.fillSet) {
        this._setFill(DefaultFill);
      }
      context2.fillText(text2, x, y);
    }
    this.pop();
  }
  /*
    Position the lines of text based on their textAlign/textBaseline properties
  */
  _positionLines(x, y, width, height, lines) {
    let { textLeading, textAlign } = this.states;
    let adjustedX, lineData = new Array(lines.length);
    let adjustedW = typeof width === "undefined" ? 0 : width;
    let adjustedH = typeof height === "undefined" ? 0 : height;
    for (let i = 0; i < lines.length; i++) {
      switch (textAlign) {
        case textCoreConstants.START:
          throw new Error("textBounds: START not yet supported for textAlign");
        // default to LEFT
        case LEFT:
          adjustedX = x;
          break;
        case CENTER:
          adjustedX = x + adjustedW / 2;
          break;
        case RIGHT:
          adjustedX = x + adjustedW;
          break;
        case textCoreConstants.END:
          throw new Error("textBounds: END not yet supported for textAlign");
      }
      lineData[i] = { text: lines[i], x: adjustedX, y: y + i * textLeading };
    }
    return this._yAlignOffset(lineData, adjustedH);
  }
  /*
    Get the y-offset for text given the height, leading, line-count and textBaseline property
  */
  _yAlignOffset(dataArr, height) {
    if (typeof height === "undefined") {
      throw Error("_yAlignOffset: height is required");
    }
    let { textLeading, textBaseline } = this.states;
    let yOff = 0, numLines = dataArr.length;
    let ydiff = height - textLeading * (numLines - 1);
    switch (textBaseline) {
      // drawingContext ?
      case TOP:
        break;
      // ??
      case BASELINE:
        break;
      case textCoreConstants._CTX_MIDDLE:
        yOff = ydiff / 2 + this._middleAlignOffset();
        break;
      case BOTTOM:
        yOff = ydiff;
        break;
      case textCoreConstants.IDEOGRAPHIC:
        console.warn("textBounds: IDEOGRAPHIC not yet supported for textBaseline");
        break;
      case textCoreConstants.HANGING:
        console.warn("textBounds: HANGING not yet supported for textBaseline");
        break;
    }
    dataArr.forEach((ele) => ele.y += yOff);
    return dataArr;
  }
}
function renderer2D(p53, fn2) {
  p53.Renderer2D = Renderer2D;
  p53.renderers[P2D] = Renderer2D;
  p53.renderers["p2d-hdr"] = new Proxy(Renderer2D, {
    construct(target, [pInst, w, h, isMainCanvas, elt]) {
      return new target(pInst, w, h, isMainCanvas, elt, { colorSpace: "display-p3" });
    }
  });
}
let p5$2 = class p52 {
  static VERSION = VERSION;
  // This is a pointer to our global mode p5 instance, if we're in
  // global mode.
  static instance = null;
  static lifecycleHooks = {
    presetup: [],
    postsetup: [],
    predraw: [],
    postdraw: [],
    remove: []
  };
  // FES stub
  static _checkForUserDefinedFunctions = () => {
  };
  static _friendlyFileLoadError = () => {
  };
  constructor(sketch2, node) {
    if (p52.decorations.size > 0) {
      for (const [patternArray, decoration] of p52.decorations) {
        for (const member in p52.prototype) {
          if (typeof p52.prototype[member] !== "function") continue;
          if (!patternArray.some((pattern) => {
            if (typeof pattern === "string") {
              return pattern === member;
            } else if (pattern instanceof RegExp) {
              return pattern.test(member);
            }
          })) continue;
          p52.prototype[member] = decoration(p52.prototype[member], {
            kind: "method",
            name: member,
            access: {},
            static: false,
            private: false,
            addInitializer(initializer2) {
            }
          });
        }
      }
      p52.decorations.clear();
    }
    this.hitCriticalError = false;
    this._setupDone = false;
    this._userNode = node;
    this._curElement = null;
    this._elements = [];
    this._glAttributes = null;
    this._webgpuAttributes = null;
    this._requestAnimId = 0;
    this._isGlobal = false;
    this._loop = true;
    this._startListener = null;
    this._initializeInstanceVariables();
    this._events = {};
    this._removeAbortController = new AbortController();
    this._removeSignal = this._removeAbortController.signal;
    this._millisStart = -1;
    this._recording = false;
    this._lcg_random_state = null;
    this._gaussian_previous = false;
    this._updateWindowSize();
    const bindGlobal = createBindGlobal(this);
    if (!sketch2) {
      this._isGlobal = true;
      if (window.hitCriticalError) {
        return;
      }
      p52.instance = this;
      for (const p2 of Object.getOwnPropertyNames(p52.prototype)) {
        if (p2[0] === "_") continue;
        bindGlobal(p2);
      }
      const protectedProperties = ["constructor", "length"];
      for (const p2 in this) {
        if (this.hasOwnProperty(p2)) {
          if (p2[0] === "_" || protectedProperties.includes(p2)) continue;
          bindGlobal(p2);
        }
      }
    } else {
      sketch2(this);
      p52._checkForUserDefinedFunctions(this);
    }
    const focusHandler = () => {
      this.focused = true;
    };
    const blurHandler = () => {
      this.focused = false;
    };
    window.addEventListener("focus", focusHandler);
    window.addEventListener("blur", blurHandler);
    p52.lifecycleHooks.remove.push(function() {
      window.removeEventListener("focus", focusHandler);
      window.removeEventListener("blur", blurHandler);
    });
    if (document.readyState === "complete") {
      this.#_start();
    } else {
      this._startListener = this.#_start.bind(this);
      window.addEventListener("load", this._startListener, false);
    }
  }
  get pixels() {
    return this._renderer.pixels;
  }
  get drawingContext() {
    return this._renderer.drawingContext;
  }
  static _registeredAddons = /* @__PURE__ */ new Set();
  static registerAddon(addon) {
    const lifecycles = {};
    if (p52._registeredAddons.has(addon)) return;
    p52._registeredAddons.add(addon);
    addon(p52, p52.prototype, lifecycles);
    const validLifecycles = Object.keys(p52.lifecycleHooks);
    for (const name of validLifecycles) {
      if (typeof lifecycles[name] === "function") {
        p52.lifecycleHooks[name].push(lifecycles[name]);
      }
    }
  }
  static decorations = /* @__PURE__ */ new Map();
  static decorateHelper(pattern, decoration) {
    let patternArray = pattern;
    if (!Array.isArray(pattern)) patternArray = [pattern];
    p52.decorations.set(patternArray, decoration);
  }
  #customActions = {};
  _customActions = new Proxy({}, {
    get: (target, prop) => {
      if (!this.#customActions[prop]) {
        const context2 = this._isGlobal ? window : this;
        if (typeof context2[prop] === "function") {
          this.#customActions[prop] = context2[prop].bind(this);
        }
      }
      return this.#customActions[prop];
    }
  });
  async #_start() {
    if (this.hitCriticalError) return;
    if (this._userNode) {
      if (typeof this._userNode === "string") {
        this._userNode = document.getElementById(this._userNode);
      }
    }
    await this.#_setup();
    if (this.hitCriticalError) return;
    if (!this._recording) {
      this._draw();
    }
  }
  async #_setup() {
    await this._runLifecycleHook("presetup");
    if (this.hitCriticalError) return;
    this.createCanvas(
      100,
      100,
      P2D
    );
    this._millisStart = window.performance.now();
    const context2 = this._isGlobal ? window : this;
    if (typeof context2.setup === "function") {
      await context2.setup();
    }
    if (this.hitCriticalError) return;
    const canvases = document.getElementsByTagName("canvas");
    for (const k of canvases) {
      k.style.touchAction = "none";
      if (k.dataset.hidden === "true") {
        k.style.visibility = "";
        delete k.dataset.hidden;
      }
    }
    this._lastTargetFrameTime = window.performance.now();
    this._lastRealFrameTime = window.performance.now();
    this._setupDone = true;
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._updateAccsOutput();
    }
    await this._runLifecycleHook("postsetup");
    this._millisStart = window.performance.now();
  }
  // While '#_draw' here is async, it is not awaited as 'requestAnimationFrame'
  // does not await its callback. Thus it is not recommended for 'draw()` to be
  // async and use await within as the next frame may start rendering before the
  // current frame finish awaiting. The same goes for lifecycle hooks 'predraw'
  // and 'postdraw'.
  async _draw(requestAnimationFrameTimestamp) {
    if (this.hitCriticalError) return;
    const now = requestAnimationFrameTimestamp || window.performance.now();
    const timeSinceLastFrame = now - this._lastTargetFrameTime;
    const targetTimeBetweenFrames = 1e3 / this._targetFrameRate;
    const epsilon = 5;
    if (!this._loop || timeSinceLastFrame >= targetTimeBetweenFrames - epsilon) {
      this.deltaTime = now - this._lastRealFrameTime;
      this._frameRate = 1e3 / this.deltaTime;
      await this.redraw();
      this._lastTargetFrameTime = Math.max(this._lastTargetFrameTime + targetTimeBetweenFrames, now);
      this._lastRealFrameTime = now;
      if (typeof this._updateMouseCoords !== "undefined") {
        this._updateMouseCoords();
        this.movedX = 0;
        this.movedY = 0;
      }
    }
    if (this._loop) {
      this._requestAnimId = window.requestAnimationFrame(
        this._draw.bind(this)
      );
    }
  }
  /**
   * Removes the sketch from the web page.
   *
   * Calling `remove()` stops the draw loop and removes any HTML elements
   * created by the sketch, including the canvas. A new sketch can be
   * created by using the <a href="#/p5/p5">p5()</a> constructor, as in
   * `new p5()`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to remove the canvas.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A white circle on a gray background. The circle follows the mouse as the user moves. The sketch disappears when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   // Paint the background repeatedly.
   *   background(200);
   *
   *   // Draw circles repeatedly.
   *   circle(mouseX, mouseY, 40);
   * }
   *
   * // Remove the sketch when the user double-clicks.
   * function doubleClicked() {
   *   remove();
   * }
   * </code>
   * </div>
   */
  async remove() {
    if (this._startListener) {
      window.removeEventListener("load", this._startListener, false);
    }
    if (this._curElement) {
      this._loop = false;
      if (this._requestAnimId) {
        window.cancelAnimationFrame(this._requestAnimId);
      }
      this._removeAbortController.abort();
      for (const e2 of this._elements) {
        if (e2.elt && e2.elt.parentNode) {
          e2.elt.parentNode.removeChild(e2.elt);
        }
      }
      await this._runLifecycleHook("remove");
    }
    if (this._isGlobal) {
      for (const p2 in p52.prototype) {
        try {
          delete window[p2];
        } catch (x) {
          window[p2] = void 0;
        }
      }
      for (const p2 in this) {
        if (this.hasOwnProperty(p2)) {
          try {
            delete window[p2];
          } catch (x) {
            window[p2] = void 0;
          }
        }
      }
      p52.instance = null;
    }
  }
  async _runLifecycleHook(hookName) {
    await Promise.all(p52.lifecycleHooks[hookName].map((hook) => {
      return hook.call(this);
    }));
  }
  _initializeInstanceVariables() {
    this._accessibleOutputs = {
      text: false,
      grid: false,
      textLabel: false,
      gridLabel: false
    };
    this._styles = [];
    this._downKeys = {};
    this._downKeyCodes = {};
  }
};
function createBindGlobal(instance) {
  return function bindGlobal(property) {
    if (property === "constructor") return;
    const instanceDescriptor = Object.getOwnPropertyDescriptor(
      instance,
      property
    );
    const prototypeDescriptor = Object.getOwnPropertyDescriptor(
      p5$2.prototype,
      property
    );
    const hasGetter = instanceDescriptor && instanceDescriptor.get || prototypeDescriptor && prototypeDescriptor.get;
    let isPrototypeFunction = false;
    let isConstant = false;
    let constantValue;
    if (!hasGetter) {
      const prototypeValue = p5$2.prototype[property];
      isPrototypeFunction = typeof prototypeValue === "function";
      if (!isPrototypeFunction && constants[property] !== void 0) {
        isConstant = true;
        constantValue = prototypeValue;
      }
    }
    if (isPrototypeFunction) {
      const boundFunction = p5$2.prototype[property].bind(instance);
      Object.defineProperty(window, property, {
        configurable: true,
        enumerable: true,
        value: boundFunction
      });
    } else if (isConstant) {
      Object.defineProperty(window, property, {
        configurable: true,
        enumerable: true,
        value: constantValue
      });
    } else if (hasGetter || !isPrototypeFunction) {
      let lastFunction = null;
      let boundFunction = null;
      let isFunction2 = null;
      Object.defineProperty(window, property, {
        configurable: true,
        enumerable: true,
        get: () => {
          const currentValue = instance[property];
          if (isFunction2 === null) {
            isFunction2 = typeof currentValue === "function";
            if (isFunction2) {
              lastFunction = currentValue;
              boundFunction = currentValue.bind(instance);
              return boundFunction;
            } else {
              return currentValue;
            }
          } else if (isFunction2) {
            if (currentValue !== lastFunction) {
              lastFunction = currentValue;
              boundFunction = currentValue.bind(instance);
            }
            return boundFunction;
          } else {
            return currentValue;
          }
        }
      });
    }
  };
}
for (const k in constants) {
  p5$2.prototype[k] = constants[k];
}
p5$2.registerAddon(transform$1);
p5$2.registerAddon(structure);
p5$2.registerAddon(environment$1);
p5$2.registerAddon(rendering);
p5$2.registerAddon(renderer);
p5$2.registerAddon(renderer2D);
p5$2.registerAddon(graphics);
function shape(p53) {
  p53.registerAddon(primitives);
  p53.registerAddon(attributes);
  p53.registerAddon(curves);
  p53.registerAddon(vertex);
  p53.registerAddon(customShapes);
}
function describe(p53, fn2) {
  const descContainer = "_Description";
  const fallbackDescId = "_fallbackDesc";
  const fallbackTableId = "_fallbackTable";
  const fallbackTableElId = "_fte_";
  const labelContainer = "_Label";
  const labelDescId = "_labelDesc";
  const labelTableId = "_labelTable";
  const labelTableElId = "_lte_";
  fn2.describe = function(text2, display) {
    if (typeof text2 !== "string") {
      return;
    }
    const cnvId = this.canvas.id;
    text2 = _descriptionText(text2);
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    if (!this.descriptions) {
      this.descriptions = {};
    }
    if (this.descriptions.fallback) {
      if (this.descriptions.fallback.innerHTML !== text2) {
        this.descriptions.fallback.innerHTML = text2;
      }
    } else {
      this._describeHTML("fallback", text2);
    }
    if (display === this.LABEL) {
      if (this.descriptions.label) {
        if (this.descriptions.label.innerHTML !== text2) {
          this.descriptions.label.innerHTML = text2;
        }
      } else {
        this._describeHTML("label", text2);
      }
    }
  };
  fn2.describeElement = function(name, text2, display) {
    if (typeof text2 !== "string" || typeof name !== "string") {
      return;
    }
    const cnvId = this.canvas.id;
    text2 = _descriptionText(text2);
    let elementName = _elementName(name);
    name = name.replace(/[^a-zA-Z0-9]/g, "");
    let inner = `<th scope="row">${elementName}</th><td>${text2}</td>`;
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    if (!this.descriptions) {
      this.descriptions = { fallbackElements: {} };
    } else if (!this.descriptions.fallbackElements) {
      this.descriptions.fallbackElements = {};
    }
    if (this.descriptions.fallbackElements[name]) {
      if (this.descriptions.fallbackElements[name].innerHTML !== inner) {
        this.descriptions.fallbackElements[name].innerHTML = inner;
      }
    } else {
      this._describeElementHTML("fallback", name, inner);
    }
    if (display === this.LABEL) {
      if (!this.descriptions.labelElements) {
        this.descriptions.labelElements = {};
      }
      if (this.descriptions.labelElements[name]) {
        if (this.descriptions.labelElements[name].innerHTML !== inner) {
          this.descriptions.labelElements[name].innerHTML = inner;
        }
      } else {
        this._describeElementHTML("label", name, inner);
      }
    }
  };
  function _descriptionText(text2) {
    if (text2 === "label" || text2 === "fallback") {
      throw new Error("description should not be LABEL or FALLBACK");
    }
    if (!text2.endsWith(".") && !text2.endsWith(";") && !text2.endsWith(",") && !text2.endsWith("?") && !text2.endsWith("!")) {
      text2 = text2 + ".";
    }
    return text2;
  }
  fn2._describeHTML = function(type2, text2) {
    const cnvId = this.canvas.id;
    if (type2 === "fallback") {
      if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
        let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><p id="${cnvId}${fallbackDescId}"></p></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) {
          this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = html;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML("beforebegin", html);
        }
      } else {
        this.dummyDOM.querySelector("#" + cnvId + fallbackTableId).insertAdjacentHTML(
          "beforebegin",
          `<p id="${cnvId + fallbackDescId}"></p>`
        );
      }
      this.descriptions.fallback = this.dummyDOM.querySelector(
        `#${cnvId}${fallbackDescId}`
      );
      this.descriptions.fallback.innerHTML = text2;
      return;
    } else if (type2 === "label") {
      if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
        let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><p id="${cnvId}${labelDescId}"></p></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) {
          this.dummyDOM.querySelector("#" + cnvId).insertAdjacentHTML("afterend", html);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) {
        this.dummyDOM.querySelector(`#${cnvId + labelTableId}`).insertAdjacentHTML(
          "beforebegin",
          `<p id="${cnvId}${labelDescId}"></p>`
        );
      }
      this.descriptions.label = this.dummyDOM.querySelector(
        "#" + cnvId + labelDescId
      );
      this.descriptions.label.innerHTML = text2;
      return;
    }
  };
  function _elementName(name) {
    if (name === "label" || name === "fallback") {
      throw new Error("element name should not be LABEL or FALLBACK");
    }
    if (name.endsWith(".") || name.endsWith(";") || name.endsWith(",")) {
      name = name.replace(/.$/, ":");
    } else if (!name.endsWith(":")) {
      name = name + ":";
    }
    return name;
  }
  fn2._describeElementHTML = function(type2, name, text2) {
    const cnvId = this.canvas.id;
    if (type2 === "fallback") {
      if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
        let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) {
          this.dummyDOM.querySelector("#" + cnvId).innerHTML = html;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (!this.dummyDOM.querySelector("#" + cnvId + fallbackTableId)) {
        this.dummyDOM.querySelector("#" + cnvId + fallbackDescId).insertAdjacentHTML(
          "afterend",
          `<table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table>`
        );
      }
      let tableRow2 = document.createElement("tr");
      tableRow2.id = cnvId + fallbackTableElId + name;
      this.dummyDOM.querySelector("#" + cnvId + fallbackTableId).appendChild(tableRow2);
      this.descriptions.fallbackElements[name] = this.dummyDOM.querySelector(
        `#${cnvId}${fallbackTableElId}${name}`
      );
      this.descriptions.fallbackElements[name].innerHTML = text2;
      return;
    } else if (type2 === "label") {
      if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
        let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><table id="${cnvId}${labelTableId}"></table></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) {
          this.dummyDOM.querySelector("#" + cnvId).insertAdjacentHTML("afterend", html);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (!this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) {
        this.dummyDOM.querySelector("#" + cnvId + labelDescId).insertAdjacentHTML(
          "afterend",
          `<table id="${cnvId + labelTableId}"></table>`
        );
      }
      let tableRow2 = document.createElement("tr");
      tableRow2.id = cnvId + labelTableElId + name;
      this.dummyDOM.querySelector("#" + cnvId + labelTableId).appendChild(tableRow2);
      this.descriptions.labelElements[name] = this.dummyDOM.querySelector(
        `#${cnvId}${labelTableElId}${name}`
      );
      this.descriptions.labelElements[name].innerHTML = text2;
    }
  };
}
if (typeof p5 !== "undefined") {
  describe(p5, p5.prototype);
}
function gridOutput(p53, fn2) {
  fn2._updateGridOutput = function(idT) {
    if (this._renderer && this._renderer.isP3D) {
      if (!this._didOutputGridWebGLMessage) {
        this._didOutputGridWebGLMessage = true;
        console.error("gridOutput() does not yet work in WebGL mode.");
      }
      return;
    }
    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {
      return;
    }
    let current2 = this._accessibleOutputs[idT];
    let innerShapeDetails = _gridShapeDetails(idT, this.ingredients.shapes);
    let innerSummary = _gridSummary(
      innerShapeDetails.numShapes,
      this.ingredients.colors.background,
      this.width,
      this.height
    );
    let innerMap = _gridMap(idT, this.ingredients.shapes);
    if (innerSummary !== current2.summary.innerHTML) {
      current2.summary.innerHTML = innerSummary;
    }
    if (innerMap !== current2.map.innerHTML) {
      current2.map.innerHTML = innerMap;
    }
    if (innerShapeDetails.details !== current2.shapeDetails.innerHTML) {
      current2.shapeDetails.innerHTML = innerShapeDetails.details;
    }
    this._accessibleOutputs[idT] = current2;
  };
  function _gridMap(idT, ingredients) {
    let shapeNumber = 0;
    let table2 = "";
    let cells = Array.from(Array(10), () => Array(10));
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let fill;
        if (x !== "line") {
          fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x}</a>`;
        } else {
          fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x} midpoint</a>`;
        }
        if (ingredients[x][y].loc.locY < cells.length && ingredients[x][y].loc.locX < cells[ingredients[x][y].loc.locY].length) {
          if (!cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX]) {
            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = fill;
          } else {
            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] + "  " + fill;
          }
          shapeNumber++;
        }
      }
    }
    for (let _r in cells) {
      let row = "<tr>";
      for (let c in cells[_r]) {
        row = row + "<td>";
        if (cells[_r][c] !== void 0) {
          row = row + cells[_r][c];
        }
        row = row + "</td>";
      }
      table2 = table2 + row + "</tr>";
    }
    return table2;
  }
  function _gridSummary(numShapes, background, width, height) {
    let text2 = `${background} canvas, ${width} by ${height} pixels, contains ${numShapes[0]}`;
    if (numShapes[0] === 1) {
      text2 = `${text2} shape: ${numShapes[1]}`;
    } else {
      text2 = `${text2} shapes: ${numShapes[1]}`;
    }
    return text2;
  }
  function _gridShapeDetails(idT, ingredients) {
    let shapeDetails = "";
    let shapes = "";
    let totalShapes = 0;
    for (let x in ingredients) {
      let shapeNum = 0;
      for (let y in ingredients[x]) {
        let line = `<li id="${idT}shape${totalShapes}">${ingredients[x][y].color} ${x},`;
        if (x === "line") {
          line = line + ` location = ${ingredients[x][y].pos}, length = ${ingredients[x][y].length} pixels`;
        } else {
          line = line + ` location = ${ingredients[x][y].pos}`;
          if (x !== "point") {
            line = line + `, area = ${ingredients[x][y].area} %`;
          }
          line = line + "</li>";
        }
        shapeDetails = shapeDetails + line;
        shapeNum++;
        totalShapes++;
      }
      if (shapeNum > 1) {
        shapes = `${shapes} ${shapeNum} ${x}s`;
      } else {
        shapes = `${shapes} ${shapeNum} ${x}`;
      }
    }
    return { numShapes: [totalShapes, shapes], details: shapeDetails };
  }
}
if (typeof p5 !== "undefined") {
  gridOutput(p5, p5.prototype);
}
function textOutput(p53, fn2) {
  fn2._updateTextOutput = function(idT) {
    if (this._renderer && this._renderer.isP3D) {
      if (!this._didOutputTextWebGLMessage) {
        this._didOutputTextWebGLMessage = true;
        console.error("textOutput() does not yet work in WebGL mode.");
      }
      return;
    }
    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {
      return;
    }
    let current2 = this._accessibleOutputs[idT];
    let innerList = _shapeList(idT, this.ingredients.shapes);
    let innerSummary = _textSummary(
      innerList.numShapes,
      this.ingredients.colors.background,
      this.width,
      this.height
    );
    let innerShapeDetails = _shapeDetails(idT, this.ingredients.shapes);
    if (innerSummary !== current2.summary.innerHTML) {
      current2.summary.innerHTML = innerSummary;
    }
    if (innerList.listShapes !== current2.list.innerHTML) {
      current2.list.innerHTML = innerList.listShapes;
    }
    if (innerShapeDetails !== current2.shapeDetails.innerHTML) {
      current2.shapeDetails.innerHTML = innerShapeDetails;
    }
    this._accessibleOutputs[idT] = current2;
  };
  function _textSummary(numShapes, background, width, height) {
    let text2 = `Your output is a, ${width} by ${height} pixels, ${background} canvas containing the following`;
    if (numShapes === 1) {
      text2 = `${text2} shape:`;
    } else {
      text2 = `${text2} ${numShapes} shapes:`;
    }
    return text2;
  }
  function _shapeDetails(idT, ingredients) {
    let shapeDetails = "";
    let shapeNumber = 0;
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let row = `<tr id="${idT}shape${shapeNumber}"><th>${ingredients[x][y].color} ${x}</th>`;
        if (x === "line") {
          row = row + `<td>location = ${ingredients[x][y].pos}</td><td>length = ${ingredients[x][y].length} pixels</td></tr>`;
        } else {
          row = row + `<td>location = ${ingredients[x][y].pos}</td>`;
          if (x !== "point") {
            row = row + `<td> area = ${ingredients[x][y].area}%</td>`;
          }
          row = row + "</tr>";
        }
        shapeDetails = shapeDetails + row;
        shapeNumber++;
      }
    }
    return shapeDetails;
  }
  function _shapeList(idT, ingredients) {
    let shapeList = "";
    let shapeNumber = 0;
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let _line = `<li><a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x}</a>`;
        if (x === "line") {
          _line = _line + `, ${ingredients[x][y].pos}, ${ingredients[x][y].length} pixels long.</li>`;
        } else {
          _line = _line + `, at ${ingredients[x][y].pos}`;
          if (x !== "point") {
            _line = _line + `, covering ${ingredients[x][y].area}% of the canvas`;
          }
          _line = _line + ".</li>";
        }
        shapeList = shapeList + _line;
        shapeNumber++;
      }
    }
    return { numShapes: shapeNumber, listShapes: shapeList };
  }
}
if (typeof p5 !== "undefined") {
  textOutput(p5, p5.prototype);
}
function outputs(p53, fn2) {
  fn2.textOutput = function(display) {
    if (this._accessibleOutputs.text) {
      return;
    } else {
      this._accessibleOutputs.text = true;
      this._createOutput("textOutput", "Fallback");
      if (display === this.LABEL) {
        this._accessibleOutputs.textLabel = true;
        this._createOutput("textOutput", "Label");
      }
    }
  };
  fn2.gridOutput = function(display) {
    if (this._accessibleOutputs.grid) {
      return;
    } else {
      this._accessibleOutputs.grid = true;
      this._createOutput("gridOutput", "Fallback");
      if (display === this.LABEL) {
        this._accessibleOutputs.gridLabel = true;
        this._createOutput("gridOutput", "Label");
      }
    }
  };
  fn2._addAccsOutput = function() {
    if (!this._accessibleOutputs) {
      this._accessibleOutputs = {
        text: false,
        grid: false,
        textLabel: false,
        gridLabel: false
      };
    }
    return this._accessibleOutputs.grid || this._accessibleOutputs.text;
  };
  fn2._createOutput = function(type2, display) {
    let cnvId = this.canvas.id;
    if (!this.ingredients) {
      this.ingredients = {
        shapes: {},
        colors: { background: "white", fill: "white", stroke: "black" },
        pShapes: "",
        pBackground: ""
      };
    }
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    let cIdT, container, inner;
    let query = "";
    if (display === "Fallback") {
      cIdT = cnvId + type2;
      container = cnvId + "accessibleOutput";
      if (!this.dummyDOM.querySelector(`#${container}`)) {
        if (!this.dummyDOM.querySelector(`#${cnvId}_Description`)) {
          this.dummyDOM.querySelector(
            `#${cnvId}`
          ).innerHTML = `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}_Description`).insertAdjacentHTML(
            "afterend",
            `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`
          );
        }
      }
    } else if (display === "Label") {
      query = display;
      cIdT = cnvId + type2 + display;
      container = cnvId + "accessibleOutput" + display;
      if (!this.dummyDOM.querySelector(`#${container}`)) {
        if (!this.dummyDOM.querySelector(`#${cnvId}_Label`)) {
          this.dummyDOM.querySelector(`#${cnvId}`).insertAdjacentHTML("afterend", `<div id="${container}"></div>`);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}_Label`).insertAdjacentHTML("afterend", `<div id="${container}"></div>`);
        }
      }
    }
    this._accessibleOutputs[cIdT] = {};
    if (type2 === "textOutput") {
      query = `#${cnvId}gridOutput${query}`;
      inner = `<div id="${cIdT}">Text Output<div id="${cIdT}Summary" aria-label="text output summary"><p id="${cIdT}_summary"></p><ul id="${cIdT}_list"></ul></div><table id="${cIdT}_shapeDetails" summary="text output shape details"></table></div>`;
      if (this.dummyDOM.querySelector(query)) {
        this.dummyDOM.querySelector(query).insertAdjacentHTML("beforebegin", inner);
      } else {
        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
      }
      this._accessibleOutputs[cIdT].list = this.dummyDOM.querySelector(
        `#${cIdT}_list`
      );
    } else if (type2 === "gridOutput") {
      query = `#${cnvId}textOutput${query}`;
      inner = `<div id="${cIdT}">Grid Output<p id="${cIdT}_summary" aria-label="grid output summary"><table id="${cIdT}_map" summary="grid output content"></table><ul id="${cIdT}_shapeDetails" aria-label="grid output shape details"></ul></div>`;
      if (this.dummyDOM.querySelector(query)) {
        this.dummyDOM.querySelector(query).insertAdjacentHTML("afterend", inner);
      } else {
        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
      }
      this._accessibleOutputs[cIdT].map = this.dummyDOM.querySelector(
        `#${cIdT}_map`
      );
    }
    this._accessibleOutputs[cIdT].shapeDetails = this.dummyDOM.querySelector(
      `#${cIdT}_shapeDetails`
    );
    this._accessibleOutputs[cIdT].summary = this.dummyDOM.querySelector(
      `#${cIdT}_summary`
    );
  };
  fn2._updateAccsOutput = function() {
    let cnvId = this.canvas.id;
    if (JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes || this.ingredients.colors.background !== this.ingredients.pBackground) {
      this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
      if (this._accessibleOutputs.text) {
        this._updateTextOutput(cnvId + "textOutput");
      }
      if (this._accessibleOutputs.grid) {
        this._updateGridOutput(cnvId + "gridOutput");
      }
      if (this._accessibleOutputs.textLabel) {
        this._updateTextOutput(cnvId + "textOutputLabel");
      }
      if (this._accessibleOutputs.gridLabel) {
        this._updateGridOutput(cnvId + "gridOutputLabel");
      }
    }
  };
  fn2._accsBackground = function(args) {
    this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
    this.ingredients.pBackground = this.ingredients.colors.background;
    this.ingredients.shapes = {};
    if (this.ingredients.colors.backgroundRGBA !== args) {
      this.ingredients.colors.backgroundRGBA = args;
      this.ingredients.colors.background = this._rgbColorName(args);
    }
  };
  fn2._accsCanvasColors = function(f, args) {
    if (f === "fill") {
      if (this.ingredients.colors.fillRGBA !== args) {
        this.ingredients.colors.fillRGBA = args;
        this.ingredients.colors.fill = this._rgbColorName(args);
      }
    } else if (f === "stroke") {
      if (this.ingredients.colors.strokeRGBA !== args) {
        this.ingredients.colors.strokeRGBA = args;
        this.ingredients.colors.stroke = this._rgbColorName(args);
      }
    }
  };
  fn2._accsOutput = function(f, args) {
    if (f === "ellipse" && args[2] === args[3]) {
      f = "circle";
    } else if (f === "rectangle" && args[2] === args[3]) {
      f = "square";
    }
    let include = {};
    let add = true;
    let middle = _getMiddle(f, args);
    if (f === "line") {
      include.color = this.ingredients.colors.stroke;
      include.length = Math.round(
        Math.hypot(args[2] - args[0], args[3] - args[1])
      );
      let p1 = this._getPos(args[0], [1]);
      let p2 = this._getPos(args[2], [3]);
      include.loc = _canvasLocator(middle, this.width, this.height);
      if (p1 === p2) {
        include.pos = `at ${p1}`;
      } else {
        include.pos = `from ${p1} to ${p2}`;
      }
    } else {
      if (f === "point") {
        include.color = this.ingredients.colors.stroke;
      } else {
        include.color = this.ingredients.colors.fill;
        include.area = this._getArea(f, args);
      }
      include.pos = this._getPos(...middle);
      include.loc = _canvasLocator(middle, this.width, this.height);
    }
    if (!this.ingredients.shapes[f]) {
      this.ingredients.shapes[f] = [include];
    } else {
      for (let y in this.ingredients.shapes[f]) {
        if (JSON.stringify(this.ingredients.shapes[f][y]) === JSON.stringify(include)) {
          add = false;
        }
      }
      if (add === true) {
        this.ingredients.shapes[f].push(include);
      }
    }
  };
  function _getMiddle(f, args) {
    let x, y;
    if (f === "rectangle" || f === "ellipse" || f === "arc" || f === "circle" || f === "square") {
      x = Math.round(args[0] + args[2] / 2);
      y = Math.round(args[1] + args[3] / 2);
    } else if (f === "triangle") {
      x = (args[0] + args[2] + args[4]) / 3;
      y = (args[1] + args[3] + args[5]) / 3;
    } else if (f === "quadrilateral") {
      x = (args[0] + args[2] + args[4] + args[6]) / 4;
      y = (args[1] + args[3] + args[5] + args[7]) / 4;
    } else if (f === "line") {
      x = (args[0] + args[2]) / 2;
      y = (args[1] + args[3]) / 2;
    } else {
      x = args[0];
      y = args[1];
    }
    return [x, y];
  }
  fn2._getPos = function(x, y) {
    const { x: transformedX, y: transformedY } = this.worldToScreen(new p53.Vector(x, y));
    const canvasWidth = this.width;
    const canvasHeight = this.height;
    if (transformedX < 0.4 * canvasWidth) {
      if (transformedY < 0.4 * canvasHeight) {
        return "top left";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom left";
      } else {
        return "mid left";
      }
    } else if (transformedX > 0.6 * canvasWidth) {
      if (transformedY < 0.4 * canvasHeight) {
        return "top right";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom right";
      } else {
        return "mid right";
      }
    } else {
      if (transformedY < 0.4 * canvasHeight) {
        return "top middle";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom middle";
      } else {
        return "middle";
      }
    }
  };
  function _canvasLocator(args, canvasWidth, canvasHeight) {
    const noRows = 10;
    const noCols = 10;
    let locX = Math.floor(args[0] / canvasWidth * noRows);
    let locY = Math.floor(args[1] / canvasHeight * noCols);
    if (locX === noRows) {
      locX = locX - 1;
    }
    if (locY === noCols) {
      locY = locY - 1;
    }
    return {
      locX,
      locY
    };
  }
  fn2._getArea = function(objectType, shapeArgs) {
    let objectArea = 0;
    if (objectType === "arc") {
      const arcSizeInRadians = ((shapeArgs[5] - shapeArgs[4]) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
      objectArea = arcSizeInRadians * shapeArgs[2] * shapeArgs[3] / 8;
      if (shapeArgs[6] === "open" || shapeArgs[6] === "chord") {
        const Ax = shapeArgs[0];
        const Ay = shapeArgs[1];
        const Bx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[4]).toFixed(2);
        const By = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[4]).toFixed(2);
        const Cx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[5]).toFixed(2);
        const Cy = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[5]).toFixed(2);
        const areaOfExtraTriangle = Math.abs(Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By)) / 2;
        if (arcSizeInRadians > Math.PI) {
          objectArea = objectArea + areaOfExtraTriangle;
        } else {
          objectArea = objectArea - areaOfExtraTriangle;
        }
      }
    } else if (objectType === "ellipse" || objectType === "circle") {
      objectArea = 3.14 * shapeArgs[2] / 2 * shapeArgs[3] / 2;
    } else if (objectType === "line") {
      objectArea = 0;
    } else if (objectType === "point") {
      objectArea = 0;
    } else if (objectType === "quadrilateral") {
      objectArea = Math.abs(
        (shapeArgs[6] + shapeArgs[0]) * (shapeArgs[7] - shapeArgs[1]) + (shapeArgs[0] + shapeArgs[2]) * (shapeArgs[1] - shapeArgs[3]) + (shapeArgs[2] + shapeArgs[4]) * (shapeArgs[3] - shapeArgs[5]) + (shapeArgs[4] + shapeArgs[6]) * (shapeArgs[5] - shapeArgs[7])
      ) / 2;
    } else if (objectType === "rectangle" || objectType === "square") {
      objectArea = shapeArgs[2] * shapeArgs[3];
    } else if (objectType === "triangle") {
      objectArea = Math.abs(
        shapeArgs[0] * (shapeArgs[3] - shapeArgs[5]) + shapeArgs[2] * (shapeArgs[5] - shapeArgs[1]) + shapeArgs[4] * (shapeArgs[1] - shapeArgs[3])
      ) / 2;
    }
    const canvasWidth = this.width * this._renderer._pixelDensity;
    const canvasHeight = this.height * this._renderer._pixelDensity;
    const canvasCorners = [
      new DOMPoint(0, 0),
      new DOMPoint(canvasWidth, 0),
      new DOMPoint(canvasWidth, canvasHeight),
      new DOMPoint(0, canvasHeight)
    ];
    const currentTransform = this._renderer.isP3D ? new DOMMatrix(this._renderer.uMVMatrix.mat4) : this.drawingContext.getTransform();
    const invertedTransform = currentTransform.inverse();
    const tc = canvasCorners.map(
      (corner) => corner.matrixTransform(invertedTransform)
    );
    const transformedCanvasArea = Math.abs(
      (tc[3].x + tc[0].x) * (tc[3].y - tc[0].y) + (tc[0].x + tc[1].x) * (tc[0].y - tc[1].y) + (tc[1].x + tc[2].x) * (tc[1].y - tc[2].y) + (tc[2].x + tc[3].x) * (tc[2].y - tc[3].y)
    ) / 2;
    const untransformedArea = Math.round(
      objectArea * 100 / transformedCanvasArea
    );
    return untransformedArea;
  };
}
if (typeof p5 !== "undefined") {
  outputs(p5, p5.prototype);
}
p5$2.ColorConversion = {
  /**
   * Convert an HSBA array to HSLA.
   */
  _hsbaToHSLA(hsba) {
    const hue = hsba[0];
    let sat = hsba[1];
    const val = hsba[2];
    const li = (2 - sat) * val / 2;
    if (li !== 0) {
      if (li === 1) {
        sat = 0;
      } else if (li < 0.5) {
        sat = sat / (2 - sat);
      } else {
        sat = sat * val / (2 - li * 2);
      }
    }
    return [hue, sat, li, hsba[3]];
  },
  /**
   * Convert an HSBA array to RGBA.
   */
  _hsbaToRGBA(hsba) {
    const hue = hsba[0] * 6;
    const sat = hsba[1];
    const val = hsba[2];
    let RGBA2 = [];
    if (sat === 0) {
      RGBA2 = [val, val, val, hsba[3]];
    } else {
      const sector = Math.floor(hue);
      const tint1 = val * (1 - sat);
      const tint2 = val * (1 - sat * (hue - sector));
      const tint3 = val * (1 - sat * (1 + sector - hue));
      let red, green, blue;
      if (sector === 1) {
        red = tint2;
        green = val;
        blue = tint1;
      } else if (sector === 2) {
        red = tint1;
        green = val;
        blue = tint3;
      } else if (sector === 3) {
        red = tint1;
        green = tint2;
        blue = val;
      } else if (sector === 4) {
        red = tint3;
        green = tint1;
        blue = val;
      } else if (sector === 5) {
        red = val;
        green = tint1;
        blue = tint2;
      } else {
        red = val;
        green = tint3;
        blue = tint1;
      }
      RGBA2 = [red, green, blue, hsba[3]];
    }
    return RGBA2;
  },
  /**
   * Convert an HSLA array to HSBA.
   */
  _hslaToHSBA(hsla) {
    const hue = hsla[0];
    let sat = hsla[1];
    const li = hsla[2];
    let val;
    if (li < 0.5) {
      val = (1 + sat) * li;
    } else {
      val = li + sat - li * sat;
    }
    sat = 2 * (val - li) / val;
    return [hue, sat, val, hsla[3]];
  },
  /**
   * Convert an HSLA array to RGBA.
   *
   * We need to change basis from HSLA to something that can be more easily be
   * projected onto RGBA. We will choose hue and brightness as our first two
   * components, and pick a convenient third one ('zest') so that we don't need
   * to calculate formal HSBA saturation.
   */
  _hslaToRGBA(hsla) {
    const hue = hsla[0] * 6;
    const sat = hsla[1];
    const li = hsla[2];
    let RGBA2 = [];
    if (sat === 0) {
      RGBA2 = [li, li, li, hsla[3]];
    } else {
      let val;
      if (li < 0.5) {
        val = (1 + sat) * li;
      } else {
        val = li + sat - li * sat;
      }
      const zest = 2 * li - val;
      const hzvToRGB = (hue2, zest2, val2) => {
        if (hue2 < 0) {
          hue2 += 6;
        } else if (hue2 >= 6) {
          hue2 -= 6;
        }
        if (hue2 < 1) {
          return zest2 + (val2 - zest2) * hue2;
        } else if (hue2 < 3) {
          return val2;
        } else if (hue2 < 4) {
          return zest2 + (val2 - zest2) * (4 - hue2);
        } else {
          return zest2;
        }
      };
      RGBA2 = [
        hzvToRGB(hue + 2, zest, val),
        hzvToRGB(hue, zest, val),
        hzvToRGB(hue - 2, zest, val),
        hsla[3]
      ];
    }
    return RGBA2;
  },
  /**
   * Convert an RGBA array to HSBA.
   */
  _rgbaToHSBA(rgba) {
    const red = rgba[0];
    const green = rgba[1];
    const blue = rgba[2];
    const val = Math.max(red, green, blue);
    const chroma = val - Math.min(red, green, blue);
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      sat = chroma / val;
      if (red === val) {
        hue = (green - blue) / chroma;
      } else if (green === val) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6, sat, val, rgba[3]];
  },
  /**
   * Convert an RGBA array to HSLA.
   */
  _rgbaToHSLA(rgba) {
    const red = rgba[0];
    const green = rgba[1];
    const blue = rgba[2];
    const val = Math.max(red, green, blue);
    const min = Math.min(red, green, blue);
    const li = val + min;
    const chroma = val - min;
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      if (li < 1) {
        sat = chroma / li;
      } else {
        sat = chroma / (2 - li);
      }
      if (red === val) {
        hue = (green - blue) / chroma;
      } else if (green === val) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6, sat, li / 2, rgba[3]];
  }
};
var color_conversion = p5$2.ColorConversion;
function colorNamer(p53, fn2) {
  let originalHSB;
  const colorExceptions = [
    {
      h: 0,
      s: 0,
      b: 0.8275,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 0.8627,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 0.7529,
      name: "gray"
    },
    {
      h: 0.0167,
      s: 0.1176,
      b: 1,
      name: "light pink"
    }
  ];
  const colorLookUp = [
    {
      h: 0,
      s: 0,
      b: 0,
      name: "black"
    },
    {
      h: 0,
      s: 0,
      b: 0.5,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 1,
      name: "white"
    },
    {
      h: 0,
      s: 0.5,
      b: 0.5,
      name: "dark maroon"
    },
    {
      h: 0,
      s: 0.5,
      b: 1,
      name: "salmon pink"
    },
    {
      h: 0,
      s: 1,
      b: 0,
      name: "black"
    },
    {
      h: 0,
      s: 1,
      b: 0.5,
      name: "dark red"
    },
    {
      h: 0,
      s: 1,
      b: 1,
      name: "red"
    },
    {
      h: 5,
      s: 0,
      b: 1,
      name: "very light peach"
    },
    {
      h: 5,
      s: 0.5,
      b: 0.5,
      name: "brown"
    },
    {
      h: 5,
      s: 0.5,
      b: 1,
      name: "peach"
    },
    {
      h: 5,
      s: 1,
      b: 0.5,
      name: "brick red"
    },
    {
      h: 5,
      s: 1,
      b: 1,
      name: "crimson"
    },
    {
      h: 10,
      s: 0,
      b: 1,
      name: "light peach"
    },
    {
      h: 10,
      s: 0.5,
      b: 0.5,
      name: "brown"
    },
    {
      h: 10,
      s: 0.5,
      b: 1,
      name: "light orange"
    },
    {
      h: 10,
      s: 1,
      b: 0.5,
      name: "brown"
    },
    {
      h: 10,
      s: 1,
      b: 1,
      name: "orange"
    },
    {
      h: 15,
      s: 0,
      b: 1,
      name: "very light yellow"
    },
    {
      h: 15,
      s: 0.5,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 15,
      s: 0.5,
      b: 1,
      name: "light yellow"
    },
    {
      h: 15,
      s: 1,
      b: 0,
      name: "dark olive green"
    },
    {
      h: 15,
      s: 1,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 15,
      s: 1,
      b: 1,
      name: "yellow"
    },
    {
      h: 20,
      s: 0,
      b: 1,
      name: "very light yellow"
    },
    {
      h: 20,
      s: 0.5,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 20,
      s: 0.5,
      b: 1,
      name: "light yellow green"
    },
    {
      h: 20,
      s: 1,
      b: 0,
      name: "dark olive green"
    },
    {
      h: 20,
      s: 1,
      b: 0.5,
      name: "dark yellow green"
    },
    {
      h: 20,
      s: 1,
      b: 1,
      name: "yellow green"
    },
    {
      h: 25,
      s: 0.5,
      b: 0.5,
      name: "dark yellow green"
    },
    {
      h: 25,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 25,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 25,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 30,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 30,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 30,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 35,
      s: 0,
      b: 0.5,
      name: "light green"
    },
    {
      h: 35,
      s: 0,
      b: 1,
      name: "very light green"
    },
    {
      h: 35,
      s: 0.5,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 35,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 35,
      s: 1,
      b: 0,
      name: "very dark green"
    },
    {
      h: 35,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 35,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 40,
      s: 0,
      b: 1,
      name: "very light green"
    },
    {
      h: 40,
      s: 0.5,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 40,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 40,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 40,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 45,
      s: 0.5,
      b: 1,
      name: "light turquoise"
    },
    {
      h: 45,
      s: 1,
      b: 0.5,
      name: "dark turquoise"
    },
    {
      h: 45,
      s: 1,
      b: 1,
      name: "turquoise"
    },
    {
      h: 50,
      s: 0,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 50,
      s: 0.5,
      b: 0.5,
      name: "dark cyan"
    },
    {
      h: 50,
      s: 0.5,
      b: 1,
      name: "light cyan"
    },
    {
      h: 50,
      s: 1,
      b: 0.5,
      name: "dark cyan"
    },
    {
      h: 50,
      s: 1,
      b: 1,
      name: "cyan"
    },
    {
      h: 55,
      s: 0,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 55,
      s: 0.5,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 55,
      s: 1,
      b: 0.5,
      name: "dark blue"
    },
    {
      h: 55,
      s: 1,
      b: 1,
      name: "sky blue"
    },
    {
      h: 60,
      s: 0,
      b: 0.5,
      name: "gray"
    },
    {
      h: 60,
      s: 0,
      b: 1,
      name: "very light blue"
    },
    {
      h: 60,
      s: 0.5,
      b: 0.5,
      name: "blue"
    },
    {
      h: 60,
      s: 0.5,
      b: 1,
      name: "light blue"
    },
    {
      h: 60,
      s: 1,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 60,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 65,
      s: 0,
      b: 1,
      name: "lavender"
    },
    {
      h: 65,
      s: 0.5,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 65,
      s: 0.5,
      b: 1,
      name: "light purple"
    },
    {
      h: 65,
      s: 1,
      b: 0.5,
      name: "dark navy blue"
    },
    {
      h: 65,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 70,
      s: 0,
      b: 1,
      name: "lavender"
    },
    {
      h: 70,
      s: 0.5,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 70,
      s: 0.5,
      b: 1,
      name: "lavender blue"
    },
    {
      h: 70,
      s: 1,
      b: 0.5,
      name: "dark navy blue"
    },
    {
      h: 70,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 75,
      s: 0.5,
      b: 1,
      name: "lavender"
    },
    {
      h: 75,
      s: 1,
      b: 0.5,
      name: "dark purple"
    },
    {
      h: 75,
      s: 1,
      b: 1,
      name: "purple"
    },
    {
      h: 80,
      s: 0.5,
      b: 1,
      name: "pinkish purple"
    },
    {
      h: 80,
      s: 1,
      b: 0.5,
      name: "dark purple"
    },
    {
      h: 80,
      s: 1,
      b: 1,
      name: "purple"
    },
    {
      h: 85,
      s: 0,
      b: 1,
      name: "light pink"
    },
    {
      h: 85,
      s: 0.5,
      b: 0.5,
      name: "purple"
    },
    {
      h: 85,
      s: 0.5,
      b: 1,
      name: "light fuchsia"
    },
    {
      h: 85,
      s: 1,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 85,
      s: 1,
      b: 1,
      name: "fuchsia"
    },
    {
      h: 90,
      s: 0.5,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 90,
      s: 0.5,
      b: 1,
      name: "hot pink"
    },
    {
      h: 90,
      s: 1,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 90,
      s: 1,
      b: 1,
      name: "fuchsia"
    },
    {
      h: 95,
      s: 0,
      b: 1,
      name: "pink"
    },
    {
      h: 95,
      s: 0.5,
      b: 1,
      name: "light pink"
    },
    {
      h: 95,
      s: 1,
      b: 0.5,
      name: "dark magenta"
    },
    {
      h: 95,
      s: 1,
      b: 1,
      name: "magenta"
    }
  ];
  function _calculateColor(hsb) {
    let colortext;
    if (hsb[0] !== 0) {
      hsb[0] = Math.round(hsb[0] * 100);
      let hue = hsb[0].toString().split("");
      const last2 = hue.length - 1;
      hue[last2] = parseInt(hue[last2]);
      if (hue[last2] < 2.5) {
        hue[last2] = 0;
      } else if (hue[last2] >= 2.5 && hue[last2] < 7.5) {
        hue[last2] = 5;
      }
      if (hue.length === 2) {
        hue[0] = parseInt(hue[0]);
        if (hue[last2] >= 7.5) {
          hue[last2] = 0;
          hue[0] = hue[0] + 1;
        }
        hsb[0] = hue[0] * 10 + hue[1];
      } else {
        if (hue[last2] >= 7.5) {
          hsb[0] = 10;
        } else {
          hsb[0] = hue[last2];
        }
      }
    }
    hsb[2] = hsb[2] / 255;
    for (let i = hsb.length - 1; i >= 1; i--) {
      if (hsb[i] <= 0.25) {
        hsb[i] = 0;
      } else if (hsb[i] > 0.25 && hsb[i] < 0.75) {
        hsb[i] = 0.5;
      } else {
        hsb[i] = 1;
      }
    }
    if (hsb[0] === 0 && hsb[1] === 0 && hsb[2] === 1) {
      for (let i = 2; i >= 0; i--) {
        originalHSB[i] = Math.round(originalHSB[i] * 1e4) / 1e4;
      }
      for (let e2 = 0; e2 < colorExceptions.length; e2++) {
        if (colorExceptions[e2].h === originalHSB[0] && colorExceptions[e2].s === originalHSB[1] && colorExceptions[e2].b === originalHSB[2]) {
          colortext = colorExceptions[e2].name;
          break;
        } else {
          colortext = "white";
        }
      }
    } else {
      for (let i = 0; i < colorLookUp.length; i++) {
        if (colorLookUp[i].h === hsb[0] && colorLookUp[i].s === hsb[1] && colorLookUp[i].b === hsb[2]) {
          colortext = colorLookUp[i].name;
          break;
        }
      }
    }
    return colortext;
  }
  fn2._rgbColorName = function(arg) {
    let hsb = color_conversion._rgbaToHSBA(arg);
    originalHSB = hsb;
    return _calculateColor([hsb[0], hsb[1], hsb[2]]);
  };
}
if (typeof p5 !== "undefined") {
  colorNamer(p5, p5.prototype);
}
function accessibility(p53) {
  p53.registerAddon(describe);
  p53.registerAddon(gridOutput);
  p53.registerAddon(textOutput);
  p53.registerAddon(outputs);
  p53.registerAddon(colorNamer);
}
function color(p53) {
  p53.registerAddon(creatingReading);
  p53.registerAddon(color$1);
  p53.registerAddon(setting);
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e2 = t[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t, r);
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _defineProperty(e2, r, t) {
  return (r = toPropertyKey(r)) in e2 ? Object.defineProperty(e2, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r] = t, e2;
}
function _objectSpread(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? Object(arguments[r]) : {}, o = Object.keys(t);
    "function" == typeof Object.getOwnPropertySymbols && o.push.apply(o, Object.getOwnPropertySymbols(t).filter(function(e3) {
      return Object.getOwnPropertyDescriptor(t, e3).enumerable;
    })), o.forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    });
  }
  return e2;
}
function _classCallCheck(a, n2) {
  if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e2, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e2, toPropertyKey(o.key), o);
  }
}
function _createClass(e2, r, t) {
  return r && _defineProperties(e2.prototype, r), t && _defineProperties(e2, t), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function _possibleConstructorReturn(t, e2) {
  if (e2 && ("object" == _typeof(e2) || "function" == typeof e2)) return e2;
  if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
function _setPrototypeOf(t, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
    return t2.__proto__ = e3, t2;
  }, _setPrototypeOf(t, e2);
}
function _inherits(t, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e2 && e2.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e2 && _setPrototypeOf(t, e2);
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type2, args) {
    if (console && console[type2]) console[type2].apply(console, args);
  }
};
var Logger = (function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options2);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options2;
      this.debug = options2.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn4() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === "string") args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create3(moduleName) {
      return new Logger2(this.logger, _objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }, this.options));
    }
  }]);
  return Logger2;
})();
var baseLogger = new Logger();
var EventEmitter = (function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on(events2, listener) {
      var _this = this;
      events2.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event]) return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
})();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object2) {
  if (object2 == null) return "";
  return "" + object2;
}
function copy(a, s, t) {
  a.forEach(function(m) {
    if (s[m]) t[m] = s[m];
  });
}
function getLastOfPath(object2, path2, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object2 || typeof object2 === "string";
  }
  var stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object2[key] && Empty) object2[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object2, key)) {
      object2 = object2[key];
    } else {
      object2 = {};
    }
  }
  if (canNotTraverseDeeper()) return {};
  return {
    obj: object2,
    k: cleanKey(stack.shift())
  };
}
function setPath(object2, path2, newValue) {
  var _getLastOfPath = getLastOfPath(object2, path2, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath(object2, path2, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object2, path2, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
}
function getPath(object2, path2) {
  var _getLastOfPath3 = getLastOfPath(object2, path2), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj) return void 0;
  return obj[k];
}
function getPathWithDefaults(data2, defaultData, key) {
  var value = getPath(data2, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data2) {
  if (typeof data2 === "string") {
    return data2.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data2;
}
var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var ResourceStore = (function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  function ResourceStore2(data2) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data2 || {};
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);
      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var path2 = [lng, ns];
      if (key && typeof key !== "string") path2 = path2.concat(key);
      if (key && typeof key === "string") path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
      }
      return getPath(this.data, path2);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0) keySeparator = ".";
      var path2 = [lng, ns];
      if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        value = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path2, value);
      if (!options2.silent) this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m in resources) {
        if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]") this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
      }
      if (!options2.silent) this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path2 = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path2) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread({}, pack, resources);
      }
      setPath(this.data, path2, pack);
      if (!options2.silent) this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1") return _objectSpread({}, {}, this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
})(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options2, translator2) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options2, translator2);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = (function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  function Translator2(services) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var resolved = this.resolve(key, options2);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options2) {
      var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0) nsSeparator = ":";
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var namespaces = options2.ns || this.options.defaultNS;
      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
        var m = key.match(this.interpolator.nestingRegexp);
        if (m && m.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string") namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options2, lastKey) {
      var _this2 = this;
      if (_typeof(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
        options2 = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options2) options2 = {};
      if (keys === void 0 || keys === null) return "";
      if (!Array.isArray(keys)) keys = [String(keys)];
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options2.lng || this.language;
      var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }
        return key;
      }
      var resolved = this.resolve(keys, options2);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options2) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy2[m] = this.translate(deepKey, _objectSpread({}, options2, {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m] === deepKey) copy2[m] = res[m];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys, options2, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options2);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count) : "";
        var defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread({}, options2, {
              keySeparator: false
            }));
            if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
          } else {
            lngs.push(options2.lng || this.language);
          }
          var send = function send2(l, k, fallbackValue) {
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options2);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options2);
            }
            _this2.emit("missingKey", l, namespace, k, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language).forEach(function(suffix) {
                  send([language], key + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options2, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
        if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, options2, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options2.skipInterpolation) {
        if (options2.interpolation) this.interpolator.init(_objectSpread({}, options2, {
          interpolation: _objectSpread({}, this.options.interpolation, options2.interpolation)
        }));
        var skipOnVariables = options2.interpolation && options2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data2 = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables) data2 = _objectSpread({}, this.options.interpolation.defaultVariables, data2);
        res = this.interpolator.interpolate(res, data2, options2.lng || this.language, options2);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft) options2.nest = false;
        }
        if (options2.nest !== false) res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options2.context) {
            _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
            return null;
          }
          return _this3.translate.apply(_this3, args.concat([key]));
        }, options2);
        if (options2.interpolation) this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
          i18nResolved: resolved
        }, options2) : options2, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string") keys = [keys];
      keys.forEach(function(k) {
        if (_this4.isValidLookup(found)) return;
        var extracted = _this4.extractFromKey(k, options2);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var needsContextHandling = options2.context !== void 0 && typeof options2.context === "string" && options2.context !== "";
        var codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code2) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code2;
            var finalKey = key;
            var finalKeys = [finalKey];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, options2);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code2, options2.count);
              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);
              if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options2.context));
              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code2, ns, possibleKey, options2);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code2, ns, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code2, ns, key, options2);
      return this.resourceStore.getResource(code2, ns, key, options2);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options2) {
      var prefix = "defaultValue";
      for (var option in options2) {
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix === option.substring(0, prefix.length) && void 0 !== options2[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
})(EventEmitter);
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var LanguageUtil = (function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options2;
    this.whitelist = this.options.supportedLngs || false;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0) return null;
      var p2 = code2.split("-");
      if (p2.length === 2) return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x") return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code2) {
      if (!code2 || code2.indexOf("-") < 0) return code2;
      var p2 = code2.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code2) {
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code2.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2) p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2) p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1) p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
    }
  }, {
    key: "isWhitelisted",
    value: function isWhitelisted(code2) {
      this.logger.deprecate("languageUtils.isWhitelisted", `function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it's usage asap.`);
      return this.isSupportedCode(code2);
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code2) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code2 = this.getLanguagePartFromCode(code2);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes) return null;
      var found;
      codes.forEach(function(code2) {
        if (found) return;
        var cleanedLng = _this.formatLanguageCode(code2);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code2) {
          if (found) return;
          var lngOnly = _this.getLanguagePartFromCode(code2);
          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
          });
        });
      }
      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code2) {
      if (!fallbacks) return [];
      if (typeof fallbacks === "function") fallbacks = fallbacks(code2);
      if (typeof fallbacks === "string") fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]") return fallbacks;
      if (!code2) return fallbacks["default"] || [];
      var found = fallbacks[code2];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code2)];
      if (!found) found = fallbacks[this.formatLanguageCode(code2)];
      if (!found) found = fallbacks[this.getLanguagePartFromCode(code2)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code2, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
      var codes = [];
      var addCode = function addCode2(c) {
        if (!c) return;
        if (_this2.isSupportedCode(c)) {
          codes.push(c);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
        }
      };
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code2));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code2));
        if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code2));
      } else if (typeof code2 === "string") {
        addCode(this.formatLanguageCode(code2));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
})();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n2) {
    return Number(n2 > 1);
  },
  2: function _2(n2) {
    return Number(n2 != 1);
  },
  3: function _3(n2) {
    return 0;
  },
  4: function _4(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _9(n2) {
    return Number(n2 >= 2);
  },
  10: function _10(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _11(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _12(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _13(n2) {
    return Number(n2 !== 0);
  },
  14: function _14(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _15(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _17(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _18(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _19(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _21(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _22(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
function createRules() {
  var rules = {};
  sets.forEach(function(set2) {
    set2.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = (function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code2) {
      return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code2) {
      var rule = this.getRule(code2);
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code2, key) {
      return this.getSuffixes(code2).map(function(suffix) {
        return key + suffix;
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code2) {
      var _this = this;
      var rule = this.getRule(code2);
      if (!rule) {
        return [];
      }
      return rule.numbers.map(function(number2) {
        return _this.getSuffix(code2, number2);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code2, count) {
      var _this2 = this;
      var rule = this.getRule(code2);
      if (rule) {
        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = "plural";
          } else if (suffix === 1) {
            suffix = "";
          }
        }
        var returnSuffix = function returnSuffix2() {
          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
        };
        if (this.options.compatibilityJSON === "v1") {
          if (suffix === 1) return "";
          if (typeof suffix === "number") return "_plural_".concat(suffix.toString());
          return returnSuffix();
        } else if (this.options.compatibilityJSON === "v2") {
          return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }
      this.logger.warn("no plural rule found for: ".concat(code2));
      return "";
    }
  }]);
  return PluralResolver2;
})();
var Interpolator = (function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    };
    this.init(options2);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options2.interpolation) options2.interpolation = {
        escapeValue: true
      };
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset2() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate2(str, data2, lng, options2) {
      var _this = this;
      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path2 = getPathWithDefaults(data2, defaultData, key);
          return _this.alwaysFormat ? _this.format(path2, void 0, lng) : path2;
        }
        var p2 = key.split(_this.formatSeparator);
        var k = p2.shift().trim();
        var f = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data2, defaultData, k), f, lng, options2);
      };
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          value = handleFormat(match[1].trim());
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match, options2);
              value = typeof temp === "string" ? temp : "";
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          str = str.replace(match[0], todo.safeValue(value));
          todo.regex.lastIndex = 0;
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match;
      var value;
      var clonedOptions = _objectSpread({}, options2);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0) return key;
        var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
        } catch (e2) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match[0].includes(this.formatSeparator) && !/{.*}/.test(match[1])) {
          var r = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r.shift();
          formatters = r;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string") return value;
        if (typeof value !== "string") value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v, f) {
            return _this2.format(v, f, options2.lng, options2);
          }, value.trim());
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
})();
function remove(arr2, what) {
  var found = arr2.indexOf(what);
  while (found !== -1) {
    arr2.splice(found, 1);
    found = arr2.indexOf(what);
  }
}
var Connector = (function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  function Connector2(backend, store, services) {
    var _this;
    var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options2;
    _this.logger = baseLogger.create("backendConnector");
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options2.backend, options2);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages2, namespaces, options2, callback) {
      var _this2 = this;
      var toLoad = [];
      var pending = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages2.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options2.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0) ;
          else if (_this2.state[name] === 1) {
            if (pending.indexOf(name) < 0) pending.push(name);
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending.indexOf(name) < 0) pending.push(name);
            if (toLoad.indexOf(name) < 0) toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
          }
        });
        if (!hasAllNamespaces) toLoadLanguages.push(lng);
      });
      if (toLoad.length || pending.length) {
        this.queue.push({
          pending,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad,
        pending,
        toLoadLanguages,
        toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data2) {
      var s = name.split("|");
      var lng = s[0];
      var ns = s[1];
      if (err) this.emit("failedLoading", lng, ns, err);
      if (data2) {
        this.store.addResourceBundle(lng, ns, data2);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q) {
        pushPath(q.loaded, [lng], ns);
        remove(q.pending, name);
        if (err) q.errors.push(err);
        if (q.pending.length === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function(l) {
            if (!loaded2[l]) loaded2[l] = [];
            if (q.loaded[l].length) {
              q.loaded[l].forEach(function(ns2) {
                if (loaded2[l].indexOf(ns2) < 0) loaded2[l].push(ns2);
              });
            }
          });
          q.done = true;
          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length) return callback(null, {});
      return this.backend[fcName](lng, ns, function(err, data2) {
        if (err && data2 && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data2);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages2, namespaces) {
      var _this4 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages2 === "string") languages2 = this.languageUtils.toResolveHierarchy(languages2);
      if (typeof namespaces === "string") namespaces = [namespaces];
      var toLoad = this.queueLoad(languages2, namespaces, options2, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages2, namespaces, callback) {
      this.prepareLoading(languages2, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages2, namespaces, callback) {
      this.prepareLoading(languages2, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s = name.split("|");
      var lng = s[0];
      var ns = s[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data2) {
        if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data2) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data2);
        _this5.loaded(name, err, data2);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages2, namespace, key, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "") return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages2, namespace, key, fallbackValue, null, _objectSpread({}, options2, {
          isUpdate
        }));
      }
      if (!languages2 || !languages2[0]) return;
      this.store.addResource(languages2[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
})(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    whitelist: false,
    nonExplicitWhitelist: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object") ret = args[1];
      if (typeof args[1] === "string") ret.defaultValue = args[1];
      if (typeof args[2] === "string") ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options2) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: false
    }
  };
}
function transformOptions(options2) {
  if (typeof options2.ns === "string") options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string") options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string") options2.fallbackNS = [options2.fallbackNS];
  if (options2.whitelist) {
    if (options2.whitelist && options2.whitelist.indexOf("cimode") < 0) {
      options2.whitelist = options2.whitelist.concat(["cimode"]);
    }
    options2.supportedLngs = options2.whitelist;
  }
  if (options2.nonExplicitWhitelist) {
    options2.nonExplicitSupportedLngs = options2.nonExplicitWhitelist;
  }
  if (options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  return options2;
}
function noop() {
}
var I18n = (function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  function I18n2() {
    var _this;
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options2);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    if (callback && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options2, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options2, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init() {
      var _this2 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (options2.whitelist && !options2.supportedLngs) {
        this.logger.deprecate("whitelist", 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.');
      }
      if (options2.nonExplicitWhitelist && !options2.nonExplicitSupportedLngs) {
        this.logger.deprecate("whitelist", 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.');
      }
      this.options = _objectSpread({}, get(), this.options, transformOptions(options2));
      this.format = this.options.interpolation.format;
      if (!callback) callback = noop;
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === "function") return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m) {
          if (m.init) m.init(_this2);
        });
      }
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t) {
          if (_this2.isInitialized) _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone) _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t);
          callback(err, t);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function") usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode") return usedCallback();
        var toLoad = [];
        var append = function append2(lng) {
          if (!lng) return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l) {
            return append(l);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var done = function done2(err, l) {
        if (l) {
          _this4.language = l;
          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          _this4.translator.changeLanguage(l);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l);
          _this4.logger.log("languageChanged", l);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err, function() {
          return _this4.t.apply(_this4, arguments);
        });
      };
      var setLng = function setLng2(lngs) {
        var l = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l) {
          if (!_this4.language) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          }
          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
        }
        _this4.loadResources(l, function(err) {
          done(err, l);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options2;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options2 = _objectSpread({}, opts);
        }
        options2.lng = options2.lng || fixedT2.lng;
        options2.lngs = options2.lngs || fixedT2.lngs;
        options2.ns = options2.ns || fixedT2.ns;
        return _this5.t(key, options2);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode") return true;
      var loadNotPending = function loadNotPending2(l, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== void 0) return preResult;
      }
      if (this.hasResourceBundle(lng, ns)) return true;
      if (!this.services.backendConnector.backend) return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string") ns = [ns];
      ns.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0) _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string") lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
      if (!lng) return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
    }
  }, {
    key: "createInstance",
    value: function createInstance() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      return new I18n2(options2, callback);
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      var mergedOptions = _objectSpread({}, this.options, options2, {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m) {
        clone2[m] = _this8[m];
      });
      clone2.services = _objectSpread({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event].concat(args));
      });
      clone2.init(mergedOptions, callback);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }]);
  return I18n2;
})(EventEmitter);
var i18next = new I18n();
var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var cookie = {
  create: function create(name, value, minutes, domain) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/"
    };
    var expires;
    if (minutes) {
      var date2 = /* @__PURE__ */ new Date();
      date2.setTime(date2.getTime() + minutes * 60 * 1e3);
      expires = "; expires=" + date2.toUTCString();
    } else expires = "";
    domain = domain ? "domain=" + domain + ";" : "";
    cookieOptions = Object.keys(cookieOptions).reduce(function(acc, key) {
      return acc + ";" + key.replace(/([A-Z])/g, function($1) {
        return "-" + $1.toLowerCase();
      }) + "=" + cookieOptions[key];
    }, "");
    document.cookie = name + "=" + encodeURIComponent(value) + expires + ";" + domain + cookieOptions;
  },
  read: function read(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(";");
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove: function remove2(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup(options2) {
    var found;
    if (options2.lookupCookie && typeof document !== "undefined") {
      var c = cookie.read(options2.lookupCookie);
      if (c) found = c;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options2) {
    if (options2.lookupCookie && typeof document !== "undefined") {
      cookie.create(options2.lookupCookie, lng, options2.cookieMinutes, options2.cookieDomain, options2.cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  lookup: function lookup2(options2) {
    var found;
    if (typeof window !== "undefined") {
      var query = window.location.search.substring(1);
      var params = query.split("&");
      for (var i = 0; i < params.length; i++) {
        var pos = params[i].indexOf("=");
        if (pos > 0) {
          var key = params[i].substring(0, pos);
          if (key === options2.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport;
try {
  hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
  var testKey = "i18next.translate.boo";
  window.localStorage.setItem(testKey, "foo");
  window.localStorage.removeItem(testKey);
} catch (e2) {
  hasLocalStorageSupport = false;
}
var localStorage$1 = {
  name: "localStorage",
  lookup: function lookup3(options2) {
    var found;
    if (options2.lookupLocalStorage && hasLocalStorageSupport) {
      var lng = window.localStorage.getItem(options2.lookupLocalStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options2) {
    if (options2.lookupLocalStorage && hasLocalStorageSupport) {
      window.localStorage.setItem(options2.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport;
try {
  hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
  var testKey$1 = "i18next.translate.boo";
  window.sessionStorage.setItem(testKey$1, "foo");
  window.sessionStorage.removeItem(testKey$1);
} catch (e2) {
  hasSessionStorageSupport = false;
}
var sessionStorage = {
  name: "sessionStorage",
  lookup: function lookup4(options2) {
    var found;
    if (options2.lookupsessionStorage && hasSessionStorageSupport) {
      var lng = window.sessionStorage.getItem(options2.lookupsessionStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage3(lng, options2) {
    if (options2.lookupsessionStorage && hasSessionStorageSupport) {
      window.sessionStorage.setItem(options2.lookupsessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup5(options2) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i = 0; i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup6(options2) {
    var found;
    var htmlTag2 = options2.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  lookup: function lookup7(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options2.lookupFromPathIndex === "number") {
          if (typeof language[options2.lookupFromPathIndex] !== "string") {
            return void 0;
          }
          found = language[options2.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup8(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
      if (language instanceof Array) {
        if (typeof options2.lookupFromSubdomainIndex === "number") {
          found = language[options2.lookupFromSubdomainIndex].replace("http://", "").replace("https://", "").replace(".", "");
        } else {
          found = language[0].replace("http://", "").replace("https://", "").replace(".", "");
        }
      }
    }
    return found;
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    //cookieMinutes: 10,
    //cookieDomain: 'myDomain'
    checkWhitelist: true,
    checkForSimilarInWhitelist: false
  };
}
var Browser = /* @__PURE__ */ (function() {
  function Browser2(services) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options2);
  }
  _createClass(Browser2, [{
    key: "init",
    value: function init(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options2, this.options || {}, getDefaults());
      if (this.options.checkForSimilarInWhitelist) this.options.checkWhitelist = true;
      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage$1);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder) detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup9 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup9 && typeof lookup9 === "string") lookup9 = [lookup9];
          if (lookup9) detected = detected.concat(lookup9);
        }
      });
      var found;
      detected.forEach(function(lng) {
        if (found) return;
        var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
        if (!_this.options.checkWhitelist || _this.services.languageUtils.isWhitelisted(cleanedLng)) found = cleanedLng;
        if (!found && _this.options.checkForSimilarInWhitelist) {
          found = _this.getSimilarInWhitelist(cleanedLng);
        }
      });
      if (!found) {
        var fallbacks = this.i18nOptions.fallbackLng;
        if (typeof fallbacks === "string") fallbacks = [fallbacks];
        if (!fallbacks) fallbacks = [];
        if (Object.prototype.toString.apply(fallbacks) === "[object Array]") {
          found = fallbacks[0];
        } else {
          found = fallbacks[0] || fallbacks["default"] && fallbacks["default"][0];
        }
      }
      return found;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage4(lng, caches) {
      var _this2 = this;
      if (!caches) caches = this.options.caches;
      if (!caches) return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
      caches.forEach(function(cacheName) {
        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }, {
    key: "getSimilarInWhitelist",
    value: function getSimilarInWhitelist(cleanedLng) {
      var _this3 = this;
      if (!this.i18nOptions.whitelist) return;
      if (cleanedLng.includes("-")) {
        var prefix = cleanedLng.split("-")[0];
        var cleanedPrefix = this.services.languageUtils.formatLanguageCode(prefix);
        if (this.services.languageUtils.isWhitelisted(cleanedPrefix)) return cleanedPrefix;
        cleanedLng = cleanedPrefix;
      }
      var similar = this.i18nOptions.whitelist.find(function(whitelistLng) {
        var cleanedWhitelistLng = _this3.services.languageUtils.formatLanguageCode(whitelistLng);
        if (cleanedWhitelistLng.startsWith(cleanedLng)) return cleanedWhitelistLng;
      });
      if (similar) return similar;
    }
  }]);
  return Browser2;
})();
Browser.type = "languageDetector";
var fes = {
  autoplay: "The media that tried to play (with '{{src}}') wasn't allowed to by this browser, most likely due to the browser's autoplay policy.\n\n+ More info: {{url}}",
  checkUserDefinedFns: "It seems that you may have accidentally written {{name}} instead of {{actualName}}. Please correct it if it's not intentional.",
  fileLoadError: {
    bytes: "It looks like there was a problem loading your file. {{suggestion}}",
    font: "It looks like there was a problem loading your font. {{suggestion}}",
    gif: "There was some trouble loading your GIF. Make sure that your GIF is using 87a or 89a encoding.",
    image: "It looks like there was a problem loading your image. {{suggestion}}",
    json: "It looks like there was a problem loading your JSON file. {{suggestion}}",
    large: "If your large file isn't fetched successfully, we recommend splitting the file into smaller segments and fetching those.",
    strings: "It looks like there was a problem loading your text file. {{suggestion}}",
    suggestion: "Try checking if the file path ({{filePath}}) is correct, hosting the file online, or running a local server.\n\n+ More info: {{url}}",
    table: "It looks like there was a problem loading your table file. {{suggestion}}",
    xml: "It looks like there was a problem loading your XML file. {{suggestion}}"
  },
  friendlyParamError: {
    type_EMPTY_VAR: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received an empty variable instead. If not intentional, this is often a problem with scope.\n\n+ More info: {{url}}",
    type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() was expecting at least {{minParams}} arguments, but received only {{argCount}}.",
    type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() was expecting no more than {{maxParams}} arguments, but received {{argCount}}.",
    type_WRONG_TYPE: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received {{argType}} instead."
  },
  globalErrors: {
    reference: {
      cannotAccess: '\n{{location}} "{{symbol}}" is used before declaration. Make sure you have declared the variable before using it.\n\n+ More info: {{url}}',
      notDefined: '\n{{location}} "{{symbol}}" is not defined in the current scope. If you have defined it in your code, you should check its scope, spelling, and letter-casing (JavaScript is case-sensitive).\n\n+ More info: {{url}}'
    },
    stackSubseq: "└[{{location}}] \n	 Called from line {{line}} in {{func}}()\n",
    stackTop: "┌[{{location}}] \n	 Error at line {{line}} in {{func}}()\n",
    syntax: {
      badReturnOrYield: "\nSyntax Error - return lies outside of a function. Make sure you’re not missing any brackets, so that return lies inside a function.\n\n+ More info: {{url}}",
      invalidToken: "\nSyntax Error - Found a symbol that JavaScript doesn't recognize or didn't expect at it's place.\n\n+ More info: {{url}}",
      missingInitializer: "\nSyntax Error - A const variable is declared but not initialized. In JavaScript, an initializer for a const is required. A value must be specified in the same statement in which the variable is declared. Check the line number in the error and assign the const variable a value.\n\n+ More info: {{url}}",
      redeclaredVariable: `
Syntax Error - "{{symbol}}" is being redeclared. JavaScript doesn't allow declaring a variable more than once. Check the line number in error for redeclaration of the variable.

+ More info: {{url}}`,
      unexpectedToken: "\nSyntax Error - Symbol present at a place that wasn't expected.\nUsually this is due to a typo. Check the line number in the error for anything missing/extra.\n\n+ More info: {{url}}"
    },
    type: {
      constAssign: "\n{{location}} A const variable is being re-assigned. In javascript, re-assigning a value to a constant is not allowed. If you want to re-assign new values to a variable, make sure it is declared as var or let.\n\n+ More info: {{url}}",
      notfunc: '\n{{location}} "{{symbol}}" could not be called as a function.\nCheck the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}',
      notfuncObj: '\n{{location}} "{{symbol}}" could not be called as a function.\nVerify whether "{{obj}}" has "{{symbol}}" in it and check the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}',
      readFromNull: "\n{{location}} The property of null can't be read. In javascript the value null indicates that an object has no value.\n\n+ More info: {{url}}",
      readFromUndefined: "\n{{location}} Cannot read property of undefined. Check the line number in error and make sure the variable which is being operated is not undefined.\n\n + More info: {{url}}"
    }
  },
  libraryError: '{{location}} An error with message "{{error}}" occurred inside the p5js library when {{func}} was called. If not stated otherwise, it might be an issue with the arguments passed to {{func}}.',
  location: "[{{file}}, line {{line}}]",
  misspelling: '{{location}} It seems that you may have accidentally written "{{name}}" instead of "{{actualName}}". Please correct it to {{actualName}} if you wish to use the {{type}} from p5.js.',
  misspelling_plural: '{{location}} It seems that you may have accidentally written "{{name}}".\nYou may have meant one of the following: \n{{suggestions}}',
  misusedTopLevel: "Did you just try to use p5.js's {{symbolName}} {{symbolType}}? If so, you may want to move it into your sketch's setup() function.\n\n+ More info: {{url}}",
  preloadDisabled: "The preload() function has been removed in p5.js 2.0. Please load assets in setup() using async / await keywords or callbacks instead. See https://github.com/processing/p5.js-compatibility for more information about 2.0 and compatibility, or https://dev.to/limzykenneth/asynchronous-p5js-20-458f for more information about promises and async/await.",
  positions: {
    p_1: "first",
    p_10: "tenth",
    p_11: "eleventh",
    p_12: "twelfth",
    p_2: "second",
    p_3: "third",
    p_4: "fourth",
    p_5: "fifth",
    p_6: "sixth",
    p_7: "seventh",
    p_8: "eighth",
    p_9: "ninth"
  },
  pre: "\n🌸 p5.js says: {{message}}",
  sketchReaderErrors: {
    reservedConst: 'you have used a p5.js reserved variable "{{symbol}}" make sure you change the variable name to something else.\n\n+ More info: {{url}}',
    reservedFunc: 'you have used a p5.js reserved function "{{symbol}}" make sure you change the function name to something else.\n\n+ More info: {{url}}'
  },
  welcome: "Welcome! This is your friendly debugger. To turn me off, switch to using p5.min.js.",
  wrongPreload: '{{location}} An error with message "{{error}}" occurred inside the p5js library when "{{func}}" was called. If not stated otherwise, it might be due to "{{func}}" being called from preload. Nothing besides load calls (loadImage, loadJSON, loadFont, loadStrings, etc.) should be inside the preload function.'
};
var en = {
  fes
};
var fallbackResources = {
  en: {
    translation: en
  }
};
const languages = [
  "en",
  "es",
  "ko",
  "zh",
  "hi",
  "ja"
];
if (typeof IS_MINIFIED === "undefined") {
  if (typeof P5_DEV_BUILD !== "undefined") {
    let completeResources = require("../../translations/dev");
    for (const language of Object.keys(completeResources)) {
      const parts = language.split("_");
      const lng = parts.slice(0, parts.length - 1).join("-");
      const ns = parts[parts.length - 1];
      fallbackResources[lng] = fallbackResources[lng] || {};
      fallbackResources[lng][ns] = completeResources[language];
    }
  }
}
class FetchResources {
  constructor(services, options2) {
    this.init(services, options2);
  }
  // run fetch with a timeout. Automatically rejects on timeout
  // default timeout = 2000 ms
  fetchWithTimeout(url, options2, timeout = 2e3) {
    return Promise.race([
      fetch(url, options2),
      new Promise(
        (_23, reject) => setTimeout(() => reject(new Error("timeout")), timeout)
      )
    ]);
  }
  init(services, options2 = {}) {
    this.services = services;
    this.options = options2;
  }
  read(language, namespace, callback) {
    const loadPath = this.options.loadPath;
    if (language === this.options.fallback) {
      callback(null, fallbackResources[language][namespace]);
    } else if (languages.includes(language)) {
      const url = this.services.interpolator.interpolate(loadPath, {
        lng: language,
        ns: namespace
      });
      this.loadUrl(url, callback);
    } else {
      callback("Not found", false);
    }
  }
  loadUrl(url, callback) {
    this.fetchWithTimeout(url).then(
      (response) => {
        const ok = response.ok;
        if (!ok) {
          throw new Error(`failed loading ${url}`);
        }
        return response.json();
      },
      () => {
        throw new Error(`failed loading ${url}`);
      }
    ).then((data2) => {
      return callback(null, data2);
    }).catch(callback);
  }
}
FetchResources.type = "backend";
let translator = (key, values) => {
  console.debug("p5.js translator called before translations were loaded");
  i18next.t(key, values);
};
const initialize = () => {
  let i18init = i18next.use(Browser).use(FetchResources).init({
    fallbackLng: "en",
    nestingPrefix: "$tr(",
    nestingSuffix: ")",
    defaultNS: "translation",
    returnEmptyString: false,
    interpolation: {
      escapeValue: false
    },
    detection: {
      checkWhitelist: false,
      // prevent storing or locating language from cookie or localStorage
      // more info on https://github.com/processing/p5.js/issues/4862
      order: ["querystring", "navigator", "htmlTag", "path", "subdomain"],
      caches: []
    },
    backend: {
      fallback: "en",
      // ensure that the FES internationalization strings are loaded
      // from the latest patch of the current minor version of p5.js
      loadPath: `https://cdn.jsdelivr.net/npm/p5@${VERSION.replace(/^(\d+\.\d+)\.\d+.*$/, "$1")}/translations/{{lng}}/{{ns}}.json`
    },
    partialBundledLanguages: true,
    resources: fallbackResources
  }).then(
    (translateFn) => {
      translator = translateFn;
    },
    (e2) => console.debug(`Translations failed to load (${e2})`)
  );
  return i18init;
};
const strings$1 = {
  ReferenceError: [
    {
      msg: "{{}} is not defined",
      type: "NOTDEFINED",
      browser: "all"
    },
    {
      msg: "Can't find variable: {{}}",
      type: "NOTDEFINED",
      browser: "Safari"
    },
    {
      msg: "Cannot access '{{.}}' before initialization",
      type: "CANNOTACCESS",
      browser: "Chrome"
    },
    {
      msg: "can't access lexical declaration '{{.}}' before initialization",
      type: "CANNOTACCESS",
      browser: "Firefox"
    }
  ],
  SyntaxError: [
    {
      msg: "illegal character",
      type: "INVALIDTOKEN",
      browser: "Firefox"
    },
    {
      msg: "Invalid character",
      type: "INVALIDTOKEN",
      browser: "Safari"
    },
    {
      msg: "Invalid or unexpected token",
      type: "INVALIDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "Unexpected token '{{.}}'",
      type: "UNEXPECTEDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "expected {{.}}, got '{{.}}'",
      type: "UNEXPECTEDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "Identifier '{{.}}' has already been declared",
      type: "REDECLAREDVARIABLE",
      browser: "Chrome"
    },
    {
      msg: "redeclaration of {} {{.}}",
      type: "REDECLAREDVARIABLE",
      browser: "Firefox"
    },
    {
      msg: "Missing initializer in const declaration",
      type: "MISSINGINITIALIZER",
      browser: "Chrome"
    },
    {
      msg: "missing = in const declaration",
      type: "MISSINGINITIALIZER",
      browser: "Firefox"
    },
    {
      msg: "Illegal return statement",
      type: "BADRETURNORYIELD",
      browser: "Chrome"
    },
    {
      msg: "return not in function",
      type: "BADRETURNORYIELD",
      browser: "Firefox"
    }
  ],
  TypeError: [
    {
      msg: "{{.}} is not a function",
      type: "NOTFUNC",
      browser: "all"
    },
    {
      msg: "Cannot read {{.}} null",
      type: "READNULL",
      browser: "Chrome"
    },
    {
      msg: "{{.}} is null",
      type: "READNULL",
      browser: "Firefox"
    },
    {
      msg: "Cannot read {{.}} undefined",
      type: "READUDEFINED",
      browser: "Chrome"
    },
    {
      msg: "{{.}} is undefined",
      type: "READUDEFINED",
      browser: "Firefox"
    },
    {
      msg: "Assignment to constant variable",
      type: "CONSTASSIGN",
      browser: "Chrome"
    },
    {
      msg: "invalid assignment to const '{{.}}'",
      type: "CONSTASSIGN",
      browser: "Firefox"
    }
  ]
};
function fesCore(p53, fn2) {
  const typeColors = ["#2D7BB6", "#EE9900", "#4DB200", "#C83C00"];
  let misusedAtTopLevelCode = null;
  let defineMisusedAtTopLevelCode = null;
  const EDIT_DIST_THRESHOLD = 2;
  class FESError extends Error {
  }
  if (typeof IS_MINIFIED !== "undefined") {
    p53._friendlyError = p53._checkForUserDefinedFunctions = p53._fesErrorMonitor = () => {
    };
  } else {
    const class2type = {};
    const toString2 = class2type.toString;
    const names = [
      "Boolean",
      "Number",
      "String",
      "Function",
      "Array",
      "Date",
      "RegExp",
      "Object",
      "Error"
    ];
    for (let n2 = 0; n2 < names.length; n2++) {
      class2type[`[object ${names[n2]}]`] = names[n2].toLowerCase();
    }
    const getType = (obj) => {
      if (obj == null) {
        return `${obj}`;
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
    };
    const entryPoints = [
      "setup",
      "draw",
      "deviceMoved",
      "deviceTurned",
      "deviceShaken",
      "doubleClicked",
      "mousePressed",
      "mouseReleased",
      "mouseMoved",
      "mouseDragged",
      "mouseClicked",
      "mouseWheel",
      "touchStarted",
      "touchMoved",
      "touchEnded",
      "keyPressed",
      "keyReleased",
      "keyTyped",
      "windowResized"
    ];
    const mapToReference = (message, func) => {
      let msgWithReference = "";
      if (func == null || func.substring(0, 4) === "load") {
        msgWithReference = message;
      } else {
        const methodParts = func.split(".");
        const referenceSection = methodParts.length > 1 ? `${methodParts[0]}.${methodParts[1]}` : "p5";
        const funcName = methodParts.length === 1 ? func : methodParts.slice(2).join("/");
        funcName.startsWith("p5.") ? msgWithReference = `${message} (https://p5js.org/reference/${referenceSection}.${funcName})` : msgWithReference = `${message} (https://p5js.org/reference/${referenceSection}/${funcName})`;
      }
      return msgWithReference;
    };
    p53._report = (message, func, color2) => {
      const log3 = p53._fesLogger == null ? console.log.bind(console) : p53._fesLogger;
      if ("undefined" === getType(color2)) {
        color2 = "#B40033";
      } else if (getType(color2) === "number") {
        color2 = typeColors[color2];
      }
      message = mapToReference(message, func);
      const prefixedMsg = translator("fes.pre", { message });
      {
        log3(prefixedMsg);
      }
    };
    p53._error = (context2, message, func) => {
      p53._report(message, func);
      context2.hitCriticalError = true;
      throw new FESError("Stopping sketch to prevent more errors");
    };
    p53._friendlyError = function(message, func, color2) {
      if (p53.disableFriendlyErrors) return;
      p53._report(message, func, color2);
    };
    p53._friendlyAutoplayError = function(src) {
      const message = translator("fes.autoplay", {
        src,
        url: "https://developer.mozilla.org/docs/Web/Media/Autoplay_guide"
      });
      console.log(translator("fes.pre", { message }));
    };
    const computeEditDistance = (w1, w2) => {
      const l1 = w1.length, l2 = w2.length;
      if (l1 === 0) return w2;
      if (l2 === 0) return w1;
      let prev = [];
      let cur = [];
      for (let j2 = 0; j2 < l2 + 1; j2++) {
        cur[j2] = j2;
      }
      prev = cur;
      for (let i = 1; i < l1 + 1; i++) {
        cur = [];
        for (let j2 = 0; j2 < l2 + 1; j2++) {
          if (j2 === 0) {
            cur[j2] = i;
          } else {
            let a1 = w1[i - 1], a2 = w2[j2 - 1];
            let temp = 999999;
            let cost = a1.toLowerCase() === a2.toLowerCase() ? 0 : 1;
            temp = temp > cost + prev[j2 - 1] ? cost + prev[j2 - 1] : temp;
            temp = temp > 1 + cur[j2 - 1] ? 1 + cur[j2 - 1] : temp;
            temp = temp > 1 + prev[j2] ? 1 + prev[j2] : temp;
            cur[j2] = temp;
          }
        }
        prev = cur;
      }
      return cur[l2];
    };
    p53.isPreloadSupported = function() {
      return false;
    };
    const checkForUserDefinedFunctions = (context2) => {
      if (p53.disableFriendlyErrors) return;
      const instanceMode = context2 instanceof p53;
      context2 = instanceMode ? context2 : window;
      const fnNames = entryPoints;
      if (context2.preload && !p53.isPreloadSupported()) {
        p53._error(context2, translator("fes.preloadDisabled"));
      }
      const fxns = {};
      fnNames.forEach((symbol) => {
        fxns[symbol.toLowerCase()] = symbol;
      });
      for (const prop of Object.keys(context2)) {
        const lowercase2 = prop.toLowerCase();
        if (fxns.hasOwnProperty(lowercase2) && !context2[fxns[lowercase2]] && typeof context2[prop] === "function") {
          const msg = translator("fes.checkUserDefinedFns", {
            name: prop,
            actualName: fxns[lowercase2]
          });
          p53._friendlyError(msg, fxns[lowercase2]);
        }
      }
    };
    const handleMisspelling = (errSym, error2) => {
      if (!misusedAtTopLevelCode) {
        defineMisusedAtTopLevelCode();
      }
      const distanceMap = {};
      let min = 999999;
      misusedAtTopLevelCode.forEach((symbol) => {
        let dist = computeEditDistance(errSym, symbol.name);
        if (distanceMap[dist]) distanceMap[dist].push(symbol);
        else distanceMap[dist] = [symbol];
        if (dist < min) min = dist;
      });
      if (min > Math.min(EDIT_DIST_THRESHOLD, errSym.length)) return false;
      const matchedSymbols = distanceMap[min].filter(
        (symbol) => symbol.name !== errSym
      );
      if (matchedSymbols.length !== 0) {
        const parsed = p53._getErrorStackParser().parse(error2);
        let locationObj;
        if (parsed && parsed[0] && parsed[0].fileName && parsed[0].lineNumber && parsed[0].columnNumber) {
          locationObj = {
            location: `${parsed[0].fileName}:${parsed[0].lineNumber}:${parsed[0].columnNumber}`,
            file: parsed[0].fileName.split("/").slice(-1),
            line: parsed[0].lineNumber
          };
        }
        let msg;
        if (matchedSymbols.length === 1) {
          msg = translator("fes.misspelling", {
            name: errSym,
            actualName: matchedSymbols[0].name,
            type: matchedSymbols[0].type,
            location: locationObj ? translator("fes.location", locationObj) : "",
            count: matchedSymbols.length
          });
        } else {
          const suggestions = matchedSymbols.map((symbol) => {
            const message = "▶️ " + symbol.name + (symbol.type === "function" ? "()" : "");
            return mapToReference(message, symbol.name);
          }).join("\n");
          msg = translator("fes.misspelling", {
            name: errSym,
            suggestions,
            location: locationObj ? translator("fes.location", locationObj) : "",
            count: matchedSymbols.length
          });
        }
        p53._friendlyError(
          msg,
          matchedSymbols.length === 1 ? matchedSymbols[0].name : void 0
        );
        return true;
      }
      return false;
    };
    const printFriendlyStack = (friendlyStack) => {
      const log3 = p53._fesLogger && typeof p53._fesLogger === "function" ? p53._fesLogger : console.log.bind(console);
      if (friendlyStack.length > 1) {
        let stacktraceMsg = "";
        friendlyStack.forEach((frame, idx) => {
          const location2 = `${frame.fileName}:${frame.lineNumber}:${frame.columnNumber}`;
          let frameMsg, translationObj = {
            func: frame.functionName,
            line: frame.lineNumber,
            location: location2,
            file: frame.fileName.split("/").slice(-1)
          };
          if (idx === 0) {
            frameMsg = translator("fes.globalErrors.stackTop", translationObj);
          } else {
            frameMsg = translator("fes.globalErrors.stackSubseq", translationObj);
          }
          stacktraceMsg += frameMsg;
        });
        log3(stacktraceMsg);
      }
    };
    const processStack = (error2, stacktrace2) => {
      if (!stacktrace2) return [false, null];
      stacktrace2.forEach((frame) => {
        frame.functionName = frame.functionName || "";
      });
      let isInternal = false;
      let p5FileName, friendlyStack, currentEntryPoint;
      try {
        throw new Error();
      } catch (testError) {
        const testStacktrace = p53._getErrorStackParser().parse(testError);
        p5FileName = testStacktrace[0].fileName;
      }
      for (let i = stacktrace2.length - 1; i >= 0; i--) {
        let splitted = stacktrace2[i].functionName.split(".");
        if (entryPoints.includes(splitted[splitted.length - 1])) {
          friendlyStack = stacktrace2.slice(0, i + 1);
          currentEntryPoint = splitted[splitted.length - 1];
          if (stacktrace2[0].fileName === p5FileName) {
            isInternal = true;
            break;
          }
          break;
        }
      }
      if (!friendlyStack) friendlyStack = stacktrace2;
      if (isInternal) {
        friendlyStack = friendlyStack.map((frame, index) => {
          frame.frameIndex = index;
          return frame;
        }).filter((frame) => frame.fileName !== p5FileName);
        if (friendlyStack.length === 0) return [true, null];
        const func = stacktrace2[friendlyStack[0].frameIndex - 1].functionName.split(".").slice(-1)[0];
        let locationObj;
        if (friendlyStack[0].fileName && friendlyStack[0].lineNumber && friendlyStack[0].columnNumber) {
          locationObj = {
            location: `${friendlyStack[0].fileName}:${friendlyStack[0].lineNumber}:${friendlyStack[0].columnNumber}`,
            file: friendlyStack[0].fileName.split("/").slice(-1),
            line: friendlyStack[0].lineNumber
          };
          if (p53._fesLogCache[locationObj.location]) return [true, null];
        }
        if (currentEntryPoint === "preload" && fn2._preloadMethods[func] == null) {
          p53._friendlyError(
            translator("fes.wrongPreload", {
              func,
              location: locationObj ? translator("fes.location", locationObj) : "",
              error: error2.message
            }),
            "preload"
          );
        } else {
          p53._friendlyError(
            translator("fes.libraryError", {
              func,
              location: locationObj ? translator("fes.location", locationObj) : "",
              error: error2.message
            }),
            func
          );
        }
        if (friendlyStack && friendlyStack.length) {
          printFriendlyStack(friendlyStack);
        }
      }
      return [isInternal, friendlyStack];
    };
    const fesErrorMonitor = (e2) => {
      if (p53.disableFriendlyErrors) return;
      if (e2 && (e2 instanceof FESError || e2.reason instanceof FESError)) return;
      let error2;
      if (e2 instanceof Error) {
        error2 = e2;
      } else if (e2 instanceof ErrorEvent) {
        error2 = e2.error;
      } else if (e2 instanceof PromiseRejectionEvent) {
        error2 = e2.reason;
        if (!(error2 instanceof Error)) return;
      }
      if (!error2) return;
      let stacktrace2 = p53._getErrorStackParser().parse(error2);
      let [isInternal, friendlyStack] = processStack(error2, stacktrace2);
      if (isInternal) {
        return;
      }
      const errList = strings$1[error2.name];
      if (!errList) return;
      let matchedError;
      for (const obj of errList) {
        let string2 = obj.msg;
        string2 = string2.replace(new RegExp("{{}}", "g"), "([a-zA-Z0-9_]+)");
        string2 = string2.replace(new RegExp("{{.}}", "g"), "(.+)");
        string2 = string2.replace(new RegExp("{}", "g"), "(?:[a-zA-Z0-9_]+)");
        let matched = error2.message.match(string2);
        if (matched) {
          matchedError = Object.assign({}, obj);
          matchedError.match = matched;
          break;
        }
      }
      if (!matchedError) return;
      let locationObj;
      if (stacktrace2 && stacktrace2[0].fileName && stacktrace2[0].lineNumber && stacktrace2[0].columnNumber) {
        locationObj = {
          location: `${stacktrace2[0].fileName}:${stacktrace2[0].lineNumber}:${stacktrace2[0].columnNumber}`,
          file: stacktrace2[0].fileName.split("/").slice(-1),
          line: friendlyStack[0].lineNumber
        };
      }
      switch (error2.name) {
        case "SyntaxError": {
          switch (matchedError.type) {
            case "INVALIDTOKEN": {
              let url = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Illegal_character#What_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.invalidToken", {
                  url
                })
              );
              break;
            }
            case "UNEXPECTEDTOKEN": {
              let url = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Unexpected_token#What_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.unexpectedToken", {
                  url
                })
              );
              break;
            }
            case "REDECLAREDVARIABLE": {
              let errSym = matchedError.match[1];
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Redeclared_parameter#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.redeclaredVariable", {
                  symbol: errSym,
                  url
                })
              );
              break;
            }
            case "MISSINGINITIALIZER": {
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Missing_initializer_in_const#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.missingInitializer", {
                  url
                })
              );
              break;
            }
            case "BADRETURNORYIELD": {
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Bad_return_or_yield#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.badReturnOrYield", {
                  url
                })
              );
              break;
            }
          }
          break;
        }
        case "ReferenceError": {
          switch (matchedError.type) {
            case "NOTDEFINED": {
              let errSym = matchedError.match[1];
              if (errSym && handleMisspelling(errSym, error2)) {
                break;
              }
              let url = "https://p5js.org/examples/data-variable-scope.html";
              p53._friendlyError(
                translator("fes.globalErrors.reference.notDefined", {
                  url,
                  symbol: errSym,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
            case "CANNOTACCESS": {
              let errSym = matchedError.match[1];
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.reference.cannotAccess", {
                  url,
                  symbol: errSym,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
          }
          break;
        }
        case "TypeError": {
          switch (matchedError.type) {
            case "NOTFUNC": {
              let errSym = matchedError.match[1];
              let splitSym = errSym.split(".");
              let url = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Not_a_function#What_went_wrong";
              let translationObj = {
                url,
                symbol: splitSym[splitSym.length - 1],
                obj: splitSym.slice(0, splitSym.length - 1).join("."),
                location: locationObj ? translator("fes.location", locationObj) : ""
              };
              if (splitSym.length > 1) {
                p53._friendlyError(
                  translator("fes.globalErrors.type.notfuncObj", translationObj)
                );
              } else {
                p53._friendlyError(
                  translator("fes.globalErrors.type.notfunc", translationObj)
                );
              }
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
            case "READNULL": {
              let errSym = matchedError.match[1];
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.type.readFromNull", {
                  url,
                  symbol: errSym,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
            case "READUDEFINED": {
              let errSym = matchedError.match[1];
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.type.readFromUndefined", {
                  url,
                  symbol: errSym,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
            case "CONSTASSIGN": {
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_const_assignment#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.type.constAssign", {
                  url,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
          }
        }
      }
    };
    p53._fesErrorMonitor = fesErrorMonitor;
    p53._checkForUserDefinedFunctions = checkForUserDefinedFunctions;
    p53._fesLogger = null;
    p53._fesLogCache = {};
    window.addEventListener("load", checkForUserDefinedFunctions, false);
    window.addEventListener("error", p53._fesErrorMonitor, false);
    window.addEventListener("unhandledrejection", p53._fesErrorMonitor, false);
  }
  misusedAtTopLevelCode = null;
  const FAQ_URL = "https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup";
  defineMisusedAtTopLevelCode = () => {
    const uniqueNamesFound = {};
    const getSymbols = (obj) => Object.getOwnPropertyNames(obj).filter((name) => {
      if (name[0] === "_") {
        return false;
      }
      if (name in uniqueNamesFound) {
        return false;
      }
      uniqueNamesFound[name] = true;
      return true;
    }).map((name) => {
      let type2;
      if (typeof obj[name] === "function") {
        type2 = "function";
      } else if (name === name.toUpperCase()) {
        type2 = "constant";
      } else {
        type2 = "variable";
      }
      return { name, type: type2 };
    });
    misusedAtTopLevelCode = [].concat(
      getSymbols(fn2),
      // At present, p5 only adds its constants to fn during
      // construction, which may not have happened at the time a
      // ReferenceError is thrown, so we'll manually add them to our list.
      getSymbols(constants)
    );
    misusedAtTopLevelCode.sort((a, b2) => b2.name.length - a.name.length);
  };
  const helpForMisusedAtTopLevelCode = (e2, log3) => {
    if (!log3) {
      log3 = console.log.bind(console);
    }
    if (!misusedAtTopLevelCode) {
      defineMisusedAtTopLevelCode();
    }
    misusedAtTopLevelCode.some((symbol) => {
      if (e2.message && e2.message.match(`\\W?${symbol.name}\\W`) !== null) {
        const symbolName = symbol.type === "function" ? `${symbol.name}()` : symbol.name;
        if (typeof IS_MINIFIED !== "undefined") {
          log3(
            `Did you just try to use p5.js's ${symbolName} ${symbol.type}? If so, you may want to move it into your sketch's setup() function.

For more details, see: ${FAQ_URL}`
          );
        } else {
          log3(
            translator("fes.misusedTopLevel", {
              symbolName,
              symbolType: symbol.type,
              url: FAQ_URL
            })
          );
        }
        return true;
      }
    });
  };
  fn2._helpForMisusedAtTopLevelCode = helpForMisusedAtTopLevelCode;
  if (document.readyState !== "complete") {
    window.addEventListener("error", helpForMisusedAtTopLevelCode, false);
    window.addEventListener("load", () => {
      window.removeEventListener("error", helpForMisusedAtTopLevelCode, false);
    });
  }
}
if (typeof p5 !== "undefined") {
  fesCore(p5, p5.prototype);
}
function ErrorStackParser() {
  let FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  let CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  let SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
  return {
    /**
     * Given an Error object, extract the most information from it.
     * @private
     * @param {Error} error object
     * @return {Array} of stack frames
     */
    parse: function ErrorStackParser$$parse(error2) {
      if (typeof error2.stacktrace !== "undefined" || typeof error2["opera#sourceloc"] !== "undefined") {
        return this.parseOpera(error2);
      } else if (error2.stack && error2.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.parseV8OrIE(error2);
      } else if (error2.stack) {
        return this.parseFFOrSafari(error2);
      } else ;
    },
    // Separate line and column numbers from a string of the form: (URI:Line:Column)
    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
      if (urlLike.indexOf(":") === -1) {
        return [urlLike];
      }
      let regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
      let parts = regExp.exec(urlLike.replace(/[()]/g, ""));
      return [parts[1], parts[2] || void 0, parts[3] || void 0];
    },
    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error2) {
      let filtered = error2.stack.split("\n").filter(function(line) {
        return !!line.match(CHROME_IE_STACK_REGEXP);
      }, this);
      return filtered.map(function(line) {
        if (line.indexOf("(eval ") > -1) {
          line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, "");
        }
        let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(");
        let location2 = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);
        sanitizedLine = location2 ? sanitizedLine.replace(location2[0], "") : sanitizedLine;
        let tokens = sanitizedLine.split(/\s+/).slice(1);
        let locationParts = this.extractLocation(
          location2 ? location2[1] : tokens.pop()
        );
        let functionName = tokens.join(" ") || void 0;
        let fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];
        return {
          functionName,
          fileName,
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        };
      }, this);
    },
    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error2) {
      let filtered = error2.stack.split("\n").filter(function(line) {
        return !line.match(SAFARI_NATIVE_CODE_REGEXP);
      }, this);
      return filtered.map(function(line) {
        if (line.indexOf(" > eval") > -1) {
          line = line.replace(
            / line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,
            ":$1"
          );
        }
        if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
          return {
            functionName: line
          };
        } else {
          let functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
          let matches = line.match(functionNameRegex);
          let functionName = matches && matches[1] ? matches[1] : void 0;
          let locationParts = this.extractLocation(
            line.replace(functionNameRegex, "")
          );
          return {
            functionName,
            fileName: locationParts[0],
            lineNumber: locationParts[1],
            columnNumber: locationParts[2],
            source: line
          };
        }
      }, this);
    },
    parseOpera: function ErrorStackParser$$parseOpera(e2) {
      if (!e2.stacktrace || e2.message.indexOf("\n") > -1 && e2.message.split("\n").length > e2.stacktrace.split("\n").length) {
        return this.parseOpera9(e2);
      } else if (!e2.stack) {
        return this.parseOpera10(e2);
      } else {
        return this.parseOpera11(e2);
      }
    },
    parseOpera9: function ErrorStackParser$$parseOpera9(e2) {
      let lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
      let lines = e2.message.split("\n");
      let result = [];
      for (let i = 2, len = lines.length; i < len; i += 2) {
        let match = lineRE.exec(lines[i]);
        if (match) {
          result.push({
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          });
        }
      }
      return result;
    },
    parseOpera10: function ErrorStackParser$$parseOpera10(e2) {
      let lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
      let lines = e2.stacktrace.split("\n");
      let result = [];
      for (let i = 0, len = lines.length; i < len; i += 2) {
        let match = lineRE.exec(lines[i]);
        if (match) {
          result.push({
            functionName: match[3] || void 0,
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          });
        }
      }
      return result;
    },
    // Opera 10.65+ Error.stack very similar to FF/Safari
    parseOpera11: function ErrorStackParser$$parseOpera11(error2) {
      let filtered = error2.stack.split("\n").filter(function(line) {
        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
      }, this);
      return filtered.map(function(line) {
        let tokens = line.split("@");
        let locationParts = this.extractLocation(tokens.pop());
        let functionCall = tokens.shift() || "";
        let functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
        let argsRaw;
        if (functionCall.match(/\(([^)]*)\)/)) {
          argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
        }
        let args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
        return {
          functionName,
          args,
          fileName: locationParts[0],
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        };
      }, this);
    }
  };
}
function stacktrace(p53, fn2) {
  p53._getErrorStackParser = function getErrorStackParser() {
    return new ErrorStackParser();
  };
}
if (typeof p5 !== "undefined") {
  stacktrace(p5, p5.prototype);
}
function $constructor(name, initializer2, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer2(inst, def);
    for (const k in _23.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _23.prototype[k].bind(inst) });
    }
    inst._zod.constr = _23;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _23(def) {
    var _a;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn2 of inst._zod.deferred) {
      fn2();
    }
    return inst;
  }
  Object.defineProperty(_23, "init", { value: init });
  Object.defineProperty(_23, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_23, "name", { value: name });
  return _23;
}
class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
const globalConfig = {};
function config(newConfig) {
  return globalConfig;
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _23]) => numericValues.indexOf(+k) === -1).map(([_23, v]) => v);
  return values;
}
function jsonStringifyReplacer(_23, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  return {
    get value() {
      {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start2 = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start2, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  Object.defineProperty(object2, key, {
    get() {
      {
        const value = getter();
        object2[key] = value;
        return value;
      }
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function esc(str) {
  return JSON.stringify(str);
}
const captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject$1(data2) {
  return typeof data2 === "object" && data2 !== null && !Array.isArray(data2);
}
const allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F2 = Function;
    new F2("");
    return true;
  } catch (_23) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject$1(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject$1(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function optionalKeys(shape2) {
  return Object.keys(shape2).filter((k) => {
    return shape2[k]._zod.optin === "optional" && shape2[k]._zod.optout === "optional";
  });
}
const NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape2) {
  if (!isPlainObject(shape2)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape2 };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a, b2) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b2._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b2._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape2 = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape2[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape2[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: shape2,
    checks: []
  });
}
function required(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape2 = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape2)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape2[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape2[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: shape2,
    // optional: [],
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
const initializer$1 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error2.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error2, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error3) => {
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error2);
  return fieldErrors;
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, _params?.callee);
    throw e2;
  }
  return result.value;
};
const parse$2 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, params?.callee);
    throw e2;
  }
  return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
const uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64$1 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
const hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$1 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time$1(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
const integer = /^\d+$/;
const number$1 = /^-?\d+(?:\.\d+)?/i;
const boolean$1 = /true|false/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn2) {
    this.indent += 1;
    fn2(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F2 = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F2(...args, lines.join("\n"));
  }
}
const version$3 = {
  major: 4,
  minor: 0,
  patch: 0
};
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version$3;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn2 of ch._zod.onattach) {
      fn2(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _23 = ch._zod.check(payload);
        if (_23 instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _23 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _23;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse$1(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_23) {
        return safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
  inst._zod.parse = (payload, _23) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_24) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_23) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data2) {
  if (data2 === "")
    return true;
  if (data2.length % 4 !== 0)
    return false;
  try {
    atob(data2);
    return true;
  } catch {
    return false;
  }
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64$1);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data2) {
  if (!base64url.test(data2))
    return false;
  const base642 = data2.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_23) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_23) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape2 = def.shape;
    const propValues = {};
    for (const key in shape2) {
      const field = shape2[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape2) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn2 = doc.compile();
    return (payload, ctx) => fn2(shape2, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject$1;
  const jit = !globalConfig.jitless;
  const allowsEval$1 = allowsEval;
  const fastEnabled = jit && allowsEval$1.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape2 = value.shape;
      for (const key of value.keys) {
        const el = shape2[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b2) {
  if (a === b2) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b2 instanceof Date && +a === +b2) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b2)) {
    const bKeys = Object.keys(b2);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b2[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b2)) {
    if (a.length !== b2.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
const $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output2 = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output2.then((output3) => {
        payload.value = output3;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _23) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = { ...this.get(p2) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry();
}
const globalRegistry = /* @__PURE__ */ registry();
function _string(Class, params) {
  return new Class({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class, params) {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class, params) {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class, params) {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji(Class, params) {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class, params) {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class, params) {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class, params) {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class, params) {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class, params) {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class, params) {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class, params) {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class, params) {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class, params) {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class, params) {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class, params) {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class, params) {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class, params) {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class, params) {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class, params) {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class, params) {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class, params) {
  return new Class({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class, params) {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _boolean(Class, params) {
  return new Class({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _any(Class) {
  return new Class({
    type: "any"
  });
}
function _unknown(Class) {
  return new Class({
    type: "unknown"
  });
}
function _never(Class, params) {
  return new Class({
    type: "never",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element2, params) {
  return new Class({
    type: "array",
    element: element2,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _tuple(Class, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _custom(Class, fn2, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...norm
  });
  return schema;
}
function _refine(Class, fn2, _params) {
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...normalizeParams(_params)
  });
  return schema;
}
class $ZodFunction {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = ((...args) => {
      const parsedArgs = this._def.input ? parse$2(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output2 = func(...parsedArgs);
      return this._def.output ? parse$2(this._def.output, output2, void 0, { callee: impl }) : output2;
    });
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync$1(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output2 = await func(...parsedArgs);
      return this._def.output ? parseAsync$1(this._def.output, output2, void 0, { callee: impl }) : output2;
    });
    return impl;
  }
  input(...args) {
    const F2 = this.constructor;
    if (Array.isArray(args[0])) {
      return new F2({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F2({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output2) {
    const F2 = this.constructor;
    return new F2({
      type: "function",
      input: this._def.input,
      output: output2
    });
  }
}
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : _array($ZodArray, _unknown($ZodUnknown)),
    output: _unknown($ZodUnknown)
  });
}
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date(params) {
  return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time(params) {
  return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration(params) {
  return _isoDuration(ZodISODuration, params);
}
const initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
const ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
});
const parse$1 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta) => {
    reg.add(inst, meta);
    return inst;
  });
  inst.parse = (data2, params) => parse$1(inst, data2, params, { callee: inst.parse });
  inst.safeParse = (data2, params) => safeParse(inst, data2, params);
  inst.parseAsync = async (data2, params) => parseAsync(inst, data2, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data2, params) => safeParseAsync(inst, data2, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn2) => inst.check(_overwrite(fn2));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime(params));
  inst.date = (params) => inst.check(date(params));
  inst.time = (params) => inst.check(time(params));
  inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
  return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number(params) {
  return _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean(params) {
  return _boolean(ZodBoolean, params);
}
const ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element2, params) {
  return _array(ZodArray, element2, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return extend(inst, incoming);
  };
  inst.merge = (other) => merge(inst, other);
  inst.pick = (mask) => pick(inst, mask);
  inst.omit = (mask) => omit(inst, mask);
  inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape2, params) {
  const def = {
    type: "object",
    get shape() {
      assignProp(this, "shape", { ...shape2 });
      return this.shape;
    },
    ...normalizeParams(params)
  };
  return new ZodObject(def);
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options2, params) {
  return new ZodUnion({
    type: "union",
    options: options2,
    ...normalizeParams(params)
  });
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
const ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
const ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal$1(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(issue(_issue));
      }
    };
    const output2 = def.transform(payload.value, payload);
    if (output2 instanceof Promise) {
      return output2.then((output3) => {
        payload.value = output3;
        return payload;
      });
    }
    payload.value = output2;
    return payload;
  };
});
function transform(fn2) {
  return new ZodTransform({
    type: "transform",
    transform: fn2
  });
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn2) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn2;
  return ch;
}
function custom(fn2, _params) {
  return _custom(ZodCustom, fn2 ?? (() => true), _params);
}
function refine(fn2, _params = {}) {
  return _refine(ZodCustom, fn2, _params);
}
function superRefine(fn2) {
  const ch = check((payload) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn2(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data2) => data2 instanceof cls,
    abort: true,
    ...normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var p5$1 = {
  describe: {
    overloads: [
      [
        "String",
        "FALLBACK|LABEL?"
      ]
    ]
  },
  describeElement: {
    overloads: [
      [
        "String",
        "String",
        "FALLBACK|LABEL?"
      ]
    ]
  },
  textOutput: {
    overloads: [
      [
        "FALLBACK|LABEL?"
      ]
    ]
  },
  gridOutput: {
    overloads: [
      [
        "FALLBACK|LABEL?"
      ]
    ]
  },
  remove: {
    overloads: [
      []
    ]
  },
  p5: {
    overloads: [
      [
        "Object",
        "String|HTMLElement"
      ]
    ]
  },
  color: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  red: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  green: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  blue: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  alpha: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  hue: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  saturation: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  brightness: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  lightness: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  lerpColor: {
    overloads: [
      [
        "p5.Color",
        "p5.Color",
        "Number"
      ]
    ]
  },
  paletteLerp: {
    overloads: [
      [
        "[p5.Color|String|Number|Number[], Number][]",
        "Number"
      ]
    ]
  },
  beginClip: {
    overloads: [
      [
        "Object?"
      ]
    ]
  },
  endClip: {
    overloads: [
      []
    ]
  },
  clip: {
    overloads: [
      [
        "Function",
        "Object?"
      ]
    ]
  },
  background: {
    overloads: [
      [
        "p5.Color"
      ],
      [
        "String",
        "Number?"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Image",
        "Number?"
      ]
    ]
  },
  clear: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      []
    ]
  },
  colorMode: {
    overloads: [
      [
        "RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH",
        "Number?"
      ],
      [
        "RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH",
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      []
    ]
  },
  fill: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  noFill: {
    overloads: [
      []
    ]
  },
  noStroke: {
    overloads: [
      []
    ]
  },
  stroke: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  erase: {
    overloads: [
      [
        "Number?",
        "Number?"
      ]
    ]
  },
  noErase: {
    overloads: [
      []
    ]
  },
  blendMode: {
    overloads: [
      [
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|REMOVE|SUBTRACT"
      ]
    ]
  },
  print: {
    overloads: [
      [
        "Any"
      ],
      [
        "String|Number|Array"
      ]
    ]
  },
  cursor: {
    overloads: [
      [
        "ARROW|CROSS|HAND|MOVE|TEXT|WAIT|String",
        "Number?",
        "Number?"
      ]
    ]
  },
  frameRate: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  getTargetFrameRate: {
    overloads: [
      []
    ]
  },
  noCursor: {
    overloads: [
      []
    ]
  },
  windowResized: {
    overloads: [
      [
        "Event?"
      ]
    ]
  },
  fullscreen: {
    overloads: [
      [
        "Boolean?"
      ]
    ]
  },
  pixelDensity: {
    overloads: [
      [
        "Number?"
      ],
      []
    ]
  },
  displayDensity: {
    overloads: [
      []
    ]
  },
  getURL: {
    overloads: [
      []
    ]
  },
  getURLPath: {
    overloads: [
      []
    ]
  },
  getURLParams: {
    overloads: [
      []
    ]
  },
  worldToScreen: {
    overloads: [
      [
        "Number|p5.Vector",
        "Number",
        "Number?"
      ]
    ]
  },
  screenToWorld: {
    overloads: [
      [
        "Number|p5.Vector",
        "Number",
        "Number?"
      ]
    ]
  },
  setup: {
    overloads: [
      []
    ]
  },
  draw: {
    overloads: [
      []
    ]
  },
  registerAddon: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  createCanvas: {
    overloads: [
      [
        "Number?",
        "Number?",
        "P2D|WEBGL|P2DHDR|WEBGPU?",
        "HTMLCanvasElement?"
      ],
      [
        "Number?",
        "Number?",
        "HTMLCanvasElement?"
      ]
    ]
  },
  resizeCanvas: {
    overloads: [
      [
        "Number",
        "Number",
        "Boolean?"
      ]
    ]
  },
  noCanvas: {
    overloads: [
      []
    ]
  },
  createGraphics: {
    overloads: [
      [
        "Number",
        "Number",
        "P2D|WEBGL?",
        "HTMLCanvasElement?"
      ],
      [
        "Number",
        "Number",
        "HTMLCanvasElement?"
      ]
    ]
  },
  createFramebuffer: {
    overloads: [
      [
        "Object?"
      ]
    ]
  },
  clearDepth: {
    overloads: [
      [
        "Number?"
      ]
    ]
  },
  noLoop: {
    overloads: [
      []
    ]
  },
  loop: {
    overloads: [
      []
    ]
  },
  isLooping: {
    overloads: [
      []
    ]
  },
  redraw: {
    overloads: [
      [
        "Integer?"
      ]
    ]
  },
  applyMatrix: {
    overloads: [
      [
        "Number[]"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  resetMatrix: {
    overloads: [
      []
    ]
  },
  rotate: {
    overloads: [
      [
        "Number",
        "p5.Vector|Number[]?"
      ]
    ]
  },
  rotateX: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  rotateY: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  rotateZ: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  scale: {
    overloads: [
      [
        "Number|p5.Vector|Number[]",
        "Number?",
        "Number?"
      ],
      [
        "p5.Vector|Number[]"
      ]
    ]
  },
  shearX: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  shearY: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  translate: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Vector"
      ]
    ]
  },
  push: {
    overloads: [
      []
    ]
  },
  pop: {
    overloads: [
      []
    ]
  },
  storeItem: {
    overloads: [
      [
        "String",
        "String|Number|Boolean|Object|Array"
      ]
    ]
  },
  getItem: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  clearStorage: {
    overloads: [
      []
    ]
  },
  removeItem: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  select: {
    overloads: [
      [
        "String",
        "String|p5.Element|HTMLElement?"
      ]
    ]
  },
  selectAll: {
    overloads: [
      [
        "String",
        "String|p5.Element|HTMLElement?"
      ]
    ]
  },
  createElement: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  removeElements: {
    overloads: [
      []
    ]
  },
  addElement: {
    overloads: [
      []
    ]
  },
  createDiv: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createP: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createSpan: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createImg: {
    overloads: [
      [
        "String",
        "String"
      ],
      [
        "String",
        "String",
        "String?",
        "Function?"
      ]
    ]
  },
  createA: {
    overloads: [
      [
        "String",
        "String",
        "String?"
      ]
    ]
  },
  createSlider: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  createButton: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  createCheckbox: {
    overloads: [
      [
        "String?",
        "Boolean?"
      ]
    ]
  },
  createSelect: {
    overloads: [
      [
        "Boolean?"
      ],
      [
        "Object"
      ]
    ]
  },
  createRadio: {
    overloads: [
      [
        "Object?"
      ],
      [
        "String?"
      ],
      []
    ]
  },
  createColorPicker: {
    overloads: [
      [
        "String|p5.Color?"
      ]
    ]
  },
  createInput: {
    overloads: [
      [
        "String?",
        "String?"
      ],
      [
        "String?"
      ]
    ]
  },
  createFileInput: {
    overloads: [
      [
        "Function",
        "Boolean?"
      ]
    ]
  },
  createVideo: {
    overloads: [
      [
        "String|String[]?",
        "Function?"
      ]
    ]
  },
  createAudio: {
    overloads: [
      [
        "String|String[]?",
        "Function?"
      ]
    ]
  },
  createCapture: {
    overloads: [
      [
        "AUDIO|VIDEO|Object?",
        "Object?",
        "Function?"
      ]
    ]
  },
  setMoveThreshold: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  setShakeThreshold: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  deviceMoved: {
    overloads: [
      []
    ]
  },
  deviceTurned: {
    overloads: [
      []
    ]
  },
  deviceShaken: {
    overloads: [
      []
    ]
  },
  keyPressed: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyReleased: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyTyped: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyIsDown: {
    overloads: [
      [
        "Number|String"
      ]
    ]
  },
  mouseMoved: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseDragged: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mousePressed: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseReleased: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseClicked: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  doubleClicked: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseWheel: {
    overloads: [
      [
        "WheelEvent?"
      ]
    ]
  },
  requestPointerLock: {
    overloads: [
      []
    ]
  },
  exitPointerLock: {
    overloads: [
      []
    ]
  },
  createImage: {
    overloads: [
      [
        "Integer",
        "Integer"
      ]
    ]
  },
  saveCanvas: {
    overloads: [
      [
        "p5.Framebuffer|p5.Element|HTMLCanvasElement",
        "String?",
        "String?"
      ],
      [
        "String?",
        "String?"
      ]
    ]
  },
  saveFrames: {
    overloads: [
      [
        "String",
        "String",
        "Number",
        "Number",
        "function(Array)?"
      ]
    ]
  },
  loadImage: {
    overloads: [
      [
        "String|Request",
        "function(p5.Image)?",
        "function(Event)?"
      ]
    ]
  },
  saveGif: {
    overloads: [
      [
        "String",
        "Number",
        "Object?"
      ]
    ]
  },
  image: {
    overloads: [
      [
        "p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture|p5.Renderer|p5.Graphics",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "CONTAIN|COVER?",
        "LEFT|RIGHT|CENTER?",
        "TOP|BOTTOM|CENTER?"
      ]
    ]
  },
  tint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  noTint: {
    overloads: [
      []
    ]
  },
  imageMode: {
    overloads: [
      [
        "CORNER|CORNERS|CENTER"
      ]
    ]
  },
  blend: {
    overloads: [
      [
        "p5.Image",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
      ],
      [
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
      ]
    ]
  },
  copy: {
    overloads: [
      [
        "p5.Image|p5.Element",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer"
      ],
      [
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer"
      ]
    ]
  },
  filter: {
    overloads: [
      [
        "THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR",
        "Number?",
        "Boolean?"
      ],
      [
        "p5.Shader"
      ]
    ]
  },
  get: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [],
      [
        "Number",
        "Number"
      ]
    ]
  },
  loadPixels: {
    overloads: [
      []
    ]
  },
  set: {
    overloads: [
      [
        "Number",
        "Number",
        "Number|Number[]|Object"
      ]
    ]
  },
  updatePixels: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      []
    ]
  },
  loadJSON: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadStrings: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadTable: {
    overloads: [
      [
        "String|Request",
        "String?",
        "String?",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadXML: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadBytes: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadBlob: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  httpGet: {
    overloads: [
      [
        "String|Request",
        "String?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function",
        "Function?"
      ]
    ]
  },
  httpPost: {
    overloads: [
      [
        "String|Request",
        "Object|Boolean?",
        "String?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Object|Boolean",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  httpDo: {
    overloads: [
      [
        "String|Request",
        "String?",
        "String?",
        "Object?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  createWriter: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  write: {
    overloads: [
      [
        "String|Number|Array"
      ]
    ]
  },
  close: {
    overloads: [
      []
    ]
  },
  save: {
    overloads: [
      [
        "Object|String?",
        "String?",
        "Boolean|String?"
      ]
    ]
  },
  saveJSON: {
    overloads: [
      [
        "Array|Object",
        "String",
        "Boolean?"
      ]
    ]
  },
  saveStrings: {
    overloads: [
      [
        "String[]",
        "String",
        "String?",
        "Boolean?"
      ]
    ]
  },
  saveTable: {
    overloads: [
      [
        "p5.Table",
        "String",
        "String?"
      ]
    ]
  },
  setContent: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  abs: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  ceil: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  constrain: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  dist: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  exp: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  floor: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  lerp: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  log: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  mag: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  map: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Boolean?"
      ]
    ]
  },
  max: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number[]"
      ]
    ]
  },
  min: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number[]"
      ]
    ]
  },
  norm: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  pow: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  round: {
    overloads: [
      [
        "Number",
        "Number?"
      ]
    ]
  },
  sq: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  sqrt: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  fract: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  createVector: {
    overloads: [
      [
        "...Number[]"
      ]
    ]
  },
  noise: {
    overloads: [
      [
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  noiseDetail: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  noiseSeed: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  randomSeed: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  random: {
    overloads: [
      [
        "Number?",
        "Number?"
      ],
      [
        "Array"
      ]
    ]
  },
  randomGaussian: {
    overloads: [
      [
        "Number?",
        "Number?"
      ]
    ]
  },
  acos: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  asin: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  atan: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  atan2: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  cos: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  sin: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  tan: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  degrees: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  radians: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  angleMode: {
    overloads: [
      [
        "RADIANS|DEGREES"
      ],
      []
    ]
  },
  arc: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "CHORD|PIE|OPEN?",
        "Integer?"
      ]
    ]
  },
  ellipse: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?"
      ]
    ]
  },
  circle: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  line: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  point: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Vector"
      ]
    ]
  },
  quad: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  rect: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  square: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  triangle: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  ellipseMode: {
    overloads: [
      [
        "CENTER|RADIUS|CORNER|CORNERS"
      ]
    ]
  },
  noSmooth: {
    overloads: [
      []
    ]
  },
  rectMode: {
    overloads: [
      [
        "CENTER|RADIUS|CORNER|CORNERS"
      ]
    ]
  },
  smooth: {
    overloads: [
      []
    ]
  },
  strokeCap: {
    overloads: [
      [
        "ROUND|SQUARE|PROJECT"
      ]
    ]
  },
  strokeJoin: {
    overloads: [
      [
        "MITER|BEVEL|ROUND"
      ]
    ]
  },
  strokeWeight: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  bezier: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierPoint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierTangent: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  spline: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  splinePoint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  splineTangent: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierOrder: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  splineVertex: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  splineProperty: {
    overloads: [
      [
        "String",
        null
      ],
      [
        "String"
      ]
    ]
  },
  splineProperties: {
    overloads: [
      [
        "Object"
      ]
    ]
  },
  vertex: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  beginContour: {
    overloads: [
      []
    ]
  },
  endContour: {
    overloads: [
      [
        "OPEN|CLOSE?"
      ]
    ]
  },
  beginShape: {
    overloads: [
      [
        "POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH?"
      ]
    ]
  },
  bezierVertex: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  endShape: {
    overloads: [
      [
        "CLOSE?",
        "Integer?"
      ]
    ]
  },
  normal: {
    overloads: [
      [
        "p5.Vector"
      ],
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  vertexProperty: {
    overloads: [
      [
        "String",
        "Number|Number[]"
      ]
    ]
  },
  getWorldInputs: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  combineColors: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getPixelInputs: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getFinalColor: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getColor: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getObjectInputs: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getCameraInputs: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  loadFont: {
    overloads: [
      [
        "String",
        "String?",
        "Object?",
        "Function?",
        "Function?"
      ],
      [
        "String",
        "Function?",
        "Function?"
      ]
    ]
  },
  text: {
    overloads: [
      [
        "String|Object|Array|Number|Boolean",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  textAlign: {
    overloads: [
      [
        "LEFT|CENTER|RIGHT?",
        "TOP|BOTTOM|CENTER|BASELINE?"
      ]
    ]
  },
  textAscent: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  textDescent: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  textLeading: {
    overloads: [
      [
        "Number?"
      ]
    ]
  },
  textFont: {
    overloads: [
      [
        "p5.Font|String|Object?",
        "Number?"
      ]
    ]
  },
  textSize: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  textStyle: {
    overloads: [
      [
        "NORMAL|ITALIC|BOLD|BOLDITALIC"
      ],
      []
    ]
  },
  textWidth: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  textWrap: {
    overloads: [
      [
        "WORD|CHAR"
      ],
      []
    ]
  },
  textBounds: {
    overloads: [
      [
        "String",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  textDirection: {
    overloads: [
      [
        "String"
      ],
      []
    ]
  },
  textProperty: {
    overloads: [
      [
        "String",
        null
      ],
      [
        "String"
      ]
    ]
  },
  textProperties: {
    overloads: [
      [
        "Object"
      ],
      []
    ]
  },
  fontBounds: {
    overloads: [
      [
        "String",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  fontWidth: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  fontAscent: {
    overloads: [
      []
    ]
  },
  fontDescent: {
    overloads: [
      []
    ]
  },
  textWeight: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  float: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  int: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  str: {
    overloads: [
      [
        "String|Boolean|Number"
      ]
    ]
  },
  boolean: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  byte: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  char: {
    overloads: [
      [
        "String|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  unchar: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  hex: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]",
        "Number?"
      ]
    ]
  },
  unhex: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  day: {
    overloads: [
      []
    ]
  },
  hour: {
    overloads: [
      []
    ]
  },
  minute: {
    overloads: [
      []
    ]
  },
  millis: {
    overloads: [
      []
    ]
  },
  month: {
    overloads: [
      []
    ]
  },
  second: {
    overloads: [
      []
    ]
  },
  year: {
    overloads: [
      []
    ]
  },
  nf: {
    overloads: [
      [
        "Number|String",
        "Integer|String?",
        "Integer|String?"
      ],
      [
        "Number[]",
        "Integer|String?",
        "Integer|String?"
      ]
    ]
  },
  nfc: {
    overloads: [
      [
        "Number|String",
        "Integer|String?"
      ],
      [
        "Number[]",
        "Integer|String?"
      ]
    ]
  },
  nfp: {
    overloads: [
      [
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Number[]",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  nfs: {
    overloads: [
      [
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Array",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  splitTokens: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  shuffle: {
    overloads: [
      [
        "Array",
        "Boolean?"
      ]
    ]
  },
  strokeMode: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  buildGeometry: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  freeGeometry: {
    overloads: [
      [
        "p5.Geometry"
      ]
    ]
  },
  plane: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  box: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  sphere: {
    overloads: [
      [
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  cylinder: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?",
        "Boolean?",
        "Boolean?"
      ]
    ]
  },
  cone: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?",
        "Boolean?"
      ]
    ]
  },
  ellipsoid: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  torus: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  curveDetail: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  orbitControl: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Object?"
      ]
    ]
  },
  debugMode: {
    overloads: [
      [],
      [
        "GRID|AXES"
      ],
      [
        "GRID|AXES",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "GRID|AXES",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  noDebugMode: {
    overloads: [
      []
    ]
  },
  ambientLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  specularColor: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  directionalLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector"
      ]
    ]
  },
  pointLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector"
      ]
    ]
  },
  imageLight: {
    overloads: [
      [
        "p5.Image"
      ]
    ]
  },
  panorama: {
    overloads: [
      [
        "p5.Image"
      ]
    ]
  },
  lights: {
    overloads: [
      []
    ]
  },
  lightFalloff: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  spotLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  noLights: {
    overloads: [
      []
    ]
  },
  loadModel: {
    overloads: [
      [
        "String|Request",
        "String?",
        "Boolean?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String|Request",
        "String?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String|Request",
        "Object?"
      ]
    ]
  },
  model: {
    overloads: [
      [
        "p5.Geometry",
        "Number?"
      ]
    ]
  },
  createModel: {
    overloads: [
      [
        "String",
        "String?",
        "Boolean?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String",
        "String?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String",
        "String?",
        "Object?"
      ]
    ]
  },
  loadShader: {
    overloads: [
      [
        "String|Request",
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  createShader: {
    overloads: [
      [
        "String",
        "String",
        "Object?"
      ]
    ]
  },
  loadFilterShader: {
    overloads: [
      [
        "String",
        "Function?",
        "Function?"
      ]
    ]
  },
  createFilterShader: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  shader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  strokeShader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  imageShader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  baseMaterialShader: {
    overloads: [
      []
    ]
  },
  baseFilterShader: {
    overloads: [
      []
    ]
  },
  baseNormalShader: {
    overloads: [
      []
    ]
  },
  baseColorShader: {
    overloads: [
      []
    ]
  },
  baseStrokeShader: {
    overloads: [
      []
    ]
  },
  resetShader: {
    overloads: [
      []
    ]
  },
  texture: {
    overloads: [
      [
        "p5.Image|p5.MediaElement|p5.Graphics|p5.Texture|p5.Framebuffer|p5.FramebufferTexture"
      ]
    ]
  },
  textureMode: {
    overloads: [
      [
        "IMAGE|NORMAL"
      ]
    ]
  },
  textureWrap: {
    overloads: [
      [
        "CLAMP|REPEAT|MIRROR",
        "CLAMP|REPEAT|MIRROR?"
      ]
    ]
  },
  normalMaterial: {
    overloads: [
      []
    ]
  },
  ambientMaterial: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  emissiveMaterial: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  specularMaterial: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  shininess: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  metalness: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  roll: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  camera: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  perspective: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  linePerspective: {
    overloads: [
      [
        "Boolean"
      ],
      []
    ]
  },
  ortho: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  frustum: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  createCamera: {
    overloads: [
      []
    ]
  },
  setCamera: {
    overloads: [
      [
        "p5.Camera"
      ]
    ]
  },
  saveObj: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  saveStl: {
    overloads: [
      [
        "String?",
        "Object?"
      ]
    ]
  },
  fromAxisAngle: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  mult: {
    overloads: [
      [
        "p5.Quat?"
      ]
    ]
  },
  rotateBy: {
    overloads: [
      [
        "p5.Quat?"
      ]
    ]
  },
  setAttributes: {
    overloads: [
      [
        "String",
        "Boolean"
      ],
      [
        "Object"
      ]
    ]
  }
};
var dataDoc = {
  p5: p5$1,
  "p5.Color": {
    toString: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    contrast: {
      overloads: [
        [
          "Color"
        ]
      ]
    },
    setRed: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setGreen: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setBlue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setAlpha: {
      overloads: [
        [
          "Number"
        ]
      ]
    }
  },
  "p5.Graphics": {
    reset: {
      overloads: [
        []
      ]
    },
    remove: {
      overloads: [
        []
      ]
    },
    createFramebuffer: {
      overloads: [
        [
          "Object?"
        ]
      ]
    }
  },
  "p5.Element": {
    remove: {
      overloads: [
        []
      ]
    },
    parent: {
      overloads: [
        [
          "String|p5.Element|Object"
        ],
        []
      ]
    },
    child: {
      overloads: [
        [],
        [
          "String|p5.Element?"
        ]
      ]
    },
    html: {
      overloads: [
        [],
        [
          "String?",
          "Boolean?"
        ]
      ]
    },
    id: {
      overloads: [
        [
          "String"
        ],
        []
      ]
    },
    "class": {
      overloads: [
        [
          "String"
        ],
        []
      ]
    },
    addClass: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    removeClass: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    hasClass: {
      overloads: [
        [
          null
        ]
      ]
    },
    toggleClass: {
      overloads: [
        [
          null
        ]
      ]
    },
    center: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    position: {
      overloads: [
        [],
        [
          "Number?",
          "Number?",
          "String?"
        ]
      ]
    },
    show: {
      overloads: [
        []
      ]
    },
    hide: {
      overloads: [
        []
      ]
    },
    size: {
      overloads: [
        [],
        [
          "Number|AUTO?",
          "Number|AUTO?"
        ]
      ]
    },
    style: {
      overloads: [
        [
          "String"
        ],
        [
          "String",
          "String|p5.Color"
        ]
      ]
    },
    attribute: {
      overloads: [
        [],
        [
          "String",
          "String"
        ]
      ]
    },
    removeAttribute: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    value: {
      overloads: [
        [],
        [
          "String|Number"
        ]
      ]
    },
    mousePressed: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    doubleClicked: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseWheel: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseReleased: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseClicked: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseMoved: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseOver: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseOut: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    dragOver: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    dragLeave: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    changed: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    input: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    drop: {
      overloads: [
        [
          "Function",
          "Function?"
        ]
      ]
    },
    draggable: {
      overloads: [
        [
          "p5.Element?"
        ]
      ]
    }
  },
  "p5.MediaElement": {
    play: {
      overloads: [
        []
      ]
    },
    stop: {
      overloads: [
        []
      ]
    },
    pause: {
      overloads: [
        []
      ]
    },
    loop: {
      overloads: [
        []
      ]
    },
    noLoop: {
      overloads: [
        []
      ]
    },
    autoplay: {
      overloads: [
        [
          "Boolean?"
        ]
      ]
    },
    volume: {
      overloads: [
        [],
        [
          "Number"
        ]
      ]
    },
    speed: {
      overloads: [
        [],
        [
          "Number"
        ]
      ]
    },
    time: {
      overloads: [
        [
          "Number?"
        ]
      ]
    },
    duration: {
      overloads: [
        []
      ]
    },
    onended: {
      overloads: [
        [
          "Function"
        ]
      ]
    },
    connect: {
      overloads: [
        [
          "AudioNode|Object"
        ]
      ]
    },
    disconnect: {
      overloads: [
        []
      ]
    },
    showControls: {
      overloads: [
        []
      ]
    },
    hideControls: {
      overloads: [
        []
      ]
    },
    addCue: {
      overloads: [
        [
          "Number",
          "Function",
          "Object?"
        ]
      ]
    },
    removeCue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    clearCues: {
      overloads: [
        []
      ]
    }
  },
  "p5.Image": {
    pixelDensity: {
      overloads: [
        [
          "Number?"
        ]
      ]
    },
    loadPixels: {
      overloads: [
        []
      ]
    },
    updatePixels: {
      overloads: [
        [
          "Integer?",
          "Integer?",
          "Integer?",
          "Integer?"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [],
        [
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Number",
          "Number",
          "Number|Number[]|Object"
        ]
      ]
    },
    resize: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    copy: {
      overloads: [
        [
          "p5.Image|p5.Element",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer"
        ],
        [
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer"
        ]
      ]
    },
    mask: {
      overloads: [
        [
          "p5.Image"
        ]
      ]
    },
    filter: {
      overloads: [
        [
          "THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR",
          "Number?"
        ]
      ]
    },
    blend: {
      overloads: [
        [
          "p5.Image",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
        ],
        [
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
        ]
      ]
    },
    save: {
      overloads: [
        [
          "String",
          "String?"
        ]
      ]
    },
    reset: {
      overloads: [
        []
      ]
    },
    getCurrentFrame: {
      overloads: [
        []
      ]
    },
    setFrame: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    numFrames: {
      overloads: [
        []
      ]
    },
    play: {
      overloads: [
        []
      ]
    },
    pause: {
      overloads: [
        []
      ]
    },
    delay: {
      overloads: [
        [
          "Number",
          "Number?"
        ]
      ]
    }
  },
  "p5.Table": {
    addRow: {
      overloads: [
        [
          "p5.TableRow?"
        ]
      ]
    },
    removeRow: {
      overloads: [
        [
          "Integer"
        ]
      ]
    },
    getRow: {
      overloads: [
        [
          "Integer"
        ]
      ]
    },
    getRows: {
      overloads: [
        []
      ]
    },
    findRow: {
      overloads: [
        [
          "String",
          "Integer|String"
        ]
      ]
    },
    findRows: {
      overloads: [
        [
          "String",
          "Integer|String"
        ]
      ]
    },
    matchRow: {
      overloads: [
        [
          "String|RegExp",
          "String|Integer"
        ]
      ]
    },
    matchRows: {
      overloads: [
        [
          "String",
          "String|Integer?"
        ]
      ]
    },
    getColumn: {
      overloads: [
        [
          "String|Number"
        ]
      ]
    },
    clearRows: {
      overloads: [
        []
      ]
    },
    addColumn: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getColumnCount: {
      overloads: [
        []
      ]
    },
    getRowCount: {
      overloads: [
        []
      ]
    },
    removeTokens: {
      overloads: [
        [
          "String",
          "String|Integer?"
        ]
      ]
    },
    trim: {
      overloads: [
        [
          "String|Integer?"
        ]
      ]
    },
    removeColumn: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "String|Number"
        ]
      ]
    },
    setNum: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "Number"
        ]
      ]
    },
    setString: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "String"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getObject: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getArray: {
      overloads: [
        []
      ]
    }
  },
  "p5.TableRow": {
    set: {
      overloads: [
        [
          "String|Integer",
          "String|Number"
        ]
      ]
    },
    setNum: {
      overloads: [
        [
          "String|Integer",
          "Number|String"
        ]
      ]
    },
    setString: {
      overloads: [
        [
          "String|Integer",
          "String|Number|Boolean|Object"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    }
  },
  "p5.XML": {
    getParent: {
      overloads: [
        []
      ]
    },
    getName: {
      overloads: [
        []
      ]
    },
    setName: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    hasChildren: {
      overloads: [
        []
      ]
    },
    listChildren: {
      overloads: [
        []
      ]
    },
    getChildren: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getChild: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    addChild: {
      overloads: [
        [
          "p5.XML"
        ]
      ]
    },
    removeChild: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getAttributeCount: {
      overloads: [
        []
      ]
    },
    listAttributes: {
      overloads: [
        []
      ]
    },
    hasAttribute: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "String",
          "Number?"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "String",
          "Number?"
        ]
      ]
    },
    setAttribute: {
      overloads: [
        [
          "String",
          "Number|String|Boolean"
        ]
      ]
    },
    getContent: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    serialize: {
      overloads: [
        []
      ]
    }
  },
  "p5.Vector": {
    getValue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setValue: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    copy: {
      overloads: [
        []
      ]
    },
    add: {
      overloads: [
        [
          "Number|Array",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    rem: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    sub: {
      overloads: [
        [
          "Number",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    mult: {
      overloads: [
        [
          "Number"
        ],
        [
          "Number",
          "Number",
          "Number?"
        ],
        [
          "Number[]"
        ],
        [
          "p5.Vector"
        ]
      ]
    },
    div: {
      overloads: [
        [
          "Number"
        ],
        [
          "Number",
          "Number",
          "Number?"
        ],
        [
          "Number[]"
        ],
        [
          "p5.Vector"
        ]
      ]
    },
    mag: {
      overloads: [
        []
      ]
    },
    magSq: {
      overloads: [
        []
      ]
    },
    dot: {
      overloads: [
        [
          "Number",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector"
        ]
      ]
    },
    cross: {
      overloads: [
        [
          "p5.Vector"
        ]
      ]
    },
    dist: {
      overloads: [
        [
          "p5.Vector"
        ]
      ]
    },
    normalize: {
      overloads: [
        []
      ]
    },
    limit: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setMag: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    heading: {
      overloads: [
        []
      ]
    },
    setHeading: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    rotate: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    angleBetween: {
      overloads: [
        [
          "p5.Vector"
        ]
      ]
    },
    lerp: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [
          "p5.Vector",
          "Number"
        ]
      ]
    },
    slerp: {
      overloads: [
        [
          "p5.Vector",
          "Number"
        ]
      ]
    },
    reflect: {
      overloads: [
        [
          "p5.Vector"
        ]
      ]
    },
    array: {
      overloads: [
        []
      ]
    },
    equals: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Array"
        ]
      ]
    },
    clampToZero: {
      overloads: [
        []
      ]
    },
    fromAngle: {
      overloads: [
        [
          "Number",
          "Number?"
        ]
      ]
    },
    fromAngles: {
      overloads: [
        [
          "Number",
          "Number",
          "Number?"
        ]
      ]
    },
    random2D: {
      overloads: [
        []
      ]
    },
    random3D: {
      overloads: [
        []
      ]
    }
  },
  "p5.Font": {
    textToPaths: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Number?",
          "Number?"
        ]
      ]
    },
    textToPoints: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    },
    textToContours: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    },
    textToModel: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    }
  },
  "p5.Camera": {
    perspective: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    ortho: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    frustum: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    pan: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    tilt: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    lookAt: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    camera: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    move: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    setPosition: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "p5.Camera"
        ]
      ]
    },
    slerp: {
      overloads: [
        [
          "p5.Camera",
          "p5.Camera",
          "Number"
        ]
      ]
    }
  },
  "p5.Framebuffer": {
    resize: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    pixelDensity: {
      overloads: [
        [
          "Number?"
        ]
      ]
    },
    autoSized: {
      overloads: [
        [
          "Boolean?"
        ]
      ]
    },
    createCamera: {
      overloads: [
        []
      ]
    },
    remove: {
      overloads: [
        []
      ]
    },
    begin: {
      overloads: [
        []
      ]
    },
    end: {
      overloads: [
        []
      ]
    },
    draw: {
      overloads: [
        [
          "Function"
        ]
      ]
    },
    loadPixels: {
      overloads: [
        []
      ]
    },
    get: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [],
        [
          "Number",
          "Number"
        ]
      ]
    }
  },
  "p5.Geometry": {
    calculateBoundingBox: {
      overloads: [
        []
      ]
    },
    clearColors: {
      overloads: [
        []
      ]
    },
    flipU: {
      overloads: [
        []
      ]
    },
    computeFaces: {
      overloads: [
        []
      ]
    },
    computeNormals: {
      overloads: [
        [
          "FLAT|SMOOTH?",
          "Object?"
        ]
      ]
    },
    makeEdgesFromFaces: {
      overloads: [
        []
      ]
    },
    normalize: {
      overloads: [
        []
      ]
    },
    vertexProperty: {
      overloads: [
        [
          "String",
          "Number|Number[]",
          "Number?"
        ]
      ]
    },
    flipV: {
      overloads: [
        []
      ]
    }
  },
  "p5.Shader": {
    version: {
      overloads: [
        []
      ]
    },
    inspectHooks: {
      overloads: [
        []
      ]
    },
    modify: {
      overloads: [
        [
          "Function",
          "Object?"
        ],
        [
          "Object?"
        ]
      ]
    },
    copyToContext: {
      overloads: [
        [
          "p5|p5.Graphics"
        ]
      ]
    },
    setUniform: {
      overloads: [
        [
          "String",
          "Boolean|Number|Number[]|p5.Image|p5.Graphics|p5.MediaElement|p5.Texture"
        ]
      ]
    }
  }
};
function validateParams(p53, fn2, lifecycles) {
  let schemaRegistry = /* @__PURE__ */ new Map();
  const p5Constructors = Object.keys(p53).reduce((acc, val) => {
    if (val.match(/^[A-Z]/) && // Starts with a capital
    !val.match(/^[A-Z][A-Z0-9]*$/) && // Is not an all caps constant
    p53[val] instanceof Function) {
      acc[val] = p53[val];
    }
    return acc;
  }, {});
  function loadP5Constructors() {
    for (let key of Object.keys(p53)) {
      if (typeof p53[key] === "function" && key[0] !== key[0].toLowerCase()) {
        p5Constructors[key] = p53[key];
      }
    }
  }
  const constantsMap = {};
  for (const [key, value] of Object.entries(constants)) {
    constantsMap[key] = value;
  }
  const schemaMap = {
    "Any": any(),
    "Array": array(any()),
    "Boolean": boolean(),
    "Function": _function(),
    "Integer": number().int(),
    "Number": number(),
    "Object": object({}),
    "String": string()
  };
  const webAPIObjects = [
    "AudioNode",
    "HTMLCanvasElement",
    "HTMLElement",
    "KeyboardEvent",
    "MouseEvent",
    "RegExp",
    "TouchEvent",
    "UIEvent",
    "WheelEvent"
  ];
  function generateWebAPISchemas(apiObjects) {
    return apiObjects.reduce((acc, obj) => {
      acc[obj] = custom((data2) => data2 instanceof globalThis[obj], {
        message: `Expected a ${obj}`
      });
      return acc;
    }, {});
  }
  const webAPISchemas = generateWebAPISchemas(webAPIObjects);
  Object.assign(schemaMap, webAPISchemas);
  const ordinals = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth"];
  function extractFuncNameAndClass(func) {
    const ichDot = func.lastIndexOf(".");
    const funcName = func.slice(ichDot + 1);
    const funcClass = func.slice(0, ichDot !== -1 ? ichDot : 0) || "p5";
    return { funcName, funcClass };
  }
  function validBracketNesting(type2) {
    let level = 0;
    for (let i = 0; i < type2.length; i++) {
      if (type2[i] === "[") {
        level++;
      } else if (type2[i] === "]") {
        level--;
        if (level < 0) return false;
      }
    }
    return level === 0;
  }
  const generateZodSchemasForFunc = function(func) {
    const { funcName, funcClass } = extractFuncNameAndClass(func);
    let funcInfo = dataDoc[funcClass][funcName];
    if (!funcInfo) return;
    let overloads = [];
    if (funcInfo.hasOwnProperty("overloads")) {
      overloads = funcInfo.overloads;
    }
    const generateTypeSchema = (baseType) => {
      if (!baseType) return any();
      let typeSchema;
      if (baseType in constantsMap) {
        typeSchema = literal$1(constantsMap[baseType]);
      } else if (baseType.match(/^[A-Z][A-Z0-9]*$/) && baseType in fn2) {
        typeSchema = literal$1(fn2[baseType]);
      } else if (baseType.startsWith("function")) {
        typeSchema = _function();
      } else if (/^p5\.[a-zA-Z0-9]+$/.exec(baseType) || baseType === "p5") {
        const className = baseType.substring(baseType.indexOf(".") + 1);
        typeSchema = _instanceof(p5Constructors[className]);
      } else if (schemaMap[baseType]) {
        typeSchema = schemaMap[baseType];
      } else if (baseType.startsWith("[") && baseType.endsWith("]") && validBracketNesting(baseType.slice(1, -1))) {
        typeSchema = tuple(
          baseType.slice(1, -1).split(/, */g).map((entry) => generateTypeSchema(entry))
        );
      } else if (baseType.match(/^[A-Z]/) && baseType in window) {
        typeSchema = _instanceof(window[baseType]);
      } else if (baseType.includes("|") && baseType.split("|").every((t) => validBracketNesting(t))) {
        const types2 = baseType.split("|");
        typeSchema = union(types2.map((t) => generateTypeSchema(t)).filter((s) => s !== void 0));
      } else if (baseType.endsWith("[]")) {
        typeSchema = array(generateTypeSchema(baseType.slice(0, -2)));
      } else {
        throw new Error(`Unsupported type '${baseType}' in parameter validation. Please report this issue.`);
      }
      return typeSchema;
    };
    const generateParamSchema = (param) => {
      const isOptional = param?.endsWith("?");
      param = param?.replace(/\?$/, "");
      const isRest = param?.startsWith("...") && param?.endsWith("[]");
      param = param?.replace(/^\.\.\.(.+)\[\]$/, "$1");
      let schema = generateTypeSchema(param);
      if (schema.def.type === "function") {
        schema = custom((val) => val instanceof Function);
      }
      if (isOptional) {
        schema = schema.optional();
      }
      return { schema, rest: isRest };
    };
    const generateOverloadCombinations = (params) => {
      if (!params.some((p2) => p2?.endsWith("?"))) {
        return [params];
      }
      const requiredParamsCount = params.filter((p2) => p2 === null || !p2.endsWith("?")).length;
      const result = [];
      for (let i = requiredParamsCount; i <= params.length; i++) {
        result.push(params.slice(0, i));
      }
      return result;
    };
    const overloadSchemas = overloads.flatMap((overload) => {
      const combinations = generateOverloadCombinations(overload);
      return combinations.map((combo) => {
        const params = combo.map((p2) => generateParamSchema(p2)).filter((s) => s.schema !== void 0);
        let rest;
        if (params.at(-1)?.rest) {
          rest = params.pop();
        }
        let combined = tuple(params.map((s) => s.schema));
        if (rest) {
          combined = combined.rest(rest.schema);
        }
        return combined;
      });
    });
    return overloadSchemas.length === 1 ? overloadSchemas[0] : union(overloadSchemas);
  };
  const findClosestSchema = function(schema, args) {
    if (!(schema instanceof ZodUnion)) {
      return schema;
    }
    const scoreSchema = (schema2) => {
      let score = Infinity;
      if (!(schema2 instanceof ZodTuple)) {
        console.warn("Schema below is not a tuple: ");
        printZodSchema(schema2);
        return score;
      }
      const numArgs = args.length;
      const schemaItems = schema2.def.items;
      const numSchemaItems = schemaItems.length;
      const numRequiredSchemaItems = schemaItems.filter((item) => !item.isOptional()).length;
      if (numArgs >= numRequiredSchemaItems && numArgs <= numSchemaItems) {
        score = 0;
      } else {
        score = Math.abs(
          numArgs < numRequiredSchemaItems ? numRequiredSchemaItems - numArgs : numArgs - numSchemaItems
        ) * 4;
      }
      for (let i = 0; i < Math.min(schemaItems.length, args.length); i++) {
        const paramSchema = schemaItems[i];
        const arg = args[i];
        if (!paramSchema.safeParse(arg).success) score++;
      }
      return score;
    };
    let closestSchema = schema.def.options[0];
    let bestScore = Infinity;
    const schemaUnion = schema.def.options;
    schemaUnion.forEach((schema2) => {
      const score = scoreSchema(schema2);
      if (score < bestScore) {
        closestSchema = schema2;
        bestScore = score;
      }
    });
    return closestSchema;
  };
  const friendlyParamError = function(zodErrorObj, func, args) {
    let message = "🌸 p5.js says: ";
    let isVersionError = false;
    let currentError = zodErrorObj.issues[0];
    const buildTypeMismatchMessage = (actualType, expectedTypeStr, position) => {
      const positionStr = position ? `at the ${ordinals[position]} parameter` : "";
      const actualTypeStr = actualType ? `, but received ${actualType}` : "";
      return `Expected ${expectedTypeStr} ${positionStr}${actualTypeStr}`;
    };
    const processUnionError = (error2) => {
      const expectedTypes = /* @__PURE__ */ new Set();
      let actualType;
      error2.errors.forEach((err) => {
        const issue2 = err[0];
        if (issue2) {
          if (!actualType) {
            actualType = issue2.message;
          }
          if (issue2.code === "invalid_type") {
            actualType = issue2.message.split(", received ")[1];
            expectedTypes.add(issue2.expected);
          } else if (issue2.code === "invalid_value") {
            expectedTypes.add("constant (please refer to documentation for allowed values)");
            actualType = args[error2.path[0]];
          } else if (issue2.code === "custom") {
            const match = issue2.message.match(/Input not instance of (\w+)/);
            if (match) expectedTypes.add(match[1]);
            actualType = void 0;
          }
        }
      });
      if (expectedTypes.size > 0) {
        if (error2.path?.length > 0 && args[error2.path[0]] instanceof Promise) {
          message += "Did you mean to put `await` before a loading function? An unexpected Promise was found. ";
          isVersionError = true;
        }
        const expectedTypesStr = Array.from(expectedTypes).join(" or ");
        const position = error2.path.join(".");
        message += buildTypeMismatchMessage(
          actualType,
          expectedTypesStr,
          position
        );
      }
      return message;
    };
    switch (currentError.code) {
      case "invalid_union": {
        processUnionError(currentError);
        break;
      }
      case "too_small": {
        const minArgs = currentError.minimum;
        message += `Expected at least ${minArgs} argument${minArgs > 1 ? "s" : ""}, but received fewer`;
        break;
      }
      case "invalid_type": {
        message += buildTypeMismatchMessage(currentError.message.split(", received ")[1], currentError.expected, currentError.path.join("."));
        break;
      }
      case "too_big": {
        const maxArgs = currentError.maximum;
        message += `Expected at most ${maxArgs} argument${maxArgs > 1 ? "s" : ""}, but received more`;
        break;
      }
      default: {
        console.log("Zod error object", currentError);
      }
    }
    message += ` in ${func}().`;
    const generateDocumentationLink = (func2) => {
      const { funcName, funcClass } = extractFuncNameAndClass(func2);
      const p5BaseUrl = "https://p5js.org/reference";
      const url = `${p5BaseUrl}/${funcClass}/${funcName}`;
      return url;
    };
    if (currentError.code === "too_big" || currentError.code === "too_small") {
      const documentationLink = generateDocumentationLink(func);
      message += ` For more information, see ${documentationLink}.`;
    }
    if (isVersionError) {
      p53._error(this, message);
    } else {
      console.log(message);
    }
    return message;
  };
  const validate = function(func, args) {
    if (p53.disableFriendlyErrors) {
      return;
    }
    if (!Array.isArray(args)) {
      args = Array.from(args);
    }
    if (Array.isArray(args) && args.length > 0 && args.every((arg) => arg === void 0)) {
      const undefinedErrorMessage = `🌸 p5.js says: All arguments for ${func}() are undefined. There is likely an error in the code.`;
      return {
        success: false,
        error: undefinedErrorMessage
      };
    }
    let funcSchemas = schemaRegistry.get(func);
    if (!funcSchemas) {
      funcSchemas = generateZodSchemasForFunc(func);
      if (!funcSchemas) return;
      schemaRegistry.set(func, funcSchemas);
    }
    try {
      return {
        success: true,
        data: funcSchemas.parse(args)
      };
    } catch (error2) {
      const closestSchema = findClosestSchema(funcSchemas, args);
      const zodError = closestSchema.safeParse(args).error;
      const errorMessage = friendlyParamError(zodError, func, args);
      return {
        success: false,
        error: errorMessage
      };
    }
  };
  fn2._validate = validate;
  p53.decorateHelper(
    /^(?!_).+$/,
    function(target, { name }) {
      return function(...args) {
        if (!p53.disableFriendlyErrors && !p53.disableParameterValidator) {
          validate(name, args);
        }
        return target.apply(this, args);
      };
    }
  );
  lifecycles.presetup = function() {
    loadP5Constructors();
  };
}
if (typeof p5 !== "undefined") {
  validateParams(p5, p5.prototype);
}
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code2, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code2) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code2) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code2, astral) {
  if (code2 < 65) {
    return code2 === 36;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes);
}
function isIdentifierChar(code2, astral) {
  if (code2 < 48) {
    return code2 === 36;
  }
  if (code2 < 58) {
    return true;
  }
  if (code2 < 65) {
    return false;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options2) {
  if (options2 === void 0) options2 = {};
  options2.keyword = name;
  return keywords[name] = new TokenType(name, options2);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code2) {
  return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
}
function nextLineBreak(code2, from, end) {
  if (end === void 0) end = code2.length;
  for (var i = from; i < end; i++) {
    var next = code2.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code2.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString$1 = ref.toString;
var hasOwn = Object.hasOwn || (function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
});
var isArray$1 = Array.isArray || (function(obj) {
  return toString$1.call(obj) === "[object Array]";
});
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code2) {
  if (code2 <= 65535) {
    return String.fromCharCode(code2);
  }
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p2, start2, end) {
  this.start = start2;
  this.end = end;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray$1(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray$1(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array2) {
  return function(block, text2, start2, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text2,
      start: start2,
      end
    };
    if (options2.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment.range = [start2, end];
    }
    array2.push(comment);
  };
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
var Parser = function Parser2(options2, input, startPos) {
  this.options = options2 = getOptions(options2);
  this.sourceFile = options2.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options2.allowReserved !== true) {
    reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
    if (options2.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options2.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend2() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options2) {
  return new this(options2, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
  var parser = new this(options2, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options2) {
  return new this(options2, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start2) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start2));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start2 + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start2 += match[0].length;
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start2] === ";") {
      start2++;
    }
  }
};
pp$9.eat = function(type2) {
  if (this.type === type2) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type2) {
  this.eat(type2) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports$1 = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports$1);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
      var name = list[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(context2) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context2) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  if (lineBreak.test(this.input.slice(this.pos, next))) {
    return false;
  }
  if (isAwaitUsing) {
    var awaitEndPos = next + 5, after;
    if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
      return false;
    }
    skipWhiteSpace.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
      return false;
    }
  }
  if (isFor) {
    var ofEndPos = next + 2, after$1;
    if (this.input.slice(next, ofEndPos) === "of") {
      if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
        return false;
      }
    }
  }
  var ch = this.input.charCodeAt(next);
  return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context2, topLevel, exports$1) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context2)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context2);
    case types$1._class:
      if (context2) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context2 && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports$1);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context2) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context2);
      }
      var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
      if (usingKind) {
        if (topLevel && this.options.sourceType === "script") {
          this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
        }
        if (usingKind === "await using") {
          if (!this.canAwait) {
            this.raise(this.start, "Await using cannot appear outside of async function");
          }
          this.next();
        }
        this.next();
        this.parseVar(node, false, usingKind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context2);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword2) {
  var isBreak = keyword2 === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword2);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node, init$1, awaitAt);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") {
      this.next();
    }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node, init$2, awaitAt);
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseForAfterInit = function(node, init, awaitAt) {
  if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    return this.parseForIn(node, init);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple2 = param.type === "Identifier";
  this.enterScope(simple2 ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple2 ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context2) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node === void 0) node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name = element2.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports$1) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports$1, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports$1) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports$1);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports$1, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports$1, node.declaration.declarations);
    } else {
      this.checkExport(exports$1, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16) {
      node.attributes = [];
    }
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports$1);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
      if (this.options.ecmaVersion >= 16) {
        node.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports$1, name, pos) {
  if (!exports$1) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports$1, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports$1[name] = true;
};
pp$8.checkPatternExport = function(exports$1, pat) {
  var type2 = pat.type;
  if (type2 === "Identifier") {
    this.checkExport(exports$1, pat, pat.start);
  } else if (type2 === "ObjectPattern") {
    for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this.checkPatternExport(exports$1, prop);
    }
  } else if (type2 === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports$1, elt);
      }
    }
  } else if (type2 === "Property") {
    this.checkPatternExport(exports$1, pat.value);
  } else if (type2 === "AssignmentPattern") {
    this.checkPatternExport(exports$1, pat.left);
  } else if (type2 === "RestElement") {
    this.checkPatternExport(exports$1, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports$1, decls) {
  if (!exports$1) {
    return;
  }
  for (var i = 0, list = decls; i < list.length; i += 1) {
    var decl = list[i];
    this.checkPatternExport(exports$1, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports$1) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports$1,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports$1) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports$1));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last2 = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last2 && last2.type === "RestElement" && last2.argument.type !== "Identifier") {
      this.unexpected(last2.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context2 = this.context[i];
    if (context2.token === "function") {
      return context2.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type2 = this.type;
  if (type2.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type2.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type2.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "Literal":
      name = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base2 || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base2 = element2;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional2 = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional2) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional2 && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base2;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base2.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional2;
    }
    base2 = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional2 && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base2;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional2;
    }
    base2 = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional2 || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base2;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base2 = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base2;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start2;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start2;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  var kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  prop.kind = kind;
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start2 = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start2, "getter should have no params");
    } else {
      this.raiseRecoverable(start2, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
    prop.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.kind = "init";
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
    var param = list[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start2 = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
    this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start2, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start2, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start2, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start2, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type2, pos, loc) {
  node.type = type2;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type2) {
  return finishNodeAt.call(this, node, type2, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type2, pos, loc) {
  return finishNodeAt.call(this, node, type2, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data$1 = {};
function buildUnicodeData(ecmaVersion) {
  var d2 = data$1[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
  d2.nonBinary.gc = d2.nonBinary.General_Category;
  d2.nonBinary.sc = d2.nonBinary.Script;
  d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
}
for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
  var ecmaVersion = list[i];
  buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base2) {
  this.parent = parent;
  this.base = base2 || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data$1[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start2, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start2 | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at2(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
    return c;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i = 0, list = chs; i < list.length; i += 1) {
    var ch = list[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _23 in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];
    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start2 = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start2;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start2;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start2 = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start2 = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(
          45
          /* - */
        );
        if (addModifiers || hasHyphen) {
          for (var i = 0; i < addModifiers.length; i++) {
            var modifier = addModifiers.charAt(i);
            if (addModifiers.indexOf(modifier, i + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers += codePointToString(ch);
    state.advance();
  }
  return modifiers;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start2 = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start2;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i = 0, list = known; i < list.length; i += 1) {
          var altID = list[i];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start2 = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start2 = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start2;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start2;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start2 = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start2 !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start2 !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start2 = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start2;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start2;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start2 = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start2;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start2 = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start2;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start2;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start2 = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start2;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code2) {
  if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code2);
};
pp.fullCharCodeAtPos = function() {
  var code2 = this.input.charCodeAt(this.pos);
  if (code2 <= 55295 || code2 >= 56320) {
    return code2;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start2 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start2 + 2, end),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start2 = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start2 + startSkip, this.pos),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type2, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type2;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code2) {
    size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code2 = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code2 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code2, true) || code2 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.getTokenFromCode = function(code2) {
  switch (code2) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      return this.readToken_dot();
    // Punctuation tokens.
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    // Quotes produce strings.
    case 34:
    case 39:
      return this.readString(code2);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code2);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code2);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code2);
    case 60:
    case 62:
      return this.readToken_lt_gt(code2);
    case 61:
    case 33:
      return this.readToken_eq_excl(code2);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.finishOp = function(type2, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type2, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start2 = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start2, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start2, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start2, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start2, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e2) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start2 = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e2 = len == null ? Infinity : len; i < e2; ++i, ++this.pos) {
    var code2 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code2 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code2;
      continue;
    }
    if (code2 >= 97) {
      val = code2 - 97 + 10;
    } else if (code2 >= 65) {
      val = code2 - 65 + 10;
    } else if (code2 >= 48 && code2 <= 57) {
      val = code2 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code2;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start2 || len != null && this.pos - start2 !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start2 = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start2 = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start2, "Invalid number");
  }
  var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
  if (octal && this.strict) {
    this.raise(start2, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start2, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start2, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code2;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code2 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code2 = this.readHexChar(4);
  }
  return code2;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      // fall through
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      // fall through
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    // 'n' -> '\n'
    case 114:
      return "\r";
    // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'
    case 117:
      return codePointToString(this.readCodePoint());
    // 'u'
    case 116:
      return "	";
    // 't' -> '\t'
    case 98:
      return "\b";
    // 'b' -> '\b'
    case 118:
      return "\v";
    // 'v' -> '\u000b'
    case 102:
      return "\f";
    // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc2 = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc2, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc2);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type2 = types$1.name;
  if (this.keywords.test(word)) {
    type2 = keywords[word];
  }
  return this.finishToken(type2, word);
};
var version$2 = "8.15.0";
Parser.acorn = {
  Parser,
  version: version$2,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options2) {
  return Parser.parse(input, options2);
}
function simple(node, visitors, baseVisitor, state, override) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c(node2, st, override2) {
    var type2 = override2 || node2.type;
    baseVisitor[type2](node2, st, c);
    if (visitors[type2]) {
      visitors[type2](node2, st);
    }
  })(node, state, override);
}
function ancestor(node, visitors, baseVisitor, state, override) {
  var ancestors = [];
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c(node2, st, override2) {
    var type2 = override2 || node2.type;
    var isNew = node2 !== ancestors[ancestors.length - 1];
    if (isNew) {
      ancestors.push(node2);
    }
    baseVisitor[type2](node2, st, c);
    if (visitors[type2]) {
      visitors[type2](node2, st || ancestors, ancestors);
    }
    if (isNew) {
      ancestors.pop();
    }
  })(node, state, override);
}
function recursive(node, state, funcs, baseVisitor, override) {
  var visitor = funcs ? make(funcs) : baseVisitor;
  (function c(node2, st, override2) {
    visitor[override2 || node2.type](node2, st, c);
  })(node, state, override);
}
function make(funcs, baseVisitor) {
  var visitor = Object.create(base);
  for (var type2 in funcs) {
    visitor[type2] = funcs[type2];
  }
  return visitor;
}
function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {
}
var base = {};
base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1) {
    var stmt = list[i];
    c(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
  return c(node.expression, st, "Expression");
};
base.IfStatement = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) {
    c(node.alternate, st, "Statement");
  }
};
base.LabeledStatement = function(node, st, c) {
  return c(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function(node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base.SwitchStatement = function(node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0, list = node.cases; i < list.length; i += 1) {
    var cs = list[i];
    c(cs, st);
  }
};
base.SwitchCase = function(node, st, c) {
  if (node.test) {
    c(node.test, st, "Expression");
  }
  for (var i = 0, list = node.consequent; i < list.length; i += 1) {
    var cons = list[i];
    c(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
  if (node.argument) {
    c(node.argument, st, "Expression");
  }
};
base.ThrowStatement = base.SpreadElement = function(node, st, c) {
  return c(node.argument, st, "Expression");
};
base.TryStatement = function(node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) {
    c(node.handler, st);
  }
  if (node.finalizer) {
    c(node.finalizer, st, "Statement");
  }
};
base.CatchClause = function(node, st, c) {
  if (node.param) {
    c(node.param, st, "Pattern");
  }
  c(node.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForStatement = function(node, st, c) {
  if (node.init) {
    c(node.init, st, "ForInit");
  }
  if (node.test) {
    c(node.test, st, "Expression");
  }
  if (node.update) {
    c(node.update, st, "Expression");
  }
  c(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function(node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInit = function(node, st, c) {
  if (node.type === "VariableDeclaration") {
    c(node, st);
  } else {
    c(node, st, "Expression");
  }
};
base.DebuggerStatement = ignore;
base.FunctionDeclaration = function(node, st, c) {
  return c(node, st, "Function");
};
base.VariableDeclaration = function(node, st, c) {
  for (var i = 0, list = node.declarations; i < list.length; i += 1) {
    var decl = list[i];
    c(decl, st);
  }
};
base.VariableDeclarator = function(node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) {
    c(node.init, st, "Expression");
  }
};
base.Function = function(node, st, c) {
  if (node.id) {
    c(node.id, st, "Pattern");
  }
  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    c(param, st, "Pattern");
  }
  c(node.body, st, node.expression ? "Expression" : "Statement");
};
base.Pattern = function(node, st, c) {
  if (node.type === "Identifier") {
    c(node, st, "VariablePattern");
  } else if (node.type === "MemberExpression") {
    c(node, st, "MemberPattern");
  } else {
    c(node, st);
  }
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function(node, st, c) {
  return c(node.argument, st, "Pattern");
};
base.ArrayPattern = function(node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];
    if (elt) {
      c(elt, st, "Pattern");
    }
  }
};
base.ObjectPattern = function(node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];
    if (prop.type === "Property") {
      if (prop.computed) {
        c(prop.key, st, "Expression");
      }
      c(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c(prop.argument, st, "Pattern");
    }
  }
};
base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function(node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];
    if (elt) {
      c(elt, st, "Expression");
    }
  }
};
base.ObjectExpression = function(node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];
    c(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function(node, st, c) {
  for (var i = 0, list = node.expressions; i < list.length; i += 1) {
    var expr = list[i];
    c(expr, st, "Expression");
  }
};
base.TemplateLiteral = function(node, st, c) {
  for (var i = 0, list = node.quasis; i < list.length; i += 1) {
    var quasi = list[i];
    c(quasi, st);
  }
  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
    var expr = list$1[i$1];
    c(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base.ConditionalExpression = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function(node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments) {
    for (var i = 0, list = node.arguments; i < list.length; i += 1) {
      var arg = list[i];
      c(arg, st, "Expression");
    }
  }
};
base.MemberExpression = function(node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) {
    c(node.property, st, "Expression");
  }
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
  if (node.declaration) {
    c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  }
  if (node.source) {
    c(node.source, st, "Expression");
  }
};
base.ExportAllDeclaration = function(node, st, c) {
  if (node.exported) {
    c(node.exported, st);
  }
  c(node.source, st, "Expression");
};
base.ImportDeclaration = function(node, st, c) {
  for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
    var spec = list[i];
    c(spec, st);
  }
  c(node.source, st, "Expression");
};
base.ImportExpression = function(node, st, c) {
  c(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
base.TaggedTemplateExpression = function(node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
  return c(node, st, "Class");
};
base.Class = function(node, st, c) {
  if (node.id) {
    c(node.id, st, "Pattern");
  }
  if (node.superClass) {
    c(node.superClass, st, "Expression");
  }
  c(node.body, st);
};
base.ClassBody = function(node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1) {
    var elt = list[i];
    c(elt, st);
  }
};
base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c) {
  if (node.computed) {
    c(node.key, st, "Expression");
  }
  if (node.value) {
    c(node.value, st, "Expression");
  }
};
const ignoreFunction = [
  "setup",
  "draw",
  "preload",
  "deviceMoved",
  "deviceTurned",
  "deviceShaken",
  "doubleClicked",
  "mousePressed",
  "mouseReleased",
  "mouseMoved",
  "mouseDragged",
  "mouseClicked",
  "mouseWheel",
  "touchStarted",
  "touchMoved",
  "touchEnded",
  "keyPressed",
  "keyReleased",
  "keyTyped",
  "windowResized"
  // 'name',
  // 'parent',
  // 'toString',
  // 'print',
  // 'stop',
  // 'onended'
];
const verifierUtils = {
  /**
   * Fetches the contents of a script element in the user's sketch.
   *
   * @private
   * @method fetchScript
   * @param {HTMLScriptElement} script
   * @returns {Promise<string>}
   */
  fetchScript: async function(script) {
    if (script.src) {
      try {
        const contents = await fetch(script.src).then((res) => res.text());
        return contents;
      } catch (error2) {
        console.error("Error fetching script:", error2);
        return "";
      }
    } else {
      return script.textContent;
    }
  },
  /**
   * Extracts the user-defined variables and functions from the user code with
   * the help of Espree parser.
   *
   * @private
   * @method extractUserDefinedVariablesAndFuncs
   * @param {String} code - The code to extract variables and functions from.
   * @returns {Object} An object containing the user's defined variables and functions.
   * @returns {Array<{name: string, line: number}>} [userDefinitions.variables] Array of user-defined variable names and their line numbers.
   * @returns {Array<{name: string, line: number}>} [userDefinitions.functions] Array of user-defined function names and their line numbers.
   */
  extractUserDefinedVariablesAndFuncs: function(code2) {
    const userDefinitions = {
      variables: [],
      functions: []
    };
    const lineOffset = -1;
    try {
      const ast2 = parse3(code2, {
        ecmaVersion: 2021,
        sourceType: "module",
        locations: true
        // This helps us get the line number.
      });
      simple(ast2, {
        VariableDeclarator(node) {
          if (node.id.type === "Identifier") {
            const category = node.init && ["ArrowFunctionExpression", "FunctionExpression"].includes(node.init.type) ? "functions" : "variables";
            userDefinitions[category].push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        },
        FunctionDeclaration(node) {
          if (node.id && node.id.type === "Identifier") {
            userDefinitions.functions.push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        },
        // We consider class declarations to be a special form of variable
        // declaration.
        ClassDeclaration(node) {
          if (node.id && node.id.type === "Identifier") {
            userDefinitions.variables.push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        }
      });
    } catch (error2) {
      console.error("Error parsing code:", error2);
    }
    return userDefinitions;
  },
  /**
   * Checks user-defined variables and functions for conflicts with p5.js
   * constants and global functions.
   *
   * This function performs two main checks:
   * 1. Verifies if any user definition conflicts with p5.js constants.
   * 2. Checks if any user definition conflicts with global functions from
   * p5.js renderer classes.
   *
   * If a conflict is found, it reports a friendly error message and halts
   * further checking.
   *
   * @private
   * @param {Object} userDefinitions - An object containing user-defined variables and functions.
   * @param {Array<{name: string, line: number}>} userDefinitions.variables - Array of user-defined variable names and their line numbers.
   * @param {Array<{name: string, line: number}>} userDefinitions.functions - Array of user-defined function names and their line numbers.
   * @returns {boolean} - Returns true if a conflict is found, false otherwise.
   */
  checkForConstsAndFuncs: function(userDefinitions, p53) {
    const allDefinitions = [
      ...userDefinitions.variables,
      ...userDefinitions.functions
    ];
    function generateFriendlyError(errorType, name, line) {
      const url = `https://p5js.org/reference/p5/${name}`;
      const message = `${errorType} "${name}" on line ${line} is being redeclared and conflicts with a p5.js ${errorType.toLowerCase()}. p5.js reference: ${url}`;
      return message;
    }
    for (let { name, line } of allDefinitions) {
      const libDefinition = constants[name];
      if (libDefinition !== void 0) {
        const message = generateFriendlyError("Constant", name, line);
        console.log(message);
        return true;
      }
    }
    const globalFunctions = new Set(
      Object.getOwnPropertyNames(p53.prototype).filter((key) => !key.startsWith("_") && key !== "constructor")
    );
    for (let { name, line } of allDefinitions) {
      if (!ignoreFunction.includes(name) && globalFunctions.has(name)) {
        const message = generateFriendlyError("Function", name, line);
        console.log(message);
        return true;
      }
    }
    return false;
  },
  /**
   * Extracts the user's code from the script fetched. Note that this method
   * assumes that the user's code is always the last script element in the
   * sketch.
   *
   * @private
   * @method getUserCode
   * @returns {Promise<string>} The user's code as a string.
   */
  getUserCode: async function() {
    const scripts = document.querySelectorAll("script");
    const userCodeScript = scripts[scripts.length - 1];
    const userCode = await verifierUtils.fetchScript(userCodeScript);
    return userCode;
  },
  /**
   * @private
   */
  runFES: async function(p53) {
    const userCode = await verifierUtils.getUserCode();
    const userDefinedVariablesAndFuncs = verifierUtils.extractUserDefinedVariablesAndFuncs(userCode);
    verifierUtils.checkForConstsAndFuncs(userDefinedVariablesAndFuncs, p53);
  }
};
function sketchVerifier(p53, _fn, lifecycles) {
  lifecycles.presetup = async function() {
    if (!p53.disableFriendlyErrors && !p53.disableSketchChecker) {
      verifierUtils.runFES(p53);
    }
  };
}
if (typeof p5 !== "undefined") {
  sketchVerifier(p5, p5.prototype);
}
function fileErrors(p53, fn2) {
  const fileLoadErrorCases = (num, filePath) => {
    const suggestion = translator("fes.fileLoadError.suggestion", {
      filePath,
      url: "https://github.com/processing/p5.js/wiki/Local-server"
    });
    switch (num) {
      case 0:
        return {
          message: translator("fes.fileLoadError.image", {
            suggestion
          }),
          method: "loadImage"
        };
      case 1:
        return {
          message: translator("fes.fileLoadError.xml", {
            suggestion
          }),
          method: "loadXML"
        };
      case 2:
        return {
          message: translator("fes.fileLoadError.table", {
            suggestion
          }),
          method: "loadTable"
        };
      case 3:
        return {
          message: translator("fes.fileLoadError.strings", {
            suggestion
          }),
          method: "loadStrings"
        };
      case 4:
        return {
          message: translator("fes.fileLoadError.font", {
            suggestion
          }),
          method: "loadFont"
        };
      case 5:
        return {
          message: translator("fes.fileLoadError.json", {
            suggestion
          }),
          method: "loadJSON"
        };
      case 6:
        return {
          message: translator("fes.fileLoadError.bytes", {
            suggestion
          }),
          method: "loadBytes"
        };
      case 7:
        return {
          message: translator("fes.fileLoadError.large"),
          method: "loadX"
        };
      case 8:
        return {
          message: translator("fes.fileLoadError.gif"),
          method: "loadImage"
        };
    }
  };
  p53._friendlyFileLoadError = function(errorType, filePath) {
    const { message, method } = fileLoadErrorCases(errorType, filePath);
    p53._friendlyError(message, method, 3);
  };
}
if (typeof p5 !== "undefined") {
  fileErrors(p5, p5.prototype);
}
function friendlyErrors(p53) {
  p53.registerAddon(fesCore);
  p53.registerAddon(stacktrace);
  p53.registerAddon(validateParams);
  p53.registerAddon(sketchVerifier);
  p53.registerAddon(fileErrors);
}
function storage(p53, fn2) {
  fn2.storeItem = function(key, value) {
    if (typeof key !== "string") {
      console.log(
        `The argument that you passed to storeItem() - ${key} is not a string.`
      );
    }
    if (key.endsWith("p5TypeID")) {
      console.log(
        `The argument that you passed to storeItem() - ${key} must not end with 'p5TypeID'.`
      );
    }
    if (typeof value === "undefined") {
      console.log("You cannot store undefined variables using storeItem().");
    }
    let type2 = typeof value;
    switch (type2) {
      case "number":
      case "boolean":
        value = value.toString();
        break;
      case "object":
        if (value instanceof p53.Color) {
          type2 = "p5.Color";
          value = value.toString();
        } else if (value instanceof p53.Vector) {
          type2 = "p5.Vector";
          const coord = value.values;
          value = coord;
        }
        value = JSON.stringify(value);
        break;
    }
    localStorage.setItem(key, value);
    const typeKey = `${key}p5TypeID`;
    localStorage.setItem(typeKey, type2);
  };
  fn2.getItem = function(key) {
    let value = localStorage.getItem(key);
    const type2 = localStorage.getItem(`${key}p5TypeID`);
    if (typeof type2 === "undefined") {
      console.log(
        `Unable to determine type of item stored under ${key}in local storage. Did you save the item with something other than setItem()?`
      );
    } else if (value !== null) {
      switch (type2) {
        case "number":
          value = parseFloat(value);
          break;
        case "boolean":
          value = value === "true";
          break;
        case "object":
          value = JSON.parse(value);
          break;
        case "p5.Color":
          value = this.color(JSON.parse(value));
          break;
        case "p5.Vector":
          value = JSON.parse(value);
          value = this.createVector(...value);
          break;
      }
    }
    return value;
  };
  fn2.clearStorage = function() {
    const keys = Object.keys(localStorage);
    keys.forEach((key) => {
      if (key.endsWith("p5TypeID")) {
        this.removeItem(key.replace("p5TypeID", ""));
      }
    });
  };
  fn2.removeItem = function(key) {
    if (typeof key !== "string") {
      console.log(
        `The argument that you passed to removeItem() - ${key} is not a string.`
      );
    }
    localStorage.removeItem(key);
    localStorage.removeItem(`${key}p5TypeID`);
  };
}
if (typeof p5 !== "undefined") {
  storage(p5, p5.prototype);
}
function data(p53) {
  p53.registerAddon(storage);
}
function dom$1(p53, fn2) {
  fn2.select = function(e2, p2) {
    const container = this._getContainer(p2);
    const res = container.querySelector(e2);
    if (res) {
      return this._wrapElement(res);
    } else {
      return null;
    }
  };
  fn2.selectAll = function(e2, p2) {
    const arr2 = [];
    const container = this._getContainer(p2);
    const res = container.querySelectorAll(e2);
    if (res) {
      for (let j2 = 0; j2 < res.length; j2++) {
        const obj = this._wrapElement(res[j2]);
        arr2.push(obj);
      }
    }
    return arr2;
  };
  fn2._getContainer = function(p2) {
    let container = document;
    if (typeof p2 === "string") {
      container = document.querySelector(p2) || document;
    } else if (p2 instanceof Element) {
      container = p2.elt;
    } else if (p2 instanceof HTMLElement) {
      container = p2;
    }
    return container;
  };
  fn2._wrapElement = function(elt) {
    const children = Array.prototype.slice.call(elt.children);
    if (elt.tagName === "INPUT" && elt.type === "checkbox") {
      let converted = new Element(elt, this);
      converted.checked = function(...args) {
        if (args.length === 0) {
          return this.elt.checked;
        } else if (args[0]) {
          this.elt.checked = true;
        } else {
          this.elt.checked = false;
        }
        return this;
      };
      return converted;
    } else if (elt.tagName === "VIDEO" || elt.tagName === "AUDIO") {
      return new MediaElement(elt, this);
    } else if (elt.tagName === "SELECT") {
      return this.createSelect(new Element(elt, this));
    } else if (children.length > 0 && children.every(function(c) {
      return c.tagName === "INPUT" || c.tagName === "LABEL";
    }) && (elt.tagName === "DIV" || elt.tagName === "SPAN")) {
      return this.createRadio(new Element(elt, this));
    } else {
      return new Element(elt, this);
    }
  };
  fn2.createElement = function(tag, content) {
    const elt = document.createElement(tag);
    if (typeof content !== "undefined") {
      elt.innerHTML = content;
    }
    return addElement(elt, this);
  };
  fn2.removeElements = function(e2) {
    const isNotCanvasElement = (el) => !(el.elt instanceof HTMLCanvasElement);
    const removeableElements = this._elements.filter(isNotCanvasElement);
    removeableElements.map((el) => el.remove());
  };
  function addElement(elt, pInst, media2) {
    const node = pInst._userNode ? pInst._userNode : document.body;
    node.appendChild(elt);
    const c = media2 ? new MediaElement(elt, pInst) : new Element(elt, pInst);
    pInst._elements.push(c);
    return c;
  }
  fn2.createDiv = function(html = "") {
    let elt = document.createElement("div");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createP = function(html = "") {
    let elt = document.createElement("p");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createSpan = function(html = "") {
    let elt = document.createElement("span");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createImg = function() {
    const elt = document.createElement("img");
    const args = arguments;
    let self2;
    if (args.length > 1 && typeof args[1] === "string") {
      elt.alt = args[1];
    }
    if (args.length > 2 && typeof args[2] === "string") {
      elt.crossOrigin = args[2];
    }
    elt.src = args[0];
    self2 = addElement(elt, this);
    elt.addEventListener("load", function() {
      self2.width = elt.offsetWidth || elt.width;
      self2.height = elt.offsetHeight || elt.height;
      const last2 = args[args.length - 1];
      if (typeof last2 === "function") last2(self2);
    });
    return self2;
  };
  fn2.createA = function(href, html, target) {
    const elt = document.createElement("a");
    elt.href = href;
    elt.innerHTML = html;
    if (target) elt.target = target;
    return addElement(elt, this);
  };
  fn2.createSlider = function(min, max, value, step) {
    const elt = document.createElement("input");
    elt.type = "range";
    elt.min = min;
    elt.max = max;
    if (step === 0) {
      elt.step = 1e-18;
    } else if (step) {
      elt.step = step;
    }
    if (typeof value === "number") elt.value = value;
    return addElement(elt, this);
  };
  fn2.createButton = function(label, value) {
    const elt = document.createElement("button");
    elt.innerHTML = label;
    if (value) elt.value = value;
    return addElement(elt, this);
  };
  fn2.createCheckbox = function(...args) {
    const elt = document.createElement("div");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    const label = document.createElement("label");
    label.appendChild(checkbox);
    elt.appendChild(label);
    const self2 = addElement(elt, this);
    self2.checked = function(...args2) {
      const cb = self2.elt.firstElementChild.getElementsByTagName("input")[0];
      if (cb) {
        if (args2.length === 0) {
          return cb.checked;
        } else if (args2[0]) {
          cb.checked = true;
        } else {
          cb.checked = false;
        }
      }
      return self2;
    };
    this.value = function(val) {
      self2.value = val;
      return this;
    };
    if (args[0]) {
      self2.value(args[0]);
      const span = document.createElement("span");
      span.innerHTML = args[0];
      label.appendChild(span);
    }
    if (args[1]) {
      checkbox.checked = true;
    }
    return self2;
  };
  fn2.createSelect = function(...args) {
    let self2;
    let arg = args[0];
    if (arg instanceof Element && arg.elt instanceof HTMLSelectElement) {
      self2 = arg;
      this.elt = arg.elt;
    } else if (arg instanceof HTMLSelectElement) {
      self2 = addElement(arg, this);
      this.elt = arg;
    } else {
      const elt = document.createElement("select");
      if (arg && typeof arg === "boolean") {
        elt.setAttribute("multiple", "true");
      }
      self2 = addElement(elt, this);
      this.elt = elt;
    }
    self2.option = function(name, value) {
      let index;
      if (name === void 0) {
        return;
      }
      for (let i = 0; i < this.elt.length; i += 1) {
        if (this.elt[i].textContent === name) {
          index = i;
          break;
        }
      }
      if (index !== void 0) {
        if (value === false) {
          this.elt.remove(index);
        } else {
          this.elt[index].value = value;
        }
      } else {
        const opt = document.createElement("option");
        opt.textContent = name;
        opt.value = value === void 0 ? name : value;
        this.elt.appendChild(opt);
        this._pInst._elements.push(opt);
      }
    };
    self2.selected = function(value) {
      if (value !== void 0) {
        for (let i = 0; i < this.elt.length; i += 1) {
          if (this.elt[i].value.toString() === value.toString()) {
            this.elt.selectedIndex = i;
          }
        }
        return this;
      } else {
        if (this.elt.getAttribute("multiple")) {
          let arr2 = [];
          for (const selectedOption of this.elt.selectedOptions) {
            arr2.push(selectedOption.value);
          }
          return arr2;
        } else {
          return this.elt.value;
        }
      }
    };
    self2.disable = function(value) {
      if (typeof value === "string") {
        for (let i = 0; i < this.elt.length; i++) {
          if (this.elt[i].value.toString() === value) {
            this.elt[i].disabled = true;
            this.elt[i].selected = false;
          }
        }
      } else {
        this.elt.disabled = true;
      }
      return this;
    };
    self2.enable = function(value) {
      if (typeof value === "string") {
        for (let i = 0; i < this.elt.length; i++) {
          if (this.elt[i].value.toString() === value) {
            this.elt[i].disabled = false;
            this.elt[i].selected = false;
          }
        }
      } else {
        this.elt.disabled = false;
        for (let i = 0; i < this.elt.length; i++) {
          this.elt[i].disabled = false;
          this.elt[i].selected = false;
        }
      }
      return this;
    };
    return self2;
  };
  let counter = 0;
  fn2.createRadio = function(...args) {
    let self2;
    let radioElement;
    let name;
    const arg0 = args[0];
    if (arg0 instanceof Element && (arg0.elt instanceof HTMLDivElement || arg0.elt instanceof HTMLSpanElement)) {
      self2 = arg0;
      this.elt = arg0.elt;
    } else if (
      // If existing radio Element is provided as argument 0
      arg0 instanceof HTMLDivElement || arg0 instanceof HTMLSpanElement
    ) {
      self2 = addElement(arg0, this);
      this.elt = arg0;
      radioElement = arg0;
      if (typeof args[1] === "string") name = args[1];
    } else {
      if (typeof arg0 === "string") name = arg0;
      radioElement = document.createElement("div");
      self2 = addElement(radioElement, this);
      this.elt = radioElement;
    }
    self2._name = name || `radioOption_${counter++}`;
    const isRadioInput = (el) => el instanceof HTMLInputElement && el.type === "radio";
    const isLabelElement = (el) => el instanceof HTMLLabelElement;
    const isSpanElement = (el) => el instanceof HTMLSpanElement;
    self2._getOptionsArray = function() {
      return Array.from(this.elt.children).filter(
        (el) => isRadioInput(el) || isLabelElement(el) && isRadioInput(el.firstElementChild)
      ).map((el) => isRadioInput(el) ? el : el.firstElementChild);
    };
    self2.option = function(value, label) {
      let optionEl;
      for (const option of self2._getOptionsArray()) {
        if (option.value === value) {
          optionEl = option;
          break;
        }
      }
      if (optionEl === void 0) {
        optionEl = document.createElement("input");
        optionEl.setAttribute("type", "radio");
        optionEl.setAttribute("value", value);
      }
      optionEl.setAttribute("name", self2._name);
      let labelElement;
      if (!isLabelElement(optionEl.parentElement)) {
        labelElement = document.createElement("label");
        labelElement.insertAdjacentElement("afterbegin", optionEl);
      } else {
        labelElement = optionEl.parentElement;
      }
      let spanElement;
      if (!isSpanElement(labelElement.lastElementChild)) {
        spanElement = document.createElement("span");
        optionEl.insertAdjacentElement("afterend", spanElement);
      } else {
        spanElement = labelElement.lastElementChild;
      }
      spanElement.innerHTML = label === void 0 ? value : label;
      this.elt.appendChild(labelElement);
      return optionEl;
    };
    self2.remove = function(value) {
      for (const optionEl of self2._getOptionsArray()) {
        if (optionEl.value === value) {
          if (isLabelElement(optionEl.parentElement)) {
            optionEl.parentElement.remove();
          } else {
            optionEl.remove();
          }
          return;
        }
      }
    };
    self2.value = function() {
      let result = "";
      for (const option of self2._getOptionsArray()) {
        if (option.checked) {
          result = option.value;
          break;
        }
      }
      return result;
    };
    self2.selected = function(value) {
      let result = null;
      if (value === void 0) {
        for (const option of self2._getOptionsArray()) {
          if (option.checked) {
            result = option;
            break;
          }
        }
      } else {
        self2._getOptionsArray().forEach((option) => {
          option.checked = false;
          option.removeAttribute("checked");
        });
        for (const option of self2._getOptionsArray()) {
          if (option.value === value) {
            option.setAttribute("checked", true);
            option.checked = true;
            result = option;
          }
        }
      }
      return result;
    };
    self2.disable = function(shouldDisable = true) {
      for (const radioInput of self2._getOptionsArray()) {
        radioInput.setAttribute("disabled", shouldDisable);
      }
    };
    return self2;
  };
  fn2.createColorPicker = function(value) {
    const elt = document.createElement("input");
    let self2;
    elt.type = "color";
    if (value) {
      if (value instanceof p53.Color) {
        elt.value = value.toString("#rrggbb");
      } else {
        this.push();
        this.colorMode("rgb");
        elt.value = this.color(value).toString("#rrggbb");
        this.pop();
      }
    } else {
      elt.value = "#000000";
    }
    self2 = addElement(elt, this);
    const inst = this;
    self2.color = function() {
      inst.push();
      if (value) {
        if (value.mode) {
          inst.colorMode(
            value.mode,
            ...value?.maxes ? value.maxes[value.mode] || [] : []
          );
        }
      }
      const c = inst.color(this.elt.value);
      inst.pop();
      return c;
    };
    return self2;
  };
  fn2.createInput = function(value = "", type2 = "text") {
    let elt = document.createElement("input");
    elt.setAttribute("value", value);
    elt.setAttribute("type", type2);
    return addElement(elt, this);
  };
  fn2.createFileInput = function(callback, multiple = false) {
    const handleFileSelect = function(event) {
      for (const file2 of event.target.files) {
        File._load(file2, callback);
      }
    };
    if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
      console.log(
        "The File APIs are not fully supported in this browser. Cannot create element."
      );
      return;
    }
    const fileInput = document.createElement("input");
    fileInput.setAttribute("type", "file");
    if (multiple) fileInput.setAttribute("multiple", true);
    fileInput.addEventListener("change", handleFileSelect, false);
    return addElement(fileInput, this);
  };
}
if (typeof p5 !== "undefined") {
  dom$1(p5, p5.prototype);
}
function dom(p53) {
  p53.registerAddon(dom$1);
  p53.registerAddon(element);
  p53.registerAddon(media);
  p53.registerAddon(file);
}
function acceleration(p53, fn2, lifecycles) {
  lifecycles.presetup = function() {
    const events2 = [
      "deviceorientation",
      "devicemotion"
    ];
    for (const event of events2) {
      window.addEventListener(event, this[`_on${event}`].bind(this), {
        passive: false,
        signal: this._removeSignal
      });
    }
  };
  fn2.deviceOrientation = window.innerWidth / window.innerHeight > 1 ? "landscape" : "portrait";
  fn2.accelerationX = 0;
  fn2.accelerationY = 0;
  fn2.accelerationZ = 0;
  fn2.pAccelerationX = 0;
  fn2.pAccelerationY = 0;
  fn2.pAccelerationZ = 0;
  fn2._updatePAccelerations = function() {
    this.pAccelerationX = this.accelerationX;
    this.pAccelerationY = this.accelerationY;
    this.pAccelerationZ = this.accelerationZ;
  };
  fn2.rotationX = 0;
  fn2.rotationY = 0;
  fn2.rotationZ = 0;
  fn2.pRotationX = 0;
  fn2.pRotationY = 0;
  fn2.pRotationZ = 0;
  let startAngleX = 0;
  let startAngleY = 0;
  let startAngleZ = 0;
  let rotateDirectionX = "clockwise";
  let rotateDirectionY = "clockwise";
  let rotateDirectionZ = "clockwise";
  fn2.pRotateDirectionX = void 0;
  fn2.pRotateDirectionY = void 0;
  fn2.pRotateDirectionZ = void 0;
  fn2._updatePRotations = function() {
    this.pRotationX = this.rotationX;
    this.pRotationY = this.rotationY;
    this.pRotationZ = this.rotationZ;
  };
  fn2.turnAxis = void 0;
  let move_threshold = 0.5;
  let shake_threshold = 30;
  fn2.setMoveThreshold = function(val) {
    move_threshold = val;
  };
  fn2.setShakeThreshold = function(val) {
    shake_threshold = val;
  };
  fn2._ondeviceorientation = function(e2) {
    this._updatePRotations();
    this.rotationX = this._fromDegrees(e2.beta);
    this.rotationY = this._fromDegrees(e2.gamma);
    this.rotationZ = this._fromDegrees(e2.alpha);
    this._handleMotion();
  };
  fn2._ondevicemotion = function(e2) {
    this._updatePAccelerations();
    this.accelerationX = e2.acceleration.x * 2;
    this.accelerationY = e2.acceleration.y * 2;
    this.accelerationZ = e2.acceleration.z * 2;
    this._handleMotion();
  };
  fn2._handleMotion = function() {
    if (screen.orientation.type === "landscape-primary" || screen.orientation.type === "landscape-secondary") {
      this.deviceOrientation = "landscape";
    } else if (screen.orientation.type === "portrait-primary" || screen.orientation.type === "portrait-secondary") {
      this.deviceOrientation = "portrait";
    } else {
      this.deviceOrientation = "undefined";
    }
    if (typeof this._customActions.deviceMoved === "function") {
      if (Math.abs(this.accelerationX - this.pAccelerationX) > move_threshold || Math.abs(this.accelerationY - this.pAccelerationY) > move_threshold || Math.abs(this.accelerationZ - this.pAccelerationZ) > move_threshold) {
        this._customActions.deviceMoved();
      }
    }
    if (typeof this._customActions.deviceTurned === "function") {
      const wRX = this._toDegrees(this.rotationX) + 180;
      const wPRX = this._toDegrees(this.pRotationX) + 180;
      let wSAX = startAngleX + 180;
      if (wRX - wPRX > 0 && wRX - wPRX < 270 || wRX - wPRX < -270) {
        rotateDirectionX = "clockwise";
      } else if (wRX - wPRX < 0 || wRX - wPRX > 270) {
        rotateDirectionX = "counter-clockwise";
      }
      if (rotateDirectionX !== this.pRotateDirectionX) {
        wSAX = wRX;
      }
      if (Math.abs(wRX - wSAX) > 90 && Math.abs(wRX - wSAX) < 270) {
        wSAX = wRX;
        this.turnAxis = "X";
        this._customActions.deviceTurned();
      }
      this.pRotateDirectionX = rotateDirectionX;
      startAngleX = wSAX - 180;
      const wRY = this._toDegrees(this.rotationY) + 180;
      const wPRY = this._toDegrees(this.pRotationY) + 180;
      let wSAY = startAngleY + 180;
      if (wRY - wPRY > 0 && wRY - wPRY < 270 || wRY - wPRY < -270) {
        rotateDirectionY = "clockwise";
      } else if (wRY - wPRY < 0 || wRY - this.pRotationY > 270) {
        rotateDirectionY = "counter-clockwise";
      }
      if (rotateDirectionY !== this.pRotateDirectionY) {
        wSAY = wRY;
      }
      if (Math.abs(wRY - wSAY) > 90 && Math.abs(wRY - wSAY) < 270) {
        wSAY = wRY;
        this.turnAxis = "Y";
        this._customActions.deviceTurned();
      }
      this.pRotateDirectionY = rotateDirectionY;
      startAngleY = wSAY - 180;
      const rotZ = this._toDegrees(this.rotationZ);
      const pRotZ = this._toDegrees(this.pRotationZ);
      if (rotZ - pRotZ > 0 && rotZ - pRotZ < 270 || rotZ - pRotZ < -270) {
        rotateDirectionZ = "clockwise";
      } else if (rotZ - pRotZ < 0 || rotZ - pRotZ > 270) {
        rotateDirectionZ = "counter-clockwise";
      }
      if (rotateDirectionZ !== this.pRotateDirectionZ) {
        startAngleZ = rotZ;
      }
      if (Math.abs(rotZ - startAngleZ) > 90 && Math.abs(rotZ - startAngleZ) < 270) {
        startAngleZ = rotZ;
        this.turnAxis = "Z";
        this._customActions.deviceTurned();
      }
      this.pRotateDirectionZ = rotateDirectionZ;
      this.turnAxis = void 0;
    }
    if (typeof this._customActions.deviceShaken === "function") {
      let accelerationChangeX;
      let accelerationChangeY;
      if (this.pAccelerationX !== null) {
        accelerationChangeX = Math.abs(
          this.accelerationX - this.pAccelerationX
        );
        accelerationChangeY = Math.abs(
          this.accelerationY - this.pAccelerationY
        );
      }
      if (accelerationChangeX + accelerationChangeY > shake_threshold) {
        this._customActions.deviceShaken();
      }
    }
  };
}
if (typeof p5 !== "undefined") {
  acceleration(p5, p5.prototype);
}
function isCode(input) {
  const leftRightKeys = [
    "Alt",
    "Shift",
    "Control",
    "Meta"
  ];
  if (leftRightKeys.includes(input)) {
    return false;
  }
  if (typeof input !== "string") {
    return false;
  }
  return input.length > 1;
}
function keyboard(p53, fn2, lifecycles) {
  lifecycles.presetup = function() {
    const events2 = [
      "keydown",
      "keyup",
      "keypress",
      "blur"
    ];
    for (const event of events2) {
      window.addEventListener(event, this[`_on${event}`].bind(this), {
        passive: false,
        signal: this._removeSignal
      });
    }
  };
  fn2.keyIsPressed = false;
  fn2.key = "";
  fn2.code = "";
  fn2.keyCode = 0;
  fn2._onkeydown = function(e2) {
    if (this._downKeys[e2.code]) {
      return;
    }
    this.keyIsPressed = true;
    this.keyCode = e2.which;
    this.key = e2.key;
    this.code = e2.code;
    this._downKeyCodes[e2.code] = true;
    this._downKeys[e2.key] = true;
    if (typeof this._customActions.keyPressed === "function" && !e2.charCode) {
      const executeDefault = this._customActions.keyPressed(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onkeyup = function(e2) {
    if (typeof this._customActions.keyReleased === "function") {
      const executeDefault = this._customActions.keyReleased(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
    delete this._downKeyCodes[e2.code];
    delete this._downKeys[e2.key];
    if (!this._areDownKeys()) {
      this.keyIsPressed = false;
      this.key = "";
      this.code = "";
    } else {
      const lastPressedCode = Object.keys(this._downKeyCodes).pop();
      this.code = lastPressedCode;
      const lastPressedKey = Object.keys(this._downKeys).pop();
      this.key = lastPressedKey;
    }
  };
  fn2._onkeypress = function(e2) {
    if (e2.which === this._lastKeyCodeTyped && e2.repeat) {
      return;
    }
    this._lastKeyCodeTyped = e2.which;
    this.key = e2.key || String.fromCharCode(e2.which) || e2.which;
    if (typeof this._customActions.keyTyped === "function") {
      const executeDefault = this._customActions.keyTyped(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onblur = function(e2) {
    this._downKeys = {};
  };
  fn2.keyIsDown = function(input) {
    if (isCode(input)) {
      return this._downKeyCodes[input] || this._downKeys[input] || false;
    } else {
      return this._downKeys[input] || this._downKeyCodes[input] || false;
    }
  };
  fn2._areDownKeys = function() {
    for (const key in this._downKeys) {
      if (this._downKeys.hasOwnProperty(key) && this._downKeys[key] === true) {
        return true;
      }
    }
    return false;
  };
}
if (typeof p5 !== "undefined") {
  keyboard(p5, p5.prototype);
}
function pointer(p53, fn2, lifecycles) {
  lifecycles.presetup = function() {
    const events2 = [
      "pointerdown",
      "pointerup",
      "pointermove",
      "dragend",
      "dragover",
      "click",
      "dblclick",
      "wheel"
    ];
    for (const event of events2) {
      window.addEventListener(event, this[`_on${event}`].bind(this), {
        passive: false,
        signal: this._removeSignal
      });
    }
  };
  fn2.movedX = 0;
  fn2.movedY = 0;
  fn2._hasMouseInteracted = false;
  fn2.mouseX = 0;
  fn2.mouseY = 0;
  fn2.pmouseX = 0;
  fn2.pmouseY = 0;
  fn2.winMouseX = 0;
  fn2.winMouseY = 0;
  fn2.pwinMouseX = 0;
  fn2.pwinMouseY = 0;
  fn2.mouseButton = {
    left: false,
    right: false,
    center: false
  };
  fn2.touches = [];
  fn2._activePointers = /* @__PURE__ */ new Map();
  fn2.mouseIsPressed = false;
  fn2._updatePointerCoords = function(e2) {
    if (this._curElement !== null) {
      const canvas2 = this._curElement.elt;
      const sx = canvas2.scrollWidth / this.width || 1;
      const sy = canvas2.scrollHeight / this.height || 1;
      if (e2.pointerType === "touch") {
        const touches = [];
        for (const touch of this._activePointers.values()) {
          touches.push(getTouchInfo(canvas2, sx, sy, touch));
        }
        this.touches = touches;
      }
      const mousePos = getMouseInfo(canvas2, sx, sy, e2);
      this.movedX = e2.movementX || 0;
      this.movedY = e2.movementY || 0;
      this.mouseX = mousePos.x;
      this.mouseY = mousePos.y;
      this.winMouseX = mousePos.winX;
      this.winMouseY = mousePos.winY;
      if (!this._hasMouseInteracted) {
        this._updateMouseCoords();
        this._hasMouseInteracted = true;
      }
    }
  };
  fn2._updateMouseCoords = function() {
    this.pmouseX = this.mouseX;
    this.pmouseY = this.mouseY;
    this.pwinMouseX = this.winMouseX;
    this.pwinMouseY = this.winMouseY;
    this._pmouseWheelDeltaY = this._mouseWheelDeltaY;
  };
  function getMouseInfo(canvas2, sx, sy, evt) {
    const rect = canvas2.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) / sx,
      y: (evt.clientY - rect.top) / sy,
      winX: evt.clientX,
      winY: evt.clientY
    };
  }
  function getTouchInfo(canvas2, sx, sy, touch) {
    const rect = canvas2.getBoundingClientRect();
    return {
      x: (touch.clientX - rect.left) / sx,
      y: (touch.clientY - rect.top) / sy,
      winX: touch.clientX,
      winY: touch.clientY,
      id: touch.pointerId
    };
  }
  fn2._setMouseButton = function(e2) {
    this.mouseButton.left = Array.from(this._activePointers.values()).some(
      (touch) => (touch.buttons & 1) !== 0
    );
    this.mouseButton.center = Array.from(this._activePointers.values()).some(
      (touch) => (touch.buttons & 4) !== 0
    );
    this.mouseButton.right = Array.from(this._activePointers.values()).some(
      (touch) => (touch.buttons & 2) !== 0
    );
  };
  fn2._onpointermove = function(e2) {
    let executeDefault;
    this._updatePointerCoords(e2);
    this._activePointers.set(e2.pointerId, e2);
    this._setMouseButton(e2);
    if (!this.mouseIsPressed && typeof this._customActions.mouseMoved === "function") {
      executeDefault = this._customActions.mouseMoved(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    } else if (this.mouseIsPressed && typeof this._customActions.mouseDragged === "function") {
      executeDefault = this._customActions.mouseDragged(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onpointerdown = function(e2) {
    let executeDefault;
    this.mouseIsPressed = true;
    this._activePointers.set(e2.pointerId, e2);
    this._setMouseButton(e2);
    this._updatePointerCoords(e2);
    if (typeof this._customActions.mousePressed === "function") {
      executeDefault = this._customActions.mousePressed(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onpointerup = function(e2) {
    let executeDefault;
    this.mouseIsPressed = false;
    this._activePointers.delete(e2.pointerId);
    this._setMouseButton(e2);
    this._updatePointerCoords(e2);
    if (typeof this._customActions.mouseReleased === "function") {
      executeDefault = this._customActions.mouseReleased(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._ondragend = fn2._onpointerup;
  fn2._ondragover = fn2._onpointermove;
  fn2._onclick = function(e2) {
    if (typeof this._customActions.mouseClicked === "function") {
      const executeDefault = this._customActions.mouseClicked(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._ondblclick = function(e2) {
    if (typeof this._customActions.doubleClicked === "function") {
      const executeDefault = this._customActions.doubleClicked(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._mouseWheelDeltaY = 0;
  fn2._pmouseWheelDeltaY = 0;
  fn2._onwheel = function(e2) {
    this._mouseWheelDeltaY = e2.deltaY;
    if (typeof this._customActions.mouseWheel === "function") {
      e2.delta = e2.deltaY;
      const executeDefault = this._customActions.mouseWheel(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2.requestPointerLock = function() {
    const canvas2 = this._curElement.elt;
    canvas2.requestPointerLock = canvas2.requestPointerLock || canvas2.mozRequestPointerLock;
    if (!canvas2.requestPointerLock) {
      console.log("requestPointerLock is not implemented in this browser");
      return false;
    }
    canvas2.requestPointerLock();
    return true;
  };
  fn2.exitPointerLock = function() {
    document.exitPointerLock();
  };
}
if (typeof p5 !== "undefined") {
  pointer(p5, p5.prototype);
}
function events(p53) {
  p53.registerAddon(acceleration);
  p53.registerAddon(keyboard);
  p53.registerAddon(pointer);
}
function image(p53) {
  p53.registerAddon(image$1);
  p53.registerAddon(loadingDisplaying);
  p53.registerAddon(image$2);
  p53.registerAddon(pixels);
  p53.registerAddon(shader);
  p53.registerAddon(texture);
}
class Table {
  constructor(rows) {
    this.columns = [];
    this.rows = [];
  }
  toString(separator = ",") {
    let rows = this.rows.map((row) => row.arr);
    if (!this.columns.some((column) => column === null)) {
      rows = [this.columns, ...rows];
    }
    return stringify(rows, {
      separator
    });
  }
  /**
   *  Use <a href="/reference/p5.Table/addRow/">addRow()</a> to add a new row of data to a <a href="#/p5.Table">p5.Table</a> object. By default,
   *  an empty row is created. Typically, you would store a reference to
   *  the new row in a TableRow object (see newRow in the example above),
   *  and then set individual values using <a href="#/p5/set">set()</a>.
   *
   *  If a <a href="#/p5.TableRow">p5.TableRow</a> object is included as a parameter, then that row is
   *  duplicated and added to the table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param   {p5.TableRow} [row] row to be added to the table
   *  @return  {p5.TableRow} the row that was added
   *
   * @example
   * <div>
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // Create a 300x300 canvas
   *   createCanvas(300, 300);
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add a new row for "Wolf"
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Canis Lupus');
   *     newRow.setString('name', 'Wolf');
   *
   *   // Set text properties
   *   fill(0);       // Text color: black
   *    textSize(12);  // Adjust text size as needed
   *
   *   // Display the table data on the canvas
   *   // Each cell is positioned based on its row and column
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       let x = c * 50 + 10;  // Horizontal spacing for each column
   *       let y = r * 30 + 20;  // Vertical spacing for each row
   *       text(table.getString(r, c), x * c, y);
   *     }
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  addRow(row) {
    const r = row || new p5.TableRow();
    if (typeof r.arr === "undefined" || typeof r.obj === "undefined") {
      throw new Error(`invalid TableRow: ${r}`);
    }
    r.table = this;
    this.rows.push(r);
    return r;
  }
  /**
   * Removes a row from the table object.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param   {Integer} id ID number of the row to remove
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *    table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Remove the first row from the table
   *   table.removeRow(0);
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the table values on the canvas:
   *   // Each row's cell values are joined into a single string and drawn on a new line.
   *   let y = 20; // Starting vertical position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 18, y * 3);
   *     y += 20;
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  removeRow(id) {
    this.rows[id].table = null;
    const chunk = this.rows.splice(id + 1, this.rows.length);
    this.rows.pop();
    this.rows = this.rows.concat(chunk);
  }
  /**
   * Returns a reference to the specified <a href="#/p5.TableRow">p5.TableRow</a>. The reference
   * can then be used to get and set values of the selected row.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {Integer}   rowID ID number of the row to get
   * @return {p5.TableRow} <a href="#/p5.TableRow">p5.TableRow</a> object
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Get the row at index 1 (second row)
   *   let row = table.getRow(1);
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set the text size
   *
   *   // Loop over each column in the row and display its value on the canvas
   *   for (let c = 0; c < table.getColumnCount(); c++) {
   *     text(row.getString(c), 10, 20 + c * 50 + 20);
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getRow(r) {
    return this.rows[r];
  }
  /**
   *  Gets all rows from the table. Returns an array of <a href="#/p5.TableRow">p5.TableRow</a>s.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {p5.TableRow[]}   Array of <a href="#/p5.TableRow">p5.TableRow</a>s
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   let rows = table.getRows();
   *
   *   // Warning: rows is an array of objects.
   *   // Set the 'name' of each row to 'Unicorn'
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].set('name', 'Unicorn');
   *   }
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the modified table values on the canvas
   *   // We'll join each row's values with a space and display each row on a new line.
   *   let y = 20; // Starting y position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 10, y * 2);
   *     y += 20; // Move to next line
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getRows() {
    return this.rows;
  }
  /**
   *  Finds the first row in the Table that contains the value
   *  provided, and returns a reference to that row. Even if
   *  multiple rows are possible matches, only the first matching
   *  row is returned. The column to search may be specified by
   *  either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} value  The value to match
   *  @param  {Integer|String} column ID number or title of the
   *                                 column to search
   *  @return {p5.TableRow}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *    // Find the row with the animal named "Zebra"
   *   let row = table.findRow('Zebra', 'name');
   *
   *   // Get the species from the found row
   *   let species = row.getString('species');
   *
   *   // Set text properties and display the species on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *   text(species, 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  findRow(value, column) {
    if (typeof column === "string") {
      for (let i = 0; i < this.rows.length; i++) {
        if (this.rows[i].obj[this.columns.indexOf(column)] === value) {
          return this.rows[i];
        }
      }
    } else {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        if (this.rows[j2].arr[column] === value) {
          return this.rows[j2];
        }
      }
    }
    return null;
  }
  /**
   *  Finds the rows in the Table that contain the value
   *  provided, and returns references to those rows. Returns an
   *  Array, so for must be used to iterate through all the rows,
   *  as shown in the example above. The column to search may be
   *  specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} value  The value to match
   *  @param  {Integer|String} column ID number or title of the
   *                                 column to search
   *  @return {p5.TableRow[]}        An Array of TableRow objects
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add another goat entry
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Scape Goat');
   *   newRow.setString('name', 'Goat');
   *
   *   // Find rows where the name is "Goat"
   *   let rows = table.findRows('Goat', 'name');
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the result on the canvas
   *   text(rows.length + ' Goats found', 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  findRows(value, column) {
    const ret = [];
    if (typeof column === "string") {
      for (let i = 0; i < this.rows.length; i++) {
        if (this.rows[i].obj[this.columns.indexOf(column)] === value) {
          ret.push(this.rows[i]);
        }
      }
    } else {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        if (this.rows[j2].arr[column] === value) {
          ret.push(this.rows[j2]);
        }
      }
    }
    return ret;
  }
  /**
   * Finds the first row in the Table that matches the regular
   * expression provided, and returns a reference to that row.
   * Even if multiple rows are possible matches, only the first
   * matching row is returned. The column to search may be
   * specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {String|RegExp} regexp The regular expression to match
   * @param  {String|Integer} column The column ID (number) or
   *                                  title (string)
   * @return {p5.TableRow}        TableRow object
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Search using the specified regex on column index 1 (species)
   *   let mammal = table.matchRow(new RegExp('ant'), 1);
   *   let species = mammal.getString(1);  // "Panthera pardus"
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);       // Text color: black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display the species on the canvas
   *   text(species, 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  matchRow(regexp, column) {
    if (typeof column === "number") {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        if (this.rows[j2].arr[column].match(regexp)) {
          return this.rows[j2];
        }
      }
    } else {
      for (let i = 0; i < this.rows.length; i++) {
        if (this.rows[i].obj[this.columns.indexOf(column)].match(regexp)) {
          return this.rows[i];
        }
      }
    }
    return null;
  }
  /**
   * Finds the rows in the Table that match the regular expression provided,
   * and returns references to those rows. Returns an array, so for must be
   * used to iterate through all the rows, as shown in the example. The
   * column to search may be specified by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {String} regexp The regular expression to match
   * @param  {String|Integer} [column] The column ID (number) or
   *                                  title (string)
   * @return {p5.TableRow[]}          An Array of TableRow objects
   * @example
   * <div>
   * <code>
   * let table;
   *
   * function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Create a new p5.Table and add columns
   *   table = new p5.Table();
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   // Add rows to the table
   *    let newRow = table.addRow();
   *   newRow.setString('name', 'Lion');
   *    newRow.setString('type', 'Mammal');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', 'Snake');
   *   newRow.setString('type', 'Reptile');
   *
   *    newRow = table.addRow();
   *   newRow.setString('name', 'Mosquito');
   *   newRow.setString('type', 'Insect');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', 'Lizard');
   *   newRow.setString('type', 'Reptile');
   *
   *   // Search for rows where the "type" starts with "R"
   *   let rows = table.matchRows('R.*', 'type');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);       // Text color: black
   *   textSize(12);  // Text size
   *
   *   // Display each matching row on the canvas
   *   let y = 20;
   *   for (let i = 0; i < rows.length; i++) {
   *     let output = rows[i].getString('name') + ': ' + rows[i].getString('type');
   *     text(output, 10, y);
   *     y += 20;
   *   }
   * }
   * </code>
   * </div>
   */
  matchRows(regexp, column) {
    const ret = [];
    if (typeof column === "number") {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        if (this.rows[j2].arr[column].match(regexp)) {
          ret.push(this.rows[j2]);
        }
      }
    } else {
      for (let i = 0; i < this.rows.length; i++) {
        if (this.rows[i].obj[this.columns.indexOf(column)].match(regexp)) {
          ret.push(this.rows[i]);
        }
      }
    }
    return ret;
  }
  /**
   *  Retrieves all values in the specified column, and returns them
   *  as an array. The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Number} column String or Number of the column to return
   *  @return {Array}       Array of column values
   *
   * @example
   * <div class="norender">
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // The table is comma separated value "csv"
   *   // and has a header specifying the columns labels.
   *   table = await loadTable('assets/mammals.csv', 'csv', 'header');
   *
   *   //getColumn returns an array that can be printed directly
   *   print(table.getColumn('species'));
   *   //outputs ["Capra hircus", "Panthera pardus", "Equus zebra"]
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getColumn(value) {
    const ret = [];
    if (typeof value === "string") {
      for (let i = 0; i < this.rows.length; i++) {
        ret.push(this.rows[i].obj[this.columns.indexOf(value)]);
      }
    } else {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        ret.push(this.rows[j2].arr[value]);
      }
    }
    return ret;
  }
  /**
   *  Removes all rows from a Table. While all rows are removed,
   *  columns and column titles are maintained.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *
   * @example
   * <div>
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Clear all rows from the table
   *   table.clearRows();
   *
   *   // Set text properties
   *   fill(0);       // Text color: black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display the number of rows and columns on the canvas
   *   text(table.getRowCount() + ' total rows in table', 10, 30);
   *   text(table.getColumnCount() + ' total columns in table', 10, 60);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  clearRows() {
    delete this.rows;
    this.rows = [];
  }
  /**
   *  Use <a href="/reference/p5.Table/addColumn/">addColumn()</a> to add a new column to a <a href="#/p5.Table">Table</a> object.
   *  Typically, you will want to specify a title, so the column
   *  may be easily referenced later by name. (If no title is
   *  specified, the new column's title will be null.)
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String} [title] title of the given column
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   createCanvas(300, 300);
   *   table = await loadTable('/assets/mammals.csv', ',', 'header');
   *
   *   table.addColumn('carnivore');
   *   table.set(0, 'carnivore', 'no');
   *   table.set(1, 'carnivore', 'yes');
   *   table.set(2, 'carnivore', 'no');
   *
   *   fill(0);      // Set text color to black
   *   textSize(11); // Adjust text size as needed
   *
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       // Keep column spacing consistent (e.g. 80 pixels apart).
   *       let x = c * 80 + 10;
   *       let y = r * 30 + 20;
   *       // Use x directly, rather than multiplying by c again
   *       text(table.getString(r, c), x, y);
   *     }
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  addColumn(title) {
    const t = title || null;
    this.columns.push(t);
  }
  /**
   *  Returns the total number of columns in a Table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {Integer} Number of columns in this table
   * @example
   * <div>
   * <code>
   * // given the cvs file "blobs.csv" in /assets directory
   * // ID, Name, Flavor, Shape, Color
   * // Blob1, Blobby, Sweet, Blob, Pink
   * // Blob2, Saddy, Savory, Blob, Blue
   *
   * let table;
   *
   * async function setup() {
   *   table = await loadTable('assets/blobs.csv');
   *
   *   createCanvas(200, 100);
   *   textAlign(CENTER);
   *   background(255);
   * }
   *
   * function draw() {
   *   let numOfColumn = table.getColumnCount();
   *   text('There are ' + numOfColumn + ' columns in the table.', 100, 50);
   * }
   * </code>
   * </div>
   */
  getColumnCount() {
    return this.columns.length;
  }
  /**
   *  Returns the total number of rows in a Table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {Integer} Number of rows in this table
   * @example
   * <div>
   * <code>
   * // given the cvs file "blobs.csv" in /assets directory
   * //
   * // ID, Name, Flavor, Shape, Color
   * // Blob1, Blobby, Sweet, Blob, Pink
   * // Blob2, Saddy, Savory, Blob, Blue
   *
   * let table;
   *
   * async function setup() {
   *   table = await loadTable('assets/blobs.csv');
   *
   *   createCanvas(200, 100);
   *   textAlign(CENTER);
   *   background(255);
   * }
   *
   * function draw() {
   *   text('There are ' + table.getRowCount() + ' rows in the table.', 100, 50);
   * }
   * </code>
   * </div>
   */
  getRowCount() {
    return this.rows.length;
  }
  /**
   *  Removes any of the specified characters (or "tokens").
   *
   *  If no column is specified, then the values in all columns and
   *  rows are processed. A specific column may be referenced by
   *  either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} chars  String listing characters to be removed
   *  @param  {String|Integer} [column] Column ID (number)
   *                                   or name (string)
   *
   * @example
   * <div class="norender"><code>
   * function setup() {
   *   let table = new p5.Table();
   *
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   let newRow = table.addRow();
   *   newRow.setString('name', '   $Lion  ,');
   *   newRow.setString('type', ',,,Mammal');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', '$Snake  ');
   *   newRow.setString('type', ',,,Reptile');
   *
   *   table.removeTokens(',$ ');
   *   print(table.getArray());
   * }
   *
   * // prints:
   * //  0  "Lion"   "Mamal"
   * //  1  "Snake"  "Reptile"
   * </code></div>
   */
  removeTokens(chars, column) {
    const escape2 = (s) => s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    const charArray = [];
    for (let i = 0; i < chars.length; i++) {
      charArray.push(escape2(chars.charAt(i)));
    }
    const regex = new RegExp(charArray.join("|"), "g");
    if (typeof column === "undefined") {
      for (let c = 0; c < this.columns.length; c++) {
        for (let d2 = 0; d2 < this.rows.length; d2++) {
          let s = this.rows[d2].arr[c];
          s = s.replace(regex, "");
          this.rows[d2].arr[c] = s;
          this.rows[d2].obj[this.columns[c]] = s;
        }
      }
    } else if (typeof column === "string") {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        let val = this.rows[j2].obj[column];
        val = val.replace(regex, "");
        this.rows[j2].obj[column] = val;
        const pos = this.columns.indexOf(column);
        this.rows[j2].arr[pos] = val;
      }
    } else {
      for (let k = 0; k < this.rows.length; k++) {
        let str = this.rows[k].arr[column];
        str = str.replace(regex, "");
        this.rows[k].arr[column] = str;
        this.rows[k].obj[this.columns[column]] = str;
      }
    }
  }
  /**
   *  Trims leading and trailing whitespace, such as spaces and tabs,
   *  from String table values. If no column is specified, then the
   *  values in all columns and rows are trimmed. A specific column
   *  may be referenced by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} [column] Column ID (number)
   *                                   or name (string)
   * @example
   * <div class="norender"><code>
   * function setup() {
   *   let table = new p5.Table();
   *
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   let newRow = table.addRow();
   *   newRow.setString('name', '   Lion  ,');
   *   newRow.setString('type', ' Mammal  ');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', '  Snake  ');
   *   newRow.setString('type', '  Reptile  ');
   *
   *   table.trim();
   *   print(table.getArray());
   * }
   *
   * // prints:
   * //  0  "Lion"   "Mamal"
   * //  1  "Snake"  "Reptile"
   * </code></div>
   */
  trim(column) {
    const regex = new RegExp(" ", "g");
    if (typeof column === "undefined") {
      for (let c = 0; c < this.columns.length; c++) {
        for (let d2 = 0; d2 < this.rows.length; d2++) {
          let s = this.rows[d2].arr[c];
          s = s.replace(regex, "");
          this.rows[d2].arr[c] = s;
          this.rows[d2].obj[this.columns[c]] = s;
        }
      }
    } else if (typeof column === "string") {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        let val = this.rows[j2].obj[column];
        val = val.replace(regex, "");
        this.rows[j2].obj[column] = val;
        const pos = this.columns.indexOf(column);
        this.rows[j2].arr[pos] = val;
      }
    } else {
      for (let k = 0; k < this.rows.length; k++) {
        let str = this.rows[k].arr[column];
        str = str.replace(regex, "");
        this.rows[k].arr[column] = str;
        this.rows[k].obj[this.columns[column]] = str;
      }
    }
  }
  /**
   *  Use <a href="/reference/p5.Table/removeColumn/">removeColumn()</a> to remove an existing column from a Table
   *  object. The column to be removed may be identified by either
   *  its title (a String) or its index value (an int).
   *  removeColumn(0) would remove the first column, removeColumn(1)
   *  would remove the second column, and so on.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or ID (number)
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *    // Remove the "id" column
   *    table.removeColumn('id');
   *
   *   // Get the remaining column count
   *   let colCount = table.getColumnCount();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the column count on the canvas
   *   text(colCount, 40, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  removeColumn(c) {
    let cString;
    let cNumber;
    if (typeof c === "string") {
      cString = c;
      cNumber = this.columns.indexOf(c);
    } else {
      cNumber = c;
      cString = this.columns[c];
    }
    const chunk = this.columns.splice(cNumber + 1, this.columns.length);
    this.columns.pop();
    this.columns = this.columns.concat(chunk);
    for (let i = 0; i < this.rows.length; i++) {
      const tempR = this.rows[i].arr;
      const chip = tempR.splice(cNumber + 1, tempR.length);
      tempR.pop();
      this.rows[i].arr = tempR.concat(chip);
      delete this.rows[i].obj[cString];
    }
  }
  /**
   * Stores a value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {String|Number} value  value to assign
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update the first row: change species to "Canis Lupus" and name to "Wolf"
   *   table.set(0, 'species', 'Canis Lupus');
   *   table.set(0, 'name', 'Wolf');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Text color: black
   *    textSize(12); // Adjust text size as needed
   *
   *   // Display the table values on the canvas:
   *   // Each row's values are concatenated into a single string and displayed on a new line.
   *   let y = 20; // Starting vertical position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 10, y * 2.5);
   *     y += 20;
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  set(row, column, value) {
    this.rows[row].set(column, value);
  }
  /**
   * Stores a Float value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {Number} value  value to assign
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas and set a white background
   *   createCanvas(100, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set the value in row 1, column "id" to the number 1
   *   table.setNum(1, 'id', 1);
   *
   *   // Get the first column as an array and join its values into a string for display.
   *   let col0 = table.getColumn(0);  // Expected output: ["0", 1, "2"]
   *   let output = col0.join(", ");
   *
   *   // Set text properties and display the output on the canvas
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *   text(output, 30, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  setNum(row, column, value) {
    this.rows[row].setNum(column, value);
  }
  /**
   * Stores a String value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {String} value  value to assign
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add a new row with the new animal data
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Canis Lupus');
   *   newRow.setString('name', 'Wolf');
   *
   *   // Convert the table to a 2D array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);       // Set text color to black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;  // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     // Join the values of each row with a comma separator
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 15, y * 2);
   *     y += 20;  // Increment y position for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  setString(row, column, value) {
    this.rows[row].setString(column, value);
  }
  /**
   * Retrieves a value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {String|Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Get the values from the table
   *   let value1 = table.get(0, 1);       // Using column index (1) => "Capra hircus"
   *   let value2 = table.get(0, 'species'); // Using column name => "Capra hircus"
   *
   *   // Display the values on the canvas
   *   text(value1, 10, 30);
   *   text(value2, 10, 60);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  get(row, column) {
    if (typeof column === "string") {
      return this.rows[row].get(this.columns.indexOf(column));
    } else {
      return this.rows[row].get(column);
    }
  }
  /**
   * Retrieves a Float value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Compute the result: id at row 1, column 0 plus 100 (i.e. 1 + 100 = 101)
   *   let result = table.getNum(1, 0) + 100;
   *
   *   // Set text properties and display the result on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *   text(result, 10, 30);  // Display the result at position (10, 30)
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getNum(row, column) {
    return this.rows[row].getNum(column);
  }
  /**
   * Retrieves a String value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {String}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each table cell value on the canvas one below the other.
   *   // We use a variable 'y' to increment the vertical position.
   *   let y = 20;
   *   text(table.getString(0, 0), 10, y); // 0
   *   y += 20;
   *   text(table.getString(0, 1), 10, y); // Capra hircus
   *   y += 20;
   *   text(table.getString(0, 2), 10, y); // Goat
   *   y += 20;
   *   text(table.getString(1, 0), 10, y); // 1
   *   y += 20;
   *   text(table.getString(1, 1), 10, y); // Panthera pardus
   *   y += 20;
   *   text(table.getString(1, 2), 10, y); // Leopard
   *   y += 20;
   *   text(table.getString(2, 0), 10, y); // 2
   *   y += 20;
   *   text(table.getString(2, 1), 10, y); // Equus zebra
   *   y += 20;
   *   text(table.getString(2, 2), 10, y); // Zebra
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getString(row, column) {
    return this.rows[row].getString(column);
  }
  /**
   * Retrieves all table data and returns as an object. If a column name is
   * passed in, each row object will be stored with that attribute as its
   * title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {String} [headerColumn] Name of the column which should be used to
   *                              title each row object (optional)
   * @return {Object}
   *
   * @example
   * <div class="norender">
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // The table is comma separated value "csv"
   *   // and has a header specifying the columns labels.
   *   table = await loadTable('assets/mammals.csv', 'csv', 'header');
   *
   *   let tableObject = table.getObject();
   *
   *   print(tableObject);
   *   //outputs an object
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getObject(headerColumn) {
    const tableObject = {};
    let obj, cPos, index;
    for (let i = 0; i < this.rows.length; i++) {
      obj = this.rows[i].obj;
      if (typeof headerColumn === "string") {
        cPos = this.columns.indexOf(headerColumn);
        if (cPos >= 0) {
          index = obj[headerColumn];
          tableObject[index] = obj;
        } else {
          throw new Error(`This table has no column named "${headerColumn}"`);
        }
      } else {
        tableObject[i] = this.rows[i].obj;
      }
    }
    return tableObject;
  }
  /**
   * Retrieves all table data and returns it as a multidimensional array.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @return {Array}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Get the CSV data as a 2D array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the CSV on the canvas
   *   // Each row is displayed on a separate line
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(", ");
   *     text(rowText, 10, 20 + i * 50 + 30);
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getArray() {
    const tableArray = [];
    for (let i = 0; i < this.rows.length; i++) {
      tableArray.push(this.rows[i].arr);
    }
    return tableArray;
  }
}
function table(p53, fn2) {
  p53.Table = Table;
}
if (typeof p5 !== "undefined") {
  table(p5, p5.prototype);
}
class TableRow {
  constructor(row = []) {
    let arr2 = row;
    this.arr = arr2;
    this.obj = Object.fromEntries(arr2.entries());
    this.table = null;
  }
  /**
   *  Stores a value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {String|Number} value  The value to be stored
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set every row's "name" to "Unicorn"
   *    let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].set('name', 'Unicorn');
   *   }
   *
   *   // Convert the table to an array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *
   *   // Display each row of the table on the canvas
   *   let y = 20; // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20; // Increment y position for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  set(column, value) {
    if (typeof column === "string") {
      const cPos = this.table.columns.indexOf(column);
      if (cPos >= 0) {
        this.obj[column] = value;
        this.arr[cPos] = value;
      } else {
        throw new Error(`This table has no column named "${column}"`);
      }
    } else {
      if (column < this.table.columns.length) {
        this.arr[column] = value;
        const cTitle = this.table.columns[column];
        this.obj[cTitle] = value;
      } else {
        throw new Error(`Column #${column} is out of the range of this table`);
      }
    }
  }
  /**
   *  Stores a Float value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {Number|String} value  The value to be stored
   *                                as a Float
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update each row's "id" to (row index + 10)
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].setNum('id', r + 10);
   *   }
   *
   *   // Convert the table to a 2D array for display
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;   // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     // Join each row's values with a comma separator
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20;  // Increment y for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  setNum(column, value) {
    const floatVal = parseFloat(value);
    this.set(column, floatVal);
  }
  /**
   *  Stores a String value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {String|Number|Boolean|Object} value  The value to be stored
   *                                as a String
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 300x200 canvas and set a white background
   *   createCanvas(300, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update each row's "name" field
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     let name = rows[r].getString('name');
   *     rows[r].setString('name', 'A ' + name + ' named George');
   *   }
   *
   *   // Convert the table to a 2D array for display
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;   // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20;    // Increment y for the next row
   *   }
   *
   *   // describe('no image displayed');
   * }
   * </code>
   */
  setString(column, value) {
    const stringVal = value.toString();
    this.set(column, stringVal);
  }
  /**
   *  Retrieves a value from the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   *  @return {String|Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x100 canvas and set a white background
   *   createCanvas(200, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *    table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Extract the names from each row and store them in an array
   *   let names = [];
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     names.push(rows[r].get('name'));
   *   }
   *
   *   // Set text properties and display the names on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *
   *   // Join names into a single string separated by commas
   *   let namesText = names.join(', ');
   *   text(namesText, 35, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  get(column) {
    if (typeof column === "string") {
      return this.obj[this.table.columns.indexOf(column)];
    } else {
      return this.arr[column];
    }
  }
  /**
   *  Retrieves a Float value from the TableRow's specified
   *  column. The column may be specified by either its ID or
   *  title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   *  @return {Number}  Float Floating point number
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 300x100 canvas and set a white background
   *   createCanvas(300, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   let rows = table.getRows();
   *   let minId = Infinity;
   *   let maxId = -Infinity;
   *
   *   for (let r = 0; r < rows.length; r++) {
   *     let id = rows[r].getNum('id');
   *     minId = min(minId, id);
   *     maxId = max(maxId, id);
   *    }
   *
   *   let result = 'minimum id = ' + minId + ', maximum id = ' + maxId;
   *
   *   // Set text properties and display the result on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *   text(result, 10, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getNum(column) {
    let ret;
    if (typeof column === "string") {
      ret = parseFloat(this.obj[this.table.columns.indexOf(column)]);
    } else {
      ret = parseFloat(this.arr[column]);
    }
    if (ret.toString() === "NaN") {
      throw `Error: ${this.obj[column]} is NaN (Not a Number)`;
    }
    return ret;
  }
  /**
   *  Retrieves an String value from the TableRow's specified
   *  column. The column may be specified by either its ID or
   *  title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *
   *  @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   *  @return {String}  String
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x100 canvas and set a white background
   *   createCanvas(200, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   let rows = table.getRows();
   *   let longest = '';
   *   for (let r = 0; r < rows.length; r++) {
   *      let species = rows[r].getString('species');
   *      if (longest.length < species.length) {
   *       longest = species;
   *     }
   *   }
   *
   *   let result = 'longest: ' + longest;
   *
   *   // Set text properties and display the result on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *   text(result, 30, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getString(column) {
    if (typeof column === "string") {
      return this.obj[this.table.columns.indexOf(column)].toString();
    } else {
      return this.arr[column].toString();
    }
  }
}
function tableRow(p53, fn2) {
  p53.TableRow = TableRow;
}
if (typeof p5 !== "undefined") {
  tableRow(p5, p5.prototype);
}
function io(p53) {
  p53.registerAddon(files);
  p53.registerAddon(table);
  p53.registerAddon(tableRow);
  p53.registerAddon(xml);
}
function calculation(p53, fn2) {
  fn2.abs = Math.abs;
  fn2.ceil = Math.ceil;
  fn2.constrain = function(n2, low, high) {
    return Math.max(Math.min(n2, high), low);
  };
  fn2.dist = function(...args) {
    if (args.length === 4) {
      return Math.hypot(args[2] - args[0], args[3] - args[1]);
    } else if (args.length === 6) {
      return Math.hypot(
        args[3] - args[0],
        args[4] - args[1],
        args[5] - args[2]
      );
    }
  };
  fn2.exp = Math.exp;
  fn2.floor = Math.floor;
  fn2.lerp = function(start2, stop, amt) {
    return amt * (stop - start2) + start2;
  };
  fn2.log = Math.log;
  fn2.mag = function(x, y) {
    return Math.hypot(x, y);
  };
  fn2.map = function(n2, start1, stop1, start2, stop2, withinBounds) {
    const newval = (n2 - start1) / (stop1 - start1) * (stop2 - start2) + start2;
    if (!withinBounds) {
      return newval;
    }
    if (start2 < stop2) {
      return this.constrain(newval, start2, stop2);
    } else {
      return this.constrain(newval, stop2, start2);
    }
  };
  fn2.max = function(...args) {
    const findMax = (arr2) => {
      let max = -Infinity;
      for (let x of arr2) {
        max = Math.max(max, x);
      }
      return max;
    };
    if (args[0] instanceof Array) {
      return findMax(args[0]);
    } else {
      return findMax(args);
    }
  };
  fn2.min = function(...args) {
    const findMin = (arr2) => {
      let min = Infinity;
      for (let x of arr2) {
        min = Math.min(min, x);
      }
      return min;
    };
    if (args[0] instanceof Array) {
      return findMin(args[0]);
    } else {
      return findMin(args);
    }
  };
  fn2.norm = function(n2, start2, stop) {
    return this.map(n2, start2, stop, 0, 1);
  };
  fn2.pow = Math.pow;
  fn2.round = function(n2, decimals) {
    if (!decimals) {
      return Math.round(n2);
    }
    const multiplier = Math.pow(10, decimals);
    return Math.round(n2 * multiplier) / multiplier;
  };
  fn2.sq = (n2) => n2 * n2;
  fn2.sqrt = Math.sqrt;
  fn2.fract = function(toConvert) {
    let sign = 0;
    let num = Number(toConvert);
    if (isNaN(num) || Math.abs(num) === Infinity) {
      return num;
    } else if (num < 0) {
      num = -num;
      sign = 1;
    }
    if (String(num).includes(".") && !String(num).includes("e")) {
      let toFract = String(num);
      toFract = Number("0" + toFract.slice(toFract.indexOf(".")));
      return Math.abs(sign - toFract);
    } else if (num < 1) {
      return Math.abs(sign - num);
    } else {
      return 0;
    }
  };
}
if (typeof p5 !== "undefined") {
  calculation(p5, p5.prototype);
}
function noise(p53, fn2) {
  const PERLIN_YWRAPB = 4;
  const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
  const PERLIN_ZWRAPB = 8;
  const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
  const PERLIN_SIZE = 4095;
  let perlin_octaves = 4;
  let perlin_amp_falloff = 0.5;
  const scaled_cosine = (i) => 0.5 * (1 - Math.cos(i * Math.PI));
  let perlin;
  fn2.noise = function(x, y = 0, z = 0) {
    if (perlin == null) {
      perlin = new Array(PERLIN_SIZE + 1);
      for (let i = 0; i < PERLIN_SIZE + 1; i++) {
        perlin[i] = Math.random();
      }
    }
    if (x < 0) {
      x = -x;
    }
    if (y < 0) {
      y = -y;
    }
    if (z < 0) {
      z = -z;
    }
    let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
    let xf = x - xi;
    let yf = y - yi;
    let zf = z - zi;
    let rxf, ryf;
    let r = 0;
    let ampl = 0.5;
    let n1, n2, n3;
    for (let o = 0; o < perlin_octaves; o++) {
      let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
      rxf = scaled_cosine(xf);
      ryf = scaled_cosine(yf);
      n1 = perlin[of & PERLIN_SIZE];
      n1 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n1);
      n2 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n2 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);
      n1 += ryf * (n2 - n1);
      of += PERLIN_ZWRAP;
      n2 = perlin[of & PERLIN_SIZE];
      n2 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n2);
      n3 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n3 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);
      n2 += ryf * (n3 - n2);
      n1 += scaled_cosine(zf) * (n2 - n1);
      r += n1 * ampl;
      ampl *= perlin_amp_falloff;
      xi <<= 1;
      xf *= 2;
      yi <<= 1;
      yf *= 2;
      zi <<= 1;
      zf *= 2;
      if (xf >= 1) {
        xi++;
        xf--;
      }
      if (yf >= 1) {
        yi++;
        yf--;
      }
      if (zf >= 1) {
        zi++;
        zf--;
      }
    }
    return r;
  };
  fn2.noiseDetail = function(lod, falloff) {
    if (lod > 0) {
      perlin_octaves = lod;
    }
    if (falloff > 0) {
      perlin_amp_falloff = falloff;
    }
  };
  fn2._getNoiseOctaves = function() {
    return perlin_octaves;
  };
  fn2._getNoiseAmpFalloff = function() {
    return perlin_amp_falloff;
  };
  fn2.noiseSeed = function(seed) {
    const lcg = /* @__PURE__ */ (() => {
      const m = 4294967296;
      const a = 1664525;
      const c = 1013904223;
      let seed2, z;
      return {
        setSeed(val) {
          z = seed2 = (val == null ? Math.random() * m : val) >>> 0;
        },
        getSeed() {
          return seed2;
        },
        rand() {
          z = (a * z + c) % m;
          return z / m;
        }
      };
    })();
    lcg.setSeed(seed);
    perlin = new Array(PERLIN_SIZE + 1);
    for (let i = 0; i < PERLIN_SIZE + 1; i++) {
      perlin[i] = lcg.rand();
    }
  };
}
if (typeof p5 !== "undefined") {
  noise(p5, p5.prototype);
}
function random(p53, fn2) {
  const randomStateProp = "_lcg_random_state";
  const m = 4294967296;
  const a = 1664525;
  const c = 1013904223;
  let y2 = 0;
  fn2._lcg = function(stateProperty) {
    this[stateProperty] = (a * this[stateProperty] + c) % m;
    return this[stateProperty] / m;
  };
  fn2._lcgSetSeed = function(stateProperty, val) {
    this[stateProperty] = (val == null ? Math.random() * m : val) >>> 0;
  };
  fn2.randomSeed = function(seed) {
    this._lcgSetSeed(randomStateProp, seed);
    this._gaussian_previous = false;
  };
  fn2.random = function(min, max) {
    let rand;
    if (this[randomStateProp] != null) {
      rand = this._lcg(randomStateProp);
    } else {
      rand = Math.random();
    }
    if (typeof min === "undefined") {
      return rand;
    } else if (typeof max === "undefined") {
      if (min instanceof Array) {
        return min[Math.floor(rand * min.length)];
      } else {
        return rand * min;
      }
    } else {
      if (min > max) {
        const tmp = min;
        min = max;
        max = tmp;
      }
      return rand * (max - min) + min;
    }
  };
  fn2.randomGaussian = function(mean, sd = 1) {
    let y1, x1, x2, w;
    if (this._gaussian_previous) {
      y1 = y2;
      this._gaussian_previous = false;
    } else {
      do {
        x1 = this.random(2) - 1;
        x2 = this.random(2) - 1;
        w = x1 * x1 + x2 * x2;
      } while (w >= 1);
      w = Math.sqrt(-2 * Math.log(w) / w);
      y1 = x1 * w;
      y2 = x2 * w;
      this._gaussian_previous = true;
    }
    const m3 = mean || 0;
    return y1 * sd + m3;
  };
}
if (typeof p5 !== "undefined") {
  random(p5, p5.prototype);
}
function math$1(p53, fn2) {
  fn2.createVector = function(x, y, z) {
    if (arguments.length === 0) {
      p53._friendlyError(
        "In 1.x, createVector() was a shortcut for createVector(0, 0, 0). In 2.x, p5.js has vectors of any dimension, so you must provide your desired number of zeros. Use createVector(0, 0) for a 2D vector and createVector(0, 0, 0) for a 3D vector."
      );
    }
    if (this instanceof p53) {
      return new p53.Vector(
        this._fromRadians.bind(this),
        this._toRadians.bind(this),
        ...arguments
      );
    } else {
      return new p53.Vector(x, y, z);
    }
  };
  fn2.createMatrix = function(...args) {
    return new p53.Matrix(...args);
  };
}
if (typeof p5 !== "undefined") {
  math$1(p5, p5.prototype);
}
function math(p53) {
  p53.registerAddon(calculation);
  p53.registerAddon(noise);
  p53.registerAddon(random);
  p53.registerAddon(trigonometry);
  p53.registerAddon(math$1);
  p53.registerAddon(vector);
}
function conversion(p53, fn2) {
  fn2.float = function(str) {
    if (str instanceof Array) {
      return str.map(parseFloat);
    }
    return parseFloat(str);
  };
  fn2.int = function(n2, radix = 10) {
    if (n2 === Infinity || n2 === "Infinity") {
      return Infinity;
    } else if (n2 === -Infinity || n2 === "-Infinity") {
      return -Infinity;
    } else if (typeof n2 === "string") {
      return parseInt(n2, radix);
    } else if (typeof n2 === "number") {
      return n2 | 0;
    } else if (typeof n2 === "boolean") {
      return n2 ? 1 : 0;
    } else if (n2 instanceof Array) {
      return n2.map((n3) => fn2.int(n3, radix));
    }
  };
  fn2.str = function(n2) {
    if (n2 instanceof Array) {
      return n2.map(fn2.str);
    } else {
      return String(n2);
    }
  };
  fn2.boolean = function(n2) {
    if (typeof n2 === "number") {
      return n2 !== 0;
    } else if (typeof n2 === "string") {
      return n2.toLowerCase() === "true";
    } else if (typeof n2 === "boolean") {
      return n2;
    } else if (n2 instanceof Array) {
      return n2.map(fn2.boolean);
    }
  };
  fn2.byte = function(n2) {
    const nn = fn2.int(n2, 10);
    if (typeof nn === "number") {
      return (nn + 128) % 256 - 128;
    } else if (nn instanceof Array) {
      return nn.map(fn2.byte);
    }
  };
  fn2.char = function(n2) {
    if (typeof n2 === "number" && !isNaN(n2)) {
      return String.fromCharCode(n2);
    } else if (n2 instanceof Array) {
      return n2.map(fn2.char);
    } else if (typeof n2 === "string") {
      return fn2.char(parseInt(n2, 10));
    }
  };
  fn2.unchar = function(n2) {
    if (typeof n2 === "string" && n2.length === 1) {
      return n2.charCodeAt(0);
    } else if (n2 instanceof Array) {
      return n2.map(fn2.unchar);
    }
  };
  fn2.hex = function(n2, digits) {
    digits = digits === void 0 || digits === null ? digits = 8 : digits;
    if (n2 instanceof Array) {
      return n2.map((n3) => fn2.hex(n3, digits));
    } else if (n2 === Infinity || n2 === -Infinity) {
      const c = n2 === Infinity ? "F" : "0";
      return c.repeat(digits);
    } else if (typeof n2 === "number") {
      if (n2 < 0) {
        n2 = 4294967295 + n2 + 1;
      }
      let hex = Number(n2).toString(16).toUpperCase();
      while (hex.length < digits) {
        hex = `0${hex}`;
      }
      if (hex.length >= digits) {
        hex = hex.substring(hex.length - digits, hex.length);
      }
      return hex;
    }
  };
  fn2.unhex = function(n2) {
    if (n2 instanceof Array) {
      return n2.map(fn2.unhex);
    } else {
      return parseInt(`0x${n2}`, 16);
    }
  };
}
if (typeof p5 !== "undefined") {
  conversion(p5, p5.prototype);
}
function utilityFunctions(p53, fn2) {
  fn2.nf = function(nums, left, right) {
    if (nums instanceof Array) {
      return nums.map((x) => doNf(x, left, right));
    } else {
      const typeOfFirst = Object.prototype.toString.call(nums);
      if (typeOfFirst === "[object Arguments]") {
        if (nums.length === 3) {
          return this.nf(nums[0], nums[1], nums[2]);
        } else if (nums.length === 2) {
          return this.nf(nums[0], nums[1]);
        } else {
          return this.nf(nums[0]);
        }
      } else {
        return doNf(nums, left, right);
      }
    }
  };
  function doNf(num, left, right) {
    let isNegative = num < 0;
    num = Math.abs(num);
    let [leftPart, rightPart] = num.toString().split(".");
    if (typeof right === "undefined") {
      leftPart = leftPart.padStart(left, "0");
      let result = rightPart ? leftPart + "." + rightPart : leftPart;
      return isNegative ? "-" + result : result;
    } else {
      let roundedOff = num.toFixed(right);
      [leftPart, rightPart] = roundedOff.toString().split(".");
      leftPart = leftPart.padStart(left, "0");
      let result = typeof rightPart === "undefined" ? leftPart : leftPart + "." + rightPart;
      return isNegative ? "-" + result : result;
    }
  }
  fn2.nfc = function(num, right) {
    if (num instanceof Array) {
      return num.map((x) => doNfc(x, right));
    } else {
      return doNfc(num, right);
    }
  };
  function doNfc(num, right) {
    num = num.toString();
    const dec = num.indexOf(".");
    let rem = dec !== -1 ? num.substring(dec) : "";
    let n2 = dec !== -1 ? num.substring(0, dec) : num;
    n2 = n2.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    if (right === 0) {
      rem = "";
    } else if (typeof right !== "undefined") {
      if (right > rem.length) {
        rem += dec === -1 ? "." : "";
        const len = right - rem.length + 1;
        for (let i = 0; i < len; i++) {
          rem += "0";
        }
      } else {
        rem = rem.substring(0, right + 1);
      }
    }
    return n2 + rem;
  }
  fn2.nfp = function(...args) {
    const nfRes = fn2.nf.apply(this, args);
    if (nfRes instanceof Array) {
      return nfRes.map(addNfp);
    } else {
      return addNfp(nfRes);
    }
  };
  function addNfp(num) {
    return parseFloat(num) > 0 ? `+${num.toString()}` : num.toString();
  }
  fn2.nfs = function(...args) {
    const nfRes = fn2.nf.apply(this, args);
    if (nfRes instanceof Array) {
      return nfRes.map(addNfs);
    } else {
      return addNfs(nfRes);
    }
  };
  function addNfs(num) {
    return parseFloat(num) >= 0 ? ` ${num.toString()}` : num.toString();
  }
  fn2.splitTokens = function(value, delims) {
    let d2;
    if (typeof delims !== "undefined") {
      let str = delims;
      const sqc = /\]/g.exec(str);
      let sqo = /\[/g.exec(str);
      if (sqo && sqc) {
        str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
        sqo = /\[/g.exec(str);
        str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
        d2 = new RegExp(`[\\[${str}\\]]`, "g");
      } else if (sqc) {
        str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
        d2 = new RegExp(`[${str}\\]]`, "g");
      } else if (sqo) {
        str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
        d2 = new RegExp(`[${str}\\[]`, "g");
      } else {
        d2 = new RegExp(`[${str}]`, "g");
      }
    } else {
      d2 = /\s/g;
    }
    return value.split(d2).filter((n2) => n2);
  };
  fn2.shuffle = function(arr2, modify) {
    const isView = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(arr2);
    arr2 = modify || isView ? arr2 : arr2.slice();
    let rnd, tmp, idx = arr2.length;
    while (idx > 1) {
      rnd = this.random(0, 1) * idx | 0;
      tmp = arr2[--idx];
      arr2[idx] = arr2[rnd];
      arr2[rnd] = tmp;
    }
    return arr2;
  };
}
if (typeof p5 !== "undefined") {
  utilityFunctions(p5, p5.prototype);
}
function timeDate(p53, fn2) {
  fn2.day = function() {
    return (/* @__PURE__ */ new Date()).getDate();
  };
  fn2.hour = function() {
    return (/* @__PURE__ */ new Date()).getHours();
  };
  fn2.minute = function() {
    return (/* @__PURE__ */ new Date()).getMinutes();
  };
  fn2.millis = function() {
    if (this._millisStart === -1) {
      return 0;
    } else {
      return window.performance.now() - this._millisStart;
    }
  };
  fn2.month = function() {
    return (/* @__PURE__ */ new Date()).getMonth() + 1;
  };
  fn2.second = function() {
    return (/* @__PURE__ */ new Date()).getSeconds();
  };
  fn2.year = function() {
    return (/* @__PURE__ */ new Date()).getFullYear();
  };
}
if (typeof p5 !== "undefined") {
  timeDate(p5, p5.prototype);
}
function utilities(p53) {
  p53.registerAddon(conversion);
  p53.registerAddon(utilityFunctions);
  p53.registerAddon(timeDate);
}
function interaction(p53, fn2) {
  fn2.orbitControl = function(sensitivityX, sensitivityY, sensitivityZ, options2) {
    this._assert3d("orbitControl");
    const cam = this._renderer.states.curCamera;
    if (typeof sensitivityX === "undefined") {
      sensitivityX = 1;
    }
    if (typeof sensitivityY === "undefined") {
      sensitivityY = sensitivityX;
    }
    if (typeof sensitivityZ === "undefined") {
      sensitivityZ = 1;
    }
    if (typeof options2 !== "object") {
      options2 = {};
    }
    if (this.contextMenuDisabled !== true) {
      this.canvas.oncontextmenu = () => false;
      this.contextMenuDisabled = true;
    }
    if (this.wheelDefaultDisabled !== true) {
      this.canvas.onwheel = () => false;
      this.wheelDefaultDisabled = true;
    }
    const { disableTouchActions = true } = options2;
    if (this.touchActionsDisabled !== true && disableTouchActions) {
      this.canvas.style["touch-action"] = "none";
      this.touchActionsDisabled = true;
    }
    const { freeRotation = false } = options2;
    const movedTouches = [];
    this.touches.forEach((curTouch) => {
      this._renderer.prevTouches.forEach((prevTouch) => {
        if (curTouch.id === prevTouch.id) {
          const movedTouch = {
            x: curTouch.x,
            y: curTouch.y,
            px: prevTouch.x,
            py: prevTouch.y
          };
          movedTouches.push(movedTouch);
        }
      });
    });
    this._renderer.prevTouches = this.touches;
    let deltaRadius = 0;
    let deltaTheta = 0;
    let deltaPhi = 0;
    let moveDeltaX = 0;
    let moveDeltaY = 0;
    const damping = 0.85;
    const rotateAccelerationFactor = 0.6;
    const moveAccelerationFactor = 0.15;
    const mouseZoomScaleFactor = 0.01;
    const touchZoomScaleFactor = 4e-4;
    const scaleFactor = this.height < this.width ? this.height : this.width;
    let pointersInCanvas = false;
    if (movedTouches.length > 0) {
      pointersInCanvas = movedTouches[0].x > 0 && movedTouches[0].x < this.width && movedTouches[0].y > 0 && movedTouches[0].y < this.height;
      if (movedTouches.length === 1) {
        const t = movedTouches[0];
        deltaTheta = -sensitivityX * (t.x - t.px) / scaleFactor;
        deltaPhi = sensitivityY * (t.y - t.py) / scaleFactor;
      } else {
        const t0 = movedTouches[0];
        const t1 = movedTouches[1];
        const distWithTouches = Math.hypot(t0.x - t1.x, t0.y - t1.y);
        const prevDistWithTouches = Math.hypot(t0.px - t1.px, t0.py - t1.py);
        const changeDist = distWithTouches - prevDistWithTouches;
        deltaRadius = -changeDist * sensitivityZ * touchZoomScaleFactor;
        moveDeltaX = 0.5 * (t0.x + t1.x) - 0.5 * (t0.px + t1.px);
        moveDeltaY = 0.5 * (t0.y + t1.y) - 0.5 * (t0.py + t1.py);
      }
      if (this.touches.length > 0) {
        if (pointersInCanvas) {
          this._renderer.executeRotateAndMove = true;
          this._renderer.executeZoom = true;
        }
      } else {
        this._renderer.executeRotateAndMove = false;
        this._renderer.executeZoom = false;
      }
    } else {
      pointersInCanvas = this.mouseX > 0 && this.mouseX < this.width && (this.mouseY > 0 && this.mouseY < this.height);
      if (this._mouseWheelDeltaY !== 0) {
        deltaRadius = Math.sign(this._mouseWheelDeltaY) * sensitivityZ;
        deltaRadius *= mouseZoomScaleFactor;
        this._mouseWheelDeltaY = 0;
        if (pointersInCanvas) this._renderer.executeZoom = true;
      } else {
        this._renderer.executeZoom = false;
      }
      if (this.mouseIsPressed) {
        if (this.mouseButton.left) {
          deltaTheta = -sensitivityX * this.movedX / scaleFactor;
          deltaPhi = sensitivityY * this.movedY / scaleFactor;
        } else if (this.mouseButton.right) {
          moveDeltaX = this.movedX;
          moveDeltaY = this.movedY * cam.yScale;
        }
        if (pointersInCanvas) this._renderer.executeRotateAndMove = true;
      } else {
        this._renderer.executeRotateAndMove = false;
      }
    }
    if (deltaRadius !== 0 && this._renderer.executeZoom) {
      this._renderer.zoomVelocity += deltaRadius;
    }
    if (Math.abs(this._renderer.zoomVelocity) > 1e-3) {
      if (freeRotation) {
        cam._orbitFree(
          0,
          0,
          this._renderer.zoomVelocity
        );
      } else {
        cam._orbit(
          0,
          0,
          this._renderer.zoomVelocity
        );
      }
      if (cam.projMatrix.mat4[15] !== 0) {
        cam.projMatrix.mat4[0] *= Math.pow(
          10,
          -this._renderer.zoomVelocity
        );
        cam.projMatrix.mat4[5] *= Math.pow(
          10,
          -this._renderer.zoomVelocity
        );
        this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
        this._renderer.states.uPMatrix.mat4[0] = cam.projMatrix.mat4[0];
        this._renderer.states.uPMatrix.mat4[5] = cam.projMatrix.mat4[5];
      }
      this._renderer.zoomVelocity *= damping;
    } else {
      this._renderer.zoomVelocity = 0;
    }
    if ((deltaTheta !== 0 || deltaPhi !== 0) && this._renderer.executeRotateAndMove) {
      this._renderer.rotateVelocity.add(
        deltaTheta * rotateAccelerationFactor,
        deltaPhi * rotateAccelerationFactor
      );
    }
    if (this._renderer.rotateVelocity.magSq() > 1e-6) {
      if (freeRotation) {
        cam._orbitFree(
          -this._renderer.rotateVelocity.x,
          this._renderer.rotateVelocity.y,
          0
        );
      } else {
        cam._orbit(
          this._renderer.rotateVelocity.x,
          this._renderer.rotateVelocity.y,
          0
        );
      }
      this._renderer.rotateVelocity.mult(damping);
    } else {
      this._renderer.rotateVelocity.set(0, 0);
    }
    if ((moveDeltaX !== 0 || moveDeltaY !== 0) && this._renderer.executeRotateAndMove) {
      const ndcX = moveDeltaX * 2 / this.width;
      const ndcY = -moveDeltaY * 2 / this.height;
      this._renderer.moveVelocity.add(
        ndcX * moveAccelerationFactor,
        ndcY * moveAccelerationFactor
      );
    }
    if (this._renderer.moveVelocity.magSq() > 1e-6) {
      const local = cam._getLocalAxes();
      const diffX = cam.eyeX - cam.centerX;
      const diffY = cam.eyeY - cam.centerY;
      const diffZ = cam.eyeZ - cam.centerZ;
      const viewZ = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);
      let cv = new Vector(cam.centerX, cam.centerY, cam.centerZ);
      cv = cam.cameraMatrix.multiplyPoint(cv);
      cv = this._renderer.states.uPMatrix.multiplyAndNormalizePoint(cv);
      cv.x -= this._renderer.moveVelocity.x;
      cv.y -= this._renderer.moveVelocity.y;
      let dx, dy;
      const uP = this._renderer.states.uPMatrix.mat4;
      if (uP[15] === 0) {
        dx = (uP[8] + cv.x) / uP[0] * viewZ;
        dy = (uP[9] + cv.y) / uP[5] * viewZ;
      } else {
        dx = (cv.x - uP[12]) / uP[0];
        dy = (cv.y - uP[13]) / uP[5];
      }
      cam.setPosition(
        cam.eyeX + dx * local.x[0] + dy * local.y[0],
        cam.eyeY + dx * local.x[1] + dy * local.y[1],
        cam.eyeZ + dx * local.x[2] + dy * local.y[2]
      );
      this._renderer.moveVelocity.mult(damping);
    } else {
      this._renderer.moveVelocity.set(0, 0);
    }
    return this;
  };
  fn2.debugMode = function(...args) {
    this._assert3d("debugMode");
    for (let i = p53.lifecycleHooks.postdraw.length - 1; i >= 0; i--) {
      if (p53.lifecycleHooks.postdraw[i].toString() === this._grid().toString() || p53.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()) {
        p53.lifecycleHooks.postdraw.splice(i, 1);
      }
    }
    if (args[0] === GRID) {
      p53.lifecycleHooks.postdraw.push(
        this._grid(args[1], args[2], args[3], args[4], args[5])
      );
    } else if (args[0] === AXES) {
      p53.lifecycleHooks.postdraw.push(
        this._axesIcon(args[1], args[2], args[3], args[4])
      );
    } else {
      p53.lifecycleHooks.postdraw.push(
        this._grid(args[0], args[1], args[2], args[3], args[4])
      );
      p53.lifecycleHooks.postdraw.push(
        this._axesIcon(args[5], args[6], args[7], args[8])
      );
    }
  };
  fn2.noDebugMode = function() {
    this._assert3d("noDebugMode");
    for (let i = p53.lifecycleHooks.postdraw.length - 1; i >= 0; i--) {
      if (p53.lifecycleHooks.postdraw[i].toString() === this._grid().toString() || p53.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()) {
        p53.lifecycleHooks.postdraw.splice(i, 1);
      }
    }
  };
  fn2._grid = function(size, numDivs, xOff, yOff, zOff) {
    if (typeof size === "undefined") {
      size = this.width / 2;
    }
    if (typeof numDivs === "undefined") {
      numDivs = Math.round(size / 30) < 4 ? 4 : Math.round(size / 30);
    }
    if (typeof xOff === "undefined") {
      xOff = 0;
    }
    if (typeof yOff === "undefined") {
      yOff = 0;
    }
    if (typeof zOff === "undefined") {
      zOff = 0;
    }
    const spacing = size / numDivs;
    const halfSize = size / 2;
    return function() {
      this.push();
      this.stroke(
        this._renderer.states.curStrokeColor[0] * 255,
        this._renderer.states.curStrokeColor[1] * 255,
        this._renderer.states.curStrokeColor[2] * 255
      );
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      for (let q = 0; q <= numDivs; q++) {
        this.beginShape(this.LINES);
        this.vertex(-halfSize + xOff, yOff, q * spacing - halfSize + zOff);
        this.vertex(+halfSize + xOff, yOff, q * spacing - halfSize + zOff);
        this.endShape();
      }
      for (let i = 0; i <= numDivs; i++) {
        this.beginShape(this.LINES);
        this.vertex(i * spacing - halfSize + xOff, yOff, -halfSize + zOff);
        this.vertex(i * spacing - halfSize + xOff, yOff, +halfSize + zOff);
        this.endShape();
      }
      this.pop();
    };
  };
  fn2._axesIcon = function(size, xOff, yOff, zOff) {
    if (typeof size === "undefined") {
      size = this.width / 20 > 40 ? this.width / 20 : 40;
    }
    if (typeof xOff === "undefined") {
      xOff = -this.width / 4;
    }
    if (typeof yOff === "undefined") {
      yOff = xOff;
    }
    if (typeof zOff === "undefined") {
      zOff = xOff;
    }
    return () => {
      this.push();
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      this.strokeWeight(2);
      this.stroke(255, 0, 0);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff + size, yOff, zOff);
      this.endShape();
      this.stroke(0, 255, 0);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff, yOff + size, zOff);
      this.endShape();
      this.stroke(0, 0, 255);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff, yOff, zOff + size);
      this.endShape();
      this.pop();
    };
  };
}
if (typeof p5 !== "undefined") {
  interaction(p5, p5.prototype);
}
async function fileExists(url) {
  try {
    const response = await fetch(url, { method: "HEAD" });
    return response.ok;
  } catch (error2) {
    return false;
  }
}
function loading$1(p53, fn2) {
  fn2.loadModel = async function(path2, fileType, normalize, successCallback, failureCallback) {
    let flipU = false;
    let flipV = false;
    if (typeof fileType === "object") {
      normalize = fileType.normalize || false;
      successCallback = fileType.successCallback;
      failureCallback = fileType.failureCallback;
      fileType = fileType.fileType || fileType;
      flipU = fileType.flipU || false;
      flipV = fileType.flipV || false;
    } else {
      if (typeof arguments[arguments.length - 1] === "function") {
        if (typeof arguments[arguments.length - 2] === "function") {
          successCallback = arguments[arguments.length - 2];
          failureCallback = arguments[arguments.length - 1];
        } else {
          successCallback = arguments[arguments.length - 1];
        }
      }
      if (typeof fileType === "string") {
        if (typeof normalize !== "boolean") normalize = false;
      } else if (typeof fileType === "boolean") {
        normalize = fileType;
        fileType = path2.slice(-4);
      } else {
        fileType = path2.slice(-4);
        normalize = false;
      }
    }
    if (fileType.toLowerCase() !== ".obj" && fileType.toLowerCase() !== ".stl") {
      fileType = ".obj";
    }
    const model = new Geometry(void 0, void 0, void 0, this._renderer);
    model.gid = `${path2}|${normalize}`;
    async function getMaterials(lines) {
      const parsedMaterialPromises = [];
      for (let line of lines) {
        const mtllibMatch = line.match(/^mtllib (.+)/);
        if (mtllibMatch) {
          let mtlPath = "";
          const mtlFilename = mtllibMatch[1];
          const objPathParts = path2.split("/");
          if (objPathParts.length > 1) {
            objPathParts.pop();
            const objFolderPath = objPathParts.join("/");
            mtlPath = objFolderPath + "/" + mtlFilename;
          } else {
            mtlPath = mtlFilename;
          }
          parsedMaterialPromises.push(
            fileExists(mtlPath).then((exists) => {
              if (exists) {
                return parseMtl(mtlPath);
              } else {
                console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);
                return {};
              }
            }).catch((error2) => {
              console.warn(`Error loading MTL file: ${mtlPath}`, error2);
              return {};
            })
          );
        }
      }
      try {
        const parsedMaterials = await Promise.all(parsedMaterialPromises);
        const materials = Object.assign({}, ...parsedMaterials);
        return materials;
      } catch (error2) {
        return {};
      }
    }
    try {
      if (fileType.match(/\.stl$/i)) {
        const { data: data2 } = await request(path2, "arrayBuffer");
        parseSTL(model, data2);
        if (normalize) {
          model.normalize();
        }
        if (flipU) {
          model.flipU();
        }
        if (flipV) {
          model.flipV();
        }
        model._makeTriangleEdges();
        if (successCallback) {
          return successCallback(model);
        } else {
          return model;
        }
      } else if (fileType.match(/\.obj$/i)) {
        const { data: data2 } = await request(path2, "text");
        const lines = data2.split("\n");
        const parsedMaterials = await getMaterials(lines);
        parseObj(model, lines, parsedMaterials);
        if (normalize) {
          model.normalize();
        }
        if (flipU) {
          model.flipU();
        }
        if (flipV) {
          model.flipV();
        }
        model._makeTriangleEdges();
        if (successCallback) {
          return successCallback(model);
        } else {
          return model;
        }
      }
    } catch (err) {
      p53._friendlyFileLoadError(3, path2);
      if (failureCallback) {
        return failureCallback(err);
      } else {
        throw err;
      }
    }
  };
  async function parseMtl(mtlPath) {
    let currentMaterial = null;
    let materials = {};
    const { data: data2 } = await request(mtlPath, "text");
    const lines = data2.split("\n");
    for (let line = 0; line < lines.length; ++line) {
      const tokens = lines[line].trim().split(/\s+/);
      if (tokens[0] === "newmtl") {
        const materialName = tokens[1];
        currentMaterial = materialName;
        materials[currentMaterial] = {};
      } else if (tokens[0] === "Kd") {
        materials[currentMaterial].diffuseColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "Ka") {
        materials[currentMaterial].ambientColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "Ks") {
        materials[currentMaterial].specularColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "map_Kd") {
        materials[currentMaterial].texturePath = tokens[1];
      }
    }
    return materials;
  }
  function parseObj(model, lines, materials = {}) {
    const loadedVerts = {
      v: [],
      vt: [],
      vn: []
    };
    const usedVerts = {};
    let currentMaterial = null;
    let hasColoredVertices = false;
    let hasColorlessVertices = false;
    for (let line = 0; line < lines.length; ++line) {
      const tokens = lines[line].trim().split(/\b\s+/);
      if (tokens.length > 0) {
        if (tokens[0] === "usemtl") {
          currentMaterial = tokens[1];
        } else if (tokens[0] === "v" || tokens[0] === "vn") {
          const vertex2 = new Vector(
            parseFloat(tokens[1]),
            parseFloat(tokens[2]),
            parseFloat(tokens[3])
          );
          loadedVerts[tokens[0]].push(vertex2);
        } else if (tokens[0] === "vt") {
          const texVertex = [parseFloat(tokens[1]), 1 - parseFloat(tokens[2])];
          loadedVerts[tokens[0]].push(texVertex);
        } else if (tokens[0] === "f") {
          for (let tri = 3; tri < tokens.length; ++tri) {
            const face = [];
            const vertexTokens = [1, tri - 1, tri];
            for (let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd) {
              const vertString = tokens[vertexTokens[tokenInd]];
              let vertParts = vertString.split("/");
              for (let i = 0; i < vertParts.length; i++) {
                vertParts[i] = parseInt(vertParts[i]) - 1;
              }
              if (!usedVerts[vertString]) {
                usedVerts[vertString] = {};
              }
              if (usedVerts[vertString][currentMaterial] === void 0) {
                const vertIndex = model.vertices.length;
                model.vertices.push(loadedVerts.v[vertParts[0]].copy());
                model.uvs.push(loadedVerts.vt[vertParts[1]] ? loadedVerts.vt[vertParts[1]].slice() : [0, 0]);
                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ? loadedVerts.vn[vertParts[2]].copy() : new Vector());
                usedVerts[vertString][currentMaterial] = vertIndex;
                face.push(vertIndex);
                if (currentMaterial && materials[currentMaterial] && materials[currentMaterial].diffuseColor) {
                  hasColoredVertices = true;
                  const materialDiffuseColor = materials[currentMaterial].diffuseColor;
                  model.vertexColors.push(materialDiffuseColor[0]);
                  model.vertexColors.push(materialDiffuseColor[1]);
                  model.vertexColors.push(materialDiffuseColor[2]);
                  model.vertexColors.push(1);
                } else {
                  hasColorlessVertices = true;
                }
              } else {
                face.push(usedVerts[vertString][currentMaterial]);
              }
            }
            if (face[0] !== face[1] && face[0] !== face[2] && face[1] !== face[2]) {
              model.faces.push(face);
            }
          }
        }
      }
    }
    if (model.vertexNormals.length === 0) {
      model.computeNormals();
    }
    if (hasColoredVertices === hasColorlessVertices) {
      throw new Error("Model coloring is inconsistent. Either all vertices should have colors or none should.");
    }
    return model;
  }
  function parseSTL(model, buffer) {
    if (isBinary(buffer)) {
      parseBinarySTL(model, buffer);
    } else {
      const reader = new DataView(buffer);
      if (!("TextDecoder" in window)) {
        console.warn(
          "Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)"
        );
        return model;
      }
      const decoder = new TextDecoder("utf-8");
      const lines = decoder.decode(reader);
      const lineArray = lines.split("\n");
      parseASCIISTL(model, lineArray);
    }
    return model;
  }
  function isBinary(data2) {
    const reader = new DataView(data2);
    const solid = [115, 111, 108, 105, 100];
    for (let off = 0; off < 5; off++) {
      if (matchDataViewAt(solid, reader, off)) return false;
    }
    return true;
  }
  function matchDataViewAt(query, reader, offset2) {
    for (let i = 0, il = query.length; i < il; i++) {
      if (query[i] !== reader.getUint8(offset2 + i, false)) return false;
    }
    return true;
  }
  function parseBinarySTL(model, buffer) {
    const reader = new DataView(buffer);
    const faces = reader.getUint32(80, true);
    let r, g2, b2, hasColors = false, colors;
    let defaultR, defaultG, defaultB;
    for (let index = 0; index < 80 - 10; index++) {
      if (reader.getUint32(index, false) === 1129270351 && reader.getUint8(index + 4) === 82 && reader.getUint8(index + 5) === 61) {
        hasColors = true;
        colors = [];
        defaultR = reader.getUint8(index + 6) / 255;
        defaultG = reader.getUint8(index + 7) / 255;
        defaultB = reader.getUint8(index + 8) / 255;
      }
    }
    const dataOffset = 84;
    const faceLength = 12 * 4 + 2;
    for (let face = 0; face < faces; face++) {
      const start2 = dataOffset + face * faceLength;
      const normalX = reader.getFloat32(start2, true);
      const normalY = reader.getFloat32(start2 + 4, true);
      const normalZ = reader.getFloat32(start2 + 8, true);
      if (hasColors) {
        const packedColor = reader.getUint16(start2 + 48, true);
        if ((packedColor & 32768) === 0) {
          r = (packedColor & 31) / 31;
          g2 = (packedColor >> 5 & 31) / 31;
          b2 = (packedColor >> 10 & 31) / 31;
        } else {
          r = defaultR;
          g2 = defaultG;
          b2 = defaultB;
        }
      }
      const newNormal = new Vector(normalX, normalY, normalZ);
      for (let i = 1; i <= 3; i++) {
        const vertexstart = start2 + i * 12;
        const newVertex = new Vector(
          reader.getFloat32(vertexstart, true),
          reader.getFloat32(vertexstart + 4, true),
          reader.getFloat32(vertexstart + 8, true)
        );
        model.vertices.push(newVertex);
        model.vertexNormals.push(newNormal);
        if (hasColors) {
          colors.push(r, g2, b2);
        }
      }
      model.faces.push([3 * face, 3 * face + 1, 3 * face + 2]);
      model.uvs.push([0, 0], [0, 0], [0, 0]);
    }
    return model;
  }
  function parseASCIISTL(model, lines) {
    let state = "";
    let curVertexIndex = [];
    let newNormal, newVertex;
    for (let iterator = 0; iterator < lines.length; ++iterator) {
      const line = lines[iterator].trim();
      const parts = line.split(" ");
      for (let partsiterator = 0; partsiterator < parts.length; ++partsiterator) {
        if (parts[partsiterator] === "") {
          parts.splice(partsiterator, 1);
        }
      }
      if (parts.length === 0) {
        continue;
      }
      switch (state) {
        case "":
          if (parts[0] !== "solid") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "solid"`);
            return;
          } else {
            state = "solid";
          }
          break;
        case "solid":
          if (parts[0] !== "facet" || parts[1] !== "normal") {
            console.error(line);
            console.error(
              `Invalid state "${parts[0]}", should be "facet normal"`
            );
            return;
          } else {
            newNormal = new Vector(
              parseFloat(parts[2]),
              parseFloat(parts[3]),
              parseFloat(parts[4])
            );
            model.vertexNormals.push(newNormal, newNormal, newNormal);
            state = "facet normal";
          }
          break;
        case "facet normal":
          if (parts[0] !== "outer" || parts[1] !== "loop") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "outer loop"`);
            return;
          } else {
            state = "vertex";
          }
          break;
        case "vertex":
          if (parts[0] === "vertex") {
            newVertex = new Vector(
              parseFloat(parts[1]),
              parseFloat(parts[2]),
              parseFloat(parts[3])
            );
            model.vertices.push(newVertex);
            model.uvs.push([0, 0]);
            curVertexIndex.push(model.vertices.indexOf(newVertex));
          } else if (parts[0] === "endloop") {
            model.faces.push(curVertexIndex);
            curVertexIndex = [];
            state = "endloop";
          } else {
            console.error(line);
            console.error(
              `Invalid state "${parts[0]}", should be "vertex" or "endloop"`
            );
            return;
          }
          break;
        case "endloop":
          if (parts[0] !== "endfacet") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "endfacet"`);
            return;
          } else {
            state = "endfacet";
          }
          break;
        case "endfacet":
          if (parts[0] === "endsolid") ;
          else if (parts[0] === "facet" && parts[1] === "normal") {
            newNormal = new Vector(
              parseFloat(parts[2]),
              parseFloat(parts[3]),
              parseFloat(parts[4])
            );
            model.vertexNormals.push(newNormal, newNormal, newNormal);
            state = "facet normal";
          } else {
            console.error(line);
            console.error(
              `Invalid state "${parts[0]}", should be "endsolid" or "facet normal"`
            );
            return;
          }
          break;
        default:
          console.error(`Invalid state "${state}"`);
          break;
      }
    }
    return model;
  }
  fn2.model = function(model, count = 1) {
    this._assert3d("model");
    this._renderer.model(model, count);
  };
  let modelCounter = 0;
  fn2.createModel = function(modelString, fileType = " ", options2) {
    let normalize = false;
    let successCallback;
    let failureCallback;
    let flipU = false;
    let flipV = false;
    if (options2 && typeof options2 === "object") {
      normalize = options2.normalize || false;
      successCallback = options2.successCallback;
      failureCallback = options2.failureCallback;
      flipU = options2.flipU || false;
      flipV = options2.flipV || false;
    } else if (typeof options2 === "boolean") {
      normalize = options2;
      successCallback = arguments[3];
      failureCallback = arguments[4];
    } else {
      successCallback = typeof arguments[2] === "function" ? arguments[2] : void 0;
      failureCallback = arguments[3];
    }
    const model = new p53.Geometry();
    model.gid = `${fileType}|${normalize}|${modelCounter++}`;
    if (fileType.match(/\.stl$/i)) {
      try {
        let uint8array = new TextEncoder().encode(modelString);
        let arrayBuffer = uint8array.buffer;
        parseSTL(model, arrayBuffer);
      } catch (error2) {
        if (failureCallback) {
          failureCallback(error2);
        } else {
          p53._friendlyError("Error during parsing: " + error2.message);
        }
        return;
      }
    } else if (fileType.match(/\.obj$/i)) {
      try {
        const lines = modelString.split("\n");
        parseObj(model, lines);
      } catch (error2) {
        if (failureCallback) {
          failureCallback(error2);
        } else {
          p53._friendlyError("Error during parsing: " + error2.message);
        }
        return;
      }
    } else {
      p53._friendlyFileLoadError(3, modelString);
      if (failureCallback) {
        failureCallback();
      } else {
        p53._friendlyError(
          "Sorry, the file type is invalid. Only OBJ and STL files are supported."
        );
      }
    }
    if (normalize) {
      model.normalize();
    }
    if (flipU) {
      model.flipU();
    }
    if (flipV) {
      model.flipV();
    }
    model._makeTriangleEdges();
    if (typeof successCallback === "function") {
      successCallback(model);
    }
    return model;
  };
}
if (typeof p5 !== "undefined") {
  loading$1(p5, p5.prototype);
}
var lib = {};
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  Object.defineProperty(lib, "__esModule", { value: true });
  var UnicodeRange = (
    /** @class */
    (function() {
      function UnicodeRange2() {
      }
      UnicodeRange2.parse = function(arr2) {
        var result = /* @__PURE__ */ new Set();
        for (var _i = 0, arr_1 = arr2; _i < arr_1.length; _i++) {
          var range2 = arr_1[_i];
          if (!UnicodeRange2.REGEXP.test(range2)) {
            throw new TypeError('"' + range2 + '" is invalid unicode-range.');
          }
          var _a = range2.match(UnicodeRange2.REGEXP), single = _a[1], start2 = _a[2], end = _a[3];
          if (single) {
            if (/\?[^?]+$/.test(single)) {
              throw new TypeError('"' + range2 + '" is invalid unicode-range.');
            }
            if (single.includes("?")) {
              var start_1 = single.replace(/\?/g, "0");
              var end_1 = single.replace(/\?/g, "F");
              var tmp = UnicodeRange2.parse(["U+" + start_1 + "-" + end_1]);
              for (var _b = 0, tmp_1 = tmp; _b < tmp_1.length; _b++) {
                var codePoint = tmp_1[_b];
                result.add(codePoint);
              }
            } else {
              result.add(parseInt(single, 16));
            }
          }
          if (start2 && end) {
            var startCodePoint = parseInt(start2, 16);
            var endCodePoint = parseInt(end, 16);
            for (var codePoint = startCodePoint; codePoint <= endCodePoint; codePoint++) {
              result.add(codePoint);
            }
          }
        }
        return Array.from(result).sort(function(a, b2) {
          return a - b2;
        });
      };
      UnicodeRange2.stringify = function(arr2) {
        var sorted = Array.from(new Set(arr2)).sort(function(a, b2) {
          return a - b2;
        });
        var results = [];
        var rangeStart;
        for (var idx = 0; idx < sorted.length; idx++) {
          var current2 = sorted[idx];
          var prev = sorted[idx - 1];
          if (rangeStart && current2 - prev !== 1) {
            results.push(UnicodeRange2.rangeString(rangeStart, prev));
            rangeStart = current2;
          }
          if (!rangeStart) {
            rangeStart = current2;
          }
          if (idx === sorted.length - 1) {
            if (rangeStart === current2) {
              results.push(UnicodeRange2.rangeString(current2));
            } else {
              results.push(UnicodeRange2.rangeString(rangeStart, current2));
            }
          }
        }
        return results;
      };
      UnicodeRange2.rangeString = function(start2, end) {
        if (!end || start2 === end) {
          return "U+" + start2.toString(16);
        }
        return "U+" + start2.toString(16) + "-" + end.toString(16);
      };
      UnicodeRange2.REGEXP = /^u\+(?:([0-9a-f]?[0-9a-f?]{1,5})|([0-9a-f]{1,6})-([0-9a-f]{1,6}))?$/i;
      return UnicodeRange2;
    })()
  );
  lib.UnicodeRange = UnicodeRange;
  return lib;
}
var libExports = requireLib();
const unicodeRanges = [
  {
    category: "control character",
    hexrange: ["0000", "001f"]
  },
  {
    category: "basic latin",
    hexrange: ["0000", "007f"]
  },
  {
    category: "latin-1 supplement",
    hexrange: ["0080", "00ff"]
  },
  {
    category: "latin extended-a",
    hexrange: ["0100", "017f"]
  },
  {
    category: "latin extended-b",
    hexrange: ["0180", "024f"]
  },
  {
    category: "ipa extensions",
    hexrange: ["0250", "02af"]
  },
  {
    category: "spacing modifier letters",
    hexrange: ["02b0", "02ff"]
  },
  {
    category: "combining diacritical marks",
    hexrange: ["0300", "036f"]
  },
  {
    category: "greek and coptic",
    hexrange: ["0370", "03ff"]
  },
  {
    category: "cyrillic",
    hexrange: ["0400", "04ff"]
  },
  {
    category: "cyrillic supplement",
    hexrange: ["0500", "052f"]
  },
  {
    category: "armenian",
    hexrange: ["0530", "058f"]
  },
  {
    category: "hebrew",
    hexrange: ["0590", "05ff"]
  },
  {
    category: "arabic",
    hexrange: ["0600", "06ff"]
  },
  {
    category: "syriac",
    hexrange: ["0700", "074f"]
  },
  {
    category: "arabic supplement",
    hexrange: ["0750", "077f"]
  },
  {
    category: "thaana",
    hexrange: ["0780", "07bf"]
  },
  {
    category: "nko",
    hexrange: ["07c0", "07ff"]
  },
  {
    category: "samaritan",
    hexrange: ["0800", "083f"]
  },
  {
    category: "mandaic",
    hexrange: ["0840", "085f"]
  },
  {
    category: "syriac supplement",
    hexrange: ["0860", "086f"]
  },
  {
    category: "arabic extended-b",
    hexrange: ["0870", "089f"]
  },
  {
    category: "arabic extended-a",
    hexrange: ["08a0", "08ff"]
  },
  {
    category: "devanagari",
    hexrange: ["0900", "097f"]
  },
  {
    category: "bengali",
    hexrange: ["0980", "09ff"]
  },
  {
    category: "gurmukhi",
    hexrange: ["0a00", "0a7f"]
  },
  {
    category: "gujarati",
    hexrange: ["0a80", "0aff"]
  },
  {
    category: "oriya",
    hexrange: ["0b00", "0b7f"]
  },
  {
    category: "tamil",
    hexrange: ["0b80", "0bff"]
  },
  {
    category: "telugu",
    hexrange: ["0c00", "0c7f"]
  },
  {
    category: "kannada",
    hexrange: ["0c80", "0cff"]
  },
  {
    category: "malayalam",
    hexrange: ["0d00", "0d7f"]
  },
  {
    category: "sinhala",
    hexrange: ["0d80", "0dff"]
  },
  {
    category: "thai",
    hexrange: ["0e00", "0e7f"]
  },
  {
    category: "lao",
    hexrange: ["0e80", "0eff"]
  },
  {
    category: "tibetan",
    hexrange: ["0f00", "0fff"]
  },
  {
    category: "myanmar",
    hexrange: ["1000", "109f"]
  },
  {
    category: "georgian",
    hexrange: ["10a0", "10ff"]
  },
  {
    category: "hangul jamo",
    hexrange: ["1100", "11ff"]
  },
  {
    category: "ethiopic",
    hexrange: ["1200", "137f"]
  },
  {
    category: "ethiopic supplement",
    hexrange: ["1380", "139f"]
  },
  {
    category: "cherokee",
    hexrange: ["13a0", "13ff"]
  },
  {
    category: "unified canadian aboriginal syllabics",
    hexrange: ["1400", "167f"]
  },
  {
    category: "ogham",
    hexrange: ["1680", "169f"]
  },
  {
    category: "runic",
    hexrange: ["16a0", "16ff"]
  },
  {
    category: "tagalog",
    hexrange: ["1700", "171f"]
  },
  {
    category: "hanunoo",
    hexrange: ["1720", "173f"]
  },
  {
    category: "buhid",
    hexrange: ["1740", "175f"]
  },
  {
    category: "tagbanwa",
    hexrange: ["1760", "177f"]
  },
  {
    category: "khmer",
    hexrange: ["1780", "17ff"]
  },
  {
    category: "mongolian",
    hexrange: ["1800", "18af"]
  },
  {
    category: "unified canadian aboriginal syllabics extended",
    hexrange: ["18b0", "18ff"]
  },
  {
    category: "limbu",
    hexrange: ["1900", "194f"]
  },
  {
    category: "tai le",
    hexrange: ["1950", "197f"]
  },
  {
    category: "new tai lue",
    hexrange: ["1980", "19df"]
  },
  {
    category: "khmer symbols",
    hexrange: ["19e0", "19ff"]
  },
  {
    category: "buginese",
    hexrange: ["1a00", "1a1f"]
  },
  {
    category: "tai tham",
    hexrange: ["1a20", "1aaf"]
  },
  {
    category: "combining diacritical marks extended",
    hexrange: ["1ab0", "1aff"]
  },
  {
    category: "balinese",
    hexrange: ["1b00", "1b7f"]
  },
  {
    category: "sundanese",
    hexrange: ["1b80", "1bbf"]
  },
  {
    category: "batak",
    hexrange: ["1bc0", "1bff"]
  },
  {
    category: "lepcha",
    hexrange: ["1c00", "1c4f"]
  },
  {
    category: "ol chiki",
    hexrange: ["1c50", "1c7f"]
  },
  {
    category: "cyrillic extended-c",
    hexrange: ["1c80", "1c8f"]
  },
  {
    category: "georgian extended",
    hexrange: ["1c90", "1cbf"]
  },
  {
    category: "sundanese supplement",
    hexrange: ["1cc0", "1ccf"]
  },
  {
    category: "vedic extensions",
    hexrange: ["1cd0", "1cff"]
  },
  {
    category: "phonetic extensions",
    hexrange: ["1d00", "1d7f"]
  },
  {
    category: "phonetic extensions supplement",
    hexrange: ["1d80", "1dbf"]
  },
  {
    category: "combining diacritical marks supplement",
    hexrange: ["1dc0", "1dff"]
  },
  {
    category: "latin extended additional",
    hexrange: ["1e00", "1eff"]
  },
  {
    category: "greek extended",
    hexrange: ["1f00", "1fff"]
  },
  {
    category: "general punctuation",
    hexrange: ["2000", "206f"]
  },
  {
    category: "superscripts and subscripts",
    hexrange: ["2070", "209f"]
  },
  {
    category: "currency symbols",
    hexrange: ["20a0", "20cf"]
  },
  {
    category: "combining diacritical marks for symbols",
    hexrange: ["20d0", "20ff"]
  },
  {
    category: "letterlike symbols",
    hexrange: ["2100", "214f"]
  },
  {
    category: "number forms",
    hexrange: ["2150", "218f"]
  },
  {
    category: "arrows",
    hexrange: ["2190", "21ff"]
  },
  {
    category: "mathematical operators",
    hexrange: ["2200", "22ff"]
  },
  {
    category: "miscellaneous technical",
    hexrange: ["2300", "23ff"]
  },
  {
    category: "control pictures",
    hexrange: ["2400", "243f"]
  },
  {
    category: "optical character recognition",
    hexrange: ["2440", "245f"]
  },
  {
    category: "enclosed alphanumerics",
    hexrange: ["2460", "24ff"]
  },
  {
    category: "box drawing",
    hexrange: ["2500", "257f"]
  },
  {
    category: "block elements",
    hexrange: ["2580", "259f"]
  },
  {
    category: "geometric shapes",
    hexrange: ["25a0", "25ff"]
  },
  {
    category: "miscellaneous symbols",
    hexrange: ["2600", "26ff"]
  },
  {
    category: "dingbats",
    hexrange: ["2700", "27bf"]
  },
  {
    category: "miscellaneous mathematical symbols-a",
    hexrange: ["27c0", "27ef"]
  },
  {
    category: "supplemental arrows-a",
    hexrange: ["27f0", "27ff"]
  },
  {
    category: "braille patterns",
    hexrange: ["2800", "28ff"]
  },
  {
    category: "supplemental arrows-b",
    hexrange: ["2900", "297f"]
  },
  {
    category: "miscellaneous mathematical symbols-b",
    hexrange: ["2980", "29ff"]
  },
  {
    category: "supplemental mathematical operators",
    hexrange: ["2a00", "2aff"]
  },
  {
    category: "miscellaneous symbols and arrows",
    hexrange: ["2b00", "2bff"]
  },
  {
    category: "glagolitic",
    hexrange: ["2c00", "2c5f"]
  },
  {
    category: "latin extended-c",
    hexrange: ["2c60", "2c7f"]
  },
  {
    category: "coptic",
    hexrange: ["2c80", "2cff"]
  },
  {
    category: "georgian supplement",
    hexrange: ["2d00", "2d2f"]
  },
  {
    category: "tifinagh",
    hexrange: ["2d30", "2d7f"]
  },
  {
    category: "ethiopic extended",
    hexrange: ["2d80", "2ddf"]
  },
  {
    category: "cyrillic extended-a",
    hexrange: ["2de0", "2dff"]
  },
  {
    category: "supplemental punctuation",
    hexrange: ["2e00", "2e7f"]
  },
  {
    category: "cjk radicals supplement",
    hexrange: ["2e80", "2eff"]
  },
  {
    category: "kangxi radicals",
    hexrange: ["2f00", "2fdf"]
  },
  {
    category: "ideographic description characters",
    hexrange: ["2ff0", "2fff"]
  },
  {
    category: "cjk symbols and punctuation",
    hexrange: ["3000", "303f"]
  },
  {
    category: "hiragana",
    hexrange: ["3040", "309f"]
  },
  {
    category: "katakana",
    hexrange: ["30a0", "30ff"]
  },
  {
    category: "bopomofo",
    hexrange: ["3100", "312f"]
  },
  {
    category: "hangul compatibility jamo",
    hexrange: ["3130", "318f"]
  },
  {
    category: "kanbun",
    hexrange: ["3190", "319f"]
  },
  {
    category: "bopomofo extended",
    hexrange: ["31a0", "31bf"]
  },
  {
    category: "cjk strokes",
    hexrange: ["31c0", "31ef"]
  },
  {
    category: "katakana phonetic extensions",
    hexrange: ["31f0", "31ff"]
  },
  {
    category: "enclosed cjk letters and months",
    hexrange: ["3200", "32ff"]
  },
  {
    category: "cjk compatibility",
    hexrange: ["3300", "33ff"]
  },
  {
    category: "cjk unified ideographs extension a",
    hexrange: ["3400", "4dbf"]
  },
  {
    category: "yijing hexagram symbols",
    hexrange: ["4dc0", "4dff"]
  },
  {
    category: "cjk unified ideographs",
    hexrange: ["4e00", "9fff"]
  },
  {
    category: "yi syllables",
    hexrange: ["a000", "a48f"]
  },
  {
    category: "yi radicals",
    hexrange: ["a490", "a4cf"]
  },
  {
    category: "lisu",
    hexrange: ["a4d0", "a4ff"]
  },
  {
    category: "vai",
    hexrange: ["a500", "a63f"]
  },
  {
    category: "cyrillic extended-b",
    hexrange: ["a640", "a69f"]
  },
  {
    category: "bamum",
    hexrange: ["a6a0", "a6ff"]
  },
  {
    category: "modifier tone letters",
    hexrange: ["a700", "a71f"]
  },
  {
    category: "latin extended-d",
    hexrange: ["a720", "a7ff"]
  },
  {
    category: "syloti nagri",
    hexrange: ["a800", "a82f"]
  },
  {
    category: "common indic number forms",
    hexrange: ["a830", "a83f"]
  },
  {
    category: "phags-pa",
    hexrange: ["a840", "a87f"]
  },
  {
    category: "saurashtra",
    hexrange: ["a880", "a8df"]
  },
  {
    category: "devanagari extended",
    hexrange: ["a8e0", "a8ff"]
  },
  {
    category: "kayah li",
    hexrange: ["a900", "a92f"]
  },
  {
    category: "rejang",
    hexrange: ["a930", "a95f"]
  },
  {
    category: "hangul jamo extended-a",
    hexrange: ["a960", "a97f"]
  },
  {
    category: "javanese",
    hexrange: ["a980", "a9df"]
  },
  {
    category: "myanmar extended-b",
    hexrange: ["a9e0", "a9ff"]
  },
  {
    category: "cham",
    hexrange: ["aa00", "aa5f"]
  },
  {
    category: "myanmar extended-a",
    hexrange: ["aa60", "aa7f"]
  },
  {
    category: "tai viet",
    hexrange: ["aa80", "aadf"]
  },
  {
    category: "meetei mayek extensions",
    hexrange: ["aae0", "aaff"]
  },
  {
    category: "ethiopic extended-a",
    hexrange: ["ab00", "ab2f"]
  },
  {
    category: "latin extended-e",
    hexrange: ["ab30", "ab6f"]
  },
  {
    category: "cherokee supplement",
    hexrange: ["ab70", "abbf"]
  },
  {
    category: "meetei mayek",
    hexrange: ["abc0", "abff"]
  },
  {
    category: "hangul syllables",
    hexrange: ["ac00", "d7af"]
  },
  {
    category: "hangul jamo extended-b",
    hexrange: ["d7b0", "d7ff"]
  },
  {
    category: "high surrogates",
    hexrange: ["d800", "db7f"]
  },
  {
    category: "high private use surrogates",
    hexrange: ["db80", "dbff"]
  },
  {
    category: "low surrogates",
    hexrange: ["dc00", "dfff"]
  },
  {
    category: "private use area",
    hexrange: ["e000", "f8ff"]
  },
  {
    category: "cjk compatibility ideographs",
    hexrange: ["f900", "faff"]
  },
  {
    category: "alphabetic presentation forms",
    hexrange: ["fb00", "fb4f"]
  },
  {
    category: "arabic presentation forms-a",
    hexrange: ["fb50", "fdff"]
  },
  {
    category: "variation selectors",
    hexrange: ["fe00", "fe0f"]
  },
  {
    category: "vertical forms",
    hexrange: ["fe10", "fe1f"]
  },
  {
    category: "combining half marks",
    hexrange: ["fe20", "fe2f"]
  },
  {
    category: "cjk compatibility forms",
    hexrange: ["fe30", "fe4f"]
  },
  {
    category: "small form variants",
    hexrange: ["fe50", "fe6f"]
  },
  {
    category: "arabic presentation forms-b",
    hexrange: ["fe70", "feff"]
  },
  {
    category: "halfwidth and fullwidth forms",
    hexrange: ["ff00", "ffef"]
  },
  {
    category: "specials",
    hexrange: ["fff0", "ffff"]
  },
  {
    category: "linear b syllabary",
    hexrange: ["10000", "1007f"]
  },
  {
    category: "linear b ideograms",
    hexrange: ["10080", "100ff"]
  },
  {
    category: "aegean numbers",
    hexrange: ["10100", "1013f"]
  },
  {
    category: "ancient greek numbers",
    hexrange: ["10140", "1018f"]
  },
  {
    category: "ancient symbols",
    hexrange: ["10190", "101cf"]
  },
  {
    category: "phaistos disc",
    hexrange: ["101d0", "101ff"]
  },
  {
    category: "lycian",
    hexrange: ["10280", "1029f"]
  },
  {
    category: "carian",
    hexrange: ["102a0", "102df"]
  },
  {
    category: "coptic epact numbers",
    hexrange: ["102e0", "102ff"]
  },
  {
    category: "old italic",
    hexrange: ["10300", "1032f"]
  },
  {
    category: "gothic",
    hexrange: ["10330", "1034f"]
  },
  {
    category: "old permic",
    hexrange: ["10350", "1037f"]
  },
  {
    category: "ugaritic",
    hexrange: ["10380", "1039f"]
  },
  {
    category: "old persian",
    hexrange: ["103a0", "103df"]
  },
  {
    category: "deseret",
    hexrange: ["10400", "1044f"]
  },
  {
    category: "shavian",
    hexrange: ["10450", "1047f"]
  },
  {
    category: "osmanya",
    hexrange: ["10480", "104af"]
  },
  {
    category: "osage",
    hexrange: ["104b0", "104ff"]
  },
  {
    category: "elbasan",
    hexrange: ["10500", "1052f"]
  },
  {
    category: "caucasian albanian",
    hexrange: ["10530", "1056f"]
  },
  {
    category: "vithkuqi",
    hexrange: ["10570", "105bf"]
  },
  {
    category: "linear a",
    hexrange: ["10600", "1077f"]
  },
  {
    category: "latin extended-f",
    hexrange: ["10780", "107bf"]
  },
  {
    category: "cypriot syllabary",
    hexrange: ["10800", "1083f"]
  },
  {
    category: "imperial aramaic",
    hexrange: ["10840", "1085f"]
  },
  {
    category: "palmyrene",
    hexrange: ["10860", "1087f"]
  },
  {
    category: "nabataean",
    hexrange: ["10880", "108af"]
  },
  {
    category: "hatran",
    hexrange: ["108e0", "108ff"]
  },
  {
    category: "phoenician",
    hexrange: ["10900", "1091f"]
  },
  {
    category: "lydian",
    hexrange: ["10920", "1093f"]
  },
  {
    category: "meroitic hieroglyphs",
    hexrange: ["10980", "1099f"]
  },
  {
    category: "meroitic cursive",
    hexrange: ["109a0", "109ff"]
  },
  {
    category: "kharoshthi",
    hexrange: ["10a00", "10a5f"]
  },
  {
    category: "old south arabian",
    hexrange: ["10a60", "10a7f"]
  },
  {
    category: "old north arabian",
    hexrange: ["10a80", "10a9f"]
  },
  {
    category: "manichaean",
    hexrange: ["10ac0", "10aff"]
  },
  {
    category: "avestan",
    hexrange: ["10b00", "10b3f"]
  },
  {
    category: "inscriptional parthian",
    hexrange: ["10b40", "10b5f"]
  },
  {
    category: "inscriptional pahlavi",
    hexrange: ["10b60", "10b7f"]
  },
  {
    category: "psalter pahlavi",
    hexrange: ["10b80", "10baf"]
  },
  {
    category: "old turkic",
    hexrange: ["10c00", "10c4f"]
  },
  {
    category: "old hungarian",
    hexrange: ["10c80", "10cff"]
  },
  {
    category: "hanifi rohingya",
    hexrange: ["10d00", "10d3f"]
  },
  {
    category: "rumi numeral symbols",
    hexrange: ["10e60", "10e7f"]
  },
  {
    category: "yezidi",
    hexrange: ["10e80", "10ebf"]
  },
  {
    category: "arabic extended-c",
    hexrange: ["10ec0", "10eff"]
  },
  {
    category: "old sogdian",
    hexrange: ["10f00", "10f2f"]
  },
  {
    category: "sogdian",
    hexrange: ["10f30", "10f6f"]
  },
  {
    category: "old uyghur",
    hexrange: ["10f70", "10faf"]
  },
  {
    category: "chorasmian",
    hexrange: ["10fb0", "10fdf"]
  },
  {
    category: "elymaic",
    hexrange: ["10fe0", "10fff"]
  },
  {
    category: "brahmi",
    hexrange: ["11000", "1107f"]
  },
  {
    category: "kaithi",
    hexrange: ["11080", "110cf"]
  },
  {
    category: "sora sompeng",
    hexrange: ["110d0", "110ff"]
  },
  {
    category: "chakma",
    hexrange: ["11100", "1114f"]
  },
  {
    category: "mahajani",
    hexrange: ["11150", "1117f"]
  },
  {
    category: "sharada",
    hexrange: ["11180", "111df"]
  },
  {
    category: "sinhala archaic numbers",
    hexrange: ["111e0", "111ff"]
  },
  {
    category: "khojki",
    hexrange: ["11200", "1124f"]
  },
  {
    category: "multani",
    hexrange: ["11280", "112af"]
  },
  {
    category: "khudawadi",
    hexrange: ["112b0", "112ff"]
  },
  {
    category: "grantha",
    hexrange: ["11300", "1137f"]
  },
  {
    category: "newa",
    hexrange: ["11400", "1147f"]
  },
  {
    category: "tirhuta",
    hexrange: ["11480", "114df"]
  },
  {
    category: "siddham",
    hexrange: ["11580", "115ff"]
  },
  {
    category: "modi",
    hexrange: ["11600", "1165f"]
  },
  {
    category: "mongolian supplement",
    hexrange: ["11660", "1167f"]
  },
  {
    category: "takri",
    hexrange: ["11680", "116cf"]
  },
  {
    category: "ahom",
    hexrange: ["11700", "1174f"]
  },
  {
    category: "dogra",
    hexrange: ["11800", "1184f"]
  },
  {
    category: "warang citi",
    hexrange: ["118a0", "118ff"]
  },
  {
    category: "dives akuru",
    hexrange: ["11900", "1195f"]
  },
  {
    category: "nandinagari",
    hexrange: ["119a0", "119ff"]
  },
  {
    category: "zanabazar square",
    hexrange: ["11a00", "11a4f"]
  },
  {
    category: "soyombo",
    hexrange: ["11a50", "11aaf"]
  },
  {
    category: "unified canadian aboriginal syllabics extended-a",
    hexrange: ["11ab0", "11abf"]
  },
  {
    category: "pau cin hau",
    hexrange: ["11ac0", "11aff"]
  },
  {
    category: "devanagari extended-a",
    hexrange: ["11b00", "11b5f"]
  },
  {
    category: "bhaiksuki",
    hexrange: ["11c00", "11c6f"]
  },
  {
    category: "marchen",
    hexrange: ["11c70", "11cbf"]
  },
  {
    category: "masaram gondi",
    hexrange: ["11d00", "11d5f"]
  },
  {
    category: "gunjala gondi",
    hexrange: ["11d60", "11daf"]
  },
  {
    category: "makasar",
    hexrange: ["11ee0", "11eff"]
  },
  {
    category: "kawi",
    hexrange: ["11f00", "11f5f"]
  },
  {
    category: "lisu supplement",
    hexrange: ["11fb0", "11fbf"]
  },
  {
    category: "tamil supplement",
    hexrange: ["11fc0", "11fff"]
  },
  {
    category: "cuneiform",
    hexrange: ["12000", "123ff"]
  },
  {
    category: "cuneiform numbers and punctuation",
    hexrange: ["12400", "1247f"]
  },
  {
    category: "early dynastic cuneiform",
    hexrange: ["12480", "1254f"]
  },
  {
    category: "cypro-minoan",
    hexrange: ["12f90", "12fff"]
  },
  {
    category: "egyptian hieroglyphs",
    hexrange: ["13000", "1342f"]
  },
  {
    category: "egyptian hieroglyph format controls",
    hexrange: ["13430", "1345f"]
  },
  {
    category: "anatolian hieroglyphs",
    hexrange: ["14400", "1467f"]
  },
  {
    category: "bamum supplement",
    hexrange: ["16800", "16a3f"]
  },
  {
    category: "mro",
    hexrange: ["16a40", "16a6f"]
  },
  {
    category: "tangsa",
    hexrange: ["16a70", "16acf"]
  },
  {
    category: "bassa vah",
    hexrange: ["16ad0", "16aff"]
  },
  {
    category: "pahawh hmong",
    hexrange: ["16b00", "16b8f"]
  },
  {
    category: "medefaidrin",
    hexrange: ["16e40", "16e9f"]
  },
  {
    category: "miao",
    hexrange: ["16f00", "16f9f"]
  },
  {
    category: "ideographic symbols and punctuation",
    hexrange: ["16fe0", "16fff"]
  },
  {
    category: "tangut",
    hexrange: ["17000", "187ff"]
  },
  {
    category: "tangut components",
    hexrange: ["18800", "18aff"]
  },
  {
    category: "khitan small script",
    hexrange: ["18b00", "18cff"]
  },
  {
    category: "tangut supplement",
    hexrange: ["18d00", "18d7f"]
  },
  {
    category: "kana extended-b",
    hexrange: ["1aff0", "1afff"]
  },
  {
    category: "kana supplement",
    hexrange: ["1b000", "1b0ff"]
  },
  {
    category: "kana extended-a",
    hexrange: ["1b100", "1b12f"]
  },
  {
    category: "small kana extension",
    hexrange: ["1b130", "1b16f"]
  },
  {
    category: "nushu",
    hexrange: ["1b170", "1b2ff"]
  },
  {
    category: "duployan",
    hexrange: ["1bc00", "1bc9f"]
  },
  {
    category: "shorthand format controls",
    hexrange: ["1bca0", "1bcaf"]
  },
  {
    category: "znamenny musical notation",
    hexrange: ["1cf00", "1cfcf"]
  },
  {
    category: "byzantine musical symbols",
    hexrange: ["1d000", "1d0ff"]
  },
  {
    category: "musical symbols",
    hexrange: ["1d100", "1d1ff"]
  },
  {
    category: "ancient greek musical notation",
    hexrange: ["1d200", "1d24f"]
  },
  {
    category: "kaktovik numerals",
    hexrange: ["1d2c0", "1d2df"]
  },
  {
    category: "mayan numerals",
    hexrange: ["1d2e0", "1d2ff"]
  },
  {
    category: "tai xuan jing symbols",
    hexrange: ["1d300", "1d35f"]
  },
  {
    category: "counting rod numerals",
    hexrange: ["1d360", "1d37f"]
  },
  {
    category: "mathematical alphanumeric symbols",
    hexrange: ["1d400", "1d7ff"]
  },
  {
    category: "sutton signwriting",
    hexrange: ["1d800", "1daaf"]
  },
  {
    category: "latin extended-g",
    hexrange: ["1df00", "1dfff"]
  },
  {
    category: "glagolitic supplement",
    hexrange: ["1e000", "1e02f"]
  },
  {
    category: "cyrillic extended-d",
    hexrange: ["1e030", "1e08f"]
  },
  {
    category: "nyiakeng puachue hmong",
    hexrange: ["1e100", "1e14f"]
  },
  {
    category: "toto",
    hexrange: ["1e290", "1e2bf"]
  },
  {
    category: "wancho",
    hexrange: ["1e2c0", "1e2ff"]
  },
  {
    category: "nag mundari",
    hexrange: ["1e4d0", "1e4ff"]
  },
  {
    category: "ethiopic extended-b",
    hexrange: ["1e7e0", "1e7ff"]
  },
  {
    category: "mende kikakui",
    hexrange: ["1e800", "1e8df"]
  },
  {
    category: "adlam",
    hexrange: ["1e900", "1e95f"]
  },
  {
    category: "indic siyaq numbers",
    hexrange: ["1ec70", "1ecbf"]
  },
  {
    category: "ottoman siyaq numbers",
    hexrange: ["1ed00", "1ed4f"]
  },
  {
    category: "arabic mathematical alphabetic symbols",
    hexrange: ["1ee00", "1eeff"]
  },
  {
    category: "mahjong tiles",
    hexrange: ["1f000", "1f02f"]
  },
  {
    category: "domino tiles",
    hexrange: ["1f030", "1f09f"]
  },
  {
    category: "playing cards",
    hexrange: ["1f0a0", "1f0ff"]
  },
  {
    category: "enclosed alphanumeric supplement",
    hexrange: ["1f100", "1f1ff"]
  },
  {
    category: "enclosed ideographic supplement",
    hexrange: ["1f200", "1f2ff"]
  },
  {
    category: "miscellaneous symbols and pictographs",
    hexrange: ["1f300", "1f5ff"]
  },
  {
    category: "emoticons (emoji)",
    hexrange: ["1f600", "1f64f"]
  },
  {
    category: "ornamental dingbats",
    hexrange: ["1f650", "1f67f"]
  },
  {
    category: "transport and map symbols",
    hexrange: ["1f680", "1f6ff"]
  },
  {
    category: "alchemical symbols",
    hexrange: ["1f700", "1f77f"]
  },
  {
    category: "geometric shapes extended",
    hexrange: ["1f780", "1f7ff"]
  },
  {
    category: "supplemental arrows-c",
    hexrange: ["1f800", "1f8ff"]
  },
  {
    category: "supplemental symbols and pictographs",
    hexrange: ["1f900", "1f9ff"]
  },
  {
    category: "chess symbols",
    hexrange: ["1fa00", "1fa6f"]
  },
  {
    category: "symbols and pictographs extended-a",
    hexrange: ["1fa70", "1faff"]
  },
  {
    category: "symbols for legacy computing",
    hexrange: ["1fb00", "1fbff"]
  },
  {
    category: "cjk unified ideographs extension b",
    hexrange: ["20000", "2a6df"]
  },
  {
    category: "cjk unified ideographs extension c",
    hexrange: ["2a700", "2b73f"]
  },
  {
    category: "cjk unified ideographs extension d",
    hexrange: ["2b740", "2b81f"]
  },
  {
    category: "cjk unified ideographs extension e",
    hexrange: ["2b820", "2ceaf"]
  },
  {
    category: "cjk unified ideographs extension f",
    hexrange: ["2ceb0", "2ebef"]
  },
  {
    category: "cjk unified ideographs extension i",
    hexrange: ["2ebf0", "2ee5f"]
  },
  {
    category: "cjk compatibility ideographs supplement",
    hexrange: ["2f800", "2fa1f"]
  },
  {
    category: "cjk unified ideographs extension g",
    hexrange: ["30000", "3134f"]
  },
  {
    category: "cjk unified ideographs extension h",
    hexrange: ["31350", "323af"]
  },
  {
    category: "tags",
    hexrange: ["e0000", "e007f"]
  },
  {
    category: "variation selectors supplement",
    hexrange: ["e0100", "e01ef"]
  },
  {
    category: "supplementary private use area-a",
    hexrange: ["f0000", "fffff"]
  },
  {
    category: "supplementary private use area-b",
    hexrange: ["100000", "10ffff"]
  }
];
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len !== 0) {
    n2 = len > 2e3 ? 2e3 : len;
    len -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c, table2 = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c = n2;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table2[n2] = c;
  }
  return table2;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p2 in source) {
      if (_has(source, p2)) {
        obj[p2] = source[p2];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c22, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start2) {
  let _in;
  let last2;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output2;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start2 - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output2[_out++] = from_source[from++];
                      if (len > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output2[_out++] = output2[from++];
                      if (len > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type2, lens, lens_index, codes, table2, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base2 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base2 = extra = work;
    match = 20;
  } else if (type2 === LENS$1) {
    base2 = lbase;
    extra = lext;
    match = 257;
  } else {
    base2 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base2[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table2[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy2) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy2 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
    copy2 -= dist;
    if (copy2) {
      state.window.set(src.subarray(end - copy2, end), 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output2;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy2
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output2.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output2[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output2, _out, put - _out) : adler32_1(state.check, output2, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output2, _out, strm.next_out - _out) : adler32_1(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options2) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data2[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options2) {
  const inflator = new Inflate$1(options2);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
var inflate_2 = inflate$1;
var inflate_1$1 = {
  inflate: inflate_2
};
const { inflate } = inflate_1$1;
var inflate_1 = inflate;
const pako = { inflate: inflate_1 };
var Typr = {};
Typr["parse"] = function(buff) {
  var bin = Typr["B"];
  var readFont = function(data3, idx, offset3, tmap2) {
    var T2 = Typr["T"];
    var prsr = {
      "cmap": T2.cmap,
      "head": T2.head,
      "hhea": T2.hhea,
      "maxp": T2.maxp,
      "hmtx": T2.hmtx,
      "name": T2.name,
      "OS/2": T2.OS2,
      "post": T2.post,
      "loca": T2.loca,
      "kern": T2.kern,
      "glyf": T2.glyf,
      "CFF ": T2.CFF,
      /*
      "GPOS",
      "GSUB",
      "GDEF",*/
      "GSUB": T2.GSUB,
      "CBLC": T2.CBLC,
      "CBDT": T2.CBDT,
      "SVG ": T2.SVG,
      "COLR": T2.colr,
      "CPAL": T2.cpal,
      "sbix": T2.sbix,
      "fvar": T2.fvar,
      "gvar": T2.gvar,
      "avar": T2.avar,
      "HVAR": T2.HVAR
      //"VORG",
    };
    var obj2 = { "_data": data3, "_index": idx, "_offset": offset3 };
    for (var t in prsr) {
      var tab = Typr["findTable"](data3, t, offset3);
      if (tab) {
        var off = tab[0], tobj = tmap2[off];
        if (tobj == null) tobj = prsr[t].parseTab(data3, off, tab[1], obj2);
        obj2[t] = tmap2[off] = tobj;
      }
    }
    return obj2;
  };
  function woffToOtf(data3) {
    var numTables = bin.readUshort(data3, 12);
    var totalSize = bin.readUint(data3, 16);
    var otf = new Uint8Array(totalSize), toff = 12 + numTables * 16;
    bin.writeASCII(otf, 0, "OTTO");
    bin.writeUshort(otf, 4, numTables);
    var off = 44;
    for (var i2 = 0; i2 < numTables; i2++) {
      var tag2 = bin.readASCII(data3, off, 4);
      var tof = bin.readUint(data3, off + 4);
      var cLe = bin.readUint(data3, off + 8);
      var oLe = bin.readUint(data3, off + 12);
      off += 20;
      var tab = data3.slice(tof, tof + cLe);
      if (cLe != oLe) tab = pako["inflate"](tab);
      var to2 = 12 + i2 * 16;
      bin.writeASCII(otf, to2, tag2);
      bin.writeUint(otf, to2 + 8, toff);
      bin.writeUint(otf, to2 + 12, oLe);
      otf.set(tab, toff);
      toff += oLe;
    }
    return otf;
  }
  var data2 = new Uint8Array(buff);
  let compressedData;
  if (data2[0] == 119) {
    compressedData = data2;
    data2 = woffToOtf(data2);
  }
  var tmap = {};
  var tag = bin.readASCII(data2, 0, 4);
  if (tag == "ttcf") {
    var offset2 = 4;
    bin.readUshort(data2, offset2);
    offset2 += 2;
    bin.readUshort(data2, offset2);
    offset2 += 2;
    var numF = bin.readUint(data2, offset2);
    offset2 += 4;
    var fnts = [];
    for (var i = 0; i < numF; i++) {
      var foff = bin.readUint(data2, offset2);
      offset2 += 4;
      fnts.push(readFont(data2, i, foff, tmap));
    }
    return fnts;
  }
  var fnt = readFont(data2, 0, 0, tmap);
  fnt._compressedData = compressedData;
  var fvar = fnt["fvar"];
  if (fvar) {
    var out = [fnt];
    for (var i = 0; i < fvar[1].length; i++) {
      var fv = fvar[1][i];
      var obj = {};
      out.push(obj);
      for (var p2 in fnt) obj[p2] = fnt[p2];
      obj["_index"] = i;
      var name = obj["name"] = JSON.parse(JSON.stringify(obj["name"]));
      name["fontSubfamily"] = fv[0];
      if (fv[3] == null) fv[3] = (name["fontFamily"] + "-" + name["fontSubfamily"])["replaceAll"](" ", "");
      name["postScriptName"] = fv[3];
    }
    return out;
  }
  return [fnt];
};
Typr["findTable"] = function(data2, tab, foff) {
  var bin = Typr["B"];
  var numTables = bin.readUshort(data2, foff + 4);
  var offset2 = foff + 12;
  for (var i = 0; i < numTables; i++) {
    var tag = bin.readASCII(data2, offset2, 4);
    bin.readUint(data2, offset2 + 4);
    var toffset = bin.readUint(data2, offset2 + 8);
    var length = bin.readUint(data2, offset2 + 12);
    if (tag == tab) return [toffset, length];
    offset2 += 16;
  }
  return null;
};
Typr["T"] = {};
Typr["B"] = {
  readFixed: function(data2, o) {
    return (data2[o] << 8 | data2[o + 1]) + (data2[o + 2] << 8 | data2[o + 3]) / (256 * 256 + 4);
  },
  readF2dot14: function(data2, o) {
    var num = Typr["B"].readShort(data2, o);
    return num / 16384;
  },
  readInt: function(buff, p2) {
    var a = Typr["B"].t.uint8;
    a[0] = buff[p2 + 3];
    a[1] = buff[p2 + 2];
    a[2] = buff[p2 + 1];
    a[3] = buff[p2];
    return Typr["B"].t.int32[0];
  },
  readInt8: function(buff, p2) {
    var a = Typr["B"].t.uint8;
    a[0] = buff[p2];
    return Typr["B"].t.int8[0];
  },
  readShort: function(buff, p2) {
    var a = Typr["B"].t.uint16;
    a[0] = buff[p2] << 8 | buff[p2 + 1];
    return Typr["B"].t.int16[0];
  },
  readUshort: function(buff, p2) {
    return buff[p2] << 8 | buff[p2 + 1];
  },
  writeUshort: function(buff, p2, n2) {
    buff[p2] = n2 >> 8 & 255;
    buff[p2 + 1] = n2 & 255;
  },
  readUshorts: function(buff, p2, len) {
    var arr2 = [];
    for (var i = 0; i < len; i++) {
      var v = Typr["B"].readUshort(buff, p2 + i * 2);
      arr2.push(v);
    }
    return arr2;
  },
  readUint: function(buff, p2) {
    var a = Typr["B"].t.uint8;
    a[3] = buff[p2];
    a[2] = buff[p2 + 1];
    a[1] = buff[p2 + 2];
    a[0] = buff[p2 + 3];
    return Typr["B"].t.uint32[0];
  },
  writeUint: function(buff, p2, n2) {
    buff[p2] = n2 >> 24 & 255;
    buff[p2 + 1] = n2 >> 16 & 255;
    buff[p2 + 2] = n2 >> 8 & 255;
    buff[p2 + 3] = n2 >> 0 & 255;
  },
  readUint64: function(buff, p2) {
    return Typr["B"].readUint(buff, p2) * (4294967295 + 1) + Typr["B"].readUint(buff, p2 + 4);
  },
  readASCII: function(buff, p2, l) {
    var s = "";
    for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p2 + i]);
    return s;
  },
  writeASCII: function(buff, p2, s) {
    for (var i = 0; i < s.length; i++)
      buff[p2 + i] = s.charCodeAt(i);
  },
  readUnicode: function(buff, p2, l) {
    var s = "";
    for (var i = 0; i < l; i++) {
      var c = buff[p2++] << 8 | buff[p2++];
      s += String.fromCharCode(c);
    }
    return s;
  },
  _tdec: window["TextDecoder"] ? new window["TextDecoder"]() : null,
  readUTF8: function(buff, p2, l) {
    var tdec = Typr["B"]._tdec;
    if (tdec && p2 == 0 && l == buff.length) return tdec["decode"](buff);
    return Typr["B"].readASCII(buff, p2, l);
  },
  readBytes: function(buff, p2, l) {
    var arr2 = [];
    for (var i = 0; i < l; i++) arr2.push(buff[p2 + i]);
    return arr2;
  },
  readASCIIArray: function(buff, p2, l) {
    var s = [];
    for (var i = 0; i < l; i++)
      s.push(String.fromCharCode(buff[p2 + i]));
    return s;
  },
  t: (function() {
    var ab = new ArrayBuffer(8);
    return {
      buff: ab,
      int8: new Int8Array(ab),
      uint8: new Uint8Array(ab),
      int16: new Int16Array(ab),
      uint16: new Uint16Array(ab),
      int32: new Int32Array(ab),
      uint32: new Uint32Array(ab)
    };
  })()
};
Typr["T"].CFF = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var CFF = Typr["T"].CFF;
    data2 = new Uint8Array(data2.buffer, offset2, length);
    offset2 = 0;
    data2[offset2];
    offset2++;
    data2[offset2];
    offset2++;
    data2[offset2];
    offset2++;
    data2[offset2];
    offset2++;
    var ninds = [];
    offset2 = CFF.readIndex(data2, offset2, ninds);
    var names = [];
    for (var i = 0; i < ninds.length - 1; i++) names.push(bin.readASCII(data2, offset2 + ninds[i], ninds[i + 1] - ninds[i]));
    offset2 += ninds[ninds.length - 1];
    var tdinds = [];
    offset2 = CFF.readIndex(data2, offset2, tdinds);
    var topDicts = [];
    for (var i = 0; i < tdinds.length - 1; i++) topDicts.push(CFF.readDict(data2, offset2 + tdinds[i], offset2 + tdinds[i + 1]));
    offset2 += tdinds[tdinds.length - 1];
    var topdict = topDicts[0];
    var sinds = [];
    offset2 = CFF.readIndex(data2, offset2, sinds);
    var strings2 = [];
    for (var i = 0; i < sinds.length - 1; i++) strings2.push(bin.readASCII(data2, offset2 + sinds[i], sinds[i + 1] - sinds[i]));
    offset2 += sinds[sinds.length - 1];
    CFF.readSubrs(data2, offset2, topdict);
    if (topdict["CharStrings"]) topdict["CharStrings"] = CFF.readBytes(data2, topdict["CharStrings"]);
    if (topdict["ROS"]) {
      offset2 = topdict["FDArray"];
      var fdind = [];
      offset2 = CFF.readIndex(data2, offset2, fdind);
      topdict["FDArray"] = [];
      for (var i = 0; i < fdind.length - 1; i++) {
        var dict = CFF.readDict(data2, offset2 + fdind[i], offset2 + fdind[i + 1]);
        CFF._readFDict(data2, dict, strings2);
        topdict["FDArray"].push(dict);
      }
      offset2 += fdind[fdind.length - 1];
      offset2 = topdict["FDSelect"];
      topdict["FDSelect"] = [];
      var fmt = data2[offset2];
      offset2++;
      if (fmt == 3) {
        var rns = bin.readUshort(data2, offset2);
        offset2 += 2;
        for (var i = 0; i < rns + 1; i++) {
          topdict["FDSelect"].push(bin.readUshort(data2, offset2), data2[offset2 + 2]);
          offset2 += 3;
        }
      } else throw fmt;
    }
    if (topdict["charset"]) topdict["charset"] = CFF.readCharset(data2, topdict["charset"], topdict["CharStrings"].length);
    CFF._readFDict(data2, topdict, strings2);
    return topdict;
  },
  _readFDict: function(data2, dict, ss) {
    var CFF = Typr["T"].CFF;
    var offset2;
    if (dict["Private"]) {
      offset2 = dict["Private"][1];
      dict["Private"] = CFF.readDict(data2, offset2, offset2 + dict["Private"][0]);
      if (dict["Private"]["Subrs"]) CFF.readSubrs(data2, offset2 + dict["Private"]["Subrs"], dict["Private"]);
    }
    for (var p2 in dict) if (["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(p2) != -1) dict[p2] = ss[dict[p2] - 426 + 35];
  },
  readSubrs: function(data2, offset2, obj) {
    obj["Subrs"] = Typr["T"].CFF.readBytes(data2, offset2);
    var bias, nSubrs = obj["Subrs"].length + 1;
    if (nSubrs < 1240) bias = 107;
    else if (nSubrs < 33900) bias = 1131;
    else bias = 32768;
    obj["Bias"] = bias;
  },
  readBytes: function(data2, offset2) {
    Typr["B"];
    var arr2 = [];
    offset2 = Typr["T"].CFF.readIndex(data2, offset2, arr2);
    var subrs = [], arl = arr2.length - 1, no = data2.byteOffset + offset2;
    for (var i = 0; i < arl; i++) {
      var ari = arr2[i];
      subrs.push(new Uint8Array(data2.buffer, no + ari, arr2[i + 1] - ari));
    }
    return subrs;
  },
  tableSE: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    0,
    111,
    112,
    113,
    114,
    0,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    0,
    123,
    0,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    0,
    132,
    133,
    0,
    134,
    135,
    136,
    137,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    138,
    0,
    139,
    0,
    0,
    0,
    0,
    140,
    141,
    142,
    143,
    0,
    0,
    0,
    0,
    0,
    144,
    0,
    0,
    0,
    145,
    0,
    0,
    146,
    147,
    148,
    149,
    0,
    0,
    0,
    0
  ],
  glyphByUnicode: function(cff, code2) {
    for (var i = 0; i < cff["charset"].length; i++) if (cff["charset"][i] == code2) return i;
    return -1;
  },
  glyphBySE: function(cff, charcode) {
    if (charcode < 0 || charcode > 255) return -1;
    return Typr["T"].CFF.glyphByUnicode(cff, Typr["T"].CFF.tableSE[charcode]);
  },
  /*readEncoding : function(data, offset, num)
    {
      var bin = Typr["B"];
  
      var array = ['.notdef'];
      var format = data[offset];  offset++;
      //console.log("Encoding");
      //console.log(format);
  
      if(format==0)
      {
        var nCodes = data[offset];  offset++;
        for(var i=0; i<nCodes; i++)  array.push(data[offset+i]);
      }
      /*
      else if(format==1 || format==2)
      {
        while(charset.length<num)
        {
          var first = bin.readUshort(data, offset);  offset+=2;
          var nLeft=0;
          if(format==1) {  nLeft = data[offset];  offset++;  }
          else          {  nLeft = bin.readUshort(data, offset);  offset+=2;  }
          for(var i=0; i<=nLeft; i++)  {  charset.push(first);  first++;  }
        }
      }
  
      else throw "error: unknown encoding format: " + format;
  
      return array;
    },*/
  readCharset: function(data2, offset2, num) {
    var bin = Typr["B"];
    var charset = [".notdef"];
    var format = data2[offset2];
    offset2++;
    if (format == 0) {
      for (var i = 0; i < num; i++) {
        var first = bin.readUshort(data2, offset2);
        offset2 += 2;
        charset.push(first);
      }
    } else if (format == 1 || format == 2) {
      while (charset.length < num) {
        var first = bin.readUshort(data2, offset2);
        offset2 += 2;
        var nLeft = 0;
        if (format == 1) {
          nLeft = data2[offset2];
          offset2++;
        } else {
          nLeft = bin.readUshort(data2, offset2);
          offset2 += 2;
        }
        for (var i = 0; i <= nLeft; i++) {
          charset.push(first);
          first++;
        }
      }
    } else throw "error: format: " + format;
    return charset;
  },
  readIndex: function(data2, offset2, inds) {
    var bin = Typr["B"];
    var count = bin.readUshort(data2, offset2) + 1;
    offset2 += 2;
    var offsize = data2[offset2];
    offset2++;
    if (offsize == 1) for (var i = 0; i < count; i++) inds.push(data2[offset2 + i]);
    else if (offsize == 2) for (var i = 0; i < count; i++) inds.push(bin.readUshort(data2, offset2 + i * 2));
    else if (offsize == 3) for (var i = 0; i < count; i++) inds.push(bin.readUint(data2, offset2 + i * 3 - 1) & 16777215);
    else if (offsize == 4) for (var i = 0; i < count; i++) inds.push(bin.readUint(data2, offset2 + i * 4));
    else if (count != 1) throw "unsupported offset size: " + offsize + ", count: " + count;
    offset2 += count * offsize;
    return offset2 - 1;
  },
  getCharString: function(data2, offset2, o) {
    var bin = Typr["B"];
    var b0 = data2[offset2], b1 = data2[offset2 + 1];
    data2[offset2 + 2];
    data2[offset2 + 3];
    data2[offset2 + 4];
    var vs = 1;
    var op = null, val = null;
    if (b0 <= 20) {
      op = b0;
      vs = 1;
    }
    if (b0 == 12) {
      op = b0 * 100 + b1;
      vs = 2;
    }
    if (21 <= b0 && b0 <= 27) {
      op = b0;
      vs = 1;
    }
    if (b0 == 28) {
      val = bin.readShort(data2, offset2 + 1);
      vs = 3;
    }
    if (29 <= b0 && b0 <= 31) {
      op = b0;
      vs = 1;
    }
    if (32 <= b0 && b0 <= 246) {
      val = b0 - 139;
      vs = 1;
    }
    if (247 <= b0 && b0 <= 250) {
      val = (b0 - 247) * 256 + b1 + 108;
      vs = 2;
    }
    if (251 <= b0 && b0 <= 254) {
      val = -(b0 - 251) * 256 - b1 - 108;
      vs = 2;
    }
    if (b0 == 255) {
      val = bin.readInt(data2, offset2 + 1) / 65535;
      vs = 5;
    }
    o.val = val != null ? val : "o" + op;
    o.size = vs;
  },
  readCharString: function(data2, offset2, length) {
    var end = offset2 + length;
    var bin = Typr["B"];
    var arr2 = [];
    while (offset2 < end) {
      var b0 = data2[offset2], b1 = data2[offset2 + 1];
      data2[offset2 + 2];
      data2[offset2 + 3];
      data2[offset2 + 4];
      var vs = 1;
      var op = null, val = null;
      if (b0 <= 20) {
        op = b0;
        vs = 1;
      }
      if (b0 == 12) {
        op = b0 * 100 + b1;
        vs = 2;
      }
      if (b0 == 19 || b0 == 20) {
        op = b0;
        vs = 2;
      }
      if (21 <= b0 && b0 <= 27) {
        op = b0;
        vs = 1;
      }
      if (b0 == 28) {
        val = bin.readShort(data2, offset2 + 1);
        vs = 3;
      }
      if (29 <= b0 && b0 <= 31) {
        op = b0;
        vs = 1;
      }
      if (32 <= b0 && b0 <= 246) {
        val = b0 - 139;
        vs = 1;
      }
      if (247 <= b0 && b0 <= 250) {
        val = (b0 - 247) * 256 + b1 + 108;
        vs = 2;
      }
      if (251 <= b0 && b0 <= 254) {
        val = -(b0 - 251) * 256 - b1 - 108;
        vs = 2;
      }
      if (b0 == 255) {
        val = bin.readInt(data2, offset2 + 1) / 65535;
        vs = 5;
      }
      arr2.push(val != null ? val : "o" + op);
      offset2 += vs;
    }
    return arr2;
  },
  readDict: function(data2, offset2, end) {
    var bin = Typr["B"];
    var dict = {};
    var carr = [];
    while (offset2 < end) {
      var b0 = data2[offset2], b1 = data2[offset2 + 1];
      data2[offset2 + 2];
      data2[offset2 + 3];
      data2[offset2 + 4];
      var vs = 1;
      var key = null, val = null;
      if (b0 == 28) {
        val = bin.readShort(data2, offset2 + 1);
        vs = 3;
      }
      if (b0 == 29) {
        val = bin.readInt(data2, offset2 + 1);
        vs = 5;
      }
      if (32 <= b0 && b0 <= 246) {
        val = b0 - 139;
        vs = 1;
      }
      if (247 <= b0 && b0 <= 250) {
        val = (b0 - 247) * 256 + b1 + 108;
        vs = 2;
      }
      if (251 <= b0 && b0 <= 254) {
        val = -(b0 - 251) * 256 - b1 - 108;
        vs = 2;
      }
      if (b0 == 255) {
        val = bin.readInt(data2, offset2 + 1) / 65535;
        vs = 5;
        throw "unknown number";
      }
      if (b0 == 30) {
        var nibs = [];
        vs = 1;
        while (true) {
          var b2 = data2[offset2 + vs];
          vs++;
          var nib0 = b2 >> 4, nib1 = b2 & 15;
          if (nib0 != 15) nibs.push(nib0);
          if (nib1 != 15) nibs.push(nib1);
          if (nib1 == 15) break;
        }
        var s = "";
        var chars = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"];
        for (var i = 0; i < nibs.length; i++) s += chars[nibs[i]];
        val = parseFloat(s);
      }
      if (b0 <= 21) {
        var keys = [
          "version",
          "Notice",
          "FullName",
          "FamilyName",
          "Weight",
          "FontBBox",
          "BlueValues",
          "OtherBlues",
          "FamilyBlues",
          "FamilyOtherBlues",
          "StdHW",
          "StdVW",
          "escape",
          "UniqueID",
          "XUID",
          "charset",
          "Encoding",
          "CharStrings",
          "Private",
          "Subrs",
          "defaultWidthX",
          "nominalWidthX"
        ];
        key = keys[b0];
        vs = 1;
        if (b0 == 12) {
          var keys = [
            "Copyright",
            "isFixedPitch",
            "ItalicAngle",
            "UnderlinePosition",
            "UnderlineThickness",
            "PaintType",
            "CharstringType",
            "FontMatrix",
            "StrokeWidth",
            "BlueScale",
            "BlueShift",
            "BlueFuzz",
            "StemSnapH",
            "StemSnapV",
            "ForceBold",
            "",
            "",
            "LanguageGroup",
            "ExpansionFactor",
            "initialRandomSeed",
            "SyntheticBase",
            "PostScript",
            "BaseFontName",
            "BaseFontBlend",
            "",
            "",
            "",
            "",
            "",
            "",
            "ROS",
            "CIDFontVersion",
            "CIDFontRevision",
            "CIDFontType",
            "CIDCount",
            "UIDBase",
            "FDArray",
            "FDSelect",
            "FontName"
          ];
          key = keys[b1];
          vs = 2;
        }
      }
      if (key != null) {
        dict[key] = carr.length == 1 ? carr[0] : carr;
        carr = [];
      } else carr.push(val);
      offset2 += vs;
    }
    return dict;
  }
};
Typr["T"].cmap = {
  parseTab: function(data2, offset2, length) {
    var obj = { tables: [], ids: {}, off: offset2 };
    data2 = new Uint8Array(data2.buffer, offset2, length);
    offset2 = 0;
    var bin = Typr["B"], rU = bin.readUshort, cmap = Typr["T"].cmap;
    rU(data2, offset2);
    offset2 += 2;
    var numTables = rU(data2, offset2);
    offset2 += 2;
    var offs = [];
    for (var i = 0; i < numTables; i++) {
      var platformID = rU(data2, offset2);
      offset2 += 2;
      var encodingID = rU(data2, offset2);
      offset2 += 2;
      var noffset = bin.readUint(data2, offset2);
      offset2 += 4;
      var id = "p" + platformID + "e" + encodingID;
      var tind = offs.indexOf(noffset);
      if (tind == -1) {
        tind = obj.tables.length;
        var subt = {};
        offs.push(noffset);
        var format = subt.format = rU(data2, noffset);
        if (format == 0) subt = cmap.parse0(data2, noffset, subt);
        else if (format == 4) subt = cmap.parse4(data2, noffset, subt);
        else if (format == 6) subt = cmap.parse6(data2, noffset, subt);
        else if (format == 12) subt = cmap.parse12(data2, noffset, subt);
        obj.tables.push(subt);
      }
      if (obj.ids[id] != null) console.log("multiple tables for one platform+encoding: " + id);
      obj.ids[id] = tind;
    }
    return obj;
  },
  parse0: function(data2, offset2, obj) {
    var bin = Typr["B"];
    offset2 += 2;
    var len = bin.readUshort(data2, offset2);
    offset2 += 2;
    bin.readUshort(data2, offset2);
    offset2 += 2;
    obj.map = [];
    for (var i = 0; i < len - 6; i++) obj.map.push(data2[offset2 + i]);
    return obj;
  },
  parse4: function(data2, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUshort, rUs = bin.readUshorts;
    var offset0 = offset2;
    offset2 += 2;
    var length = rU(data2, offset2);
    offset2 += 2;
    rU(data2, offset2);
    offset2 += 2;
    var segCountX2 = rU(data2, offset2);
    offset2 += 2;
    var segCount = segCountX2 >>> 1;
    obj.searchRange = rU(data2, offset2);
    offset2 += 2;
    obj.entrySelector = rU(data2, offset2);
    offset2 += 2;
    obj.rangeShift = rU(data2, offset2);
    offset2 += 2;
    obj.endCount = rUs(data2, offset2, segCount);
    offset2 += segCount * 2;
    offset2 += 2;
    obj.startCount = rUs(data2, offset2, segCount);
    offset2 += segCount * 2;
    obj.idDelta = [];
    for (var i = 0; i < segCount; i++) {
      obj.idDelta.push(bin.readShort(data2, offset2));
      offset2 += 2;
    }
    obj.idRangeOffset = rUs(data2, offset2, segCount);
    offset2 += segCount * 2;
    obj.glyphIdArray = rUs(data2, offset2, offset0 + length - offset2 >> 1);
    return obj;
  },
  parse6: function(data2, offset2, obj) {
    var bin = Typr["B"];
    offset2 += 2;
    bin.readUshort(data2, offset2);
    offset2 += 2;
    bin.readUshort(data2, offset2);
    offset2 += 2;
    obj.firstCode = bin.readUshort(data2, offset2);
    offset2 += 2;
    var entryCount = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj.glyphIdArray = [];
    for (var i = 0; i < entryCount; i++) {
      obj.glyphIdArray.push(bin.readUshort(data2, offset2));
      offset2 += 2;
    }
    return obj;
  },
  parse12: function(data2, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUint;
    offset2 += 4;
    rU(data2, offset2);
    offset2 += 4;
    rU(data2, offset2);
    offset2 += 4;
    var nGroups = rU(data2, offset2) * 3;
    offset2 += 4;
    var gps = obj.groups = new Uint32Array(nGroups);
    for (var i = 0; i < nGroups; i += 3) {
      gps[i] = rU(data2, offset2 + (i << 2));
      gps[i + 1] = rU(data2, offset2 + (i << 2) + 4);
      gps[i + 2] = rU(data2, offset2 + (i << 2) + 8);
    }
    return obj;
  }
};
Typr["T"].CBLC = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"], ooff = offset2;
    bin.readUshort(data2, offset2);
    offset2 += 2;
    bin.readUshort(data2, offset2);
    offset2 += 2;
    var numSizes = bin.readUint(data2, offset2);
    offset2 += 4;
    var out = [];
    for (var i = 0; i < numSizes; i++) {
      var off = bin.readUint(data2, offset2);
      offset2 += 4;
      bin.readUint(data2, offset2);
      offset2 += 4;
      bin.readUint(data2, offset2);
      offset2 += 4;
      offset2 += 4;
      offset2 += 2 * 12;
      bin.readUshort(data2, offset2);
      offset2 += 2;
      bin.readUshort(data2, offset2);
      offset2 += 2;
      offset2 += 4;
      var coff = ooff + off;
      for (var j2 = 0; j2 < 3; j2++) {
        var fgI = bin.readUshort(data2, coff);
        coff += 2;
        var lgI = bin.readUshort(data2, coff);
        coff += 2;
        var nxt = bin.readUint(data2, coff);
        coff += 4;
        var gcnt = lgI - fgI + 1;
        var ioff = ooff + off + nxt;
        var inF = bin.readUshort(data2, ioff);
        ioff += 2;
        if (inF != 1) throw inF;
        var imF = bin.readUshort(data2, ioff);
        ioff += 2;
        var imgo = bin.readUint(data2, ioff);
        ioff += 4;
        var oarr = [];
        for (var gi = 0; gi < gcnt; gi++) {
          var sbitO = bin.readUint(data2, ioff + gi * 4);
          oarr.push(imgo + sbitO);
        }
        out.push([fgI, lgI, imF, oarr]);
      }
    }
    return out;
  }
};
Typr["T"].CBDT = {
  parseTab: function(data2, offset2, length) {
    Typr["B"];
    return new Uint8Array(data2.buffer, data2.byteOffset + offset2, length);
  }
};
Typr["T"].glyf = {
  parseTab: function(data2, offset2, length, font2) {
    var obj = [], ng = font2["maxp"]["numGlyphs"];
    for (var g2 = 0; g2 < ng; g2++) obj.push(null);
    return obj;
  },
  _parseGlyf: function(font2, g2) {
    var bin = Typr["B"];
    var data2 = font2["_data"], loca = font2["loca"];
    if (loca[g2] == loca[g2 + 1]) return null;
    var offset2 = Typr["findTable"](data2, "glyf", font2["_offset"])[0] + loca[g2];
    var gl = {};
    gl.noc = bin.readShort(data2, offset2);
    offset2 += 2;
    gl.xMin = bin.readShort(data2, offset2);
    offset2 += 2;
    gl.yMin = bin.readShort(data2, offset2);
    offset2 += 2;
    gl.xMax = bin.readShort(data2, offset2);
    offset2 += 2;
    gl.yMax = bin.readShort(data2, offset2);
    offset2 += 2;
    if (gl.xMin >= gl.xMax || gl.yMin >= gl.yMax) return null;
    if (gl.noc > 0) {
      gl.endPts = [];
      for (var i = 0; i < gl.noc; i++) {
        gl.endPts.push(bin.readUshort(data2, offset2));
        offset2 += 2;
      }
      var instructionLength = bin.readUshort(data2, offset2);
      offset2 += 2;
      if (data2.length - offset2 < instructionLength) return null;
      gl.instructions = bin.readBytes(data2, offset2, instructionLength);
      offset2 += instructionLength;
      var crdnum = gl.endPts[gl.noc - 1] + 1;
      gl.flags = [];
      for (var i = 0; i < crdnum; i++) {
        var flag = data2[offset2];
        offset2++;
        gl.flags.push(flag);
        if ((flag & 8) != 0) {
          var rep = data2[offset2];
          offset2++;
          for (var j2 = 0; j2 < rep; j2++) {
            gl.flags.push(flag);
            i++;
          }
        }
      }
      gl.xs = [];
      for (var i = 0; i < crdnum; i++) {
        var i8 = (gl.flags[i] & 2) != 0, same = (gl.flags[i] & 16) != 0;
        if (i8) {
          gl.xs.push(same ? data2[offset2] : -data2[offset2]);
          offset2++;
        } else {
          if (same) gl.xs.push(0);
          else {
            gl.xs.push(bin.readShort(data2, offset2));
            offset2 += 2;
          }
        }
      }
      gl.ys = [];
      for (var i = 0; i < crdnum; i++) {
        var i8 = (gl.flags[i] & 4) != 0, same = (gl.flags[i] & 32) != 0;
        if (i8) {
          gl.ys.push(same ? data2[offset2] : -data2[offset2]);
          offset2++;
        } else {
          if (same) gl.ys.push(0);
          else {
            gl.ys.push(bin.readShort(data2, offset2));
            offset2 += 2;
          }
        }
      }
      var x = 0, y = 0;
      for (var i = 0; i < crdnum; i++) {
        x += gl.xs[i];
        y += gl.ys[i];
        gl.xs[i] = x;
        gl.ys[i] = y;
      }
    } else {
      var ARG_1_AND_2_ARE_WORDS = 1 << 0;
      var ARGS_ARE_XY_VALUES = 1 << 1;
      var WE_HAVE_A_SCALE = 1 << 3;
      var MORE_COMPONENTS = 1 << 5;
      var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
      var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
      var WE_HAVE_INSTRUCTIONS = 1 << 8;
      gl.parts = [];
      var flags;
      do {
        flags = bin.readUshort(data2, offset2);
        offset2 += 2;
        var part = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
        gl.parts.push(part);
        part.glyphIndex = bin.readUshort(data2, offset2);
        offset2 += 2;
        if (flags & ARG_1_AND_2_ARE_WORDS) {
          var arg1 = bin.readShort(data2, offset2);
          offset2 += 2;
          var arg2 = bin.readShort(data2, offset2);
          offset2 += 2;
        } else {
          var arg1 = bin.readInt8(data2, offset2);
          offset2++;
          var arg2 = bin.readInt8(data2, offset2);
          offset2++;
        }
        if (flags & ARGS_ARE_XY_VALUES) {
          part.m.tx = arg1;
          part.m.ty = arg2;
        } else {
          part.p1 = arg1;
          part.p2 = arg2;
        }
        if (flags & WE_HAVE_A_SCALE) {
          part.m.a = part.m.d = bin.readF2dot14(data2, offset2);
          offset2 += 2;
        } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
          part.m.a = bin.readF2dot14(data2, offset2);
          offset2 += 2;
          part.m.d = bin.readF2dot14(data2, offset2);
          offset2 += 2;
        } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
          part.m.a = bin.readF2dot14(data2, offset2);
          offset2 += 2;
          part.m.b = bin.readF2dot14(data2, offset2);
          offset2 += 2;
          part.m.c = bin.readF2dot14(data2, offset2);
          offset2 += 2;
          part.m.d = bin.readF2dot14(data2, offset2);
          offset2 += 2;
        }
      } while (flags & MORE_COMPONENTS);
      if (flags & WE_HAVE_INSTRUCTIONS) {
        var numInstr = bin.readUshort(data2, offset2);
        offset2 += 2;
        gl.instr = [];
        for (var i = 0; i < numInstr; i++) {
          gl.instr.push(data2[offset2]);
          offset2++;
        }
      }
    }
    return gl;
  }
};
Typr["T"].head = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readFixed(data2, offset2);
    offset2 += 4;
    obj["fontRevision"] = bin.readFixed(data2, offset2);
    offset2 += 4;
    bin.readUint(data2, offset2);
    offset2 += 4;
    bin.readUint(data2, offset2);
    offset2 += 4;
    obj["flags"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["unitsPerEm"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["created"] = bin.readUint64(data2, offset2);
    offset2 += 8;
    obj["modified"] = bin.readUint64(data2, offset2);
    offset2 += 8;
    obj["xMin"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["yMin"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["xMax"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["yMax"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["macStyle"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["lowestRecPPEM"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["fontDirectionHint"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["indexToLocFormat"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["glyphDataFormat"] = bin.readShort(data2, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].hhea = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readFixed(data2, offset2);
    offset2 += 4;
    var keys = [
      "ascender",
      "descender",
      "lineGap",
      "advanceWidthMax",
      "minLeftSideBearing",
      "minRightSideBearing",
      "xMaxExtent",
      "caretSlopeRise",
      "caretSlopeRun",
      "caretOffset",
      "res0",
      "res1",
      "res2",
      "res3",
      "metricDataFormat",
      "numberOfHMetrics"
    ];
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var func = key == "advanceWidthMax" || key == "numberOfHMetrics" ? bin.readUshort : bin.readShort;
      obj[key] = func(data2, offset2 + i * 2);
    }
    return obj;
  }
};
Typr["T"].hmtx = {
  parseTab: function(data2, offset2, length, font2) {
    var bin = Typr["B"];
    var aWidth = [];
    var lsBearing = [];
    var nG = font2["maxp"]["numGlyphs"], nH = font2["hhea"]["numberOfHMetrics"];
    var aw = 0, lsb = 0, i = 0;
    while (i < nH) {
      aw = bin.readUshort(data2, offset2 + (i << 2));
      lsb = bin.readShort(data2, offset2 + (i << 2) + 2);
      aWidth.push(aw);
      lsBearing.push(lsb);
      i++;
    }
    while (i < nG) {
      aWidth.push(aw);
      lsBearing.push(lsb);
      i++;
    }
    return { aWidth, lsBearing };
  }
};
Typr["T"].kern = {
  parseTab: function(data2, offset2, length, font2) {
    var bin = Typr["B"], kern = Typr["T"].kern;
    var version2 = bin.readUshort(data2, offset2);
    if (version2 == 1) return kern.parseV1(data2, offset2, length, font2);
    var nTables = bin.readUshort(data2, offset2 + 2);
    offset2 += 4;
    var map2 = { glyph1: [], rval: [] };
    for (var i = 0; i < nTables; i++) {
      offset2 += 2;
      var length = bin.readUshort(data2, offset2);
      offset2 += 2;
      var coverage = bin.readUshort(data2, offset2);
      offset2 += 2;
      var format = coverage >>> 8;
      format &= 15;
      if (format == 0) offset2 = kern.readFormat0(data2, offset2, map2);
    }
    return map2;
  },
  parseV1: function(data2, offset2, length, font2) {
    var bin = Typr["B"], kern = Typr["T"].kern;
    bin.readFixed(data2, offset2);
    var nTables = bin.readUint(data2, offset2 + 4);
    offset2 += 8;
    var map2 = { glyph1: [], rval: [] };
    for (var i = 0; i < nTables; i++) {
      bin.readUint(data2, offset2);
      offset2 += 4;
      var coverage = bin.readUshort(data2, offset2);
      offset2 += 2;
      bin.readUshort(data2, offset2);
      offset2 += 2;
      var format = coverage & 255;
      if (format == 0) offset2 = kern.readFormat0(data2, offset2, map2);
    }
    return map2;
  },
  readFormat0: function(data2, offset2, map2) {
    var bin = Typr["B"], rUs = bin.readUshort;
    var pleft = -1;
    var nPairs = rUs(data2, offset2);
    rUs(data2, offset2 + 2);
    rUs(data2, offset2 + 4);
    rUs(data2, offset2 + 6);
    offset2 += 8;
    for (var j2 = 0; j2 < nPairs; j2++) {
      var left = rUs(data2, offset2);
      offset2 += 2;
      var right = rUs(data2, offset2);
      offset2 += 2;
      var value = bin.readShort(data2, offset2);
      offset2 += 2;
      if (left != pleft) {
        map2.glyph1.push(left);
        map2.rval.push({ glyph2: [], vals: [] });
      }
      var rval = map2.rval[map2.rval.length - 1];
      rval.glyph2.push(right);
      rval.vals.push(value);
      pleft = left;
    }
    return offset2;
  }
};
Typr["T"].loca = {
  parseTab: function(data2, offset2, length, font2) {
    var bin = Typr["B"];
    var obj = [];
    var ver = font2["head"]["indexToLocFormat"];
    var len = font2["maxp"]["numGlyphs"] + 1;
    if (ver == 0) for (var i = 0; i < len; i++) obj.push(bin.readUshort(data2, offset2 + (i << 1)) << 1);
    if (ver == 1) for (var i = 0; i < len; i++) obj.push(bin.readUint(data2, offset2 + (i << 2)));
    return obj;
  }
};
Typr["T"].maxp = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"], rU = bin.readUshort;
    var obj = {};
    bin.readUint(data2, offset2);
    offset2 += 4;
    obj["numGlyphs"] = rU(data2, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].name = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readUshort(data2, offset2);
    offset2 += 2;
    var count = bin.readUshort(data2, offset2);
    offset2 += 2;
    var stringOffset = bin.readUshort(data2, offset2);
    offset2 += 2;
    var ooo = offset2 - 6 + stringOffset;
    var names = [
      "copyright",
      "fontFamily",
      "fontSubfamily",
      "ID",
      "fullName",
      "version",
      "postScriptName",
      "trademark",
      "manufacturer",
      "designer",
      "description",
      "urlVendor",
      "urlDesigner",
      "licence",
      "licenceURL",
      "---",
      "typoFamilyName",
      "typoSubfamilyName",
      "compatibleFull",
      "sampleText",
      "postScriptCID",
      "wwsFamilyName",
      "wwsSubfamilyName",
      "lightPalette",
      "darkPalette"
    ];
    var rU = bin.readUshort;
    for (var i = 0; i < count; i++) {
      var platformID = rU(data2, offset2);
      offset2 += 2;
      var encodingID = rU(data2, offset2);
      offset2 += 2;
      var languageID = rU(data2, offset2);
      offset2 += 2;
      var nameID = rU(data2, offset2);
      offset2 += 2;
      var slen = rU(data2, offset2);
      offset2 += 2;
      var noffset = rU(data2, offset2);
      offset2 += 2;
      var soff = ooo + noffset;
      var str;
      if (platformID == 0) str = bin.readUnicode(data2, soff, slen / 2);
      else if (platformID == 3 && encodingID == 0) str = bin.readUnicode(data2, soff, slen / 2);
      else if (platformID == 1 && encodingID == 25) str = bin.readUnicode(data2, soff, slen / 2);
      else if (encodingID == 0) str = bin.readASCII(data2, soff, slen);
      else if (encodingID == 1) str = bin.readUnicode(data2, soff, slen / 2);
      else if (encodingID == 3) str = bin.readUnicode(data2, soff, slen / 2);
      else if (encodingID == 4) str = bin.readUnicode(data2, soff, slen / 2);
      else if (encodingID == 5) str = bin.readUnicode(data2, soff, slen / 2);
      else if (encodingID == 10) str = bin.readUnicode(data2, soff, slen / 2);
      else if (platformID == 1) {
        str = bin.readASCII(data2, soff, slen);
        console.log("reading unknown MAC encoding " + encodingID + " as ASCII");
      } else {
        console.log("unknown encoding " + encodingID + ", platformID: " + platformID);
        str = bin.readASCII(data2, soff, slen);
      }
      var tid = "p" + platformID + "," + languageID.toString(16);
      if (obj[tid] == null) obj[tid] = {};
      var name = names[nameID];
      if (name == null) name = "_" + nameID;
      obj[tid][name] = str;
      obj[tid]["_lang"] = languageID;
    }
    var out = Typr["T"].name.selectOne(obj), ff = "fontFamily";
    if (out[ff] == null) {
      for (var p2 in obj) if (obj[p2][ff] != null) out[ff] = obj[p2][ff];
    }
    return out;
  },
  selectOne: function(obj) {
    var psn = "postScriptName";
    for (var p2 in obj) if (obj[p2][psn] != null && obj[p2]["_lang"] == 1033) return obj[p2];
    for (var p2 in obj) if (obj[p2][psn] != null && obj[p2]["_lang"] == 0) return obj[p2];
    for (var p2 in obj) if (obj[p2][psn] != null && obj[p2]["_lang"] == 3084) return obj[p2];
    for (var p2 in obj) if (obj[p2][psn] != null) return obj[p2];
    var out;
    for (var p2 in obj) {
      out = obj[p2];
      break;
    }
    console.log("returning name table with languageID " + out._lang);
    if (out[psn] == null && out["ID"] != null) out[psn] = out["ID"];
    return out;
  }
};
Typr["T"].OS2 = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var ver = bin.readUshort(data2, offset2);
    offset2 += 2;
    var OS2 = Typr["T"].OS2;
    var obj = {};
    if (ver == 0) OS2.version0(data2, offset2, obj);
    else if (ver == 1) OS2.version1(data2, offset2, obj);
    else if (ver == 2 || ver == 3 || ver == 4) OS2.version2(data2, offset2, obj);
    else if (ver == 5) OS2.version5(data2, offset2, obj);
    else throw "unknown OS/2 table version: " + ver;
    return obj;
  },
  version0: function(data2, offset2, obj) {
    var bin = Typr["B"];
    obj["xAvgCharWidth"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["usWeightClass"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["usWidthClass"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["fsType"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["ySubscriptXSize"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["ySubscriptYSize"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["ySubscriptXOffset"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["ySubscriptYOffset"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["ySuperscriptXSize"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["ySuperscriptYSize"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["ySuperscriptXOffset"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["ySuperscriptYOffset"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["yStrikeoutSize"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["yStrikeoutPosition"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["sFamilyClass"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["panose"] = bin.readBytes(data2, offset2, 10);
    offset2 += 10;
    obj["ulUnicodeRange1"] = bin.readUint(data2, offset2);
    offset2 += 4;
    obj["ulUnicodeRange2"] = bin.readUint(data2, offset2);
    offset2 += 4;
    obj["ulUnicodeRange3"] = bin.readUint(data2, offset2);
    offset2 += 4;
    obj["ulUnicodeRange4"] = bin.readUint(data2, offset2);
    offset2 += 4;
    obj["achVendID"] = bin.readASCII(data2, offset2, 4);
    offset2 += 4;
    obj["fsSelection"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["usFirstCharIndex"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["usLastCharIndex"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["sTypoAscender"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["sTypoDescender"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["sTypoLineGap"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["usWinAscent"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    obj["usWinDescent"] = bin.readUshort(data2, offset2);
    offset2 += 2;
    return offset2;
  },
  version1: function(data2, offset2, obj) {
    var bin = Typr["B"];
    offset2 = Typr["T"].OS2.version0(data2, offset2, obj);
    obj["ulCodePageRange1"] = bin.readUint(data2, offset2);
    offset2 += 4;
    obj["ulCodePageRange2"] = bin.readUint(data2, offset2);
    offset2 += 4;
    return offset2;
  },
  version2: function(data2, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUshort;
    offset2 = Typr["T"].OS2.version1(data2, offset2, obj);
    obj["sxHeight"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["sCapHeight"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["usDefault"] = rU(data2, offset2);
    offset2 += 2;
    obj["usBreak"] = rU(data2, offset2);
    offset2 += 2;
    obj["usMaxContext"] = rU(data2, offset2);
    offset2 += 2;
    return offset2;
  },
  version5: function(data2, offset2, obj) {
    var rU = Typr["B"].readUshort;
    offset2 = Typr["T"].OS2.version2(data2, offset2, obj);
    obj["usLowerOpticalPointSize"] = rU(data2, offset2);
    offset2 += 2;
    obj["usUpperOpticalPointSize"] = rU(data2, offset2);
    offset2 += 2;
    return offset2;
  }
};
Typr["T"].post = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    obj["version"] = bin.readFixed(data2, offset2);
    offset2 += 4;
    obj["italicAngle"] = bin.readFixed(data2, offset2);
    offset2 += 4;
    obj["underlinePosition"] = bin.readShort(data2, offset2);
    offset2 += 2;
    obj["underlineThickness"] = bin.readShort(data2, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].SVG = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var obj = { entries: [], svgs: [] };
    var offset0 = offset2;
    bin.readUshort(data2, offset2);
    offset2 += 2;
    var svgDocIndexOffset = bin.readUint(data2, offset2);
    offset2 += 4;
    bin.readUint(data2, offset2);
    offset2 += 4;
    offset2 = svgDocIndexOffset + offset0;
    var numEntries = bin.readUshort(data2, offset2);
    offset2 += 2;
    for (var i = 0; i < numEntries; i++) {
      var startGlyphID = bin.readUshort(data2, offset2);
      offset2 += 2;
      var endGlyphID = bin.readUshort(data2, offset2);
      offset2 += 2;
      var svgDocOffset = bin.readUint(data2, offset2);
      offset2 += 4;
      var svgDocLength = bin.readUint(data2, offset2);
      offset2 += 4;
      var sbuf = new Uint8Array(data2.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);
      if (sbuf[0] == 31 && sbuf[1] == 139 && sbuf[2] == 8) sbuf = pako["inflate"](sbuf);
      var svg = bin.readUTF8(sbuf, 0, sbuf.length);
      for (var f = startGlyphID; f <= endGlyphID; f++) {
        obj.entries[f] = obj.svgs.length;
      }
      obj.svgs.push(svg);
    }
    return obj;
  }
};
Typr["T"].sbix = {
  parseTab: function(data2, offset2, length, obj) {
    var numGlyphs = obj["maxp"]["numGlyphs"];
    var ooff = offset2;
    var bin = Typr["B"];
    var numStrikes = bin.readUint(data2, offset2 + 4);
    var out = [];
    for (var si = numStrikes - 1; si < numStrikes; si++) {
      var off = ooff + bin.readUint(data2, offset2 + 8 + si * 4);
      for (var gi = 0; gi < numGlyphs; gi++) {
        var aoff = bin.readUint(data2, off + 4 + gi * 4);
        var noff = bin.readUint(data2, off + 4 + gi * 4 + 4);
        if (aoff == noff) {
          out[gi] = null;
          continue;
        }
        var go = off + aoff;
        var tag = bin.readASCII(data2, go + 4, 4);
        if (tag != "png ") throw tag;
        out[gi] = new Uint8Array(data2.buffer, data2.byteOffset + go + 8, noff - aoff - 8);
      }
    }
    return out;
  }
};
Typr["T"].colr = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var ooff = offset2;
    offset2 += 2;
    var num = bin.readUshort(data2, offset2);
    offset2 += 2;
    var boff = bin.readUint(data2, offset2);
    offset2 += 4;
    var loff = bin.readUint(data2, offset2);
    offset2 += 4;
    var lnum = bin.readUshort(data2, offset2);
    offset2 += 2;
    var base2 = {};
    var coff = ooff + boff;
    for (var i = 0; i < num; i++) {
      base2["g" + bin.readUshort(data2, coff)] = [bin.readUshort(data2, coff + 2), bin.readUshort(data2, coff + 4)];
      coff += 6;
    }
    var lays = [];
    coff = ooff + loff;
    for (var i = 0; i < lnum; i++) {
      lays.push(bin.readUshort(data2, coff), bin.readUshort(data2, coff + 2));
      coff += 4;
    }
    return [base2, lays];
  }
};
Typr["T"].cpal = {
  parseTab: function(data2, offset2, length) {
    var bin = Typr["B"];
    var ooff = offset2;
    var vsn = bin.readUshort(data2, offset2);
    offset2 += 2;
    if (vsn == 0) {
      bin.readUshort(data2, offset2);
      offset2 += 2;
      bin.readUshort(data2, offset2);
      offset2 += 2;
      var tot = bin.readUshort(data2, offset2);
      offset2 += 2;
      var fst = bin.readUint(data2, offset2);
      offset2 += 4;
      return new Uint8Array(data2.buffer, ooff + fst, tot * 4);
    } else throw vsn;
  }
};
Typr["T"].GSUB = {
  parseTab: function(data2, offset2, length, obj) {
    var bin = Typr["B"], rU = bin.readUshort;
    bin.readUint;
    var off = offset2;
    rU(data2, off);
    off += 2;
    rU(data2, off);
    off += 2;
    rU(data2, off);
    off += 2;
    var flO = rU(data2, off);
    off += 2;
    rU(data2, off);
    off += 2;
    off = offset2 + flO;
    var fmap = {};
    var cnt = rU(data2, off);
    off += 2;
    for (var i = 0; i < cnt; i++) {
      var tag = bin.readASCII(data2, off, 4);
      off += 4;
      rU(data2, off);
      off += 2;
      fmap[tag] = true;
    }
    return fmap;
  }
};
Typr["T"].fvar = {
  parseTab: function(data2, offset2, length, obj) {
    var name = obj["name"];
    var off = offset2;
    var bin = Typr["B"];
    var axes = [], inst = [];
    off += 8;
    var acnt = bin.readUshort(data2, off);
    off += 2;
    off += 2;
    var icnt = bin.readUshort(data2, off);
    off += 2;
    var isiz = bin.readUshort(data2, off);
    off += 2;
    for (var i = 0; i < acnt; i++) {
      var tag = bin.readASCII(data2, off, 4);
      var min = bin.readFixed(data2, off + 4);
      var def = bin.readFixed(data2, off + 8);
      var max = bin.readFixed(data2, off + 12);
      var flg = bin.readUshort(data2, off + 16);
      var nid = bin.readUshort(data2, off + 18);
      axes.push([tag, min, def, max, flg, name["_" + nid]]);
      off += 20;
    }
    for (var i = 0; i < icnt; i++) {
      var snid = bin.readUshort(data2, off), pnid = null;
      var flg = bin.readUshort(data2, off + 2);
      var crd = [];
      for (var j2 = 0; j2 < acnt; j2++) crd.push(bin.readFixed(data2, off + 4 + j2 * 4));
      off += 4 + acnt * 4;
      if ((isiz & 3) == 2) {
        pnid = bin.readUshort(data2, off);
        off += 2;
      }
      inst.push([name["_" + snid], flg, crd, pnid]);
    }
    return [axes, inst];
  }
};
Typr["T"].gvar = (function() {
  var EMBEDDED_PEAK_TUPLE = 32768;
  var INTERMEDIATE_REGION = 16384;
  var PRIVATE_POINT_NUMBERS = 8192;
  var DELTAS_ARE_ZERO = 128;
  var DELTAS_ARE_WORDS = 64;
  var POINTS_ARE_WORDS = 128;
  var SHARED_POINT_NUMBERS = 32768;
  var bin = Typr["B"];
  function readTuple(data2, o, acnt) {
    var tup = [];
    for (var j2 = 0; j2 < acnt; j2++) tup.push(bin.readF2dot14(data2, o + j2 * 2));
    return tup;
  }
  function readTupleVarHeader(data2, off, vcnt, acnt, eoff) {
    var out = [];
    for (var j2 = 0; j2 < vcnt; j2++) {
      var dsiz = bin.readUshort(data2, off);
      off += 2;
      var tind = bin.readUshort(data2, off), flag = tind & 61440;
      tind = tind & 4095;
      off += 2;
      var peak = null, start2 = null, end = null;
      if (flag & EMBEDDED_PEAK_TUPLE) {
        peak = readTuple(data2, off, acnt);
        off += acnt * 2;
      }
      if (flag & INTERMEDIATE_REGION) {
        start2 = readTuple(data2, off, acnt);
        off += acnt * 2;
      }
      if (flag & INTERMEDIATE_REGION) {
        end = readTuple(data2, off, acnt);
        off += acnt * 2;
      }
      out.push([dsiz, tind, flag, start2, peak, end]);
    }
    return out;
  }
  function readPointNumbers(data2, off, gid) {
    var cnt = data2[off];
    off++;
    if (cnt == 0) return [[], off];
    if (127 < cnt) {
      cnt = (cnt & 127) << 8 | data2[off++];
    }
    var pts = [], last2 = 0;
    while (pts.length < cnt) {
      var v = data2[off];
      off++;
      var wds = (v & POINTS_ARE_WORDS) != 0;
      v = (v & 127) + 1;
      for (var i = 0; i < v; i++) {
        var dif = 0;
        if (wds) {
          dif = bin.readUshort(data2, off);
          off += 2;
        } else {
          dif = data2[off];
          off++;
        }
        last2 += dif;
        pts.push(last2);
      }
    }
    return [pts, off];
  }
  function parseTab(data2, offset2, length, obj) {
    var off = offset2 + 4;
    var acnt = bin.readUshort(data2, off);
    off += 2;
    var tcnt = bin.readUshort(data2, off);
    off += 2;
    var toff = bin.readUint(data2, off);
    off += 4;
    var gcnt = bin.readUshort(data2, off);
    off += 2;
    bin.readUshort(data2, off);
    off += 2;
    var goff = bin.readUint(data2, off);
    off += 4;
    var offs = [];
    for (var i = 0; i < gcnt + 1; i++) offs.push(bin.readUint(data2, off + i * 4));
    var tups = [], mins = [], maxs = [];
    off = offset2 + toff;
    for (var i = 0; i < tcnt; i++) {
      var peak = readTuple(data2, off + i * acnt * 2, acnt), imin = [], imax = [];
      tups.push(peak);
      mins.push(imin);
      maxs.push(imax);
      for (var k = 0; k < acnt; k++) {
        imin[k] = Math.min(peak[k], 0);
        imax[k] = Math.max(peak[k], 0);
      }
    }
    var i8 = new Int8Array(data2.buffer);
    var tabs = [];
    for (var i = 0; i < gcnt; i++) {
      off = offset2 + goff + offs[i];
      var vcnt = bin.readUshort(data2, off);
      off += 2;
      var snum = vcnt & SHARED_POINT_NUMBERS;
      vcnt &= 4095;
      var soff = bin.readUshort(data2, off);
      off += 2;
      var hdr = readTupleVarHeader(data2, off, vcnt, acnt);
      var tab = [];
      tabs.push(tab);
      off = offset2 + goff + offs[i] + soff;
      var sind = null;
      if (snum) {
        var oo = readPointNumbers(data2, off);
        sind = oo[0];
        off = oo[1];
      }
      for (var j2 = 0; j2 < vcnt; j2++) {
        var vr = hdr[j2], end = off + vr[0];
        var ind = sind;
        if (vr[2] & PRIVATE_POINT_NUMBERS) {
          var oo = readPointNumbers(data2, off);
          ind = oo[0];
          off = oo[1];
        }
        var ds = [];
        while (off < end) {
          var cb = data2[off++];
          var cnt = (cb & 63) + 1;
          if (cb & DELTAS_ARE_ZERO) {
            for (var k = 0; k < cnt; k++) ds.push(0);
          } else if (cb & DELTAS_ARE_WORDS) {
            for (var k = 0; k < cnt; k++) ds.push(bin.readShort(data2, off + k * 2));
            off += cnt * 2;
          } else {
            for (var k = 0; k < cnt; k++) ds.push(i8[off + k]);
            off += cnt;
          }
        }
        var ti = vr[1];
        tab.push([[
          vr[3] ? vr[3] : mins[ti],
          vr[4] ? vr[4] : tups[ti],
          vr[5] ? vr[5] : maxs[ti]
        ], ds, ind.length == 0 ? null : ind]);
        if (ind.length != 0 && ind.length * 2 != ds.length) throw "e";
      }
    }
    return tabs;
  }
  return { parseTab };
})();
Typr["T"].avar = {
  parseTab: function(data2, offset2, length, obj) {
    var off = offset2;
    var bin = Typr["B"], out = [];
    off += 6;
    var acnt = bin.readUshort(data2, off);
    off += 2;
    for (var ai = 0; ai < acnt; ai++) {
      var cnt = bin.readUshort(data2, off);
      off += 2;
      var poly = [];
      out.push(poly);
      for (var i = 0; i < cnt; i++) {
        var x = bin.readF2dot14(data2, off);
        var y = bin.readF2dot14(data2, off + 2);
        off += 4;
        poly.push(x, y);
      }
    }
    return out;
  }
};
Typr["T"].HVAR = {
  parseTab: function(data2, offset2, length, obj) {
    var off = offset2, oo = offset2;
    var bin = Typr["B"];
    off += 4;
    var varO = bin.readUint(data2, off);
    off += 4;
    var advO = bin.readUint(data2, off);
    off += 4;
    var lsbO = bin.readUint(data2, off);
    off += 4;
    var rsbO = bin.readUint(data2, off);
    off += 4;
    if (lsbO != 0 || rsbO != 0) throw lsbO;
    off = oo + varO;
    var ioff = off;
    var fmt = bin.readUshort(data2, off);
    off += 2;
    if (fmt != 1) throw "e";
    var vregO = bin.readUint(data2, off);
    off += 4;
    var vcnt = bin.readUshort(data2, off);
    off += 2;
    var offs = [];
    for (var i = 0; i < vcnt; i++) offs.push(bin.readUint(data2, off + i * 4));
    off += vcnt * 4;
    off = ioff + vregO;
    var acnt = bin.readUshort(data2, off);
    off += 2;
    var rcnt = bin.readUshort(data2, off);
    off += 2;
    var regs = [];
    for (var i = 0; i < rcnt; i++) {
      var crd = [[], [], []];
      regs.push(crd);
      for (var j2 = 0; j2 < acnt; j2++) {
        crd[0].push(bin.readF2dot14(data2, off + 0));
        crd[1].push(bin.readF2dot14(data2, off + 2));
        crd[2].push(bin.readF2dot14(data2, off + 4));
        off += 6;
      }
    }
    var i8 = new Int8Array(data2.buffer);
    var varStore = [];
    for (var i = 0; i < offs.length; i++) {
      off = oo + varO + offs[i];
      var vdata = [];
      varStore.push(vdata);
      var icnt = bin.readUshort(data2, off);
      off += 2;
      var dcnt = bin.readUshort(data2, off);
      off += 2;
      if (dcnt & 32768) throw "e";
      var rcnt = bin.readUshort(data2, off);
      off += 2;
      var ixs = [];
      for (var j2 = 0; j2 < rcnt; j2++) ixs.push(bin.readUshort(data2, off + j2 * 2));
      off += rcnt * 2;
      for (var k = 0; k < icnt; k++) {
        var deltaData = [];
        for (var ri = 0; ri < rcnt; ri++) {
          deltaData.push(ri < dcnt ? bin.readShort(data2, off) : i8[off]);
          off += ri < dcnt ? 2 : 1;
        }
        var dd = new Array(regs.length);
        dd.fill(0);
        vdata.push(dd);
        for (var j2 = 0; j2 < ixs.length; j2++) dd[ixs[j2]] = deltaData[j2];
      }
    }
    off = oo + advO;
    var fmt = data2[off++];
    if (fmt != 0) throw "e";
    var entryFormat = data2[off++];
    var mapCount = bin.readUshort(data2, off);
    off += 2;
    var INNER_INDEX_BIT_COUNT_MASK = 15;
    var MAP_ENTRY_SIZE_MASK = 48;
    var entrySize = ((entryFormat & MAP_ENTRY_SIZE_MASK) >> 4) + 1;
    var dfs = [];
    for (var i = 0; i < mapCount; i++) {
      var entry = 0;
      if (entrySize == 1) entry = data2[off++];
      else {
        entry = bin.readUshort(data2, off);
        off += 2;
      }
      var outerIndex = entry >> (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1;
      var innerIndex = entry & (1 << (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1) - 1;
      dfs.push(varStore[outerIndex][innerIndex]);
    }
    return [regs, dfs];
  }
};
Typr["U"] = (function() {
  var P = {
    MoveTo: function(p2, x, y) {
      p2.cmds.push("M");
      p2.crds.push(x, y);
    },
    LineTo: function(p2, x, y) {
      p2.cmds.push("L");
      p2.crds.push(x, y);
    },
    CurveTo: function(p2, a, b2, c, d2, e2, f) {
      p2.cmds.push("C");
      p2.crds.push(a, b2, c, d2, e2, f);
    },
    qCurveTo: function(p2, a, b2, c, d2) {
      p2.cmds.push("Q");
      p2.crds.push(a, b2, c, d2);
    },
    ClosePath: function(p2) {
      p2.cmds.push("Z");
    }
  };
  function getGlyphPosition(font2, gls, i1, ltr) {
    var g1 = gls[i1], g2 = gls[i1 + 1], kern = font2["kern"];
    if (kern) {
      var ind1 = kern.glyph1.indexOf(g1);
      if (ind1 != -1) {
        var ind2 = kern.rval[ind1].glyph2.indexOf(g2);
        if (ind2 != -1) return [0, 0, kern.rval[ind1].vals[ind2], 0];
      }
    }
    return [0, 0, 0, 0];
  }
  function shape2(font2, str, prm) {
    if (prm == null) prm = {};
    prm["ltr"];
    prm["fts"];
    var axs = prm["axs"];
    if (font2["fvar"] && axs == null) axs = font2["fvar"][1][font2["_index"]][2];
    var HVAR = font2["HVAR"];
    if (axs && HVAR) {
      axs = _normalizeAxis(font2, axs);
    }
    var gls = [];
    for (var i2 = 0; i2 < str.length; i2++) {
      var cc = str.codePointAt(i2);
      if (cc > 65535) i2++;
      gls.push(codeToGlyph(font2, cc));
    }
    var shape3 = [];
    for (var i2 = 0; i2 < gls.length; i2++) {
      var padj = getGlyphPosition(font2, gls, i2);
      var gid = gls[i2];
      var ax = font2["hmtx"].aWidth[gid] + padj[2];
      if (HVAR && HVAR[1][gid]) {
        var difs = HVAR[1][gid];
        for (var j2 = 0; j2 < HVAR[0].length; j2++) {
          ax += _interpolate(HVAR[0][j2], axs) * difs[j2];
        }
      }
      shape3.push({ "g": gid, "cl": i2, "dx": 0, "dy": 0, "ax": ax, "ay": 0 });
    }
    return shape3;
  }
  function shapeToPath(font2, shape3, prm) {
    var tpath = { cmds: [], crds: [] };
    var x = 0, y = 0, clr, axs;
    if (prm) {
      clr = prm["clr"];
      axs = prm["axs"];
    }
    for (var i2 = 0; i2 < shape3.length; i2++) {
      var it2 = shape3[i2];
      var path2 = glyphToPath(font2, it2["g"], false, axs), crds = path2["crds"];
      for (var j2 = 0; j2 < crds.length; j2 += 2) {
        tpath.crds.push(crds[j2] + x + it2["dx"]);
        tpath.crds.push(crds[j2 + 1] + y + it2["dy"]);
      }
      if (clr) tpath.cmds.push(clr);
      for (var j2 = 0; j2 < path2["cmds"].length; j2++) tpath.cmds.push(path2["cmds"][j2]);
      var clen = tpath.cmds.length;
      if (clr) {
        if (clen != 0 && tpath.cmds[clen - 1] != "X") tpath.cmds.push("X");
      }
      x += it2["ax"];
      y += it2["ay"];
    }
    return { "cmds": tpath.cmds, "crds": tpath.crds };
  }
  function arrSearch(arr2, k, v) {
    var l = 0, r = ~~(arr2.length / k);
    while (l + 1 != r) {
      var mid = l + (r - l >>> 1);
      if (arr2[mid * k] <= v) l = mid;
      else r = mid;
    }
    return l * k;
  }
  var wha = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 6158, 8232, 8233, 8239, 8288, 12288, 65279], whm = {};
  for (var i = 0; i < wha.length; i++) whm[wha[i]] = 1;
  for (var i = 8192; i <= 8205; i++) whm[i] = 1;
  function codeToGlyph(font2, code2) {
    if (font2["_ctab"] == null) {
      var cmap = font2["cmap"];
      var tind = -1, pps = [
        "p3e10",
        "p0e4",
        "p3e1",
        "p1e0",
        "p0e3",
        "p0e1",
        "p3e0",
        "p3e5"
        /*Korean*/
      ];
      for (var i2 = 0; i2 < pps.length; i2++) if (cmap.ids[pps[i2]] != null) {
        tind = cmap.ids[pps[i2]];
        break;
      }
      if (tind == -1) throw "no familiar platform and encoding!";
      font2["_ctab"] = cmap.tables[tind];
    }
    var tab = font2["_ctab"], fmt = tab.format, gid = -1;
    if (fmt == 0) {
      if (code2 >= tab.map.length) gid = 0;
      else gid = tab.map[code2];
    } else if (fmt == 4) {
      var ec = tab.endCount;
      gid = 0;
      if (code2 <= ec[ec.length - 1]) {
        var sind = arrSearch(ec, 1, code2);
        if (ec[sind] < code2) sind++;
        if (code2 >= tab.startCount[sind]) {
          var gli = 0;
          if (tab.idRangeOffset[sind] != 0) gli = tab.glyphIdArray[code2 - tab.startCount[sind] + (tab.idRangeOffset[sind] >> 1) - (tab.idRangeOffset.length - sind)];
          else gli = code2 + tab.idDelta[sind];
          gid = gli & 65535;
        }
      }
    } else if (fmt == 6) {
      var off = code2 - tab.firstCode, arr2 = tab.glyphIdArray;
      if (off < 0 || off >= arr2.length) gid = 0;
      else gid = arr2[off];
    } else if (fmt == 12) {
      var grp = tab.groups;
      gid = 0;
      if (code2 <= grp[grp.length - 2]) {
        var i2 = arrSearch(grp, 3, code2);
        if (grp[i2] <= code2 && code2 <= grp[i2 + 1]) {
          gid = grp[i2 + 2] + (code2 - grp[i2]);
        }
      }
    } else throw "unknown cmap table format " + tab.format;
    var SVG = font2["SVG "], loca = font2["loca"];
    if (gid != 0 && font2["CFF "] == null && (SVG == null || SVG.entries[gid] == null) && loca && loca[gid] == loca[gid + 1] && whm[code2] == null) gid = 0;
    return gid;
  }
  function glyphToPath(font2, gid, noColor, axs) {
    var path2 = { cmds: [], crds: [] };
    if (font2["fvar"]) {
      if (axs == null) axs = font2["fvar"][1][font2["_index"]][2];
      axs = _normalizeAxis(font2, axs);
    }
    var SVG = font2["SVG "], CFF = font2["CFF "], COLR = font2["COLR"], CBLC = font2["CBLC"], CBDT = font2["CBDT"], sbix = font2["sbix"], upng = window["UPNG"];
    var strike = null;
    if (CBLC && upng) {
      for (var i2 = 0; i2 < CBLC.length; i2++) if (CBLC[i2][0] <= gid && gid <= CBLC[i2][1]) strike = CBLC[i2];
    }
    if (strike || sbix && sbix[gid]) {
      if (strike && strike[2] != 17) throw "not a PNG";
      if (font2["__tmp"] == null) font2["__tmp"] = {};
      var cmd = font2["__tmp"]["g" + gid];
      if (cmd == null) {
        var bmp, len;
        if (sbix) {
          bmp = sbix[gid];
          len = bmp.length;
        } else {
          var boff = strike[3][gid - strike[0]] + 5;
          len = CBDT[boff + 1] << 16 | CBDT[boff + 2] << 8 | CBDT[boff + 3];
          boff += 4;
          bmp = new Uint8Array(CBDT.buffer, CBDT.byteOffset + boff, len);
        }
        var str = "";
        for (var i2 = 0; i2 < len; i2++) str += String.fromCharCode(bmp[i2]);
        cmd = font2["__tmp"]["g" + gid] = "data:image/png;base64," + btoa(str);
      }
      path2.cmds.push(cmd);
      var upe = font2["head"]["unitsPerEm"] * 1.15;
      var gw = Math.round(upe), gh = Math.round(upe), dy = Math.round(-gh * 0.15);
      path2.crds.push(0, gh + dy, gw, gh + dy, gw, dy, 0, dy);
    } else if (SVG && SVG.entries[gid]) {
      var p2 = SVG.entries[gid];
      if (p2 != null) {
        if (typeof p2 == "number") {
          var svg = SVG.svgs[p2];
          if (typeof svg == "string") {
            var prsr = new DOMParser();
            var doc = prsr["parseFromString"](svg, "image/svg+xml");
            svg = SVG.svgs[p2] = doc.getElementsByTagName("svg")[0];
          }
          p2 = Typr["U"]["SVG"].toPath(svg, gid);
          SVG.entries[gid] = p2;
        }
        path2 = p2;
      }
    } else if (noColor != true && COLR && COLR[0]["g" + gid] && COLR[0]["g" + gid][1] > 1) {
      let toHex2 = function(n2) {
        var o = n2.toString(16);
        return (o.length == 1 ? "0" : "") + o;
      };
      var toHex = toHex2;
      var CPAL = font2["CPAL"], gl = COLR[0]["g" + gid];
      for (var i2 = 0; i2 < gl[1]; i2++) {
        var lid = gl[0] + i2;
        var cgl = COLR[1][2 * lid], pid = COLR[1][2 * lid + 1] * 4;
        var pth = glyphToPath(font2, cgl, cgl == gid);
        var col = "#" + toHex2(CPAL[pid + 2]) + toHex2(CPAL[pid + 1]) + toHex2(CPAL[pid + 0]);
        path2.cmds.push(col);
        path2.cmds = path2.cmds.concat(pth["cmds"]);
        path2.crds = path2.crds.concat(pth["crds"]);
        path2.cmds.push("X");
      }
    } else if (CFF) {
      var pdct = CFF["Private"];
      var state = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: pdct ? pdct["defaultWidthX"] : 0, open: false };
      if (CFF["ROS"]) {
        var gi = 0;
        while (CFF["FDSelect"][gi + 2] <= gid) gi += 2;
        pdct = CFF["FDArray"][CFF["FDSelect"][gi + 1]]["Private"];
      }
      _drawCFF(CFF["CharStrings"][gid], state, CFF, pdct, path2);
    } else if (font2["glyf"]) {
      _drawGlyf(gid, font2, path2, axs);
    }
    return { "cmds": path2.cmds, "crds": path2.crds };
  }
  function _drawGlyf(gid, font2, path2, axs) {
    var gl = font2["glyf"][gid];
    if (gl == null) gl = font2["glyf"][gid] = Typr["T"].glyf._parseGlyf(font2, gid);
    if (gl != null) {
      if (gl.noc > -1) _simpleGlyph(gl, font2, gid, path2, axs);
      else _compoGlyph(gl, font2, gid, path2, axs);
    }
  }
  function _interpolate(axs, v) {
    v.length;
    var S2 = 1;
    var s = axs[0];
    var p2 = axs[1];
    var e2 = axs[2];
    for (var i2 = 0; i2 < v.length; i2++) {
      var AS = 1;
      if (s[i2] > p2[i2] || p2[i2] > e2[i2]) AS = 1;
      else if (s[i2] < 0 && e2[i2] > 0 && p2[i2] != 0) AS = 1;
      else if (p2[i2] == 0) AS = 1;
      else if (v[i2] < s[i2] || v[i2] > e2[i2]) AS = 0;
      else {
        if (v[i2] == p2[i2]) AS = 1;
        else if (v[i2] < p2[i2]) AS = (v[i2] - s[i2]) / (p2[i2] - s[i2]);
        else AS = (e2[i2] - v[i2]) / (e2[i2] - p2[i2]);
      }
      S2 = S2 * AS;
    }
    return S2;
  }
  function _normalizeAxis(font2, vv) {
    var fvar = font2["fvar"], avar = font2["avar"];
    var fv = fvar ? fvar[0] : null;
    var nv = [];
    for (var i2 = 0; i2 < fv.length; i2++) {
      var min = fv[i2][1], def = fv[i2][2], max = fv[i2][3], v = Math.max(min, Math.min(max, vv[i2]));
      if (v < def) nv[i2] = (def - v) / (min - def);
      else if (v > def) nv[i2] = (v - def) / (max - def);
      else nv[i2] = 0;
      if (avar && nv[i2] != -1) {
        var av = avar[i2], j2 = 0;
        for (; j2 < av.length; j2 += 2) if (av[j2] >= nv[i2]) break;
        var f = (nv[i2] - av[j2 - 2]) / (av[j2] - av[j2 - 2]);
        nv[i2] = f * av[j2 + 1] + (1 - f) * av[j2 - 1];
      }
    }
    return nv;
  }
  function interpolateDeltas(dfs, ind, xs, ys, endPts) {
    var N = xs.length, ndfs = new Array(N * 2 + 8);
    ndfs.fill(0);
    for (var i2 = 0; i2 < N; i2++) {
      var dx = 0, dy = 0, ii = ind.indexOf(i2);
      if (ii != -1) {
        dx = dfs[ii];
        dy = dfs[ind.length + ii];
      } else {
        var cmp = 0;
        while (endPts[cmp] < i2) cmp++;
        var cmp0 = cmp == 0 ? 0 : endPts[cmp - 1] + 1;
        var cmp1 = endPts[cmp];
        var i0 = -1, i1 = -1;
        for (var j2 = 0; j2 < ind.length; j2++) {
          var v = ind[j2];
          if (v < cmp0 || v > cmp1 || v >= N) continue;
          i0 = j2;
          if (i1 == -1) i1 = j2;
        }
        for (var j2 = 0; j2 < ind.length; j2++) {
          var v = ind[j2];
          if (v < cmp0 || v > cmp1 || v >= N) continue;
          if (v < i2) i0 = j2;
          if (i2 < v) {
            i1 = j2;
            break;
          }
        }
        for (var ax = 0; ax < 2; ax++) {
          var crd = ax == 0 ? xs : ys, ofs = ax * ind.length, dlt = 0;
          var c0 = crd[ind[i0]], c12 = crd[ind[i1]], cC = crd[i2];
          var d02 = dfs[ofs + i0], d1 = dfs[ofs + i1];
          if (c0 == c12) {
            if (d02 == d1) dlt = d02;
            else dlt = 0;
          } else {
            if (cC <= Math.min(c0, c12)) {
              if (c0 < c12) dlt = d02;
              else dlt = d1;
            } else if (Math.max(c0, c12) <= cC) {
              if (c0 < c12) dlt = d1;
              else dlt = d02;
            } else {
              var prop = (cC - c0) / (c12 - c0);
              dlt = prop * d1 + (1 - prop) * d02;
            }
          }
          if (ax == 0) dx = dlt;
          else dy = dlt;
        }
      }
      ndfs[i2] = dx;
      ndfs[N + 4 + i2] = dy;
    }
    return ndfs;
  }
  function _simpleGlyph(gl, font2, gid, p2, axs) {
    var xs = gl.xs, ys = gl.ys;
    if (font2["fvar"] && axs) {
      xs = xs.slice(0);
      ys = ys.slice(0);
      var gvar = font2["gvar"];
      var gv = gvar ? gvar[gid] : null;
      for (var vi = 0; vi < gv.length; vi++) {
        var axv = gv[vi][0];
        var S2 = _interpolate(axv, axs);
        if (S2 < 1e-9) continue;
        var dfs = gv[vi][1], ind = gv[vi][2];
        if (ind) {
          dfs = gv[vi][1] = interpolateDeltas(dfs, ind, xs, ys, gl.endPts);
          gv[vi][2] = null;
        }
        if (dfs.length == xs.length * 2 + 8)
          for (var i2 = 0; i2 < xs.length; i2++) {
            xs[i2] += S2 * dfs[i2];
            ys[i2] += S2 * dfs[i2 + xs.length + 4];
          }
      }
    }
    for (var c = 0; c < gl.noc; c++) {
      var i0 = c == 0 ? 0 : gl.endPts[c - 1] + 1;
      var il = gl.endPts[c];
      for (var i2 = i0; i2 <= il; i2++) {
        var pr = i2 == i0 ? il : i2 - 1;
        var nx = i2 == il ? i0 : i2 + 1;
        var onCurve = gl.flags[i2] & 1;
        var prOnCurve = gl.flags[pr] & 1;
        var nxOnCurve = gl.flags[nx] & 1;
        var x = xs[i2], y = ys[i2];
        if (i2 == i0) {
          if (onCurve) {
            if (prOnCurve) P.MoveTo(p2, xs[pr], ys[pr]);
            else {
              P.MoveTo(p2, x, y);
              continue;
            }
          } else {
            if (prOnCurve) P.MoveTo(p2, xs[pr], ys[pr]);
            else P.MoveTo(p2, Math.floor((xs[pr] + x) * 0.5), Math.floor((ys[pr] + y) * 0.5));
          }
        }
        if (onCurve) {
          if (prOnCurve) P.LineTo(p2, x, y);
        } else {
          if (nxOnCurve) P.qCurveTo(p2, x, y, xs[nx], ys[nx]);
          else P.qCurveTo(p2, x, y, Math.floor((x + xs[nx]) * 0.5), Math.floor((y + ys[nx]) * 0.5));
        }
      }
      P.ClosePath(p2);
    }
  }
  function _compoGlyph(gl, font2, gid, p2, axs) {
    var dx = [0, 0, 0, 0, 0, 0], dy = [0, 0, 0, 0, 0, 0], ccnt = gl.parts.length;
    if (font2["fvar"] && axs) {
      var gvar = font2["gvar"];
      var gv = gvar ? gvar[gid] : null;
      for (var vi = 0; vi < gv.length; vi++) {
        var axv = gv[vi][0];
        var S2 = _interpolate(axv, axs);
        if (S2 < 1e-6) continue;
        var dfs = gv[vi][1], ind = gv[vi][2];
        if (ind == null)
          for (var i2 = 0; i2 < ccnt; i2++) {
            dx[i2] += S2 * dfs[i2];
            dy[i2] += S2 * dfs[i2 + ccnt + 4];
          }
        else
          for (var j2 = 0; j2 < ind.length; j2++) {
            var i2 = ind[j2];
            dx[i2] += S2 * dfs[0];
            dy[i2] += S2 * dfs[0 + ccnt];
          }
      }
    }
    for (var j2 = 0; j2 < ccnt; j2++) {
      var path2 = { cmds: [], crds: [] };
      var prt = gl.parts[j2];
      _drawGlyf(prt.glyphIndex, font2, path2, axs);
      var m = prt.m, tx = m.tx + dx[j2], ty = m.ty + dy[j2];
      for (var i2 = 0; i2 < path2.crds.length; i2 += 2) {
        var x = path2.crds[i2], y = path2.crds[i2 + 1];
        p2.crds.push(x * m.a + y * m.c + tx);
        p2.crds.push(x * m.b + y * m.d + ty);
      }
      for (var i2 = 0; i2 < path2.cmds.length; i2++) p2.cmds.push(path2.cmds[i2]);
    }
  }
  function pathToSVG(path2, prec) {
    var cmds = path2["cmds"], crds = path2["crds"];
    if (prec == null) prec = 5;
    function num(v) {
      return parseFloat(v.toFixed(prec));
    }
    function merge2(o) {
      var no = [], lstF = false, lstC = "";
      for (var i3 = 0; i3 < o.length; i3++) {
        var it2 = o[i3], isF = typeof it2 == "number";
        if (!isF) {
          if (it2 == lstC && it2.length == 1 && it2 != "m") continue;
          lstC = it2;
        }
        if (lstF && isF && it2 >= 0) no.push(" ");
        no.push(it2);
        lstF = isF;
      }
      return no.join("");
    }
    var out = [], co = 0, lmap = { "M": 2, "L": 2, "Q": 4, "C": 6 };
    var x = 0, y = 0, ex = 0, ey = 0, mx = 0, my = 0;
    for (var i2 = 0; i2 < cmds.length; i2++) {
      var cmd = cmds[i2], cc = lmap[cmd] ? lmap[cmd] : 0;
      var o0 = [], dx, dy, rx, ry;
      if (cmd == "L") {
        dx = crds[co] - x;
        dy = crds[co + 1] - y;
        rx = num(dx + ex);
        ry = num(dy + ey);
        if (cmds[i2 + 1] == "Z" && crds[co] == mx && crds[co + 1] == my) {
          rx = dx;
          ry = dy;
        } else if (rx == 0 && ry == 0) ;
        else if (rx == 0) o0.push("v", ry);
        else if (ry == 0) o0.push("h", rx);
        else {
          o0.push("l", rx, ry);
        }
      } else {
        o0.push(cmd.toLowerCase());
        for (var j2 = 0; j2 < cc; j2 += 2) {
          dx = crds[co + j2] - x;
          dy = crds[co + j2 + 1] - y;
          rx = num(dx + ex);
          ry = num(dy + ey);
          o0.push(rx, ry);
        }
      }
      if (cc != 0) {
        ex += dx - rx;
        ey += dy - ry;
      }
      var ou = o0;
      for (var j2 = 0; j2 < ou.length; j2++) out.push(ou[j2]);
      if (cc != 0) {
        co += cc;
        x = crds[co - 2];
        y = crds[co - 1];
      }
      if (cmd == "M") {
        mx = x;
        my = y;
      }
      if (cmd == "Z") {
        x = mx;
        y = my;
      }
    }
    return merge2(out);
  }
  function SVGToPath(d2) {
    var pth = { cmds: [], crds: [] };
    Typr["U"]["SVG"].svgToPath(d2, pth);
    return { "cmds": pth.cmds, "crds": pth.crds };
  }
  function mipmapB(buff, w, h, hlp) {
    var nw = w >> 1, nh = h >> 1;
    var nbuf = new Uint8Array(nw * nh * 4);
    var sb32 = new Uint32Array(buff.buffer), nb32 = new Uint32Array(nbuf.buffer);
    for (var y = 0; y < nh; y++)
      for (var x = 0; x < nw; x++) {
        var ti = y * nw + x, si = (y << 1) * w + (x << 1);
        var c0 = sb32[si], c12 = sb32[si + 1], c22 = sb32[si + w], c32 = sb32[si + w + 1];
        var a0 = c0 >>> 24, a1 = c12 >>> 24, a2 = c22 >>> 24, a3 = c32 >>> 24, a = a0 + a1 + a2 + a3;
        if (a == 1020) {
          var r = (c0 >>> 0 & 255) + (c12 >>> 0 & 255) + (c22 >>> 0 & 255) + (c32 >>> 0 & 255) + 2 >>> 2;
          var g2 = (c0 >>> 8 & 255) + (c12 >>> 8 & 255) + (c22 >>> 8 & 255) + (c32 >>> 8 & 255) + 2 >>> 2;
          var b2 = (c0 >>> 16 & 255) + (c12 >>> 16 & 255) + (c22 >>> 16 & 255) + (c32 >>> 16 & 255) + 2 >>> 2;
          nb32[ti] = 255 << 24 | b2 << 16 | g2 << 8 | r;
        } else if (a == 0) nb32[ti] = 0;
        else {
          var r = (c0 >>> 0 & 255) * a0 + (c12 >>> 0 & 255) * a1 + (c22 >>> 0 & 255) * a2 + (c32 >>> 0 & 255) * a3;
          var g2 = (c0 >>> 8 & 255) * a0 + (c12 >>> 8 & 255) * a1 + (c22 >>> 8 & 255) * a2 + (c32 >>> 8 & 255) * a3;
          var b2 = (c0 >>> 16 & 255) * a0 + (c12 >>> 16 & 255) * a1 + (c22 >>> 16 & 255) * a2 + (c32 >>> 16 & 255) * a3;
          var ia = 1 / a;
          r = ~~(r * ia + 0.5);
          g2 = ~~(g2 * ia + 0.5);
          b2 = ~~(b2 * ia + 0.5);
          nb32[ti] = a + 2 >>> 2 << 24 | b2 << 16 | g2 << 8 | r;
        }
      }
    return { buff: nbuf, w: nw, h: nh };
  }
  var __cnv, __ct;
  function pathToContext(path2, ctx) {
    var c = 0, cmds = path2["cmds"], crds = path2["crds"];
    for (var j2 = 0; j2 < cmds.length; j2++) {
      var cmd = cmds[j2];
      if (cmd == "M") {
        ctx.moveTo(crds[c], crds[c + 1]);
        c += 2;
      } else if (cmd == "L") {
        ctx.lineTo(crds[c], crds[c + 1]);
        c += 2;
      } else if (cmd == "C") {
        ctx.bezierCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3], crds[c + 4], crds[c + 5]);
        c += 6;
      } else if (cmd == "Q") {
        ctx.quadraticCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3]);
        c += 4;
      } else if (cmd[0] == "d") {
        var upng = window["UPNG"];
        var x0 = crds[c], y0 = crds[c + 1], x1 = crds[c + 2], y1 = crds[c + 3], x2 = crds[c + 4], y2 = crds[c + 5], x3 = crds[c + 6], y3 = crds[c + 7];
        c += 8;
        if (upng == null) {
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.lineTo(x3, y3);
          ctx.closePath();
          continue;
        }
        var dx0 = x1 - x0, dy0 = y1 - y0, dx1 = x3 - x0, dy1 = y3 - y0;
        var sbmp = atob(cmd.slice(22));
        var bmp = new Uint8Array(sbmp.length);
        for (var i2 = 0; i2 < sbmp.length; i2++) bmp[i2] = sbmp.charCodeAt(i2);
        var img = upng["decode"](bmp.buffer), w = img["width"], h = img["height"];
        var nbmp = new Uint8Array(upng["toRGBA8"](img)[0]);
        var tr = ctx["getTransform"]();
        var scl = Math.sqrt(Math.abs(tr["a"] * tr["d"] - tr["b"] * tr["c"])) * Math.sqrt(dx1 * dx1 + dy1 * dy1) / h;
        while (scl < 0.5) {
          var nd = mipmapB(nbmp, w, h);
          nbmp = nd.buff;
          w = nd.w;
          h = nd.h;
          scl *= 2;
        }
        if (__cnv == null) {
          __cnv = document.createElement("canvas");
          __ct = __cnv.getContext("2d");
        }
        if (__cnv.width != w || __cnv.height != h) {
          __cnv.width = w;
          __cnv.height = h;
        }
        __ct.putImageData(new ImageData(new Uint8ClampedArray(nbmp.buffer), w, h), 0, 0);
        ctx.save();
        ctx.transform(dx0, dy0, dx1, dy1, x0, y0);
        ctx.scale(1 / w, 1 / h);
        ctx.drawImage(__cnv, 0, 0);
        ctx.restore();
      } else if (cmd.charAt(0) == "#" || cmd.charAt(0) == "r") {
        ctx.beginPath();
        ctx.fillStyle = cmd;
      } else if (cmd.charAt(0) == "O" && cmd != "OX") {
        ctx.beginPath();
        var pts = cmd.split("-");
        ctx.lineWidth = parseFloat(pts[2]);
        ctx.lineCap = ["butt", "round", "square"][parseFloat(pts[3])];
        ctx.lineJoin = ["miter", "round", "bevel"][parseFloat(pts[4])];
        ctx.miterLimit = parseFloat(pts[5]);
        ctx.lineDashOffset = parseFloat(pts[6]);
        ctx.setLineDash(pts[7].split(",").map(parseFloat));
        ctx.strokeStyle = pts[1];
      } else if (cmd == "Z") {
        ctx.closePath();
      } else if (cmd == "X") {
        ctx.fill();
      } else if (cmd == "OX") {
        ctx.stroke();
      }
    }
  }
  function _drawCFF(cmds, state, font2, pdct, p2) {
    var stack = state.stack;
    var nStems = state.nStems, haveWidth = state.haveWidth, width = state.width, open = state.open;
    var i2 = 0;
    var x = state.x, y = state.y, c1x = 0, c1y = 0, c2x = 0, c2y = 0, c3x = 0, c3y = 0, c4x = 0, c4y = 0, jpx = 0, jpy = 0;
    var CFF = Typr["T"].CFF;
    var nominalWidthX = pdct["nominalWidthX"];
    var o = { val: 0, size: 0 };
    while (i2 < cmds.length) {
      CFF.getCharString(cmds, i2, o);
      var v = o.val;
      i2 += o.size;
      if (v == "o1" || v == "o18") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
      } else if (v == "o3" || v == "o23") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
      } else if (v == "o4") {
        if (stack.length > 1 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        if (open) P.ClosePath(p2);
        y += stack.pop();
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o5") {
        while (stack.length > 0) {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
      } else if (v == "o6" || v == "o7") {
        var count = stack.length;
        var isX = v == "o6";
        for (var j2 = 0; j2 < count; j2++) {
          var sval = stack.shift();
          if (isX) x += sval;
          else y += sval;
          isX = !isX;
          P.LineTo(p2, x, y);
        }
      } else if (v == "o8" || v == "o24") {
        var count = stack.length;
        var index = 0;
        while (index + 6 <= count) {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
          index += 6;
        }
        if (v == "o24") {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
      } else if (v == "o11") break;
      else if (v == "o1234" || v == "o1235" || v == "o1236" || v == "o1237") {
        if (v == "o1234") {
          c1x = x + stack.shift();
          c1y = y;
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y;
          c3x = jpx + stack.shift();
          c3y = c2y;
          c4x = c3x + stack.shift();
          c4y = y;
          x = c4x + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1235") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y + stack.shift();
          c3x = jpx + stack.shift();
          c3y = jpy + stack.shift();
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          x = c4x + stack.shift();
          y = c4y + stack.shift();
          stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1236") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y;
          c3x = jpx + stack.shift();
          c3y = c2y;
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          x = c4x + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1237") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y + stack.shift();
          c3x = jpx + stack.shift();
          c3y = jpy + stack.shift();
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
            x = c4x + stack.shift();
          } else {
            y = c4y + stack.shift();
          }
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
      } else if (v == "o14") {
        if (stack.length > 0 && stack.length != 4 && !haveWidth) {
          width = stack.shift() + font2["nominalWidthX"];
          haveWidth = true;
        }
        if (stack.length == 4) {
          var adx = stack.shift();
          var ady = stack.shift();
          var bchar = stack.shift();
          var achar = stack.shift();
          var bind = CFF.glyphBySE(font2, bchar);
          var aind = CFF.glyphBySE(font2, achar);
          _drawCFF(font2["CharStrings"][bind], state, font2, pdct, p2);
          state.x = adx;
          state.y = ady;
          _drawCFF(font2["CharStrings"][aind], state, font2, pdct, p2);
        }
        if (open) {
          P.ClosePath(p2);
          open = false;
        }
      } else if (v == "o19" || v == "o20") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
        i2 += nStems + 7 >> 3;
      } else if (v == "o21") {
        if (stack.length > 2 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        y += stack.pop();
        x += stack.pop();
        if (open) P.ClosePath(p2);
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o22") {
        if (stack.length > 1 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        x += stack.pop();
        if (open) P.ClosePath(p2);
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o25") {
        while (stack.length > 6) {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
        c1x = x + stack.shift();
        c1y = y + stack.shift();
        c2x = c1x + stack.shift();
        c2y = c1y + stack.shift();
        x = c2x + stack.shift();
        y = c2y + stack.shift();
        P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
      } else if (v == "o26") {
        if (stack.length % 2) {
          x += stack.shift();
        }
        while (stack.length > 0) {
          c1x = x;
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x;
          y = c2y + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
        }
      } else if (v == "o27") {
        if (stack.length % 2) {
          y += stack.shift();
        }
        while (stack.length > 0) {
          c1x = x + stack.shift();
          c1y = y;
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y;
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
        }
      } else if (v == "o10" || v == "o29") {
        var obj = v == "o10" ? pdct : font2;
        if (stack.length == 0) {
          console.log("error: empty stack");
        } else {
          var ind = stack.pop();
          var subr = obj["Subrs"][ind + obj["Bias"]];
          state.x = x;
          state.y = y;
          state.nStems = nStems;
          state.haveWidth = haveWidth;
          state.width = width;
          state.open = open;
          _drawCFF(subr, state, font2, pdct, p2);
          x = state.x;
          y = state.y;
          nStems = state.nStems;
          haveWidth = state.haveWidth;
          width = state.width;
          open = state.open;
        }
      } else if (v == "o30" || v == "o31") {
        var count, count1 = stack.length;
        var index = 0;
        var alternate = v == "o31";
        count = count1 & -3;
        index += count1 - count;
        while (index < count) {
          if (alternate) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            if (count - index == 5) {
              x = c2x + stack.shift();
              index++;
            } else x = c2x;
            alternate = false;
          } else {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            if (count - index == 5) {
              y = c2y + stack.shift();
              index++;
            } else y = c2y;
            alternate = true;
          }
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
          index += 4;
        }
      } else if ((v + "").charAt(0) == "o") {
        console.log("Unknown operation: " + v, cmds);
        throw v;
      } else stack.push(v);
    }
    state.x = x;
    state.y = y;
    state.nStems = nStems;
    state.haveWidth = haveWidth;
    state.width = width;
    state.open = open;
  }
  function initHB(hurl, resp) {
    var codeLength = function(code2) {
      var len = 0;
      if ((code2 & 4294967295 - (1 << 7) + 1) == 0) {
        len = 1;
      } else if ((code2 & 4294967295 - (1 << 11) + 1) == 0) {
        len = 2;
      } else if ((code2 & 4294967295 - (1 << 16) + 1) == 0) {
        len = 3;
      } else if ((code2 & 4294967295 - (1 << 21) + 1) == 0) {
        len = 4;
      }
      return len;
    };
    fetch(hurl).then(function(x) {
      return x["arrayBuffer"]();
    }).then(function(ab) {
      return WebAssembly["instantiate"](ab);
    }).then(function(res) {
      console.log("HB ready");
      var exp = res["instance"]["exports"], mem = exp["memory"];
      var heapu8, u32, i32, f32;
      var __lastFnt, blob, blobPtr, face, font2;
      Typr["U"]["shapeHB"] = /* @__PURE__ */ (function() {
        var toJson = function(ptr) {
          var length = exp["hb_buffer_get_length"](ptr);
          var result = [];
          var iPtr32 = exp["hb_buffer_get_glyph_infos"](ptr, 0) >>> 2;
          var pPtr32 = exp["hb_buffer_get_glyph_positions"](ptr, 0) >>> 2;
          for (var i2 = 0; i2 < length; ++i2) {
            var a = iPtr32 + i2 * 5, b2 = pPtr32 + i2 * 5;
            result.push({
              "g": u32[a + 0],
              "cl": u32[a + 2],
              "ax": i32[b2 + 0],
              "ay": i32[b2 + 1],
              "dx": i32[b2 + 2],
              "dy": i32[b2 + 3]
            });
          }
          return result;
        };
        var te;
        return function(fnt, str, prm) {
          var fdata = fnt["_data"], fn2 = fnt["name"]["postScriptName"];
          var ltr = prm["ltr"], fts = prm["fts"], axs = prm["axs"];
          if (fnt["fvar"] && axs == null) axs = fnt["fvar"][1][fnt["_index"]][2];
          heapu8 = new Uint8Array(mem.buffer);
          u32 = new Uint32Array(mem.buffer);
          i32 = new Int32Array(mem.buffer);
          f32 = new Float32Array(mem.buffer);
          if (__lastFnt != fn2) {
            if (blob != null) {
              exp["hb_blob_destroy"](blob);
              exp["free"](blobPtr);
              exp["hb_face_destroy"](face);
              exp["hb_font_destroy"](font2);
            }
            blobPtr = exp["malloc"](fdata.byteLength);
            heapu8.set(fdata, blobPtr);
            blob = exp["hb_blob_create"](blobPtr, fdata.byteLength, 2, 0, 0);
            face = exp["hb_face_create"](blob, fnt["_index"]);
            font2 = exp["hb_font_create"](face);
            __lastFnt = fn2;
          }
          if (window["TextEncoder"] == null) {
            alert("Your browser is too old. Please, update it.");
            return;
          }
          if (te == null) te = new window["TextEncoder"]("utf8");
          var buffer = exp["hb_buffer_create"]();
          var bytes = te["encode"](str);
          var len = bytes.length, strp = exp["malloc"](len);
          heapu8.set(bytes, strp);
          exp["hb_buffer_add_utf8"](buffer, strp, len, 0, len);
          exp["free"](strp);
          var bin = Typr["B"];
          var feat = 0;
          if (fts) {
            feat = exp["malloc"](16 * fts.length);
            for (var i2 = 0; i2 < fts.length; i2++) {
              var fe = fts[i2];
              var off = feat + i2 * 16, qo = off >>> 2;
              bin.writeASCII(heapu8, off, fe[0].split("").reverse().join(""));
              u32[qo + 1] = fe[1];
              u32[qo + 2] = fe[2];
              u32[qo + 3] = fe[3];
            }
          }
          var vdat = 0;
          if (axs && fnt["fvar"]) {
            var axes = fnt["fvar"][0];
            vdat = exp["malloc"](8 * axs.length);
            for (var i2 = 0; i2 < axs.length; i2++) {
              var off = vdat + i2 * 8, qo = off >>> 2;
              bin.writeASCII(heapu8, off, axes[i2][0].split("").reverse().join(""));
              f32[qo + 1] = axs[i2];
            }
          }
          if (axs) exp["hb_font_set_variations"](font2, vdat, axs.length);
          exp["hb_buffer_set_direction"](buffer, ltr ? 4 : 5);
          exp["hb_buffer_guess_segment_properties"](buffer);
          exp["hb_shape"](font2, buffer, feat, fts ? fts.length : 0);
          var json = toJson(buffer);
          exp["hb_buffer_destroy"](buffer);
          if (fts) exp["free"](feat);
          if (axs) exp["free"](vdat);
          var arr2 = json.slice(0);
          if (!ltr) arr2.reverse();
          var ci = 0, bi = 0;
          for (var i2 = 1; i2 < arr2.length; i2++) {
            var gl = arr2[i2], cl = gl["cl"];
            while (true) {
              var cpt = str.codePointAt(ci), cln = codeLength(cpt);
              if (bi + cln <= cl) {
                bi += cln;
                ci += cpt <= 65535 ? 1 : 2;
              } else break;
            }
            gl["cl"] = ci;
          }
          return json;
        };
      })();
      resp();
    });
  }
  return { "shape": shape2, "shapeToPath": shapeToPath, "codeToGlyph": codeToGlyph, "glyphToPath": glyphToPath, "pathToSVG": pathToSVG, "SVGToPath": SVGToPath, "pathToContext": pathToContext, "initHB": initHB };
})();
var bezierPath = { exports: {} };
var hasRequiredBezierPath;
function requireBezierPath() {
  if (hasRequiredBezierPath) return bezierPath.exports;
  hasRequiredBezierPath = 1;
  (function(module, exports$1) {
    !(function(t, e2) {
      module.exports = e2();
    })(self, (() => (() => {
      var t = { 177: (t2, e3, s) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.BezierPath = void 0;
        const i = s(558), h = s(188);
        e3.BezierPath = class {
          constructor(t3) {
            this.samples = [], this.segments = t3;
            const e4 = t3.map(((t4) => t4.getTotalLength())), s2 = [0];
            for (let t4 = 1; t4 < e4.length; t4++) s2.push(s2[t4 - 1] + e4[t4 - 1]);
            this._totalLength = s2[s2.length - 1] + e4[e4.length - 1];
            const a = t3.map(((t4) => Math.max(4, Math.ceil(t4.getTotalLength() / i.BezierSegment.sampleSpacing())))), n2 = a.reduce(((t4, e5) => t4 + e5)), r = 1 / n2 / 10, o = this._totalLength / n2;
            this.samples.push({ dist: 0, pt: this.segments[0].A, tan: this.segments[0].tangentAtParameter(0), segIdx: 0, t: 0 }), t3.forEach(((t4, e5) => {
              const i2 = a[e5], n3 = (0, h.times)(i2 + 1).map(((t5) => t5 / i2)), x = n3.map(((e6) => t4.pointAtParameter(e6)));
              let y;
              for (let e6 = 0; e6 < 4; e6++) {
                y = (0, h.times)(i2).map(((t5) => Math.hypot(x[t5 + 1].x - x[t5].x, x[t5 + 1].y - x[t5].y)));
                const e7 = y.map(((t5) => t5 - o));
                let s3 = 0;
                for (let i3 = 1; i3 < n3.length - 1; i3++) s3 += e7[i3 - 1], n3[i3] -= r * s3, x[i3] = t4.pointAtParameter(n3[i3]);
              }
              let p2 = 0;
              x.slice(1).forEach(((t5, i3) => {
                p2 += y[i3], this.samples.push({ dist: s2[e5] + p2, pt: t5, tan: this.segments[e5].tangentAtParameter(n3[i3 + 1]), segIdx: e5, t: n3[i3 + 1] });
              }));
            })), this._jumps = [], this.segmentStartEnds = [{ start: 0, end: 0 }];
            for (let t4 = 1; t4 < this.samples.length; t4++) {
              const e5 = this.samples[t4 - 1], s3 = this.samples[t4];
              if (s3.segIdx === e5.segIdx ? this.segmentStartEnds[this.segmentStartEnds.length - 1].end = s3.dist : this.segmentStartEnds[s3.segIdx] = { start: s3.dist, end: s3.dist }, e5.segIdx !== s3.segIdx && (this.segments[e5.segIdx].D.x !== this.segments[s3.segIdx].A.x || this.segments[e5.segIdx].D.y !== this.segments[s3.segIdx].A.y)) {
                const i2 = (e5.dist + s3.dist) / 2, h2 = { dist: i2 - 1e-8, pt: this.segments[e5.segIdx].D, tan: this.segments[e5.segIdx].tangentAtParameter(1), segIdx: e5.segIdx, t: 1 }, a2 = { dist: i2 + 1e-8, pt: this.segments[s3.segIdx].A, tan: this.segments[s3.segIdx].tangentAtParameter(0), segIdx: s3.segIdx, t: 0 };
                this._jumps.push(i2), this.samples.splice(t4, 0, h2, a2), t4 += 2;
              }
            }
          }
          jumps() {
            return [...this._jumps];
          }
          getTotalLength() {
            return this._totalLength;
          }
          findClosestSampleIdx(t3) {
            let e4 = 0, s2 = this.samples.length - 1;
            for (; e4 < s2; ) {
              const i2 = Math.floor((e4 + s2) / 2);
              if (this.samples[i2].dist > t3) s2 = i2 - 1;
              else {
                if (!(this.samples[i2].dist < t3)) return i2;
                e4 = i2 + 1;
              }
            }
            return Math.max(0, Math.min(this.samples.length - 1, Math.floor((e4 + s2) / 2)));
          }
          getPointAtLength(t3, e4 = false) {
            if (t3 <= 0) return this.samples[0].pt;
            if (t3 >= this._totalLength) return this.samples[this.samples.length - 1].pt;
            const s2 = this.findClosestSampleIdx(t3), i2 = this.samples[s2].dist < t3 ? Math.min(s2 + 1, this.samples.length - 1) : Math.max(0, s2 - 1), h2 = Math.abs(this.samples[i2].dist - this.samples[s2].dist) < 1e-6 ? 0 : (t3 - this.samples[s2].dist) / (this.samples[i2].dist - this.samples[s2].dist);
            if (e4 || this.samples[s2].segIdx > this.samples[i2].segIdx) return { x: (1 - h2) * this.samples[s2].pt.x + h2 * this.samples[i2].pt.x, y: (1 - h2) * this.samples[s2].pt.y + h2 * this.samples[i2].pt.y };
            if (this.samples[s2].segIdx !== this.samples[i2].segIdx) {
              if (h2 < 0.5) {
                const t4 = this.segments[this.samples[s2].segIdx], e5 = 2 * h2, i3 = (1 - e5) * this.samples[s2].t + e5;
                return t4.pointAtParameter(i3);
              }
              {
                const t4 = this.segments[this.samples[i2].segIdx], e5 = 2 * (h2 - 0.5) * this.samples[i2].t;
                return t4.pointAtParameter(e5);
              }
            }
            {
              const t4 = this.segments[this.samples[s2].segIdx], e5 = (1 - h2) * this.samples[s2].t + h2 * this.samples[i2].t;
              return t4.pointAtParameter(e5);
            }
          }
          getAngleAtLength(t3, e4 = false) {
            const s2 = this.getTangentAtLength(t3, e4);
            return Math.atan2(s2.y, s2.x);
          }
          getTangentAtLength(t3, e4 = false) {
            if (t3 <= 0) return this.samples[0].tan;
            if (t3 >= this._totalLength) return this.samples[this.samples.length - 1].tan;
            const s2 = this.findClosestSampleIdx(t3), i2 = this.samples[s2].dist < t3 ? Math.min(s2 + 1, this.samples.length - 1) : Math.max(0, s2 - 1), h2 = (t3 - this.samples[s2].dist) / (this.samples[i2].dist - this.samples[s2].dist);
            if (e4 || this.samples[s2].segIdx > this.samples[i2].segIdx) {
              let t4 = (1 - h2) * this.samples[s2].tan.x + h2 * this.samples[i2].tan.x, e5 = (1 - h2) * this.samples[s2].tan.y + h2 * this.samples[i2].tan.y;
              const a = Math.max(Math.hypot(t4, e5), 1e-4);
              return t4 /= a, e5 /= a, { x: t4, y: e5 };
            }
            if (this.samples[s2].segIdx !== this.samples[i2].segIdx) {
              if (h2 < 0.5) {
                const t4 = this.segments[this.samples[s2].segIdx], e5 = 2 * h2, i3 = (1 - e5) * this.samples[s2].t + e5;
                return t4.tangentAtParameter(i3);
              }
              {
                const t4 = this.segments[this.samples[i2].segIdx], e5 = 2 * (h2 - 0.5) * this.samples[i2].t;
                return t4.tangentAtParameter(e5);
              }
            }
            {
              const t4 = this.segments[this.samples[s2].segIdx], e5 = (1 - h2) * this.samples[s2].t + h2 * this.samples[i2].t;
              return t4.tangentAtParameter(e5);
            }
          }
        };
      }, 558: (t2, e3, s) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.BezierSegment = void 0;
        const i = s(188);
        class h {
          constructor(t3, e4, s2, i2) {
            this._totalLength = void 0, this.A = t3, this.B = e4, this.C = s2, this.D = i2;
          }
          static sampleSpacing() {
            return 2;
          }
          tangentAtParameter(t3) {
            const e4 = Math.max(0, Math.min(1, t3));
            if (0 === e4 || 1 === e4) {
              let t4, s3;
              0 === e4 ? this.A.x === this.B.x && this.A.y === this.B.y ? (t4 = this.C.x - this.A.x, s3 = this.C.y - this.A.y) : (t4 = this.B.x - this.A.x, s3 = this.B.y - this.A.y) : this.D.x === this.C.x && this.D.y === this.C.y ? (t4 = this.D.x - this.B.x, s3 = this.D.y - this.B.y) : (t4 = this.D.x - this.C.x, s3 = this.D.y - this.C.y);
              const i3 = Math.hypot(t4, s3);
              return Math.abs(i3) > 1e-4 && (t4 /= i3, s3 /= i3), { x: t4, y: s3 };
            }
            const s2 = 1 - e4;
            let i2 = 3 * this.D.x * Math.pow(e4, 2) - 3 * this.C.x * Math.pow(e4, 2) + 6 * this.C.x * s2 * e4 - 6 * this.B.x * s2 * e4 + 3 * this.B.x * Math.pow(s2, 2) - 3 * this.A.x * Math.pow(s2, 2), h2 = 3 * this.D.y * Math.pow(e4, 2) - 3 * this.C.y * Math.pow(e4, 2) + 6 * this.C.y * s2 * e4 - 6 * this.B.y * s2 * e4 + 3 * this.B.y * Math.pow(s2, 2) - 3 * this.A.y * Math.pow(s2, 2);
            const a = Math.hypot(i2, h2);
            return Math.abs(a) > 1e-4 && (i2 /= a, h2 /= a), { x: i2, y: h2 };
          }
          isLinear() {
            return this.A.x === this.B.x && this.A.y === this.B.y && this.C.x === this.D.x && this.C.y === this.D.y;
          }
          pointAtParameter(t3) {
            const e4 = Math.max(0, Math.min(1, t3));
            return { x: Math.pow(1 - e4, 3) * this.A.x + 3 * Math.pow(1 - e4, 2) * e4 * this.B.x + 3 * (1 - e4) * Math.pow(e4, 2) * this.C.x + Math.pow(e4, 3) * this.D.x, y: Math.pow(1 - e4, 3) * this.A.y + 3 * Math.pow(1 - e4, 2) * e4 * this.B.y + 3 * (1 - e4) * Math.pow(e4, 2) * this.C.y + Math.pow(e4, 3) * this.D.y };
          }
          getTotalLength() {
            if (void 0 === this._totalLength) if (this.isLinear()) this._totalLength = Math.hypot(this.D.x - this.A.x, this.D.y - this.A.y);
            else {
              const t3 = Math.max(10, Math.ceil((Math.hypot(this.B.x - this.A.x, this.B.y - this.A.y) + Math.hypot(this.C.x - this.B.x, this.C.y - this.B.y) + Math.hypot(this.D.x - this.C.x, this.D.y - this.C.y)) / h.sampleSpacing())), e4 = (0, i.times)(t3).map(((e5) => this.pointAtParameter(e5 / (t3 - 1))));
              let s2 = 0;
              for (let t4 = 1; t4 < e4.length; t4++) s2 += Math.hypot(e4[t4].x - e4[t4 - 1].x, e4[t4].y - e4[t4 - 1].y);
              this._totalLength = s2;
            }
            return this._totalLength;
          }
        }
        e3.BezierSegment = h;
      }, 729: (t2, e3, s) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.createFromCommands = e3.create = e3.createFromElement = e3.createFromCircle = e3.createFromLine = e3.createFromPath = void 0;
        const i = s(821), h = s(558), a = { M: ["x", "y"], m: ["dx", "dy"], H: ["x"], h: ["dx"], V: ["y"], v: ["dy"], L: ["x", "y"], l: ["dx", "dy"], Z: [], C: ["x1", "y1", "x2", "y2", "x", "y"], c: ["dx1", "dy1", "dx2", "dy2", "dx", "dy"], S: ["x2", "y2", "x", "y"], s: ["dx2", "dy2", "dx", "dy"], Q: ["x1", "y1", "x", "y"], q: ["dx1", "dy1", "dx", "dy"], T: ["x", "y"], t: ["dx", "dy"], A: ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"], a: ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"] };
        e3.createFromPath = (t3) => {
          const e4 = (function(t4) {
            const e5 = t4.replace(/[\n\r]/g, "").replace(/-/g, " -").replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ").replace(/(\d)([A-Za-z])/g, "$1 $2").replace(/([A-Za-z])(\d)/g, "$1 $2").trim().split(/\s*,|\s+/), s3 = [];
            let i2 = "", h2 = {};
            for (; e5.length > 0; ) {
              let t5 = e5.shift();
              a.hasOwnProperty(t5) ? i2 = t5 : e5.unshift(t5), h2 = { type: i2 }, a[i2].forEach(((s4) => {
                t5 = e5.shift(), h2[s4] = parseFloat(t5);
              })), "M" === i2 ? i2 = "L" : "m" === i2 && (i2 = "l"), s3.push(h2);
            }
            return s3;
          })(t3.getAttribute("d"));
          if (e4.length < 2) throw new Error(`Path doesn't have enough commands: ${JSON.stringify(e4)}`);
          if ("M" !== e4[0].type) throw new Error(`Path starts with ${e4[0].type} instead of M!`);
          let s2 = { x: e4[0].x, y: e4[0].y };
          e4.shift();
          const n2 = [];
          for (; e4.length > 0; ) {
            const t4 = e4.shift();
            if ("C" === t4.type) n2.push(new h.BezierSegment(s2, { x: t4.x1, y: t4.y1 }, { x: t4.x2, y: t4.y2 }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else if ("L" === t4.type) n2.push(new h.BezierSegment(s2, s2, { x: t4.x, y: t4.y }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else if ("H" === t4.type) n2.push(new h.BezierSegment(s2, s2, { x: t4.x, y: s2.y }, { x: t4.x, y: s2.y })), s2 = { x: t4.x, y: s2.y };
            else if ("V" === t4.type) n2.push(new h.BezierSegment(s2, s2, { x: s2.x, y: t4.y }, { x: s2.x, y: t4.y })), s2 = { x: s2.x, y: t4.y };
            else if ("Z" !== t4.type) throw new Error(`Unsupported path command ${t4.type}; use only H, V, M, L, C, Z!`);
          }
          return new i.BezierPath(n2);
        }, e3.createFromLine = (t3) => {
          const [e4, s2, a2, n2] = ["x1", "x2", "y1", "y2"].map(((e5) => parseFloat(t3.getAttribute(e5) || "0")));
          return new i.BezierPath([new h.BezierSegment({ x: e4, y: a2 }, { x: e4, y: a2 }, { x: s2, y: n2 }, { x: s2, y: n2 })]);
        }, e3.createFromCircle = (t3) => {
          const [e4, s2, a2] = ["cx", "cy", "r"].map(((e5) => parseFloat(t3.getAttribute(e5) || "0"))), n2 = 1.3;
          return new i.BezierPath([new h.BezierSegment({ x: e4 - a2, y: s2 }, { x: e4 - a2, y: s2 - n2 * a2 }, { x: e4 + a2, y: s2 - n2 * a2 }, { x: e4 + a2, y: s2 }), new h.BezierSegment({ x: e4 + a2, y: s2 }, { x: e4 + a2, y: s2 + n2 * a2 }, { x: e4 - a2, y: s2 + n2 * a2 }, { x: e4 - a2, y: s2 })]);
        }, e3.createFromElement = (t3) => {
          const s2 = t3.tagName.toLowerCase();
          if ("path" === s2) return (0, e3.createFromPath)(t3);
          if ("line" === s2) return (0, e3.createFromLine)(t3);
          if ("circle" === s2) return (0, e3.createFromCircle)(t3);
          throw new Error(`Unsupported SVG tag: ${s2}`);
        }, e3.create = (t3) => {
          const e4 = [];
          for (let s2 = 1; s2 < t3.length; s2++) {
            const i2 = t3[s2 - 1], a2 = t3[s2];
            e4.push(new h.BezierSegment(i2.pt, i2.right || i2.pt, a2.left || a2.pt, a2.pt));
          }
          return new i.BezierPath(e4);
        }, e3.createFromCommands = (t3) => {
          const e4 = t3.slice();
          if (e4.length < 2) throw new Error(`Path doesn't have enough commands: ${JSON.stringify(e4)}`);
          if ("M" !== e4[0].type) throw new Error(`Path starts with ${e4[0].type} instead of M!`);
          let s2 = { x: e4[0].x, y: e4[0].y }, a2 = Object.assign({}, s2);
          const n2 = [];
          for (; e4.length > 0; ) {
            const t4 = e4.shift();
            if ("M" === t4.type) a2 = { x: t4.x, y: t4.y }, s2 = a2;
            else if ("C" === t4.type) n2.push(new h.BezierSegment(s2, { x: t4.x1, y: t4.y1 }, { x: t4.x2, y: t4.y2 }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else if ("L" === t4.type) t4.x === s2.x && t4.y === s2.y || n2.push(new h.BezierSegment(s2, s2, { x: t4.x, y: t4.y }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else if ("H" === t4.type) t4.x !== s2.x && n2.push(new h.BezierSegment(s2, s2, { x: t4.x, y: s2.y }, { x: t4.x, y: s2.y })), s2 = { x: t4.x, y: s2.y };
            else if ("V" === t4.type) t4.y !== s2.y && n2.push(new h.BezierSegment(s2, s2, { x: s2.x, y: t4.y }, { x: s2.x, y: t4.y })), s2 = { x: s2.x, y: t4.y };
            else if ("Q" === t4.type) n2.push(new h.BezierSegment(s2, { x: s2.x + 2 / 3 * (t4.x1 - s2.x), y: s2.y + 2 / 3 * (t4.y1 - s2.y) }, { x: t4.x + 2 / 3 * (t4.x1 - t4.x), y: t4.y + 2 / 3 * (t4.y1 - t4.y) }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else {
              if ("Z" !== t4.type) throw new Error(`Unsupported path command ${t4.type}; use only H, V, M, L, C, Z!`);
              Math.hypot(s2.x - a2.x, s2.y - a2.y) > 0 && n2.push(new h.BezierSegment(s2, s2, a2, a2));
            }
          }
          return new i.BezierPath(n2);
        };
      }, 821: function(t2, e3, s) {
        var i = this && this.__createBinding || (Object.create ? function(t3, e4, s2, i2) {
          void 0 === i2 && (i2 = s2);
          var h2 = Object.getOwnPropertyDescriptor(e4, s2);
          h2 && !("get" in h2 ? !e4.__esModule : h2.writable || h2.configurable) || (h2 = { enumerable: true, get: function() {
            return e4[s2];
          } }), Object.defineProperty(t3, i2, h2);
        } : function(t3, e4, s2, i2) {
          void 0 === i2 && (i2 = s2), t3[i2] = e4[s2];
        }), h = this && this.__exportStar || function(t3, e4) {
          for (var s2 in t3) "default" === s2 || Object.prototype.hasOwnProperty.call(e4, s2) || i(e4, t3, s2);
        };
        Object.defineProperty(e3, "__esModule", { value: true }), h(s(177), e3), h(s(558), e3), h(s(729), e3), h(s(856), e3);
      }, 856: (t2, e3) => {
        Object.defineProperty(e3, "__esModule", { value: true });
      }, 188: (t2, e3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.times = void 0, e3.times = function(t3) {
          const e4 = [];
          for (let s = 0; s < t3; s++) e4.push(s);
          return e4;
        };
      } }, e2 = {};
      return (function s(i) {
        var h = e2[i];
        if (void 0 !== h) return h.exports;
        var a = e2[i] = { exports: {} };
        return t[i].call(a.exports, a, a.exports, s), a.exports;
      })(821);
    })()));
  })(bezierPath);
  return bezierPath.exports;
}
var bezierPathExports = requireBezierPath();
const pathArgCounts = { M: 2, L: 2, C: 6, Q: 4 };
const validFontTypes = ["ttf", "otf", "woff"];
const validFontTypesRe = new RegExp(`\\.(${validFontTypes.join("|")})`, "i");
const extractFontNameRe = new RegExp(`([^/]+)(\\.(?:${validFontTypes.join("|")}))`, "i");
const invalidFontError = "Sorry, only TTF, OTF and WOFF files are supported.";
const fontFaceVariations = ["weight", "stretch", "style"];
class Font {
  constructor(p2, fontFace, name, path2, data2) {
    if (!(fontFace instanceof FontFace)) {
      throw Error("FontFace is required");
    }
    this._pInst = p2;
    this.name = name;
    this.path = path2;
    this.data = data2;
    this.face = fontFace;
  }
  /**
   * Checks whether a font has glyph point data and
   * can thus be used for textToPoints(), WEBGL mode, etc.
   * @private
   */
  static hasGlyphData(textFont) {
    let { font: font2 } = textFont;
    return typeof font2 === "object" && typeof font2.data !== "undefined";
  }
  fontBounds(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let renderer2 = options2?.graphics?._renderer || this._pInst._renderer;
    if (!renderer2) throw Error("p5 or graphics required for fontBounds()");
    return renderer2.fontBounds(str, x, y, width, height);
  }
  textBounds(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let renderer2 = options2?.graphics?._renderer || this._pInst._renderer;
    if (!renderer2) throw Error("p5 or graphics required for fontBounds()");
    return renderer2.textBounds(str, x, y, width, height);
  }
  /**
   * Returns a flat array of path commands that describe the outlines of a string of text.
   *
   * Each command is represented as an array of the form `[type, ...coords]`, where:
   * - `type` is one of `'M'`, `'L'`, `'Q'`, `'C'`, or `'Z'`,
   * - `coords` are the numeric values needed for that command.
   *
   * `'M'` indicates a "move to" (starting a new contour),
   * `'L'` a line segment,
   * `'Q'` a quadratic bezier,
   * `'C'` a cubic bezier, and
   * `'Z'` closes the current path.
   *
   * The first two parameters, `x` and `y`, specify the baseline origin for the text.
   * Optionally, you can provide a `width` and `height` for text wrapping; if you don't need
   * wrapping, you can omit them and directly pass `options` as the fourth parameter.
   *
   * @param  {String} str            The text to convert into path commands.
   * @param  {Number} x              x‐coordinate of the text baseline.
   * @param  {Number} y              y‐coordinate of the text baseline.
   * @param  {Number} [width]        Optional width for text wrapping.
   * @param  {Number} [height]       Optional height for text wrapping.
   * @return {Array<Array>}          A flat array of path commands.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(200, 200);
   *   background(220);
   *   noLoop();
   * }
   *
   * function draw() {
   *   background(220);
   *   stroke(0);
   *   noFill();
   *   textSize(60);
   *
   *   // Get path commands for "Hello" (drawn at baseline x=50, y=100):
   *   const pathCommands = font.textToPaths('Hello', 30, 110);
   *
   *   beginShape();
   *   for (let i = 0; i < pathCommands.length; i++) {
   *     const cmd = pathCommands[i];
   *     const type = cmd[0];
   *
   *     switch (type) {
   *       case 'M': {
   *         // Move to (start a new contour)
   *         const x = cmd[1];
   *         const y = cmd[2];
   *         endContour(); // In case we were already drawing
   *         beginContour();
   *         vertex(x, y);
   *         break;
   *       }
   *       case 'L': {
   *         // Line to
   *         const x = cmd[1];
   *         const y = cmd[2];
   *         vertex(x, y);
   *         break;
   *       }
   *       case 'Q': {
   *         // Quadratic bezier
   *         const cx = cmd[1];
   *         const cy = cmd[2];
   *         const x = cmd[3];
   *         const y = cmd[4];
   *         bezierOrder(2);
   *         bezierVertex(cx, cy);
   *         bezierVertex(x, y);
   *         break;
   *       }
   *       case 'C': {
   *         // Cubic bezier
   *         const cx1 = cmd[1];
   *         const cy1 = cmd[2];
   *         const cx2 = cmd[3];
   *         const cy2 = cmd[4];
   *         const x = cmd[5];
   *         const y = cmd[6];
   *         bezierOrder(3);
   *         bezierVertex(cx1, cy1);
   *         bezierVertex(cx2, cy2);
   *         bezierVertex(x, y);
   *         break;
   *       }
   *       case 'Z': {
   *         // Close path
   *         endContour(CLOSE);
   *         beginContour();
   *         break;
   *       }
   *     }
   *   }
   *   endContour();
   *   endShape();
   * }
   * </code>
   * </div>
   */
  textToPaths(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    if (!this.data) {
      throw Error('No font data available for "' + this.name + '"\nTry downloading a local copy of the font file');
    }
    let lines = this._lineateAndPathify(str, x, y, width, height, options2);
    let glyphs = lines.map((o) => o.glyphs).flat();
    return glyphs.map((g2) => g2.path.commands).flat();
  }
  /**
   * Returns an array of points outlining a string of text written using the
   * font.
   *
   * Each point object in the array has three properties that describe the
   * point's location and orientation, called its path angle. For example,
   * `{ x: 10, y: 20, alpha: 450 }`.
   *
   * The first parameter, `str`, is a string of text. The second and third
   * parameters, `x` and `y`, are the text's position. By default, they set the
   * coordinates of the bounding box's bottom-left corner. See
   * <a href="#/p5/textAlign">textAlign()</a> for more ways to align text.
   *
   * The fourth parameter, `options`, is also optional. `font.textToPoints()`
   * expects an object with the following properties:
   *
   * `sampleFactor` is the ratio of the text's path length to the number of
   * samples. It defaults to 0.1. Higher values produce more points along the
   * path and are more precise.
   *
   * `simplifyThreshold` removes collinear points if it's set to a number other
   * than 0. The value represents the threshold angle in radians to use when determining
   * whether two edges are collinear.
   *
   * @param  {String} str        string of text.
   * @param  {Number} x          x-coordinate of the text.
   * @param  {Number} y          y-coordinate of the text.
   * @param  {Object} [options]  Configuration:
   * @param  {Number} [options.sampleFactor=0.1] The ratio of the text's path length to the number of samples.
   * @param  {Number} [options.simplifyThreshold=0] A minmum angle in radian sbetween two segments. Segments with a shallower angle will be merged.
   * @return {Array<Object>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   background(200);
   *   textSize(35);
   *
   *   // Get the point array.
   *   let points = font.textToPoints('p5*js', 6, 60, { sampleFactor: 0.5 });
   *
   *   // Draw a dot at each point.
   *   for (let p of points) {
   *     point(p.x, p.y);
   *   }
   *
   *   describe('A set of black dots outlining the text "p5*js" on a gray background.');
   * }
   * </code>
   * </div>
   */
  textToPoints(str, x, y, width, height, options2) {
    const contourPoints = this.textToContours(
      str,
      x,
      y,
      width,
      height,
      options2
    );
    return contourPoints.reduce((acc, next) => {
      acc.push(...next);
      return acc;
    }, []);
  }
  /**
   * Returns an array of arrays of points outlining a string of text written using the
   * font. Each array represents a contour, so the letter O will have two outer arrays:
   * one for the outer edge of the shape, and one for the inner edge of the hole.
   *
   * Each point object in a contour array has three properties that describe the
   * point's location and orientation, called its path angle. For example,
   * `{ x: 10, y: 20, alpha: 450 }`.
   *
   * The first parameter, `str`, is a string of text. The second and third
   * parameters, `x` and `y`, are the text's position. By default, they set the
   * coordinates of the bounding box's bottom-left corner. See
   * <a href="#/p5/textAlign">textAlign()</a> for more ways to align text.
   *
   * The fourth parameter, `options`, is also optional. `font.textToPoints()`
   * expects an object with the following properties:
   *
   * `sampleFactor` is the ratio of the text's path length to the number of
   * samples. It defaults to 0.1. Higher values produce more points along the
   * path and are more precise.
   *
   * `simplifyThreshold` removes collinear points if it's set to a number other
   * than 0. The value represents the threshold angle in radians to use when determining
   * whether two edges are collinear.
   *
   * @param  {String} str        string of text.
   * @param  {Number} x          x-coordinate of the text.
   * @param  {Number} y          y-coordinate of the text.
   * @param  {Object} [options]  Configuration options:
   * @param  {Number} [options.sampleFactor=0.1] The ratio of the text's path length to the number of samples.
   * @param  {Number} [options.simplifyThreshold=0] A minmum angle in radians between two segments. Segments with a shallower angle will be merged.
   * @return {Array<Array<Object>>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('/assets/inconsolata.otf');
   * }
   *
   * function draw() {
   *   background(200);
   *   textAlign(CENTER, CENTER);
   *   textSize(30);
   *
   *   // Get the point array.
   *   let contours = font.textToContours('p5*js', width/2, height/2, { sampleFactor: 0.5 });
   *
   *   beginShape();
   *   for (const pts of contours) {
   *     beginContour();
   *     for (const pt of pts) {
   *       vertex(pt.x + 5*sin(pt.y*0.1 + millis()*0.01), pt.y);
   *     }
   *     endContour(CLOSE);
   *   }
   *   endShape();
   *
   *   describe('The text p5*js wobbling over time');
   * }
   * </code>
   * </div>
   */
  textToContours(str, x = 0, y = 0, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    const cmds = this.textToPaths(str, x, y, width, height, options2);
    const cmdContours = [];
    for (const cmd of cmds) {
      if (cmd[0] === "M") {
        cmdContours.push([]);
      }
      cmdContours[cmdContours.length - 1].push(cmd);
    }
    return cmdContours.map((commands) => pathToPoints(commands, options2, this));
  }
  /**
   *
   * Converts text into a 3D model that can be rendered in WebGL mode.
   *
   * This method transforms flat text into extruded 3D geometry, allowing
   * for dynamic effects like depth, warping, and custom shading.
   *
   * It works by taking the outlines (contours) of each character in the
   * provided text string and constructing a 3D shape from them.
   *
   * Once your 3D text is ready, you can rotate it in 3D space using <a href="#/p5/orbitControl">orbitControl()</a>
   * — just click and drag with your mouse to see it from all angles!
   *
   * Use the extrude slider to give your letters depth: slide it up, and your
   * flat text turns into a solid, multi-dimensional object.
   *
   * You can also choose from various fonts such as "Anton", "Montserrat", or "Source Serif",
   * much like selecting fancy fonts in a word processor,
   *
   * The generated model (a Geometry object) can be manipulated further—rotated, scaled,
   * or styled with shaders—to create engaging, interactive visual art.
   *
   * @param {String} str The text string to convert into a 3D model.
   * @param {Number} x The x-coordinate for the starting position of the text.
   * @param {Number} y The y-coordinate for the starting position of the text.
   * @param {Number} width Maximum width of the text block (wraps text if exceeded).
   * @param {Number} height Maximum height of the text block.
   * @param {Object} [options] Configuration options for the 3D text:
   * @param {Number} [options.extrude=0] The depth to extrude the text. A value of 0 produces
   * flat text; higher values create thicker, 3D models.
   * @param {Number} [options.sampleFactor=1] A factor controlling the level of detail for the text contours.
   *  Higher values result in smoother curves.
   * @return {p5.Geometry} A geometry object representing the 3D model of the text.
   *
   * @example
   * <div modernizr='webgl'>
   * <code>
   * let font;
   * let geom;
   *
   * async function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   font = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');
   *
   *   geom = font.textToModel("Hello", 50, 0, { sampleFactor: 2 });
   *   geom.clearColors();
   *   geom.normalize();
   * }
   *
   * function draw() {
   *   background(255);
   *   orbitControl();
   *   fill("red");
   *   strokeWeight(4);
   *   scale(min(width, height) / 300);
   *   model(geom);
   *   describe('A red non-extruded "Hello" in Anton on white canvas, rotatable via mouse.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div modernizr='webgl'>
   * <code>
   * let font;
   * let geom;
   *
   * async function setup() {
   *   createCanvas(200, 200, WEBGL);
   *
   *   // Alternative fonts:
   *   // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'
   *   // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'
   *   // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'
   *
   *   // Using Source Serif for this example:
   *   font = await loadFont('https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf');
   *
   *   geom = font.textToModel("Hello", 50, 0, { sampleFactor: 2, extrude: 5 });
   *   geom.clearColors();
   *   geom.normalize();
   * }
   *
   * function draw() {
   *   background(255);
   *   orbitControl();
   *   fill("red");
   *   strokeWeight(4);
   *   scale(min(width, height) / 300);
   *   model(geom);
   *   describe('3D red extruded "Hello" in Source Serif on white, rotatable via mouse.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div modernizr='webgl'>
   * <code>
   * let geom;
   * let activeFont;
   * let artShader;
   * let lineShader;
   *
   * // Define parameters as simple variables
   * let words = 'HELLO';
   * let warp = 1;
   * let extrude = 5;
   * let palette = ["#ffe03d", "#fe4830", "#d33033", "#6d358a", "#1c509e", "#00953c"];
   *
   * async function setup() {
   *   createCanvas(200, 200, WEBGL);
   *
   *   // Using Anton as the default font for this example:
   *
   *  // Alternative fonts:
   *  // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'
   *  // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'
   *  // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'
   *   activeFont = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');
   *
   *   geom = activeFont.textToModel(words, 0, 50, { sampleFactor: 2, extrude });
   *   geom.clearColors();
   *   geom.normalize();
   *
   *   artShader = baseMaterialShader().modify({
   *     uniforms: {
   *       'float time': () => millis(),
   *       'float warp': () => warp,
   *       'float numColors': () => palette.length,
   *       'vec3[6] colors': () => palette.flatMap((c) => [red(c)/255, green(c)/255, blue(c)/255]),
   *     },
   *     vertexDeclarations: 'out vec3 vPos;',
   *     fragmentDeclarations: 'in vec3 vPos;',
   *     'Vertex getObjectInputs': `(Vertex inputs) {
   *       vPos = inputs.position;
   *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);
   *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);
   *       return inputs;
   *     }`,
   *     'vec4 getFinalColor': `(vec4 _c) {
   *       float x = vPos.x * 0.005;
   *       float a = floor(fract(x) * numColors);
   *       float b = a == numColors - 1. ? 0. : a + 1.;
   *       float t = fract(x * numColors);
   *       vec3 c = mix(colors[int(a)], colors[int(b)], t);
   *       return vec4(c, 1.);
   *     }`
   *   });
   *
   *   lineShader = baseStrokeShader().modify({
   *     uniforms: {
   *       'float time': () => millis(),
   *       'float warp': () => warp,
   *     },
   *     'StrokeVertex getObjectInputs': `(StrokeVertex inputs) {
   *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);
   *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);
   *       return inputs;
   *     }`,
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   orbitControl();
   *   shader(artShader);
   *   strokeShader(lineShader);
   *   strokeWeight(4);
   *   scale(min(width, height) / 210);
   *   model(geom);
   *   describe('3D wavy with different color sets "Hello" in Anton on white canvas, rotatable via mouse.');
   * }
   * </code>
   * </div>
   */
  textToModel(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    const extrude = options2?.extrude || 0;
    let contours = this.textToContours(str, x, y, width, height, options2);
    const geom = this._pInst.buildGeometry(() => {
      const prevValidateFaces = this._pInst._renderer._validateFaces;
      this._pInst._renderer._validateFaces = true;
      this._pInst.beginShape();
      for (const contour of contours) {
        this._pInst.beginContour();
        for (const pt2 of contour) {
          this._pInst.vertex(pt2.x, pt2.y, 0);
        }
        this._pInst.endContour(this._pInst.CLOSE);
      }
      this._pInst.endShape(this._pInst.CLOSE);
      this._pInst._renderer._validateFaces = prevValidateFaces;
    });
    if (extrude === 0) {
      return geom;
    }
    const vertexIndices = {};
    const vertexId = (v) => `${v.x.toFixed(6)}-${v.y.toFixed(6)}-${v.z.toFixed(6)}`;
    const newVertices = [];
    const newVertexIndex = [];
    for (const v of geom.vertices) {
      const id = vertexId(v);
      if (!(id in vertexIndices)) {
        const index = newVertices.length;
        vertexIndices[id] = index;
        newVertices.push(v.copy());
      }
      newVertexIndex.push(vertexIndices[id]);
    }
    const newFaces = geom.faces.map((f) => f.map((i) => newVertexIndex[i]));
    const seen = {};
    for (const face of newFaces) {
      for (let off = 0; off < face.length; off++) {
        const a = face[off];
        const b2 = face[(off + 1) % face.length];
        const id = `${Math.min(a, b2)}-${Math.max(a, b2)}`;
        if (!seen[id]) seen[id] = [];
        seen[id].push([a, b2]);
      }
    }
    const validEdges = [];
    for (const key in seen) {
      if (seen[key].length === 1) {
        validEdges.push(seen[key][0]);
      }
    }
    const extruded = this._pInst.buildGeometry(() => {
    });
    const half = extrude * 0.5;
    extruded.vertices = [];
    extruded.faces = [];
    extruded.edges = [];
    for (const [a, b2] of validEdges) {
      const vA = newVertices[a];
      const vB = newVertices[b2];
      const edgeVector = new Vector(vB.x - vA.x, vB.y - vA.y, vB.z - vA.z);
      const extrudeVector = new Vector(0, 0, extrude);
      const crossProduct = Vector.cross(edgeVector, extrudeVector);
      const dist = edgeVector.mag();
      if (crossProduct.mag() < 1e-4 || dist < 1e-4) continue;
      const frontA = extruded.vertices.length;
      extruded.vertices.push(new Vector(vA.x, vA.y, vA.z + half));
      const frontB = extruded.vertices.length;
      extruded.vertices.push(new Vector(vB.x, vB.y, vB.z + half));
      const backA = extruded.vertices.length;
      extruded.vertices.push(new Vector(vA.x, vA.y, vA.z - half));
      const backB = extruded.vertices.length;
      extruded.vertices.push(new Vector(vB.x, vB.y, vB.z - half));
      extruded.faces.push([frontA, backA, backB]);
      extruded.faces.push([frontA, backB, frontB]);
      extruded.edges.push([frontA, frontB]);
      extruded.edges.push([backA, backB]);
      extruded.edges.push([frontA, backA]);
      extruded.edges.push([frontB, backB]);
    }
    const frontVertexOffset = extruded.vertices.length;
    for (const v of newVertices) {
      extruded.vertices.push(new Vector(v.x, v.y, v.z + half));
    }
    for (const face of newFaces) {
      if (face.length < 3) continue;
      const mappedFace = face.map((i) => i + frontVertexOffset);
      extruded.faces.push(mappedFace);
      for (let i = 0; i < mappedFace.length; i++) {
        const nextIndex2 = (i + 1) % mappedFace.length;
        extruded.edges.push([mappedFace[i], mappedFace[nextIndex2]]);
      }
    }
    const backVertexOffset = extruded.vertices.length;
    for (const v of newVertices) {
      extruded.vertices.push(new Vector(v.x, v.y, v.z - half));
    }
    for (const face of newFaces) {
      if (face.length < 3) continue;
      const mappedFace = [...face].reverse().map((i) => i + backVertexOffset);
      extruded.faces.push(mappedFace);
      for (let i = 0; i < mappedFace.length; i++) {
        const nextIndex2 = (i + 1) % mappedFace.length;
        extruded.edges.push([mappedFace[i], mappedFace[nextIndex2]]);
      }
    }
    extruded.computeNormals();
    return extruded;
  }
  variations() {
    let vars = {};
    if (this.data) {
      let axes = this.face?.axes;
      if (axes) {
        axes.forEach((ax) => {
          vars[ax.tag] = ax.value;
        });
      }
    }
    fontFaceVariations.forEach((v) => {
      let val = this.face[v];
      if (val !== "normal") {
        vars[v] = vars[v] || val;
      }
    });
    return vars;
  }
  metadata() {
    let meta = this.data?.name || {};
    for (let p2 in this.face) {
      if (!/^load/.test(p2)) {
        meta[p2] = meta[p2] || this.face[p2];
      }
    }
    return meta;
  }
  static async list(log3 = false) {
    if (log3) {
      console.log("There are", document.fonts.size, "font-faces\n");
      let loaded = 0;
      for (let fontFace of document.fonts.values()) {
        console.log("FontFace: {");
        for (let property in fontFace) {
          console.log("  " + property + ": " + fontFace[property]);
        }
        console.log("}\n");
        if (fontFace.status === "loaded") {
          loaded++;
        }
      }
      console.log(loaded + " loaded");
    }
    return await Array.from(document.fonts);
  }
  /////////////////////////////// HELPERS ////////////////////////////////
  /*
    Returns an array of line objects, each containing { text, x, y, glyphs: [ {g, path} ] }
  */
  _lineateAndPathify(str, x, y, width, height, options2 = {}) {
    let renderer2 = options2?.graphics?._renderer || this._pInst._renderer;
    renderer2.push();
    renderer2.textFont(this);
    let { lines, bounds } = renderer2._computeBounds(
      textCoreConstants._FONT_BOUNDS,
      str,
      x,
      y,
      width,
      height,
      { ignoreRectMode: true, ...options2 }
    );
    lines = this._position(renderer2, lines, bounds, width, height);
    let uPE = this.data?.head?.unitsPerEm || 1e3;
    let scale = renderer2.states.textSize / uPE;
    const axs = this._currentAxes(renderer2);
    let pathsForLine = lines.map((l) => this._lineToGlyphs(l, { scale, axs }));
    renderer2.pop();
    return pathsForLine;
  }
  _currentAxes(renderer2) {
    let axs;
    if ((this.data?.fvar?.length ?? 0) > 0) {
      const fontAxes = this.data.fvar[0];
      axs = fontAxes.map(([tag, minVal, defaultVal, maxVal, flags, name]) => {
        if (!renderer2) return defaultVal;
        if (tag === "wght") {
          return renderer2.states.fontWeight;
        } else if (tag === "wdth") {
          return 100;
        } else if (renderer2.textCanvas().style.fontVariationSettings) {
          const match = new RegExp(`\\b${tag}s+(d+)`).exec(renderer2.textCanvas().style.fontVariationSettings);
          if (match) {
            return parseInt(match[1]);
          } else {
            return defaultVal;
          }
        } else {
          return defaultVal;
        }
      });
    }
    return axs;
  }
  _textToPathPoints(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let cmds = this.textToPaths(str, x, y, width, height, options2);
    const subdivide = (pts2, pt1, pt2, md) => {
      if (fn.dist(pt1.x, pt1.y, pt2.x, pt2.y) > md) {
        let middle = { x: (pt1.x + pt2.x) / 2, y: (pt1.y + pt2.y) / 2 };
        pts2.push(middle);
        subdivide(pts2, pt1, middle, md);
        subdivide(pts2, middle, pt2, md);
      }
    };
    let pts = [];
    let { textSize } = this._pInst._renderer.states;
    let maxDist = textSize / this.data.head.unitsPerEm * 500;
    for (let i = 0; i < cmds.length; i++) {
      let { type: type2, data: d2 } = cmds[i];
      if (type2 !== "Z") {
        let pt2 = { x: d2[d2.length - 2], y: d2[d2.length - 1] };
        if (type2 === "L" && pts.length && !options2?.nodivide > 0) {
          subdivide(pts, pts[pts.length - 1], pt2, maxDist);
        }
        pts.push(pt2);
      }
    }
    return pts;
  }
  _parseArgs(width, height, options2 = {}) {
    if (typeof width === "object") {
      options2 = width;
      width = height = void 0;
    } else if (typeof height === "object") {
      options2 = height;
      height = void 0;
    }
    return { width, height, options: options2 };
  }
  _position(renderer2, lines, bounds, width, height) {
    let { textAlign, textLeading, textSize } = renderer2.states;
    let metrics = this._measureTextDefault(renderer2, "X");
    let ascent = metrics.fontBoundingBoxAscent;
    let coordify = (text2, i) => {
      let x = bounds.x;
      let y = bounds.y + i * textLeading + ascent;
      let lineWidth = renderer2._fontWidthSingle(text2);
      if (textAlign === CENTER) {
        x += (bounds.w - lineWidth) / 2;
      } else if (textAlign === RIGHT) {
        x += bounds.w - lineWidth;
      }
      if (typeof width !== "undefined") {
        switch (renderer2.states.rectMode) {
          case CENTER:
            x -= width / 2;
            y -= height / 2;
            break;
          case RADIUS:
            x -= width;
            y -= height;
            break;
        }
      }
      return { text: text2, x, y };
    };
    return lines.map(coordify);
  }
  _lineToGlyphs(line, { scale = 1, axs } = {}) {
    if (!this.data) {
      throw Error('No font data available for "' + this.name + '"\nTry downloading a local copy of the font file');
    }
    let glyphShapes = Typr.U.shape(this.data, line.text, { axs });
    line.glyphShapes = glyphShapes;
    line.glyphs = this._shapeToPaths(glyphShapes, line, { scale, axs });
    return line;
  }
  _positionGlyphs(text2, options2) {
    let renderer2 = options2?.graphics?._renderer || this._pInst._renderer;
    const axs = this._currentAxes(renderer2);
    const glyphShapes = Typr.U.shape(this.data, text2, { axs });
    const positionedGlyphs = [];
    let x = 0;
    for (const glyph of glyphShapes) {
      positionedGlyphs.push({ x, index: glyph.g, shape: glyph });
      x += glyph.ax;
    }
    return positionedGlyphs;
  }
  _singleShapeToPath(shape2, {
    scale = 1,
    x = 0,
    y = 0,
    lineX = 0,
    lineY = 0,
    axs
  } = {}) {
    let font2 = this.data;
    let crdIdx = 0;
    let { g: g2, ax, ay, dx, dy } = shape2;
    let { crds, cmds } = Typr.U.glyphToPath(font2, g2, true, axs);
    let glyph = {
      /*g: line.text[i], points: [],*/
      path: { commands: [] }
    };
    for (let j2 = 0; j2 < cmds.length; j2++) {
      let type2 = cmds[j2], command = [type2];
      if (type2 in pathArgCounts) {
        let argCount = pathArgCounts[type2];
        for (let k = 0; k < argCount; k += 2) {
          let gx = crds[k + crdIdx] + x + dx;
          let gy = crds[k + crdIdx + 1] + y + dy;
          let fx = lineX + gx * scale;
          let fy = lineY + gy * -scale;
          command.push(fx);
          command.push(fy);
        }
        crdIdx += argCount;
      }
      glyph.path.commands.push(command);
    }
    return { glyph, ax, ay };
  }
  _shapeToPaths(glyphs, line, { scale = 1, axs } = {}) {
    let x = 0, y = 0, paths = [];
    if (glyphs.length !== line.text.length) {
      throw Error("Invalid shape data");
    }
    for (let i = 0; i < glyphs.length; i++) {
      const { glyph, ax, ay } = this._singleShapeToPath(glyphs[i], {
        scale,
        x,
        y,
        lineX: line.x,
        lineY: line.y,
        axs
      });
      paths.push(glyph);
      x += ax;
      y += ay;
    }
    return paths;
  }
  _measureTextDefault(renderer2, str) {
    let { textAlign, textBaseline } = renderer2.states;
    let ctx = renderer2.textDrawingContext();
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    let metrics = ctx.measureText(str);
    ctx.textAlign = textAlign;
    ctx.textBaseline = textBaseline;
    return metrics;
  }
  drawPaths(ctx, commands, opts) {
    ctx.strokeStyle = opts?.stroke || ctx.strokeStyle;
    ctx.fillStyle = opts?.fill || ctx.fillStyle;
    ctx.beginPath();
    commands.forEach(([type2, ...data2]) => {
      if (type2 === "M") {
        ctx.moveTo(...data2);
      } else if (type2 === "L") {
        ctx.lineTo(...data2);
      } else if (type2 === "C") {
        ctx.bezierCurveTo(...data2);
      } else if (type2 === "Q") {
        ctx.quadraticCurveTo(...data2);
      } else if (type2 === "Z") {
        ctx.closePath();
      }
    });
    if (opts?.fill) ctx.fill();
    if (opts?.stroke) ctx.stroke();
  }
  _pathsToCommands(paths, scale) {
    let commands = [];
    for (let i = 0; i < paths.length; i++) {
      let pathData = paths[i];
      let { x, y, path: path2 } = pathData;
      let { crds, cmds } = path2;
      for (let c = 0, j2 = 0; j2 < cmds.length; j2++) {
        let cmd = cmds[j2], obj = { type: cmd, data: [] };
        if (cmd === "M" || cmd === "L") {
          obj.data.push(x + crds[c] * scale, y + crds[c + 1] * -scale);
          c += 2;
        } else if (cmd === "C") {
          for (let i2 = 0; i2 < 6; i2 += 2) {
            obj.data.push(
              x + crds[c + i2] * scale,
              y + crds[c + i2 + 1] * -scale
            );
          }
          c += 6;
        } else if (cmd === "Q") {
          for (let i2 = 0; i2 < 4; i2 += 2) {
            obj.data.push(
              x + crds[c + i2] * scale,
              y + crds[c + i2 + 1] * -scale
            );
          }
          c += 4;
        }
        commands.push(obj);
      }
    }
    return commands;
  }
}
async function create2(pInst, name, path2, descriptors, rawFont) {
  let face = createFontFace(name, path2, descriptors, rawFont);
  if (face.status !== "loaded") await face.load();
  document.fonts.add(face);
  await document.fonts.ready;
  return new Font(pInst, face, name, path2, rawFont);
}
function sanitizeFontName(name) {
  if (!/^[A-Za-z][A-Za-z0-9_-]*$/.test(name)) {
    name = "'" + String(name).replace(/'/g, "\\'") + "'";
  }
  return name;
}
function createFontFace(name, path2, descriptors, rawFont) {
  name = sanitizeFontName(name);
  let fontArg = rawFont?._compressedData ?? rawFont?._data;
  if (!fontArg) {
    if (!validFontTypesRe.test(path2)) {
      throw Error(invalidFontError);
    }
    if (!path2.startsWith("url(")) {
      path2 = "url(" + path2 + ")";
    }
    fontArg = path2;
  }
  if ((rawFont?.fvar?.length ?? 0) > 0) {
    descriptors = descriptors || {};
    for (const [
      tag,
      minVal,
      defaultVal,
      maxVal,
      flags,
      name2
    ] of rawFont.fvar[0]) {
      if (tag === "wght") {
        descriptors.weight = `${minVal} ${maxVal}`;
      } else if (tag === "wdth") {
        descriptors.stretch = `${minVal}% ${maxVal}%`;
      }
    }
  }
  let face = new FontFace(name, fontArg, descriptors);
  if (face.status === "error") {
    throw Error('Failed to create FontFace for "' + name + '"');
  }
  return face;
}
function extractFontName(font2, path2) {
  let result, meta = font2?.name;
  if (meta) {
    if (meta.fullName) {
      return meta.fullName;
    }
    if (meta.familyName) {
      result = meta.familyName;
    }
  }
  if (!result) {
    let matches = extractFontNameRe.exec(path2);
    if (matches && matches.length >= 3) {
      result = matches[1];
    } else {
      result = path2;
    }
  }
  if (result.includes(" ")) {
    result = result.replace(/ /g, "_");
  }
  return result;
}
function pathToPoints(cmds, options2, font2) {
  const parseOpts = (options3, defaults2) => {
    if (typeof options3 !== "object") {
      options3 = defaults2;
    } else {
      for (const key in defaults2) {
        if (typeof options3[key] === "undefined") {
          options3[key] = defaults2[key];
        }
      }
    }
    return options3;
  };
  const at3 = (v, i) => {
    const s = v.length;
    return v[i < 0 ? i % s + s : i % s];
  };
  const simplify = (pts, angle) => {
    angle = angle || 0;
    let num = 0;
    for (let i = pts.length - 1; pts.length > 3 && i >= 0; --i) {
      if (collinear(at3(pts, i - 1), at3(pts, i), at3(pts, i + 1), angle)) {
        pts.splice(i % pts.length, 1);
        num++;
      }
    }
    return num;
  };
  const collinear = (a, b2, c, thresholdAngle) => {
    if (!thresholdAngle) {
      return areaTriangle(a, b2, c) === 0;
    }
    if (typeof collinear.tmpPoint1 === "undefined") {
      collinear.tmpPoint1 = [];
      collinear.tmpPoint2 = [];
    }
    const ab = collinear.tmpPoint1, bc = collinear.tmpPoint2;
    ab.x = b2.x - a.x;
    ab.y = b2.y - a.y;
    bc.x = c.x - b2.x;
    bc.y = c.y - b2.y;
    const dot = ab.x * bc.x + ab.y * bc.y, magA = Math.sqrt(ab.x * ab.x + ab.y * ab.y), magB = Math.sqrt(bc.x * bc.x + bc.y * bc.y), angle = Math.acos(dot / (magA * magB));
    return angle < thresholdAngle;
  };
  const areaTriangle = (a, b2, c) => {
    return (b2[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b2[1] - a[1]);
  };
  const path2 = bezierPathExports.createFromCommands(arrayCommandsToObjects(cmds));
  let opts = parseOpts(options2, {
    sampleFactor: 0.1,
    simplifyThreshold: 0
  });
  const totalPoints = Math.max(
    1,
    Math.ceil(path2.getTotalLength() * opts.sampleFactor)
  );
  let points = [];
  const mode = font2._pInst.angleMode();
  const DEGREES = font2._pInst.DEGREES;
  for (let i = 0; i < totalPoints; i++) {
    const length = path2.getTotalLength() * (totalPoints === 1 ? 0 : i / (totalPoints - 1));
    points.push({
      ...path2.getPointAtLength(length),
      get angle() {
        const angle = path2.getAngleAtLength(length);
        if (mode === DEGREES) {
          return angle * 180 / Math.PI;
        } else {
          return angle;
        }
      },
      // For backwards compatibility
      get alpha() {
        return this.angle;
      }
    });
  }
  if (opts.simplifyThreshold) {
    simplify(points, opts.simplifyThreshold);
  }
  return points;
}
function unquote(name) {
  if ((name.startsWith('"') || name.startsWith("'")) && name.at(0) === name.at(-1)) {
    return name.slice(1, -1).replace(/\/(['"])/g, "$1");
  }
  return name;
}
function parseCreateArgs(...args) {
  let path2 = args.shift();
  if (typeof path2 !== "string" || path2.length === 0) {
    p5._friendlyError(invalidFontError, "p5.loadFont");
  }
  let name;
  if (typeof args[0] === "string") {
    name = args.shift();
  }
  let success, error2, options2;
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (typeof arg === "function") {
      if (!success) {
        success = arg;
      } else {
        error2 = arg;
      }
    } else if (typeof arg === "object") {
      options2 = arg;
    }
  }
  return { path: path2, name, success, error: error2, options: options2 };
}
function font(p53, fn2) {
  p53.Font = Font;
  fn2.parseFontData = async function(pathOrData) {
    let result = pathOrData instanceof Uint8Array ? pathOrData : await fn2.loadBytes(pathOrData);
    if (!result) {
      throw Error("Failed to load font data");
    }
    let fonts = Typr.parse(result);
    if (fonts.length === 0 || fonts[0].cmap === void 0) {
      throw Error("parsing font data");
    }
    return fonts[0];
  };
  fn2.loadFont = async function(...args) {
    let {
      path: path2,
      name,
      success,
      error: error2,
      options: { sets: sets2, ...descriptors } = {}
    } = parseCreateArgs(...args);
    let isCSS = path2.includes("@font-face");
    if (!isCSS) {
      let info;
      try {
        info = await fetch(path2, { method: "HEAD" });
      } catch (e2) {
        info = await fetch(path2);
      }
      const isCSSFile = info.headers.get("content-type")?.startsWith("text/css");
      if (isCSSFile) {
        isCSS = true;
        path2 = await fetch(path2).then((res) => res.text());
      }
    }
    if (isCSS) {
      const stylesheet2 = new CSSStyleSheet();
      await stylesheet2.replace(path2);
      const possibleFonts = [];
      for (const rule of stylesheet2.cssRules) {
        if (rule instanceof CSSFontFaceRule) {
          const style = rule.style;
          let name2 = unquote(style.getPropertyValue("font-family"));
          const src = style.getPropertyValue("src");
          const fontDescriptors = { ...descriptors || {} };
          for (const key of style) {
            if (key === "font-family" || key === "src") continue;
            const camelCaseKey = key.replace(/^font-/, "").split("-").map((v, i) => i === 0 ? v : `${v[0].toUpperCase()}${v.slice(1)}`).join("");
            fontDescriptors[camelCaseKey] = style.getPropertyValue(key);
          }
          possibleFonts.push({
            name: name2,
            src,
            fontDescriptors,
            loadWithData: async () => {
              let fontData;
              try {
                const urlMatch = /url\(([^\)]+)\)/.exec(src);
                if (urlMatch) {
                  let url = urlMatch[1];
                  if (/^['"]/.exec(url) && url.at(0) === url.at(-1)) {
                    url = url.slice(1, -1);
                  }
                  fontData = await fn2.parseFontData(url);
                }
              } catch (_e) {
              }
              return create2(this, name2, src, fontDescriptors, fontData);
            },
            loadWithoutData: () => create2(this, name2, src, fontDescriptors)
          });
        }
      }
      sets2 = sets2 || ["latin"];
      const requestedGroups = (sets2 instanceof Array ? sets2 : [sets2]).map((s) => s.toLowerCase());
      const requestedCategories = unicodeRanges.filter((r) => requestedGroups.some(
        (g2) => r.category.includes(g2) && // Only include extended character sets if specifically requested
        r.category.includes("ext") === g2.includes("ext")
      ));
      const requestedRanges = new Set(
        libExports.UnicodeRange.parse(
          requestedCategories.map((c) => `U+${c.hexrange[0]}-${c.hexrange[1]}`)
        )
      );
      let closestRangeOverlap = 0;
      let closestDescriptorOverlap = 0;
      let closestMatch = void 0;
      for (const font2 of possibleFonts) {
        if (!font2.fontDescriptors.unicodeRange) continue;
        const fontRange = new Set(
          libExports.UnicodeRange.parse(
            font2.fontDescriptors.unicodeRange.split(/,\s*/g)
          )
        );
        const rangeOverlap = [...fontRange.values()].filter((v) => requestedRanges.has(v)).length;
        const targetDescriptors = {
          // Default to normal style at regular weight
          style: "normal",
          weight: 400,
          // Override from anything else passed in
          ...descriptors
        };
        const descriptorOverlap = Object.keys(font2.fontDescriptors).filter((k) => font2.fontDescriptors[k] === targetDescriptors[k]).length;
        if (descriptorOverlap > closestDescriptorOverlap || descriptorOverlap === closestDescriptorOverlap && rangeOverlap >= closestRangeOverlap) {
          closestDescriptorOverlap = descriptorOverlap;
          closestRangeOverlap = rangeOverlap;
          closestMatch = font2;
        }
      }
      const picked = closestMatch || possibleFonts.at(-1);
      for (const font2 of possibleFonts) {
        if (font2 !== picked) {
          font2.loadWithoutData();
        }
      }
      return picked?.loadWithData();
    }
    let pfont;
    try {
      const fontData = await fn2.parseFontData(path2);
      name = name || extractFontName(fontData, path2);
      pfont = await create2(this, name, path2, descriptors, fontData);
    } catch (err) {
      let ident = name || path2.substring(path2.lastIndexOf("/") + 1).replace(/\.[^/.]+$/, "");
      console.warn(`WARN: No glyph data for '${ident}', retrying as FontFace`);
      try {
        pfont = await create2(this, ident, path2, descriptors);
      } catch (err2) {
        if (error2) return error2(err2);
        throw err2;
      }
    }
    if (success) return success(pfont);
    return pfont;
  };
}
const arrayCommandsToObjects = (commands) => commands.map((command) => {
  const type2 = command[0];
  switch (type2) {
    case "Z": {
      return { type: type2 };
    }
    case "M":
    case "L": {
      const [, x, y] = command;
      return { type: type2, x, y };
    }
    case "Q": {
      const [, x1, y1, x, y] = command;
      return { type: type2, x1, y1, x, y };
    }
    case "C": {
      const [, x1, y1, x2, y2, x, y] = command;
      return { type: type2, x1, y1, x2, y2, x, y };
    }
    default: {
      throw new Error(`Unexpected path command: ${type2}`);
    }
  }
});
if (typeof p5 !== "undefined") {
  font(p5, p5.prototype);
}
function text(p53, fn2) {
  Renderer3D.prototype.maxCachedGlyphs = function() {
    return 200;
  };
  Font.prototype._getFontInfo = function(axs) {
    this._fontInfos = this._fontInfos || {};
    const key = JSON.stringify(axs);
    if (this._fontInfos[key]) {
      const val = this._fontInfos[key];
      return val;
    } else {
      const val = new FontInfo(this, { axs });
      this._fontInfos[key] = val;
      return val;
    }
  };
  const charGridWidth = 9;
  const charGridHeight = charGridWidth;
  const strokeImageWidth = 64;
  const strokeImageHeight = 64;
  const gridImageWidth = 64;
  const gridImageHeight = 64;
  const cellImageWidth = 64;
  const cellImageHeight = 64;
  class ImageInfos {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.infos = [];
    }
    /**
     *
     * @param {Integer} space
     * @return {Object} contains the ImageData, and pixel index into that
     *                  ImageData where the free space was allocated.
     *
     * finds free space of a given size in the ImageData list
     */
    findImage(space) {
      const imageSize = this.width * this.height;
      if (space > imageSize)
        throw new Error("font is too complex to render in 3D");
      let imageInfo, imageData;
      for (let ii = this.infos.length - 1; ii >= 0; --ii) {
        const imageInfoTest = this.infos[ii];
        if (imageInfoTest.index + space < imageSize) {
          imageInfo = imageInfoTest;
          imageData = imageInfoTest.imageData;
          break;
        }
      }
      if (!imageInfo) {
        try {
          imageData = new ImageData(this.width, this.height);
        } catch (err) {
          let canvas2 = document.getElementsByTagName("canvas")[0];
          const created = !canvas2;
          if (!canvas2) {
            canvas2 = document.createElement("canvas");
            canvas2.style.display = "none";
            document.body.appendChild(canvas2);
          }
          const ctx = canvas2.getContext("2d");
          if (ctx) {
            imageData = ctx.createImageData(this.width, this.height);
          }
          if (created) {
            document.body.removeChild(canvas2);
          }
        }
        imageInfo = { index: 0, imageData };
        this.infos.push(imageInfo);
      }
      const index = imageInfo.index;
      imageInfo.index += space;
      imageData._dirty = true;
      return { imageData, index };
    }
  }
  function setPixel(imageInfo, r, g2, b2, a) {
    const imageData = imageInfo.imageData;
    const pixels2 = imageData.data;
    let index = imageInfo.index++ * 4;
    pixels2[index++] = r;
    pixels2[index++] = g2;
    pixels2[index++] = b2;
    pixels2[index++] = a;
  }
  const SQRT3 = Math.sqrt(3);
  class FontInfo {
    constructor(font2, { axs } = {}) {
      this.font = font2;
      this.axs = axs;
      this.strokeImageInfos = new ImageInfos(
        strokeImageWidth,
        strokeImageHeight
      );
      this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
      this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
      this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
      this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
      this.glyphInfos = {};
    }
    /**
     * @param {Glyph} glyph the x positions of points in the curve
     * @returns {Object} the glyphInfo for that glyph
     *
     * calculates rendering info for a glyph, including the curve information,
     * row & column stripes compiled into textures.
     */
    getGlyphInfo(glyph) {
      let gi = this.glyphInfos[glyph.index];
      if (gi) return gi;
      const axs = this.axs;
      const {
        glyph: {
          path: { commands }
        }
      } = this.font._singleShapeToPath(glyph.shape, { axs });
      let xMin = Infinity;
      let xMax = -Infinity;
      let yMin = Infinity;
      let yMax = -Infinity;
      for (const cmd of commands) {
        for (let i2 = 1; i2 < cmd.length; i2 += 2) {
          xMin = Math.min(xMin, cmd[i2]);
          xMax = Math.max(xMax, cmd[i2]);
          yMin = Math.min(yMin, cmd[i2 + 1]);
          yMax = Math.max(yMax, cmd[i2 + 1]);
        }
      }
      if (xMin >= xMax || yMin >= yMax || !commands.length) {
        return this.glyphInfos[glyph.index] = {};
      }
      const gWidth = xMax - xMin;
      const gHeight = yMax - yMin;
      const cmds = arrayCommandsToObjects(commands);
      let i;
      const strokes = [];
      const rows = [];
      const cols = [];
      for (i = charGridWidth - 1; i >= 0; --i) cols.push([]);
      for (i = charGridHeight - 1; i >= 0; --i) rows.push([]);
      function push(xs2, ys2, v) {
        const index = strokes.length;
        strokes.push(v);
        function minMax(rg, min, max) {
          for (let i2 = rg.length; i2-- > 0; ) {
            const v2 = rg[i2];
            if (min > v2) min = v2;
            if (max < v2) max = v2;
          }
          return { min, max };
        }
        const cellOffset = 0.5;
        const mmX = minMax(xs2, 1, 0);
        const ixMin = Math.max(
          Math.floor(mmX.min * charGridWidth - cellOffset),
          0
        );
        const ixMax = Math.min(
          Math.ceil(mmX.max * charGridWidth + cellOffset),
          charGridWidth
        );
        for (let iCol = ixMin; iCol < ixMax; ++iCol) cols[iCol].push(index);
        const mmY = minMax(ys2, 1, 0);
        const iyMin = Math.max(
          Math.floor(mmY.min * charGridHeight - cellOffset),
          0
        );
        const iyMax = Math.min(
          Math.ceil(mmY.max * charGridHeight + cellOffset),
          charGridHeight
        );
        for (let iRow = iyMin; iRow < iyMax; ++iRow) rows[iRow].push(index);
      }
      function clamp2(v, min, max) {
        if (v < min) return min;
        if (v > max) return max;
        return v;
      }
      function byte(v) {
        return clamp2(255 * v, 0, 255);
      }
      class Cubic {
        constructor(p0, c0, c12, p1) {
          this.p0 = p0;
          this.c0 = c0;
          this.c1 = c12;
          this.p1 = p1;
        }
        /**
         * @return {Object} the quadratic approximation
         *
         * converts the cubic to a quadtratic approximation by
         * picking an appropriate quadratic control point
         */
        toQuadratic() {
          return {
            x: this.p0.x,
            y: this.p0.y,
            x1: this.p1.x,
            y1: this.p1.y,
            cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,
            cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4
          };
        }
        /**
         * @return {Number} the error
         *
         * calculates the magnitude of error of this curve's
         * quadratic approximation.
         */
        quadError() {
          return Vector.sub(
            Vector.sub(this.p1, this.p0),
            Vector.mult(Vector.sub(this.c1, this.c0), 3)
          ).mag() / 2;
        }
        /**
         * @param {Number} t the value (0-1) at which to split
         * @return {Cubic} the second part of the curve
         *
         * splits the cubic into two parts at a point 't' along the curve.
         * this cubic keeps its start point and its end point becomes the
         * point at 't'. the 'end half is returned.
         */
        split(t) {
          const m12 = Vector.lerp(this.p0, this.c0, t);
          const m22 = Vector.lerp(this.c0, this.c1, t);
          const mm1 = Vector.lerp(m12, m22, t);
          this.c1 = Vector.lerp(this.c1, this.p1, t);
          this.c0 = Vector.lerp(m22, this.c1, t);
          const pt2 = Vector.lerp(mm1, this.c0, t);
          const part1 = new Cubic(this.p0, m12, mm1, pt2);
          this.p0 = pt2;
          return part1;
        }
        /**
         * @return {Cubic[]} the non-inflecting pieces of this cubic
         *
         * returns an array containing 0, 1 or 2 cubics split resulting
         * from splitting this cubic at its inflection points.
         * this cubic is (potentially) altered and returned in the list.
         */
        splitInflections() {
          const a = Vector.sub(this.c0, this.p0);
          const b2 = Vector.sub(Vector.sub(this.c1, this.c0), a);
          const c = Vector.sub(
            Vector.sub(Vector.sub(this.p1, this.c1), a),
            Vector.mult(b2, 2)
          );
          const cubics = [];
          let A = b2.x * c.y - b2.y * c.x;
          if (A !== 0) {
            let B = a.x * c.y - a.y * c.x;
            let C = a.x * b2.y - a.y * b2.x;
            const disc = B * B - 4 * A * C;
            if (disc >= 0) {
              if (A < 0) {
                A = -A;
                B = -B;
                C = -C;
              }
              const Q2 = Math.sqrt(disc);
              const t0 = (-B - Q2) / (2 * A);
              let t1 = (-B + Q2) / (2 * A);
              if (t0 > 0 && t0 < 1) {
                cubics.push(this.split(t0));
                t1 = 1 - (1 - t1) / (1 - t0);
              }
              if (t1 > 0 && t1 < 1) {
                cubics.push(this.split(t1));
              }
            }
          }
          cubics.push(this);
          return cubics;
        }
      }
      function cubicToQuadratics(x02, y02, cx0, cy0, cx1, cy1, x1, y1) {
        const cubics = new Cubic(
          new Vector(x02, y02),
          new Vector(cx0, cy0),
          new Vector(cx1, cy1),
          new Vector(x1, y1)
        ).splitInflections();
        const qs = [];
        const precision = 30 / SQRT3;
        for (let cubic of cubics) {
          const tail = [];
          let t3;
          for (; ; ) {
            t3 = precision / cubic.quadError();
            if (t3 >= 0.5 * 0.5 * 0.5) {
              break;
            }
            const t = Math.pow(t3, 1 / 3);
            const start2 = cubic.split(t);
            const middle = cubic.split(1 - t / (1 - t));
            qs.push(start2);
            tail.push(cubic);
            cubic = middle;
          }
          if (t3 < 1) {
            qs.push(cubic.split(0.5));
          }
          qs.push(cubic);
          Array.prototype.push.apply(qs, tail.reverse());
        }
        return qs;
      }
      function pushLine(x02, y02, x1, y1) {
        const mx = (x02 + x1) / 2;
        const my = (y02 + y1) / 2;
        push([x02, x1], [y02, y1], { x: x02, y: y02, cx: mx, cy: my });
      }
      function samePoint(x02, y02, x1, y1) {
        return Math.abs(x1 - x02) < 1e-5 && Math.abs(y1 - y02) < 1e-5;
      }
      let x0, y0, xs, ys;
      for (const cmd of cmds) {
        const x1 = (cmd.x - xMin) / gWidth;
        const y1 = (cmd.y - yMin) / gHeight;
        if (samePoint(x0, y0, x1, y1)) continue;
        switch (cmd.type) {
          case "M": {
            xs = x1;
            ys = y1;
            break;
          }
          case "L": {
            pushLine(x0, y0, x1, y1);
            break;
          }
          case "Q": {
            const cx = (cmd.x1 - xMin) / gWidth;
            const cy = (cmd.y1 - yMin) / gHeight;
            push([x0, x1, cx], [y0, y1, cy], { x: x0, y: y0, cx, cy });
            break;
          }
          case "Z": {
            if (!samePoint(x0, y0, xs, ys)) {
              pushLine(x0, y0, xs, ys);
              strokes.push({ x: xs, y: ys });
            } else {
              strokes.push({ x: x0, y: y0 });
            }
            break;
          }
          case "C": {
            const cx1 = (cmd.x1 - xMin) / gWidth;
            const cy1 = (cmd.y1 - yMin) / gHeight;
            const cx2 = (cmd.x2 - xMin) / gWidth;
            const cy2 = (cmd.y2 - yMin) / gHeight;
            const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);
            for (let iq = 0; iq < qs.length; iq++) {
              const q = qs[iq].toQuadratic();
              push([q.x, q.x1, q.cx], [q.y, q.y1, q.cy], q);
            }
            break;
          }
          default:
            throw new Error(`unknown command type: ${cmd.type}`);
        }
        x0 = x1;
        y0 = y1;
      }
      const strokeCount = strokes.length;
      const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);
      const strokeOffset = strokeImageInfo.index;
      for (let il = 0; il < strokeCount; ++il) {
        const s = strokes[il];
        setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));
      }
      function layout(dim, dimImageInfos, cellImageInfos) {
        const dimLength = dim.length;
        const dimImageInfo = dimImageInfos.findImage(dimLength);
        const dimOffset = dimImageInfo.index;
        let totalStrokes = 0;
        for (let id = 0; id < dimLength; ++id) {
          totalStrokes += dim[id].length;
        }
        const cellImageInfo = cellImageInfos.findImage(totalStrokes);
        for (let i2 = 0; i2 < dimLength; ++i2) {
          const strokeIndices = dim[i2];
          const strokeCount2 = strokeIndices.length;
          const cellLineIndex = cellImageInfo.index;
          setPixel(
            dimImageInfo,
            cellLineIndex >> 7,
            cellLineIndex & 127,
            strokeCount2 >> 7,
            strokeCount2 & 127
          );
          for (let iil = 0; iil < strokeCount2; ++iil) {
            const strokeIndex = strokeIndices[iil] + strokeOffset;
            setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 127, 0, 0);
          }
        }
        return {
          cellImageInfo,
          dimOffset,
          dimImageInfo
        };
      }
      gi = this.glyphInfos[glyph.index] = {
        glyph,
        uGlyphRect: [xMin, yMin, xMax, yMax],
        strokeImageInfo,
        strokes,
        colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),
        rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos)
      };
      gi.uGridOffset = [gi.colInfo.dimOffset, gi.rowInfo.dimOffset];
      return gi;
    }
  }
  Renderer3D.prototype._renderText = function(line, x, y, maxY, minY) {
    if (!this.states.textFont || typeof this.states.textFont === "string") {
      console.log(
        "WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details."
      );
      return;
    }
    if (y >= maxY || !this.states.fillColor) {
      return;
    }
    if (!p53.Font.hasGlyphData(this.states.textFont)) {
      console.log(
        "WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported"
      );
      return;
    }
    this.push();
    const doStroke = this.states.strokeColor;
    const drawMode = this.states.drawMode;
    this.states.setValue("strokeColor", null);
    this.states.setValue("drawMode", TEXTURE);
    const { font: font2 } = this.states.textFont;
    if (!font2) {
      throw new Error(
        "In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name."
      );
    }
    const axs = font2._currentAxes(this);
    let fontInfo = font2._getFontInfo(axs);
    const pos = { x, y };
    const fontSize = this.states.textSize;
    const scale = fontSize / (font2.data?.head?.unitsPerEm || 1e3);
    this.translate(pos.x, pos.y, 0);
    this.scale(scale, scale, 1);
    const initializeShader = !this._defaultFontShader;
    const sh = this._getFontShader();
    sh.init();
    sh.bindShader("text");
    if (initializeShader) {
      sh.setUniform("uGridImageSize", [gridImageWidth, gridImageHeight]);
      sh.setUniform("uCellsImageSize", [cellImageWidth, cellImageHeight]);
      sh.setUniform("uStrokeImageSize", [strokeImageWidth, strokeImageHeight]);
      sh.setUniform("uGridSize", [charGridWidth, charGridHeight]);
    }
    const curFillColor = this.states.fillSet ? this.states.curFillColor : [0, 0, 0, 1];
    this._setGlobalUniforms(sh);
    this._applyColorBlend(curFillColor);
    let g2 = this.geometryBufferCache.getGeometryByID("glyph");
    if (!g2) {
      g2 = this._textGeom = new Geometry(
        1,
        1,
        function() {
          for (let i = 0; i <= 1; i++) {
            for (let j2 = 0; j2 <= 1; j2++) {
              this.vertices.push(new Vector(j2, i, 0));
              this.uvs.push(j2, i);
            }
          }
        },
        this
      );
      g2.gid = "glyph";
      g2.computeFaces().computeNormals();
      this.geometryBufferCache.ensureCached(g2);
    }
    for (const buff of this.buffers.text) {
      buff._prepareBuffer(g2, sh);
    }
    sh.setUniform("uMaterialColor", curFillColor);
    this._disableRemainingAttributes(sh);
    this._beforeDrawText();
    this.glyphDataCache = this.glyphDataCache || /* @__PURE__ */ new Set();
    try {
      const glyphs = font2._positionGlyphs(line);
      for (const glyph of glyphs) {
        const gi = fontInfo.getGlyphInfo(glyph);
        if (gi.uGlyphRect) {
          const rowInfo = gi.rowInfo;
          const colInfo = gi.colInfo;
          const glyphResources = [
            gi.strokeImageInfo.imageData,
            rowInfo.cellImageInfo.imageData,
            rowInfo.dimImageInfo.imageData,
            colInfo.cellImageInfo.imageData,
            colInfo.dimImageInfo.imageData
          ];
          for (const resource of glyphResources) {
            this.glyphDataCache.delete(resource);
            this.glyphDataCache.add(resource);
          }
          while (this.glyphDataCache.size > this.maxCachedGlyphs()) {
            const data2 = this.glyphDataCache.values().next().value;
            this.glyphDataCache.delete(data2);
            const tex = this.textures.get(data2);
            if (tex) {
              tex.remove();
              this.textures.delete(data2);
            }
          }
          sh.setUniform("uSamplerStrokes", gi.strokeImageInfo.imageData);
          sh.setUniform("uSamplerRowStrokes", rowInfo.cellImageInfo.imageData);
          sh.setUniform("uSamplerRows", rowInfo.dimImageInfo.imageData);
          sh.setUniform("uSamplerColStrokes", colInfo.cellImageInfo.imageData);
          sh.setUniform("uSamplerCols", colInfo.dimImageInfo.imageData);
          sh.setUniform("uGridOffset", gi.uGridOffset);
          sh.setUniform("uGlyphRect", gi.uGlyphRect);
          sh.setUniform("uGlyphOffset", glyph.x);
          sh.bindTextures();
          this._drawBuffers(g2, { mode: TRIANGLES, count: 1 });
        }
      }
    } finally {
      sh.unbindShader();
      this.states.setValue("strokeColor", doStroke);
      this.states.setValue("drawMode", drawMode);
      this._afterDrawText();
      this.pop();
    }
  };
}
var lightingShader = '#define PI 3.141592\n\nprecision highp float;\nprecision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform mat3 uCameraRotation;\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];	\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\nuniform float uMetallic;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\n// setting from  _setImageLightUniforms()\n// boolean to initiate the calculateImageDiffuse and calculateImageSpecular\nuniform bool uUseImageLight;\n// texture for use in calculateImageDiffuse\nuniform sampler2D environmentMapDiffused;\n// texture for use in calculateImageSpecular\nuniform sampler2D environmentMapSpecular;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n  float specular;\n  float diffuse;\n};\n\nfloat _phongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  vec3 R = reflect(lightDirection, surfaceNormal);\n  return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n  return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector, float shininess, float metallic) {\n\n  vec3 lightDir = normalize(lightVector);\n\n  //compute our diffuse & specular terms\n  LightResult lr;\n  float specularIntensity = mix(1.0, 0.4, metallic);\n  float diffuseIntensity = mix(1.0, 0.1, metallic);\n  if (uSpecular)\n    lr.specular = (_phongSpecular(lightDir, viewDirection, normal, shininess)) * specularIntensity;\n    lr.diffuse = _lambertDiffuse(lightDir, normal) * diffuseIntensity;\n  return lr;\n}\n\n// converts the range of "value" from [min1 to max1] to [min2 to max2]\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 mapTextureToNormal( vec3 v ){\n  // x = r sin(phi) cos(theta)   \n  // y = r cos(phi)  \n  // z = r sin(phi) sin(theta)\n  float phi = acos( v.y );\n  // if phi is 0, then there are no x, z components\n  float theta = 0.0;\n  // else \n  theta = acos(v.x / sin(phi));\n  float sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * 3.14159);\n  phi = phi / 3.14159 ;\n  \n  vec2 angles = vec2( fract(theta + 0.25), 1.0 - phi );\n  return angles;\n}\n\n\nvec3 calculateImageDiffuse(vec3 vNormal, vec3 vViewPosition, float metallic){\n  // make 2 seperate builds \n  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);  // hardcoded world camera position\n  vec3 worldNormal = normalize(vNormal * uCameraRotation);\n  vec2 newTexCoor = mapTextureToNormal( worldNormal );\n  vec4 texture = TEXTURE( environmentMapDiffused, newTexCoor );\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(smoothstep(vec3(0.0), vec3(1.0), texture.xyz), vec3(0.0), metallic);\n}\n\nvec3 calculateImageSpecular(vec3 vNormal, vec3 vViewPosition, float shininess, float metallic){\n  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);\n  vec3 worldNormal = normalize(vNormal);\n  vec3 lightDirection = normalize( vViewPosition - worldCameraPosition );\n  vec3 R = reflect(lightDirection, worldNormal) * uCameraRotation;\n  vec2 newTexCoor = mapTextureToNormal( R );\n#ifdef WEBGL2\n  // In p5js the range of shininess is >= 1,\n  // Therefore roughness range will be ([0,1]*8)*20 or [0, 160]\n  // The factor of 8 is because currently the getSpecularTexture\n  // only calculated 8 different levels of roughness\n  // The factor of 20 is just to spread up this range so that,\n  // [1, max] of shininess is converted to [0,160] of roughness\n  float roughness = 20. / shininess;\n  vec4 outColor = textureLod(environmentMapSpecular, newTexCoor, roughness * 8.);\n#else\n  vec4 outColor = TEXTURE(environmentMapSpecular, newTexCoor);\n#endif\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(\n    pow(outColor.xyz, vec3(10)),\n    pow(outColor.xyz, vec3(1.2)),\n    metallic \n  );\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  float shininess,\n  float metallic,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  if( uUseImageLight ){\n    totalDiffuse += calculateImageDiffuse(normal, modelPosition, metallic);\n    totalSpecular += calculateImageSpecular(normal, modelPosition, shininess, metallic);\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n';
var normalVert = "IN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\n#define HOOK_DEFINES\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat3 uModelNormalMatrix;\nuniform mat3 uCameraNormalMatrix;\n#else\nuniform mat4 uModelViewMatrix;\nuniform mat3 uNormalMatrix;\n#endif\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uMaterialColor;\nuniform bool uUseVertexColor;\n\nOUT vec3 vVertexNormal;\nOUT highp vec2 vVertTexCoord;\nOUT vec4 vColor;\n\nstruct Vertex {\n  vec3 position;\n  vec3 normal;\n  vec2 texCoord;\n  vec4 color;\n};\n\nvoid main(void) {\n  HOOK_beforeVertex();\n\n  Vertex inputs;\n  inputs.position = aPosition;\n  inputs.normal = aNormal;\n  inputs.texCoord = aTexCoord;\n  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uModelNormalMatrix * inputs.normal;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uCameraNormalMatrix * inputs.normal;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uNormalMatrix * inputs.normal;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n#endif\n\n  // Pass varyings to fragment shader\n  vVertTexCoord = inputs.texCoord;\n  vVertexNormal = normalize(inputs.normal);\n  vColor = inputs.color;\n\n  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);\n\n  HOOK_afterVertex();\n}\n";
var normalFrag = "IN vec3 vVertexNormal;\nvoid main(void) {\n  HOOK_beforeFragment();\n  OUT_COLOR = HOOK_getFinalColor(vec4(vVertexNormal, 1.0));\n  HOOK_afterFragment();\n}\n";
var basicFrag = "IN vec4 vColor;\nvoid main(void) {\n  HOOK_beforeFragment();\n  OUT_COLOR = HOOK_getFinalColor(vColor);\n  OUT_COLOR.rgb *= OUT_COLOR.a; // Premultiply alpha before rendering\n  HOOK_afterFragment();\n}\n";
var lightVert = "// include lighting.glgl\n\nIN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform bool uUseVertexColor;\nuniform vec4 uMaterialColor;\n\nOUT highp vec2 vVertTexCoord;\nOUT vec3 vDiffuseColor;\nOUT vec3 vSpecularColor;\nOUT vec4 vColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;\n\n  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);\n  vVertTexCoord = aTexCoord;\n\n  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);\n\n  for (int i = 0; i < 8; i++) {\n    if (i < uAmbientLightCount) {\n      vDiffuseColor += uAmbientColor[i];\n    }\n  }\n  \n  vColor = ((uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor);\n}\n";
var lightTextureFrag = "uniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nIN highp vec2 vVertTexCoord;\nIN vec3 vDiffuseColor;\nIN vec3 vSpecularColor;\nIN vec4 vColor;\n\nvoid main(void) {\n  if(uEmissive && !isTexture) {\n    OUT_COLOR = vColor;\n  }\n  else {\n    vec4 baseColor = isTexture\n      // Textures come in with premultiplied alpha. To apply tint and still have\n      // premultiplied alpha output, we need to multiply the RGB channels by the\n      // tint RGB, and all channels by the tint alpha.\n      ? TEXTURE(uSampler, vVertTexCoord) * vec4(uTint.rgb/255., 1.) * (uTint.a/255.)\n      // Colors come in with unmultiplied alpha, so we need to multiply the RGB\n      // channels by alpha to convert it to premultiplied alpha.\n      : vec4(vColor.rgb * vColor.a, vColor.a);\n    OUT_COLOR = vec4(baseColor.rgb * vDiffuseColor + vSpecularColor, baseColor.a);\n  }\n}\n";
var phongVert = "precision highp int;\n\n#define HOOK_DEFINES\n\nIN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat3 uModelNormalMatrix;\nuniform mat3 uCameraNormalMatrix;\n#else\nuniform mat4 uModelViewMatrix;\nuniform mat3 uNormalMatrix;\n#endif\nuniform mat4 uProjectionMatrix;\n\nuniform bool uUseVertexColor;\nuniform vec4 uMaterialColor;\n\nOUT vec3 vNormal;\nOUT vec2 vTexCoord;\nOUT vec3 vViewPosition;\nOUT vec3 vAmbientColor;\nOUT vec4 vColor;\n\nstruct Vertex {\n  vec3 position;\n  vec3 normal;\n  vec2 texCoord;\n  vec4 color;\n};\n\nvoid main(void) {\n  HOOK_beforeVertex();\n\n  Vertex inputs;\n  inputs.position = aPosition;\n  inputs.normal = aNormal;\n  inputs.texCoord = aTexCoord;\n  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uModelNormalMatrix * inputs.normal;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uCameraNormalMatrix * inputs.normal;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uNormalMatrix * inputs.normal;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n#endif\n\n  // Pass varyings to fragment shader\n  vViewPosition = inputs.position;\n  vTexCoord = inputs.texCoord;\n  vNormal = inputs.normal;\n  vColor = inputs.color;\n\n  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);\n  HOOK_afterVertex();\n}\n";
var phongFrag = "// include lighting.glsl\nprecision highp int;\n\nuniform bool uHasSetAmbient;\nuniform vec3 uAmbientColor;\nuniform vec4 uSpecularMatColor;\nuniform vec4 uAmbientMatColor;\nuniform vec4 uEmissiveMatColor;\n\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\n\nIN vec3 vNormal;\nIN vec2 vTexCoord;\nIN vec3 vViewPosition;\nIN vec4 vColor;\n\nstruct ColorComponents {\n  vec3 baseColor;\n  float opacity;\n  vec3 ambientColor;\n  vec3 specularColor;\n  vec3 diffuse;\n  vec3 ambient;\n  vec3 specular;\n  vec3 emissive;\n};\n\nstruct Inputs {\n  vec3 normal;\n  vec2 texCoord;\n  vec3 ambientLight;\n  vec3 ambientMaterial;\n  vec3 specularMaterial;\n  vec3 emissiveMaterial;\n  vec4 color;\n  float shininess;\n  float metalness;\n};\n\nvoid main(void) {\n  HOOK_beforeFragment();\n\n  Inputs inputs;\n  inputs.normal = normalize(vNormal);\n  inputs.texCoord = vTexCoord;\n  inputs.ambientLight = uAmbientColor;\n  inputs.color = isTexture\n      ? TEXTURE(uSampler, vTexCoord) * (vec4(uTint.rgb/255., 1.) * uTint.a/255.)\n      : vColor;\n  if (isTexture && inputs.color.a > 0.0) {\n    // Textures come in with premultiplied alpha. Temporarily unpremultiply it\n    // so hooks users don't have to think about premultiplied alpha.\n    inputs.color.rgb /= inputs.color.a;\n  }\n  inputs.shininess = uShininess;\n  inputs.metalness = uMetallic;\n  inputs.ambientMaterial = uHasSetAmbient ? uAmbientMatColor.rgb : inputs.color.rgb;\n  inputs.specularMaterial = uSpecularMatColor.rgb;\n  inputs.emissiveMaterial = uEmissiveMatColor.rgb;\n  inputs = HOOK_getPixelInputs(inputs);\n\n  vec3 diffuse;\n  vec3 specular;\n  totalLight(vViewPosition, inputs.normal, inputs.shininess, inputs.metalness, diffuse, specular);\n\n  // Calculating final color as result of all lights (plus emissive term).\n\n  vec4 baseColor = inputs.color;\n  ColorComponents c;\n  c.opacity = baseColor.a;\n  c.baseColor = baseColor.rgb;\n  c.ambientColor = inputs.ambientMaterial;\n  c.specularColor = inputs.specularMaterial;\n  c.diffuse = diffuse;\n  c.ambient = inputs.ambientLight;\n  c.specular = specular;\n  c.emissive = inputs.emissiveMaterial;\n  OUT_COLOR = HOOK_getFinalColor(HOOK_combineColors(c));\n  OUT_COLOR.rgb *= OUT_COLOR.a; // Premultiply alpha before rendering\n  HOOK_afterFragment();\n}\n";
var fontVert = "IN vec3 aPosition;\nIN vec2 aTexCoord;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uGlyphRect;\nuniform float uGlyphOffset;\n\nOUT vec2 vTexCoord;\n\nvoid main() {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // scale by the size of the glyph's rectangle\n  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;\n\n  // Expand glyph bounding boxes by 1px on each side to give a bit of room\n  // for antialiasing\n  vec3 newOrigin = (uModelViewMatrix * vec4(0., 0., 0., 1.)).xyz;\n  vec3 newDX = (uModelViewMatrix * vec4(1., 0., 0., 1.)).xyz;\n  vec3 newDY = (uModelViewMatrix * vec4(0., 1., 0., 1.)).xyz;\n  vec2 pixelScale = vec2(\n    1. / length(newOrigin - newDX),\n    1. / length(newOrigin - newDY)\n  );\n  vec2 offset = pixelScale * normalize(aTexCoord - vec2(0.5, 0.5));\n  vec2 textureOffset = offset * (1. / vec2(\n    uGlyphRect.z - uGlyphRect.x,\n    uGlyphRect.w - uGlyphRect.y\n  ));\n\n  // move to the corner of the glyph\n  positionVec4.xy += uGlyphRect.xy;\n\n  // move to the letter's line offset\n  positionVec4.x += uGlyphOffset;\n\n  positionVec4.xy += offset;\n  \n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vTexCoord = aTexCoord + textureOffset;\n}\n";
var fontFrag = "#ifndef WEBGL2\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#if 0\n  // simulate integer math using floats\n	#define int float\n	#define ivec2 vec2\n	#define INT(x) float(x)\n\n	int ifloor(float v) { return floor(v); }\n	ivec2 ifloor(vec2 v) { return floor(v); }\n\n#else\n  // use native integer math\n	precision highp int;\n	#define INT(x) x\n\n	int ifloor(float v) { return int(v); }\n	int ifloor(int v) { return v; }\n	ivec2 ifloor(vec2 v) { return ivec2(v); }\n\n#endif\n\nuniform sampler2D uSamplerStrokes;\nuniform sampler2D uSamplerRowStrokes;\nuniform sampler2D uSamplerRows;\nuniform sampler2D uSamplerColStrokes;\nuniform sampler2D uSamplerCols;\n\nuniform ivec2 uStrokeImageSize;\nuniform ivec2 uCellsImageSize;\nuniform ivec2 uGridImageSize;\n\nuniform ivec2 uGridOffset;\nuniform ivec2 uGridSize;\nuniform vec4 uMaterialColor;\n\nIN vec2 vTexCoord;\n\n// some helper functions\nint ROUND(float v) { return ifloor(v + 0.5); }\nivec2 ROUND(vec2 v) { return ifloor(v + 0.5); }\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }\n\nint mul(float v1, int v2) {\n  return ifloor(v1 * float(v2));\n}\n\nivec2 mul(vec2 v1, ivec2 v2) {\n  return ifloor(v1 * vec2(v2) + 0.5);\n}\n\n// unpack a 16-bit integer from a float vec2\nint getInt16(vec2 v) {\n  ivec2 iv = ROUND(v * 255.0);\n  return iv.x * INT(128) + iv.y;\n}\n\nvec2 pixelScale;\nvec2 coverage = vec2(0.0);\nvec2 weight = vec2(0.5);\nconst float minDistance = 1.0/8192.0;\nconst float hardness = 1.05; // amount of antialias\n\n// the maximum number of curves in a glyph\nconst int N = INT(250);\n\n// retrieves an indexed pixel from a sampler\nvec4 getTexel(sampler2D sampler, int pos, ivec2 size) {\n  int width = size.x;\n  int y = ifloor(pos / width);\n  int x = pos - y * width;  // pos % width\n\n  return TEXTURE(sampler, (vec2(x, y) + 0.5) / vec2(size));\n}\n\nvoid calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {\n\n  // get the coefficients of the quadratic in t\n  vec2 a = p0 - p1 * 2.0 + p2;\n  vec2 b = p0 - p1;\n  vec2 c = p0 - vTexCoord;\n\n  // found out which values of 't' it crosses the axes\n  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));\n  vec2 t1 = ((b - surd) / a).yx;\n  vec2 t2 = ((b + surd) / a).yx;\n\n  // approximate straight lines to avoid rounding errors\n  if (abs(a.y) < 0.001)\n    t1.x = t2.x = c.y / (2.0 * b.y);\n\n  if (abs(a.x) < 0.001)\n    t1.y = t2.y = c.x / (2.0 * b.x);\n\n  // plug into quadratic formula to find the corrdinates of the crossings\n  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;\n  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;\n}\n\nvoid coverageX(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  // determine on which side of the x-axis the points lie\n  bool y0 = p0.y > vTexCoord.y;\n  bool y1 = p1.y > vTexCoord.y;\n  bool y2 = p2.y > vTexCoord.y;\n\n  // could web be under the curve (after t1)?\n  if (y1 ? !y2 : y0) {\n    // add the coverage for t1\n    coverage.x += saturate(C1.x + 0.5);\n    // calculate the anti-aliasing for t1\n    weight.x = min(weight.x, abs(C1.x));\n  }\n\n  // are we outside the curve (after t2)?\n  if (y1 ? !y0 : y2) {\n    // subtract the coverage for t2\n    coverage.x -= saturate(C2.x + 0.5);\n    // calculate the anti-aliasing for t2\n    weight.x = min(weight.x, abs(C2.x));\n  }\n}\n\n// this is essentially the same as coverageX, but with the axes swapped\nvoid coverageY(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  bool x0 = p0.x > vTexCoord.x;\n  bool x1 = p1.x > vTexCoord.x;\n  bool x2 = p2.x > vTexCoord.x;\n\n  if (x1 ? !x2 : x0) {\n    coverage.y -= saturate(C1.y + 0.5);\n    weight.y = min(weight.y, abs(C1.y));\n  }\n\n  if (x1 ? !x0 : x2) {\n    coverage.y += saturate(C2.y + 0.5);\n    weight.y = min(weight.y, abs(C2.y));\n  }\n}\n\nvoid main() {\n\n  // calculate the pixel scale based on screen-coordinates\n  pixelScale = hardness / fwidth(vTexCoord);\n\n  // which grid cell is this pixel in?\n  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));\n\n  // intersect curves in this row\n  {\n    // the index into the row info bitmap\n    int rowIndex = gridCoord.y + uGridOffset.y;\n    // fetch the info texel\n    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);\n    // unpack the rowInfo\n    int rowStrokeIndex = getInt16(rowInfo.xy);\n    int rowStrokeCount = getInt16(rowInfo.zw);\n\n    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {\n      if (iRowStroke >= rowStrokeCount)\n        break;\n\n      // each stroke is made up of 3 points: the start and control point\n      // and the start of the next curve.\n      // fetch the indices of this pair of strokes:\n      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);\n\n      // unpack the stroke index\n      int strokePos = getInt16(strokeIndices.xy);\n\n      // fetch the two strokes\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n\n      // calculate the coverage\n      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  // intersect curves in this column\n  {\n    int colIndex = gridCoord.x + uGridOffset.x;\n    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);\n    int colStrokeIndex = getInt16(colInfo.xy);\n    int colStrokeCount = getInt16(colInfo.zw);\n    \n    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {\n      if (iColStroke >= colStrokeCount)\n        break;\n\n      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);\n\n      int strokePos = getInt16(strokeIndices.xy);\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  weight = saturate(1.0 - weight * 2.0);\n  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.\n  float antialias = abs(dot(coverage, weight) / distance);\n  float cover = min(abs(coverage.x), abs(coverage.y));\n  OUT_COLOR = vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a;\n  OUT_COLOR *= saturate(max(antialias, cover));\n}\n";
var lineVert = "/*\n  Part of the Processing project - http://processing.org\n  Copyright (c) 2012-15 The Processing Foundation\n  Copyright (c) 2004-12 Ben Fry and Casey Reas\n  Copyright (c) 2001-04 Massachusetts Institute of Technology\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation, version 2.1.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General\n  Public License along with this library; if not, write to the\n  Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n  Boston, MA  02111-1307  USA\n*/\n\n#define PROCESSING_LINE_SHADER\n\n#define HOOK_DEFINES\n\nprecision highp int;\nprecision highp float;\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\n#else\nuniform mat4 uModelViewMatrix;\n#endif\n\nuniform mat4 uProjectionMatrix;\nuniform float uStrokeWeight;\n\nuniform bool uUseLineColor;\nuniform bool uSimpleLines;\nuniform vec4 uMaterialColor;\n\nuniform vec4 uViewport;\nuniform int uPerspective;\nuniform int uStrokeJoin;\n\nIN vec3 aPosition;\nIN vec3 aTangentIn;\nIN vec3 aTangentOut;\nIN float aSide;\nIN vec4 aVertexColor;\n\nOUT vec4 vColor;\nOUT vec2 vTangent;\nOUT vec2 vCenter;\nOUT vec2 vPosition;\nOUT float vMaxDist;\nOUT float vCap;\nOUT float vJoin;\nOUT float vStrokeWeight;\n\nvec2 lineIntersection(vec2 aPoint, vec2 aDir, vec2 bPoint, vec2 bDir) {\n  // Rotate and translate so a starts at the origin and goes out to the right\n  bPoint -= aPoint;\n  vec2 rotatedBFrom = vec2(\n    bPoint.x*aDir.x + bPoint.y*aDir.y,\n    bPoint.y*aDir.x - bPoint.x*aDir.y\n  );\n  vec2 bTo = bPoint + bDir;\n  vec2 rotatedBTo = vec2(\n    bTo.x*aDir.x + bTo.y*aDir.y,\n    bTo.y*aDir.x - bTo.x*aDir.y\n  );\n  float intersectionDistance =\n    rotatedBTo.x + (rotatedBFrom.x - rotatedBTo.x) * rotatedBTo.y /\n    (rotatedBTo.y - rotatedBFrom.y);\n  return aPoint + aDir * intersectionDistance;\n}\n\nstruct StrokeVertex {\n  vec3 position;\n  vec3 tangentIn;\n  vec3 tangentOut;\n  vec4 color;\n  float weight;\n};\n\nvoid main() {\n  HOOK_beforeVertex();\n\n  if (!uSimpleLines) {\n      // Caps have one of either the in or out tangent set to 0\n      vCap = (aTangentIn == vec3(0.)) != (aTangentOut == vec3(0.)) ? 1. : 0.;\n\n      // Joins have two unique, defined tangents\n      vJoin = (\n          aTangentIn != vec3(0.) &&\n          aTangentOut != vec3(0.) &&\n          aTangentIn != aTangentOut\n      ) ? 1. : 0.;\n  }\n\n  StrokeVertex inputs;\n  inputs.position = aPosition.xyz;\n  inputs.color = uUseLineColor ? aVertexColor : uMaterialColor;\n  inputs.weight = uStrokeWeight;\n  inputs.tangentIn = aTangentIn;\n  inputs.tangentOut = aTangentOut;\n\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uModelMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uModelMatrix * vec4(aTangentOut, 0.)).xyz;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uViewMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uViewMatrix * vec4(aTangentOut, 0.)).xyz;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uModelViewMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uModelViewMatrix * vec4(aTangentOut, 0.)).xyz;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n#endif\n\n  vec4 posp = vec4(inputs.position, 1.);\n  vec4 posqIn = vec4(inputs.position + inputs.tangentIn, 1.);\n  vec4 posqOut = vec4(inputs.position + inputs.tangentOut, 1.);\n  vStrokeWeight = inputs.weight;\n\n  float facingCamera = pow(\n    // The word space tangent's z value is 0 if it's facing the camera\n    abs(normalize(posqIn-posp).z),\n\n    // Using pow() here to ramp `facingCamera` up from 0 to 1 really quickly\n    // so most lines get scaled and don't get clipped\n    0.25\n  );\n\n  // Moving vertices slightly toward the camera\n  // to avoid depth-fighting with the fill triangles.\n  // A mix of scaling and offsetting is used based on distance\n  // Discussion here:\n  // https://github.com/processing/p5.js/issues/7200 \n\n  // using a scale <1 moves the lines towards nearby camera\n  // in order to prevent popping effects due to half of\n  // the line disappearing behind the geometry faces.\n  float zDistance = -posp.z; \n  float distanceFactor = smoothstep(0.0, 800.0, zDistance); \n  \n  // Discussed here:\n  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  \n  float scale = mix(1., 0.995, facingCamera);\n  float dynamicScale = mix(scale, 1.0, distanceFactor); // Closer = more scale, farther = less\n\n  posp.xyz = posp.xyz * dynamicScale;\n  posqIn.xyz = posqIn.xyz * dynamicScale;\n  posqOut.xyz = posqOut.xyz * dynamicScale;\n\n  // Moving vertices slightly toward camera when far away \n  // https://github.com/processing/p5.js/issues/6956 \n  float zOffset = mix(0., -1., facingCamera);\n  float dynamicZAdjustment = mix(0.0, zOffset, distanceFactor); // Closer = less zAdjustment, farther = more\n\n  posp.z -= dynamicZAdjustment;\n  posqIn.z -= dynamicZAdjustment;\n  posqOut.z -= dynamicZAdjustment;\n  \n  vec4 p = uProjectionMatrix * posp;\n  vec4 qIn = uProjectionMatrix * posqIn;\n  vec4 qOut = uProjectionMatrix * posqOut;\n\n  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])\n  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw\n\n  // prevent division by W by transforming the tangent formula (div by 0 causes\n  // the line to disappear, see https://github.com/processing/processing/issues/5183)\n  // t = screen_q - screen_p\n  //\n  // tangent is normalized and we don't care which aDirection it points to (+-)\n  // t = +- normalize( screen_q - screen_p )\n  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )\n  //\n  // extract common factor, <1,1> - <1,1> cancels out\n  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )\n  //\n  // convert to common divisor\n  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )\n  //\n  // remove the common scalar divisor/factor, not needed due to normalize and +-\n  // (keep uViewport - can't remove because it has different components for x and y\n  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)\n  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )\n\n  vec2 tangentIn = normalize((qIn.xy*p.w - p.xy*qIn.w) * uViewport.zw);\n  vec2 tangentOut = normalize((qOut.xy*p.w - p.xy*qOut.w) * uViewport.zw);\n\n  vec2 curPerspScale;\n  if(uPerspective == 1) {\n    // Perspective ---\n    // convert from world to clip by multiplying with projection scaling factor\n    // to get the right thickness (see https://github.com/processing/processing/issues/5182)\n\n    // The y value of the projection matrix may be flipped if rendering to a Framebuffer.\n    // Multiplying again by its sign here negates the flip to get just the scale.\n    curPerspScale = (uProjectionMatrix * vec4(1, sign(uProjectionMatrix[1][1]), 0, 0)).xy;\n  } else {\n    // No Perspective ---\n    // multiply by W (to cancel out division by W later in the pipeline) and\n    // convert from screen to clip (derived from clip to screen above)\n    curPerspScale = p.w / (0.5 * uViewport.zw);\n  }\n\n  vec2 offset;\n  if (vJoin == 1. && !uSimpleLines) {\n    vTangent = normalize(tangentIn + tangentOut);\n    vec2 normalIn = vec2(-tangentIn.y, tangentIn.x);\n    vec2 normalOut = vec2(-tangentOut.y, tangentOut.x);\n    float side = sign(aSide);\n    float sideEnum = abs(aSide);\n\n    // We generate vertices for joins on either side of the centerline, but\n    // the \"elbow\" side is the only one needing a join. By not setting the\n    // offset for the other side, all its vertices will end up in the same\n    // spot and not render, effectively discarding it.\n    if (sign(dot(tangentOut, vec2(-tangentIn.y, tangentIn.x))) != side) {\n      // Side enums:\n      //   1: the side going into the join\n      //   2: the middle of the join\n      //   3: the side going out of the join\n      if (sideEnum == 2.) {\n        // Calculate the position + tangent on either side of the join, and\n        // find where the lines intersect to find the elbow of the join\n        vec2 c = (posp.xy/posp.w + vec2(1.,1.)) * 0.5 * uViewport.zw;\n        vec2 intersection = lineIntersection(\n          c + (side * normalIn * inputs.weight / 2.),\n          tangentIn,\n          c + (side * normalOut * inputs.weight / 2.),\n          tangentOut\n        );\n        offset = (intersection - c);\n\n        // When lines are thick and the angle of the join approaches 180, the\n        // elbow might be really far from the center. We'll apply a limit to\n        // the magnitude to avoid lines going across the whole screen when this\n        // happens.\n        float mag = length(offset);\n        float maxMag = 3. * inputs.weight;\n        if (mag > maxMag) {\n          offset *= maxMag / mag;\n        }\n      } else if (sideEnum == 1.) {\n        offset = side * normalIn * inputs.weight / 2.;\n      } else if (sideEnum == 3.) {\n        offset = side * normalOut * inputs.weight / 2.;\n      }\n    }\n    if (uStrokeJoin == STROKE_JOIN_BEVEL) {\n      vec2 avgNormal = vec2(-vTangent.y, vTangent.x);\n      vMaxDist = abs(dot(avgNormal, normalIn * inputs.weight / 2.));\n    } else {\n      vMaxDist = inputs.weight / 2.;\n    }\n  } else {\n    vec2 tangent = aTangentIn == vec3(0.) ? tangentOut : tangentIn;\n\n    vTangent = tangent;\n    vec2 normal = vec2(-tangent.y, tangent.x);\n\n    float normalOffset = sign(aSide);\n    // Caps will have side values of -2 or 2 on the edge of the cap that\n    // extends out from the line\n    float tangentOffset = abs(aSide) - 1.;\n    offset = (normal * normalOffset + tangent * tangentOffset) *\n      inputs.weight * 0.5;\n    vMaxDist = inputs.weight / 2.;\n  }\n\n  vCenter = p.xy;\n  vPosition = vCenter + offset;\n  vColor = inputs.color;\n\n  gl_Position.xy = p.xy + offset.xy * curPerspScale;\n  gl_Position.zw = p.zw;\n  \n  HOOK_afterVertex();\n}\n";
var lineFrag = "precision highp int;\nprecision highp float;\n\nuniform vec4 uMaterialColor;\nuniform int uStrokeCap;\nuniform int uStrokeJoin;\n\nIN vec4 vColor;\nIN vec2 vTangent;\nIN vec2 vCenter;\nIN vec2 vPosition;\nIN float vStrokeWeight;\nIN float vMaxDist;\nIN float vCap;\nIN float vJoin;\n\nfloat distSquared(vec2 a, vec2 b) {\n  vec2 aToB = b - a;\n  return dot(aToB, aToB);\n}\n\nstruct Inputs {\n  vec4 color;\n  vec2 tangent;\n  vec2 center;\n  vec2 position;\n  float strokeWeight;\n};\n\nvoid main() {\n  HOOK_beforeFragment();\n\n  Inputs inputs;\n  inputs.color = vColor;\n  inputs.tangent = vTangent;\n  inputs.center = vCenter;\n  inputs.position = vPosition;\n  inputs.strokeWeight = vStrokeWeight;\n  inputs = HOOK_getPixelInputs(inputs);\n\n  if (vCap > 0.) {\n    if (\n      uStrokeCap == STROKE_CAP_ROUND &&\n      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)\n    ) {\n      discard;\n    } else if (\n      uStrokeCap == STROKE_CAP_SQUARE &&\n      HOOK_shouldDiscard(dot(inputs.position - inputs.center, inputs.tangent) > 0.)\n    ) {\n      discard;\n    // Use full area for PROJECT\n    } else if (HOOK_shouldDiscard(false)) {\n      discard;\n    }\n  } else if (vJoin > 0.) {\n    if (\n      uStrokeJoin == STROKE_JOIN_ROUND &&\n      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)\n    ) {\n      discard;\n    } else if (uStrokeJoin == STROKE_JOIN_BEVEL) {\n      vec2 normal = vec2(-inputs.tangent.y, inputs.tangent.x);\n      if (HOOK_shouldDiscard(abs(dot(inputs.position - inputs.center, normal)) > vMaxDist)) {\n        discard;\n      }\n    // Use full area for MITER\n    } else if (HOOK_shouldDiscard(false)) {\n      discard;\n    }\n  }\n  OUT_COLOR = HOOK_getFinalColor(vec4(inputs.color.rgb, 1.) * inputs.color.a);\n  HOOK_afterFragment();\n}\n";
var imageLightVert = "precision highp float;\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nvarying vec3 localPos;\nvarying vec3 vWorldNormal;\nvarying vec3 vWorldPosition;\nvarying vec2 vTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n  \n  // orient the normals and pass to the fragment shader\n  vWorldNormal = uNormalMatrix * aNormal;\n  \n  // send the view position to the fragment shader\n  vWorldPosition = (uModelViewMatrix * vec4(aPosition, 1.0)).xyz;\n  \n  localPos = vWorldPosition;\n  vTexCoord = aTexCoord;\n}\n\n\n/*\nin the vertex shader we'll compute the world position and world oriented normal of the vertices and pass those to the fragment shader as varyings.\n*/\n";
var imageLightDiffusedFrag = "precision highp float;\nvarying vec3 localPos;\n\n// the HDR cubemap converted (can be from an equirectangular environment map.)\nuniform sampler2D environmentMap;\nvarying vec2 vTexCoord;\n\nconst float PI = 3.14159265359;\n\nvec2 nTOE( vec3 v ){\n  // x = r sin(phi) cos(theta)   \n  // y = r cos(phi)  \n  // z = r sin(phi) sin(theta)\n  float phi = acos( v.y );\n  // if phi is 0, then there are no x, z components\n  float theta = 0.0;\n  // else \n  theta = acos(v.x / sin(phi));\n  float sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * 3.14159);\n  phi = phi / 3.14159 ;\n  \n  vec2 angles = vec2( phi, theta );\n  return angles;\n}\n\nfloat random(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid main()\n{   	 \n	// the sample direction equals the hemisphere's orientation\n  float phi = vTexCoord.x * 2.0 * PI;\n  float theta = vTexCoord.y * PI;\n  float x = sin(theta) * cos(phi);\n  float y = sin(theta) * sin(phi);\n  float z = cos(theta);\n  vec3 normal = vec3( x, y, z);\n\n	// Discretely sampling the hemisphere given the integral's\n  // spherical coordinates translates to the following fragment code:\n	vec3 irradiance = vec3(0.0);  \n	vec3 up	= vec3(0.0, 1.0, 0.0);\n	vec3 right = normalize(cross(up, normal));\n	up = normalize(cross(normal, right));\n\n	//  We specify a fixed sampleDelta delta value to traverse\n  // the hemisphere; decreasing or increasing the sample delta\n  // will increase or decrease the accuracy respectively.\n	const float sampleDelta = 0.100;\n	float nrSamples = 0.0;\n  float randomOffset = random(gl_FragCoord.xy) * sampleDelta;\n	for(float rawPhi = 0.0; rawPhi < 2.0 * PI; rawPhi += sampleDelta)\n	{\n    float phi = rawPhi + randomOffset;\n    for(float rawTheta = 0.0; rawTheta < ( 0.5 ) * PI; rawTheta += sampleDelta)\n    {\n      float theta = rawTheta + randomOffset;\n      // spherical to cartesian (in tangent space) // tangent space to world // add each sample result to irradiance\n      float x = sin(theta) * cos(phi);\n      float y = sin(theta) * sin(phi);\n      float z = cos(theta);\n      vec3 tangentSample = vec3( x, y, z);\n      \n      vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal;\n        irradiance += (texture2D(environmentMap, nTOE(sampleVec)).xyz) * cos(theta) * sin(theta);\n      nrSamples++;\n    }\n	}\n	// divide by the total number of samples taken, giving us the average sampled irradiance.\n	irradiance = PI * irradiance * (1.0 / float(nrSamples )) ;\n  \n \n	gl_FragColor = vec4(irradiance, 1.0);\n}";
var imageLightSpecularFrag = "precision highp float;\r\nvarying vec3 localPos;\r\nvarying vec2 vTexCoord;\r\n\r\n// our texture\r\nuniform sampler2D environmentMap;\r\nuniform float roughness;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat VanDerCorput(int bits);\r\nvec2 HammersleyNoBitOps(int i, int N);\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\r\n\r\n\r\nvec2 nTOE( vec3 v ){\r\n  // x = r sin(phi) cos(theta)   \r\n  // y = r cos(phi)  \r\n  // z = r sin(phi) sin(theta)\r\n  float phi = acos( v.y );\r\n  // if phi is 0, then there are no x, z components\r\n  float theta = 0.0;\r\n  // else \r\n  theta = acos(v.x / sin(phi));\r\n  float sinTheta = v.z / sin(phi);\r\n  if (sinTheta < 0.0) {\r\n    // Turn it into -theta, but in the 0-2PI range\r\n    theta = 2.0 * PI - theta;\r\n  }\r\n  theta = theta / (2.0 * 3.14159);\r\n  phi = phi / 3.14159 ;\r\n  \r\n  vec2 angles = vec2( phi, theta );\r\n  return angles;\r\n}\r\n\r\n\r\nvoid main(){\r\n  const int SAMPLE_COUNT = 400; // 4096\r\n  int lowRoughnessLimit = int(pow(2.0,(roughness+0.1)*20.0));\r\n  float totalWeight = 0.0;\r\n  vec3 prefilteredColor = vec3(0.0);\r\n  float phi = vTexCoord.x * 2.0 * PI;\r\n  float theta = vTexCoord.y * PI;\r\n  float x = sin(theta) * cos(phi);\r\n  float y = sin(theta) * sin(phi);\r\n  float z = cos(theta);\r\n  vec3 N = vec3(x,y,z);\r\n  vec3 V = N;\r\n  for (int i = 0; i < SAMPLE_COUNT; ++i)\r\n  {\r\n    // break at smaller sample numbers for low roughness levels\r\n    if(i == lowRoughnessLimit)\r\n    {\r\n      break;\r\n    }\r\n    vec2 Xi = HammersleyNoBitOps(i, SAMPLE_COUNT);\r\n    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\r\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    if (NdotL > 0.0)\r\n    {\r\n      prefilteredColor += texture2D(environmentMap, nTOE(L)).xyz * NdotL;\r\n      totalWeight += NdotL;\r\n    }\r\n  }\r\n  prefilteredColor = prefilteredColor / totalWeight;\r\n\r\n  gl_FragColor = vec4(prefilteredColor, 1.0);\r\n}\r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness){\r\n  float a = roughness * roughness;\r\n\r\n  float phi = 2.0 * PI * Xi.x;\r\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\r\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\r\n  // from spherical coordinates to cartesian coordinates\r\n  vec3 H;\r\n  H.x = cos(phi) * sinTheta;\r\n  H.y = sin(phi) * sinTheta;\r\n  H.z = cosTheta;\r\n\r\n  // from tangent-space vector to world-space sample vector\r\n  vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n  vec3 tangent = normalize(cross(up, N));\r\n  vec3 bitangent = cross(N, tangent);\r\n\r\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n  return normalize(sampleVec);\r\n}\r\n\r\n\r\nfloat VanDerCorput(int n, int base)\r\n{\r\n#ifdef WEBGL2\r\n\r\n    uint bits = uint(n);\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n\r\n#else\r\n\r\n  float invBase = 1.0 / float(base);\r\n  float denom = 1.0;\r\n  float result = 0.0;\r\n\r\n\r\n  for (int i = 0; i < 32; ++i)\r\n  {\r\n        if (n > 0)\r\n        {\r\n        denom = mod(float(n), 2.0);\r\n        result += denom * invBase;\r\n        invBase = invBase / 2.0;\r\n        n = int(float(n) / 2.0);\r\n        }\r\n  }\r\n\r\n\r\n  return result;\r\n\r\n#endif\r\n}\r\n\r\nvec2 HammersleyNoBitOps(int i, int N)\r\n{\r\n  return vec2(float(i) / float(N), VanDerCorput(i, 2));\r\n}\r\n";
const { lineDefs } = getStrokeDefs((n2, v) => `#define ${n2} ${v}
`);
const defaultShaders = {
  normalVert,
  normalFrag,
  basicFrag,
  lightVert: lightingShader + lightVert,
  lightTextureFrag,
  phongVert,
  phongFrag: lightingShader + phongFrag,
  fontVert,
  fontFrag,
  lineVert: lineDefs + lineVert,
  lineFrag: lineDefs + lineFrag,
  imageLightVert,
  imageLightDiffusedFrag,
  imageLightSpecularFrag,
  filterBaseVert,
  filterBaseFrag
};
for (const key in defaultShaders) {
  defaultShaders[key] = webgl2CompatibilityShader + defaultShaders[key];
}
class RendererGL extends Renderer3D {
  constructor(pInst, w, h, isMainCanvas, elt) {
    super(pInst, w, h, isMainCanvas, elt);
    if (this.webglVersion === WEBGL2) {
      this.blendExt = this.GL;
    } else {
      this.blendExt = this.GL.getExtension("EXT_blend_minmax");
    }
    this._userEnabledStencil = false;
    this._internalEnable = this.drawingContext.enable;
    this._internalDisable = this.drawingContext.disable;
    this.drawingContext.enable = (key) => {
      if (key === this.drawingContext.STENCIL_TEST) {
        if (!this._clipping) {
          this._userEnabledStencil = true;
        }
      }
      return this._internalEnable.call(this.drawingContext, key);
    };
    this.drawingContext.disable = (key) => {
      if (key === this.drawingContext.STENCIL_TEST) {
        this._userEnabledStencil = false;
      }
      return this._internalDisable.call(this.drawingContext, key);
    };
    this._cachedBlendMode = void 0;
    this.strandsBackend = glslBackend;
  }
  setupContext() {
    this._setAttributeDefaults(this._pInst);
    this._initContext();
    this.GL = this.drawingContext;
  }
  //////////////////////////////////////////////
  // Rendering
  //////////////////////////////////////////////
  /**
   * @private sets blending in gl context to curBlendMode
   * @param  {Number[]} color [description]
   * @return {Number[]}  Normalized numbers array
   */
  _applyBlendMode() {
    if (this._cachedBlendMode === this.states.curBlendMode) {
      return;
    }
    const gl = this.GL;
    switch (this.states.curBlendMode) {
      case BLEND:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case ADD:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE);
        break;
      case REMOVE:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case MULTIPLY:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case SCREEN:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
        break;
      case EXCLUSION:
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(
          gl.ONE_MINUS_DST_COLOR,
          gl.ONE_MINUS_SRC_COLOR,
          gl.ONE,
          gl.ONE
        );
        break;
      case REPLACE:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ZERO);
        break;
      case SUBTRACT:
        gl.blendEquationSeparate(gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case DARKEST:
        if (this.blendExt) {
          gl.blendEquationSeparate(
            this.blendExt.MIN || this.blendExt.MIN_EXT,
            gl.FUNC_ADD
          );
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          console.warn(
            "blendMode(DARKEST) does not work in your browser in WEBGL mode."
          );
        }
        break;
      case LIGHTEST:
        if (this.blendExt) {
          gl.blendEquationSeparate(
            this.blendExt.MAX || this.blendExt.MAX_EXT,
            gl.FUNC_ADD
          );
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          console.warn(
            "blendMode(LIGHTEST) does not work in your browser in WEBGL mode."
          );
        }
        break;
      default:
        console.error(
          "Oops! Somehow Renderer3D set curBlendMode to an unsupported mode."
        );
        break;
    }
    this._cachedBlendMode = this.states.curBlendMode;
  }
  _shaderOptions() {
    return void 0;
  }
  _useShader(shader2) {
    const gl = this.GL;
    gl.useProgram(shader2._glProgram);
  }
  /**
   * Once all buffers have been bound, this checks to see if there are any
   * remaining active attributes, likely left over from previous renders,
   * and disables them so that they don't affect rendering.
   * @private
   */
  _disableRemainingAttributes(shader2) {
    for (const location2 of this.registerEnabled.values()) {
      if (!Object.keys(shader2.attributes).some(
        (key) => shader2.attributes[key].location === location2
      )) {
        this.GL.disableVertexAttribArray(location2);
        this.registerEnabled.delete(location2);
      }
    }
  }
  _drawBuffers(geometry2, { mode = TRIANGLES, count }) {
    const gl = this.GL;
    const glBuffers = this.geometryBufferCache.getCached(geometry2);
    if (!glBuffers) return;
    if (this._curShader.shaderType === "stroke") {
      if (count === 1) {
        gl.drawArrays(gl.TRIANGLES, 0, geometry2.lineVertices.length / 3);
      } else {
        try {
          gl.drawArraysInstanced(
            gl.TRIANGLES,
            0,
            geometry2.lineVertices.length / 3,
            count
          );
        } catch (e2) {
          console.log(
            "🌸 p5.js says: Instancing is only supported in WebGL2 mode"
          );
        }
      }
    } else if (this._curShader.shaderType === "text") {
      this._bindBuffer(glBuffers.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    } else if (glBuffers.indexBuffer) {
      this._bindBuffer(glBuffers.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
      if (this._pInst.webglVersion !== WEBGL2 && glBuffers.indexBufferType === gl.UNSIGNED_INT) {
        if (!gl.getExtension("OES_element_index_uint")) {
          throw new Error(
            "Unable to render a 3d model with > 65535 triangles. Your web browser does not support the WebGL Extension OES_element_index_uint."
          );
        }
      }
      if (count === 1) {
        gl.drawElements(
          gl.TRIANGLES,
          geometry2.faces.length * 3,
          glBuffers.indexBufferType,
          0
        );
      } else {
        try {
          gl.drawElementsInstanced(
            gl.TRIANGLES,
            geometry2.faces.length * 3,
            glBuffers.indexBufferType,
            0,
            count
          );
        } catch (e2) {
          console.log(
            "🌸 p5.js says: Instancing is only supported in WebGL2 mode"
          );
        }
      }
    } else {
      const glMode = mode === TRIANGLES ? gl.TRIANGLES : gl.TRIANGLE_STRIP;
      if (count === 1) {
        gl.drawArrays(glMode, 0, geometry2.vertices.length);
      } else {
        try {
          gl.drawArraysInstanced(glMode, 0, geometry2.vertices.length, count);
        } catch (e2) {
          console.log(
            "🌸 p5.js says: Instancing is only supported in WebGL2 mode"
          );
        }
      }
    }
  }
  //////////////////////////////////////////////
  // Text
  //////////////////////////////////////////////
  _beforeDrawText() {
    this.GL.pixelStorei(this.GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  }
  _afterDrawText() {
    this.GL.pixelStorei(this.GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
  }
  //////////////////////////////////////////////
  // Setting
  //////////////////////////////////////////////
  _setAttributeDefaults(pInst) {
    const applyAA = navigator.userAgent.toLowerCase().includes("safari");
    const defaults2 = {
      alpha: true,
      depth: true,
      stencil: true,
      antialias: applyAA,
      premultipliedAlpha: true,
      preserveDrawingBuffer: true,
      perPixelLighting: true,
      version: 2
    };
    if (pInst._glAttributes === null) {
      pInst._glAttributes = defaults2;
    } else {
      pInst._glAttributes = Object.assign(defaults2, pInst._glAttributes);
    }
    return;
  }
  _setAttributes(key, value) {
    if (typeof this._pInst._glAttributes === "undefined") {
      console.log(
        "You are trying to use setAttributes on a p5.Graphics object that does not use a WEBGL renderer."
      );
      return;
    }
    let unchanged = true;
    if (typeof value !== "undefined") {
      if (this._pInst._glAttributes === null) {
        this._pInst._glAttributes = {};
      }
      if (this._pInst._glAttributes[key] !== value) {
        this._pInst._glAttributes[key] = value;
        unchanged = false;
      }
    } else if (key instanceof Object) {
      if (this._pInst._glAttributes !== key) {
        this._pInst._glAttributes = key;
        unchanged = false;
      }
    }
    if (!this.isP3D || unchanged) {
      return;
    }
    if (!this._pInst._setupDone) {
      if (this.geometryBufferCache.numCached() > 0) {
        p5._friendlyError(
          "Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()"
        );
        return;
      }
    }
    this._resetContext(null, null, RendererGL);
    if (this.states.curCamera) {
      this.states.curCamera._renderer = this._renderer;
    }
  }
  _initContext() {
    if (this._pInst._glAttributes?.version !== 1) {
      this.drawingContext = this.canvas.getContext(
        "webgl2",
        this._pInst._glAttributes
      );
    }
    this.webglVersion = this.drawingContext ? WEBGL2 : WEBGL;
    this._pInst.webglVersion = this.webglVersion;
    if (!this.drawingContext) {
      this.drawingContext = this.canvas.getContext("webgl", this._pInst._glAttributes) || this.canvas.getContext("experimental-webgl", this._pInst._glAttributes);
    }
    if (this.drawingContext === null) {
      throw new Error("Error creating webgl context");
    } else {
      const gl = this.drawingContext;
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      this._viewport = this.drawingContext.getParameter(
        this.drawingContext.VIEWPORT
      );
    }
  }
  _updateSize() {
  }
  _getMaxTextureSize() {
    const gl = this.drawingContext;
    return gl.getParameter(gl.MAX_TEXTURE_SIZE);
  }
  _adjustDimensions(width, height) {
    if (!this._maxTextureSize) {
      this._maxTextureSize = this._getMaxTextureSize();
    }
    let maxTextureSize = this._maxTextureSize;
    let maxAllowedPixelDimensions = Math.floor(
      maxTextureSize / this._pixelDensity
    );
    let adjustedWidth = Math.min(width, maxAllowedPixelDimensions);
    let adjustedHeight = Math.min(height, maxAllowedPixelDimensions);
    if (adjustedWidth !== width || adjustedHeight !== height) {
      console.warn(
        `Warning: The requested width/height exceeds hardware limits. Adjusting dimensions to width: ${adjustedWidth}, height: ${adjustedHeight}.`
      );
    }
    return { adjustedWidth, adjustedHeight };
  }
  _resetBuffersBeforeDraw() {
    this.GL.clearStencil(0);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT | this.GL.STENCIL_BUFFER_BIT);
    if (!this._userEnabledStencil) {
      this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
    }
  }
  _applyClip() {
    const gl = this.GL;
    gl.clearStencil(0);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    this._internalEnable.call(gl, gl.STENCIL_TEST);
    this._stencilTestOn = true;
    gl.stencilFunc(
      gl.ALWAYS,
      // the test
      1,
      // reference value
      255
      // mask
    );
    gl.stencilOp(
      gl.KEEP,
      // what to do if the stencil test fails
      gl.KEEP,
      // what to do if the depth test fails
      gl.REPLACE
      // what to do if both tests pass
    );
    gl.disable(gl.DEPTH_TEST);
  }
  _unapplyClip() {
    const gl = this.GL;
    gl.stencilOp(
      gl.KEEP,
      // what to do if the stencil test fails
      gl.KEEP,
      // what to do if the depth test fails
      gl.KEEP
      // what to do if both tests pass
    );
    gl.stencilFunc(
      this._clipInvert ? gl.EQUAL : gl.NOTEQUAL,
      // the test
      0,
      // reference value
      255
      // mask
    );
    gl.enable(gl.DEPTH_TEST);
  }
  _clearClipBuffer() {
    this.GL.clearStencil(1);
    this.GL.clear(this.GL.STENCIL_BUFFER_BIT);
    if (!this._userEnabledStencil) {
      this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
    }
  }
  // x,y are canvas-relative (pre-scaled by _pixelDensity)
  _getPixel(x, y) {
    const gl = this.GL;
    return readPixelWebGL(
      gl,
      null,
      x,
      y,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      this._pInst.height * this._pInst.pixelDensity()
    );
  }
  /**
   * Loads the pixels data for this canvas into the pixels[] attribute.
   * Note that updatePixels() and set() do not work.
   * Any pixel manipulation must be done directly to the pixels[] array.
   *
   * @private
   */
  loadPixels() {
    if (this._pInst._glAttributes.preserveDrawingBuffer !== true) {
      console.log(
        "loadPixels only works in WebGL when preserveDrawingBuffer is true."
      );
      return;
    }
    const pd = this._pixelDensity;
    const gl = this.GL;
    this.pixels = readPixelsWebGL(
      this.pixels,
      gl,
      null,
      0,
      0,
      this.width * pd,
      this.height * pd,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      this.height * pd
    );
  }
  updatePixels() {
    const fbo = this._getTempFramebuffer();
    fbo.pixels = this.pixels;
    fbo.updatePixels();
    this.push();
    this.resetMatrix();
    this.clear();
    this.states.setValue("imageMode", CORNER);
    this.image(
      fbo,
      0,
      0,
      fbo.width,
      fbo.height,
      -fbo.width / 2,
      -fbo.height / 2,
      fbo.width,
      fbo.height
    );
    this.pop();
    this.GL.clearDepth(1);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
  }
  zClipRange() {
    return [-1, 1];
  }
  defaultNearScale() {
    return 0.1;
  }
  defaultFarScale() {
    return 10;
  }
  viewport(w, h) {
    this._viewport = [0, 0, w, h];
    this.GL.viewport(0, 0, w, h);
  }
  _updateViewport() {
    this._origViewport = {
      width: this.GL.drawingBufferWidth,
      height: this.GL.drawingBufferHeight
    };
    this.viewport(this._origViewport.width, this._origViewport.height);
  }
  _createPixelsArray() {
    this.pixels = new Uint8Array(
      this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4
    );
  }
  /**
   * clears color and depth buffers
   * with r,g,b,a
   * @private
   * @param {Number} r normalized red val.
   * @param {Number} g normalized green val.
   * @param {Number} b normalized blue val.
   * @param {Number} a normalized alpha val.
   */
  clear(...args) {
    const _r = args[0] || 0;
    const _g = args[1] || 0;
    const _b = args[2] || 0;
    let _a = args[3] || 0;
    const activeFramebuffer = this.activeFramebuffer();
    if (activeFramebuffer && activeFramebuffer.format === UNSIGNED_BYTE && !activeFramebuffer.antialias && _a === 0) {
      _a = 1e-10;
    }
    this.GL.clearColor(_r * _a, _g * _a, _b * _a, _a);
    this.GL.clearDepth(1);
    this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);
  }
  /**
   * Resets all depth information so that nothing previously drawn will
   * occlude anything subsequently drawn.
   */
  clearDepth(depth = 1) {
    this.GL.clearDepth(depth);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
  }
  _applyStencilTestIfClipping() {
    const drawTarget = this.drawTarget();
    if (drawTarget._isClipApplied !== this._stencilTestOn) {
      if (drawTarget._isClipApplied) {
        this._internalEnable.call(this.GL, this.GL.STENCIL_TEST);
        this._stencilTestOn = true;
      } else {
        if (!this._userEnabledStencil) {
          this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
        }
        this._stencilTestOn = false;
      }
    }
  }
  //////////////////////////////////////////////
  // SHADER
  //////////////////////////////////////////////
  /*
   * shaders are created and cached on a per-renderer basis,
   * on the grounds that each renderer will have its own gl context
   * and the shader must be valid in that context.
   */
  baseMaterialShader() {
    if (!this._pInst._glAttributes.perPixelLighting) {
      throw new Error(
        "The material shader does not support hooks without perPixelLighting. Try turning it back on."
      );
    }
    return super.baseMaterialShader();
  }
  _getLightShader() {
    if (!this._defaultLightShader) {
      if (this._pInst._glAttributes.perPixelLighting) {
        this._defaultLightShader = new Shader(
          this,
          this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.phongVert,
          this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.phongFrag,
          {
            vertex: {
              "void beforeVertex": "() {}",
              "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
              "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
              "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
              "void afterVertex": "() {}"
            },
            fragment: {
              "void beforeFragment": "() {}",
              "Inputs getPixelInputs": "(Inputs inputs) { return inputs; }",
              "vec4 combineColors": `(ColorComponents components) {
                vec4 color = vec4(0.);
                color.rgb += components.diffuse * components.baseColor;
                color.rgb += components.ambient * components.ambientColor;
                color.rgb += components.specular * components.specularColor;
                color.rgb += components.emissive;
                color.a = components.opacity;
                return color;
              }`,
              "vec4 getFinalColor": "(vec4 color) { return color; }",
              "void afterFragment": "() {}"
            }
          }
        );
      } else {
        this._defaultLightShader = new Shader(
          this,
          this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.lightVert,
          this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.lightTextureFrag
        );
      }
    }
    return this._defaultLightShader;
  }
  _getNormalShader() {
    if (!this._defaultNormalShader) {
      this._defaultNormalShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.normalVert,
        this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.normalFrag,
        {
          vertex: {
            "void beforeVertex": "() {}",
            "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
            "void afterVertex": "() {}"
          },
          fragment: {
            "void beforeFragment": "() {}",
            "vec4 getFinalColor": "(vec4 color) { return color; }",
            "void afterFragment": "() {}"
          }
        }
      );
    }
    return this._defaultNormalShader;
  }
  _getColorShader() {
    if (!this._defaultColorShader) {
      this._defaultColorShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.normalVert,
        this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.basicFrag,
        {
          vertex: {
            "void beforeVertex": "() {}",
            "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
            "void afterVertex": "() {}"
          },
          fragment: {
            "void beforeFragment": "() {}",
            "vec4 getFinalColor": "(vec4 color) { return color; }",
            "void afterFragment": "() {}"
          }
        }
      );
    }
    return this._defaultColorShader;
  }
  _getLineShader() {
    if (!this._defaultLineShader) {
      this._defaultLineShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.lineVert,
        this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.lineFrag,
        {
          vertex: {
            "void beforeVertex": "() {}",
            "StrokeVertex getObjectInputs": "(StrokeVertex inputs) { return inputs; }",
            "StrokeVertex getWorldInputs": "(StrokeVertex inputs) { return inputs; }",
            "StrokeVertex getCameraInputs": "(StrokeVertex inputs) { return inputs; }",
            "void afterVertex": "() {}"
          },
          fragment: {
            "void beforeFragment": "() {}",
            "Inputs getPixelInputs": "(Inputs inputs) { return inputs; }",
            "vec4 getFinalColor": "(vec4 color) { return color; }",
            "bool shouldDiscard": "(bool outside) { return outside; }",
            "void afterFragment": "() {}"
          }
        }
      );
    }
    return this._defaultLineShader;
  }
  _getFontShader() {
    if (!this._defaultFontShader) {
      if (this.webglVersion === WEBGL) {
        this.GL.getExtension("OES_standard_derivatives");
      }
      this._defaultFontShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.fontVert,
        this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.fontFrag
      );
    }
    return this._defaultFontShader;
  }
  baseFilterShader() {
    if (!this._baseFilterShader) {
      this._baseFilterShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.filterBaseVert,
        this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.filterBaseFrag,
        {
          vertex: {},
          fragment: {
            "vec4 getColor": `(FilterInputs inputs, in sampler2D canvasContent) {
                return getTexture(canvasContent, inputs.texCoord);
              }`
          }
        }
      );
    }
    return this._baseFilterShader;
  }
  _webGL2CompatibilityPrefix(shaderType, floatPrecision) {
    let code2 = "";
    if (this.webglVersion === WEBGL2) {
      code2 += "#version 300 es\n#define WEBGL2\n";
    }
    if (shaderType === "vert") {
      code2 += "#define VERTEX_SHADER\n";
    } else if (shaderType === "frag") {
      code2 += "#define FRAGMENT_SHADER\n";
    }
    if (floatPrecision) {
      code2 += `precision ${floatPrecision} float;
`;
    }
    return code2;
  }
  /*
   * WebGL-specific implementation of imageLight shader creation
   */
  _createImageLightShader(type2) {
    if (type2 === "diffused") {
      return this._pInst.createShader(
        defaultShaders.imageLightVert,
        defaultShaders.imageLightDiffusedFrag
      );
    } else if (type2 === "specular") {
      return this._pInst.createShader(
        defaultShaders.imageLightVert,
        defaultShaders.imageLightSpecularFrag
      );
    }
    throw new Error(`Unknown imageLight shader type: ${type2}`);
  }
  /*
   * WebGL-specific implementation of mipmap texture creation
   */
  _createMipmapTexture(levels) {
    return new MipmapTexture(this, levels, {});
  }
  /*
   * Prepare array to collect ImageData levels for WebGL
   */
  _prepareMipmapData(size, mipLevels) {
    return { levels: [], size, mipLevels };
  }
  /*
   * Accumulate ImageData from framebuffer for WebGL
   */
  _accumulateMipLevel(framebuffer2, mipmapData, mipLevel, width, height) {
    const imageData = framebuffer2.get().drawingContext.getImageData(0, 0, width, height);
    mipmapData.levels.push(imageData);
  }
  /*
   * Create final MipmapTexture from collected ImageData for WebGL
   */
  _finalizeMipmapTexture(mipmapData) {
    return new MipmapTexture(this, mipmapData.levels, {
      minFilter: LINEAR_MIPMAP,
      magFilter: LINEAR
    });
  }
  createMipmapTextureHandle({ levels, format, dataType, width, height }) {
    const gl = this.GL;
    const texture2 = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture2);
    const glFormat = gl.RGBA;
    const glDataType = gl.UNSIGNED_BYTE;
    for (let level = 0; level < levels.length; level++) {
      gl.texImage2D(
        gl.TEXTURE_2D,
        level,
        glFormat,
        glFormat,
        glDataType,
        levels[level]
      );
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return { texture: texture2, glFormat, glDataType };
  }
  /* Binds a buffer to the drawing context
   * when passed more than two arguments it also updates or initializes
   * the data associated with the buffer
   */
  _bindBuffer(buffer, target, values, type2, usage) {
    const gl = this.GL;
    if (!target) target = gl.ARRAY_BUFFER;
    gl.bindBuffer(target, buffer);
    if (values !== void 0) {
      const data2 = this._normalizeBufferData(values, type2);
      gl.bufferData(target, data2, usage || gl.STATIC_DRAW);
    }
  }
  _prepareBuffer(renderBuffer2, geometry2, shader2) {
    const attributes2 = shader2.attributes;
    const gl = this.GL;
    const glBuffers = this._getOrMakeCachedBuffers(geometry2);
    const attr = attributes2[renderBuffer2.attr];
    if (!attr) {
      return;
    }
    let buffer = glBuffers[renderBuffer2.dst];
    const src = geometry2[renderBuffer2.src];
    if (src && src.length > 0) {
      const createBuffer = !buffer;
      if (createBuffer) {
        glBuffers[renderBuffer2.dst] = buffer = gl.createBuffer();
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      if (createBuffer || geometry2.dirtyFlags[renderBuffer2.src] !== false) {
        const map2 = renderBuffer2.map;
        const values = map2 ? map2(src) : src;
        this._bindBuffer(buffer, gl.ARRAY_BUFFER, values);
        geometry2.dirtyFlags[renderBuffer2.src] = false;
      }
      shader2.enableAttrib(attr, renderBuffer2.size);
    } else {
      const loc = attr.location;
      if (loc === -1 || !this.registerEnabled.has(loc)) {
        return;
      }
      gl.disableVertexAttribArray(loc);
      this.registerEnabled.delete(loc);
    }
  }
  _enableAttrib(_shader, attr, size, type2, normalized, stride, offset2) {
    const loc = attr.location;
    const gl = this.GL;
    if (!this.registerEnabled.has(loc)) {
      gl.enableVertexAttribArray(loc);
      this.registerEnabled.add(loc);
    }
    gl.vertexAttribPointer(
      loc,
      size,
      type2 || gl.FLOAT,
      normalized || false,
      stride || 0,
      offset2 || 0
    );
  }
  _ensureGeometryBuffers(buffers, indices, indexType) {
    const gl = this.GL;
    if (indices) {
      let buffer = buffers.indexBuffer;
      if (!buffer) buffer = gl.createBuffer();
      this._bindBuffer(buffer, gl.ELEMENT_ARRAY_BUFFER, indices, indexType);
      buffers.indexBuffer = buffer;
      buffers.indexBufferType = indexType === Uint32Array ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
    } else if (buffers.indexBuffer) {
      gl.deleteBuffer(buffers.indexBuffer);
      buffers.indexBuffer = null;
    }
  }
  _freeBuffers(buffers) {
    const gl = this.GL;
    if (buffers.indexBuffer) {
      gl.deleteBuffer(buffers.indexBuffer);
    }
    function freeBuffers(defs) {
      for (const def of defs) {
        if (buffers[def.dst]) {
          gl.deleteBuffer(buffers[def.dst]);
          buffers[def.dst] = null;
        }
      }
    }
    freeBuffers(this.buffers.stroke);
    freeBuffers(this.buffers.fill);
    freeBuffers(this.buffers.user);
  }
  _initShader(shader2) {
    const gl = this.GL;
    const vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, shader2.vertSrc());
    gl.compileShader(vertShader);
    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
      throw new Error(`Yikes! An error occurred compiling the vertex shader: ${gl.getShaderInfoLog(vertShader)} in:

${shader2.vertSrc()}`);
    }
    const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, shader2.fragSrc());
    gl.compileShader(fragShader);
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
      throw new Error(`Darn! An error occurred compiling the fragment shader: ${gl.getShaderInfoLog(fragShader)}`);
    }
    const program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(
        `Snap! Error linking shader program: ${gl.getProgramInfoLog(program)}`
      );
    }
    shader2._glProgram = program;
    shader2._vertShader = vertShader;
    shader2._fragShader = fragShader;
  }
  _finalizeShader() {
  }
  _getShaderAttributes(shader2) {
    return getWebGLShaderAttributes(shader2, this.GL);
  }
  getUniformMetadata(shader2) {
    return getWebGLUniformMetadata(shader2, this.GL);
  }
  updateUniformValue(shader2, uniform, data2) {
    return setWebGLUniformValue(
      shader2,
      uniform,
      data2,
      (tex) => this.getTexture(tex),
      this.GL
    );
  }
  _updateTexture(uniform, tex) {
    const gl = this.GL;
    gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
    tex.bindTexture();
    tex.update();
    gl.uniform1i(uniform.location, uniform.samplerIndex);
  }
  bindTexture(tex) {
    this.GL.bindTexture(this.GL.TEXTURE_2D, tex.getTexture().texture);
  }
  unbindTexture() {
    this.GL.bindTexture(this.GL.TEXTURE_2D, null);
  }
  _unbindFramebufferTexture(uniform) {
    const gl = this.GL;
    const empty2 = this._getEmptyTexture();
    gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
    empty2.bindTexture();
    gl.uniform1i(uniform.location, uniform.samplerIndex);
  }
  createTexture({ width, height, format, dataType }) {
    const gl = this.GL;
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      width,
      height,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      null
    );
    return { texture: tex, glFormat: gl.RGBA, glDataType: gl.UNSIGNED_BYTE };
  }
  createFramebufferTextureHandle(framebufferTexture) {
    return null;
  }
  uploadTextureFromSource({ texture: texture2, glFormat, glDataType }, source) {
    const gl = this.GL;
    gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, glFormat, glDataType, source);
  }
  uploadTextureFromData({ texture: texture2, glFormat, glDataType }, data2, width, height) {
    const gl = this.GL;
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      glFormat,
      width,
      height,
      0,
      glFormat,
      glDataType,
      data2
    );
  }
  getSampler(_texture) {
    return void 0;
  }
  bindTextureToShader({ texture: texture2 }, sampler, uniformName, unit) {
    const gl = this.GL;
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, texture2);
    const location2 = gl.getUniformLocation(glProgram, uniformName);
    gl.uniform1i(location2, unit);
  }
  setTextureParams(texture2) {
    return setWebGLTextureParams(texture2, this.GL, this.webglVersion);
  }
  deleteTexture({ texture: texture2 }) {
    this.GL.deleteTexture(texture2);
  }
  /**
   * @private blends colors according to color components.
   * If alpha value is less than 1, or non-standard blendMode
   * we need to enable blending on our gl context.
   * @param  {Number[]} color The currently set color, with values in 0-1 range
   * @param  {Boolean} [hasTransparency] Whether the shape being drawn has other
   * transparency internally, e.g. via vertex colors
   * @return {Number[]}  Normalized numbers array
   */
  _applyColorBlend(colors, hasTransparency) {
    const gl = this.GL;
    const isTexture = this.states.drawMode === TEXTURE;
    const doBlend = hasTransparency || this.states.userFillShader || this.states.userStrokeShader || isTexture || this.states.curBlendMode !== BLEND || colors[colors.length - 1] < 1 || this._isErasing;
    if (doBlend !== this._isBlending) {
      if (doBlend || this.states.curBlendMode !== BLEND && this.states.curBlendMode !== ADD) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      gl.depthMask(true);
      this._isBlending = doBlend;
    }
    this._applyBlendMode();
    return colors;
  }
  //////////////////////////////////////////////
  // Shader hooks
  //////////////////////////////////////////////
  uniformNameFromHookKey(key) {
    return key.slice(key.indexOf(" ") + 1);
  }
  populateHooks(shader2, src, shaderType) {
    return populateGLSLHooks(shader2, src, shaderType);
  }
  getShaderHookTypes(shader2, hookName) {
    return getShaderHookTypes(shader2, hookName);
  }
  //////////////////////////////////////////////
  // Framebuffer methods
  //////////////////////////////////////////////
  defaultFramebufferAlpha() {
    return this._pInst._glAttributes.alpha;
  }
  defaultFramebufferAntialias() {
    return this.supportsFramebufferAntialias() ? this._pInst._glAttributes.antialias : false;
  }
  supportsFramebufferAntialias() {
    return this.webglVersion === WEBGL2;
  }
  createFramebufferResources(framebuffer2) {
    const gl = this.GL;
    framebuffer2.framebuffer = gl.createFramebuffer();
    if (!framebuffer2.framebuffer) {
      throw new Error("Unable to create a framebuffer");
    }
    if (framebuffer2.antialias) {
      framebuffer2.aaFramebuffer = gl.createFramebuffer();
      if (!framebuffer2.aaFramebuffer) {
        throw new Error("Unable to create a framebuffer for antialiasing");
      }
    }
  }
  validateFramebufferFormats(framebuffer2) {
    const gl = this.GL;
    if (framebuffer2.useDepth && this.webglVersion === WEBGL && !gl.getExtension("WEBGL_depth_texture")) {
      console.warn(
        "Unable to create depth textures in this environment. Falling back to a framebuffer without depth."
      );
      framebuffer2.useDepth = false;
    }
    if (framebuffer2.useDepth && this.webglVersion === WEBGL && framebuffer2.depthFormat === FLOAT) {
      console.warn(
        "FLOAT depth format is unavailable in WebGL 1. Defaulting to UNSIGNED_INT."
      );
      framebuffer2.depthFormat = UNSIGNED_INT;
    }
    if (![
      UNSIGNED_BYTE,
      FLOAT,
      HALF_FLOAT
    ].includes(framebuffer2.format)) {
      console.warn(
        "Unknown Framebuffer format. Please use UNSIGNED_BYTE, FLOAT, or HALF_FLOAT. Defaulting to UNSIGNED_BYTE."
      );
      framebuffer2.format = UNSIGNED_BYTE;
    }
    if (framebuffer2.useDepth && ![
      UNSIGNED_INT,
      FLOAT
    ].includes(framebuffer2.depthFormat)) {
      console.warn(
        "Unknown Framebuffer depth format. Please use UNSIGNED_INT or FLOAT. Defaulting to FLOAT."
      );
      framebuffer2.depthFormat = FLOAT;
    }
    const support = checkWebGLCapabilities(this);
    if (!support.float && framebuffer2.format === FLOAT) {
      console.warn(
        "This environment does not support FLOAT textures. Falling back to UNSIGNED_BYTE."
      );
      framebuffer2.format = UNSIGNED_BYTE;
    }
    if (framebuffer2.useDepth && !support.float && framebuffer2.depthFormat === FLOAT) {
      console.warn(
        "This environment does not support FLOAT depth textures. Falling back to UNSIGNED_INT."
      );
      framebuffer2.depthFormat = UNSIGNED_INT;
    }
    if (!support.halfFloat && framebuffer2.format === HALF_FLOAT) {
      console.warn(
        "This environment does not support HALF_FLOAT textures. Falling back to UNSIGNED_BYTE."
      );
      framebuffer2.format = UNSIGNED_BYTE;
    }
    if (framebuffer2.channels === RGB && [FLOAT, HALF_FLOAT].includes(framebuffer2.format)) {
      console.warn(
        "FLOAT and HALF_FLOAT formats do not work cross-platform with only RGB channels. Falling back to RGBA."
      );
      framebuffer2.channels = RGBA;
    }
  }
  recreateFramebufferTextures(framebuffer2) {
    const gl = this.GL;
    const prevBoundTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
    const prevBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    const colorTexture = gl.createTexture();
    if (!colorTexture) {
      throw new Error("Unable to create color texture");
    }
    gl.bindTexture(gl.TEXTURE_2D, colorTexture);
    const colorFormat = this._getFramebufferColorFormat(framebuffer2);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      colorFormat.internalFormat,
      framebuffer2.width * framebuffer2.density,
      framebuffer2.height * framebuffer2.density,
      0,
      colorFormat.format,
      colorFormat.type,
      null
    );
    framebuffer2.colorTexture = colorTexture;
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer2.framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      colorTexture,
      0
    );
    if (framebuffer2.useDepth) {
      const depthTexture = gl.createTexture();
      if (!depthTexture) {
        throw new Error("Unable to create depth texture");
      }
      const depthFormat = this._getFramebufferDepthFormat(framebuffer2);
      gl.bindTexture(gl.TEXTURE_2D, depthTexture);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        depthFormat.internalFormat,
        framebuffer2.width * framebuffer2.density,
        framebuffer2.height * framebuffer2.density,
        0,
        depthFormat.format,
        depthFormat.type,
        null
      );
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        framebuffer2.useStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT,
        gl.TEXTURE_2D,
        depthTexture,
        0
      );
      framebuffer2.depthTexture = depthTexture;
    }
    if (framebuffer2.antialias) {
      framebuffer2.colorRenderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer2.colorRenderbuffer);
      gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        Math.max(
          0,
          Math.min(framebuffer2.antialiasSamples, gl.getParameter(gl.MAX_SAMPLES))
        ),
        colorFormat.internalFormat,
        framebuffer2.width * framebuffer2.density,
        framebuffer2.height * framebuffer2.density
      );
      if (framebuffer2.useDepth) {
        const depthFormat = this._getFramebufferDepthFormat(framebuffer2);
        framebuffer2.depthRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer2.depthRenderbuffer);
        gl.renderbufferStorageMultisample(
          gl.RENDERBUFFER,
          Math.max(
            0,
            Math.min(framebuffer2.antialiasSamples, gl.getParameter(gl.MAX_SAMPLES))
          ),
          depthFormat.internalFormat,
          framebuffer2.width * framebuffer2.density,
          framebuffer2.height * framebuffer2.density
        );
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer2.aaFramebuffer);
      gl.framebufferRenderbuffer(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.RENDERBUFFER,
        framebuffer2.colorRenderbuffer
      );
      if (framebuffer2.useDepth) {
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          framebuffer2.useStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT,
          gl.RENDERBUFFER,
          framebuffer2.depthRenderbuffer
        );
      }
    }
    gl.bindTexture(gl.TEXTURE_2D, prevBoundTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, prevBoundFramebuffer);
  }
  /**
   * To create a WebGL texture, one needs to supply three pieces of information:
   * the type (the data type each channel will be stored as, e.g. int or float),
   * the format (the color channels that will each be stored in the previously
   * specified type, e.g. rgb or rgba), and the internal format (the specifics
   * of how data for each channel, in the aforementioned type, will be packed
   * together, such as how many bits to use, e.g. RGBA32F or RGB565.)
   *
   * The format and channels asked for by the user hint at what these values
   * need to be, and the WebGL version affects what options are avaiable.
   * This method returns the values for these three properties, given the
   * framebuffer's settings.
   *
   * @private
   */
  _getFramebufferColorFormat(framebuffer2) {
    let type2, format, internalFormat;
    const gl = this.GL;
    if (framebuffer2.format === FLOAT) {
      type2 = gl.FLOAT;
    } else if (framebuffer2.format === HALF_FLOAT) {
      type2 = this.webglVersion === WEBGL2 ? gl.HALF_FLOAT : gl.getExtension("OES_texture_half_float").HALF_FLOAT_OES;
    } else {
      type2 = gl.UNSIGNED_BYTE;
    }
    if (framebuffer2.channels === RGBA) {
      format = gl.RGBA;
    } else {
      format = gl.RGB;
    }
    if (this.webglVersion === WEBGL2) {
      const table2 = {
        [gl.FLOAT]: {
          [gl.RGBA]: gl.RGBA32F
          // gl.RGB32F is not available in Firefox without an alpha channel
        },
        [gl.HALF_FLOAT]: {
          [gl.RGBA]: gl.RGBA16F
          // gl.RGB16F is not available in Firefox without an alpha channel
        },
        [gl.UNSIGNED_BYTE]: {
          [gl.RGBA]: gl.RGBA8,
          // gl.RGBA4
          [gl.RGB]: gl.RGB8
          // gl.RGB565
        }
      };
      internalFormat = table2[type2][format];
    } else if (framebuffer2.format === HALF_FLOAT) {
      internalFormat = gl.RGBA;
    } else {
      internalFormat = format;
    }
    return { internalFormat, format, type: type2 };
  }
  /**
   * To create a WebGL texture, one needs to supply three pieces of information:
   * the type (the data type each channel will be stored as, e.g. int or float),
   * the format (the color channels that will each be stored in the previously
   * specified type, e.g. rgb or rgba), and the internal format (the specifics
   * of how data for each channel, in the aforementioned type, will be packed
   * together, such as how many bits to use, e.g. RGBA32F or RGB565.)
   *
   * This method takes into account the settings asked for by the user and
   * returns values for these three properties that can be used for the
   * texture storing depth information.
   *
   * @private
   */
  _getFramebufferDepthFormat(framebuffer2) {
    let type2, format, internalFormat;
    const gl = this.GL;
    if (framebuffer2.useStencil) {
      if (framebuffer2.depthFormat === FLOAT) {
        type2 = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
      } else if (this.webglVersion === WEBGL2) {
        type2 = gl.UNSIGNED_INT_24_8;
      } else {
        type2 = gl.getExtension("WEBGL_depth_texture").UNSIGNED_INT_24_8_WEBGL;
      }
    } else {
      if (framebuffer2.depthFormat === FLOAT) {
        type2 = gl.FLOAT;
      } else {
        type2 = gl.UNSIGNED_INT;
      }
    }
    if (framebuffer2.useStencil) {
      format = gl.DEPTH_STENCIL;
    } else {
      format = gl.DEPTH_COMPONENT;
    }
    if (framebuffer2.useStencil) {
      if (framebuffer2.depthFormat === FLOAT) {
        internalFormat = gl.DEPTH32F_STENCIL8;
      } else if (this.webglVersion === WEBGL2) {
        internalFormat = gl.DEPTH24_STENCIL8;
      } else {
        internalFormat = gl.DEPTH_STENCIL;
      }
    } else if (this.webglVersion === WEBGL2) {
      if (framebuffer2.depthFormat === FLOAT) {
        internalFormat = gl.DEPTH_COMPONENT32F;
      } else {
        internalFormat = gl.DEPTH_COMPONENT24;
      }
    } else {
      internalFormat = gl.DEPTH_COMPONENT;
    }
    return { internalFormat, format, type: type2 };
  }
  _deleteFramebufferTexture(texture2) {
    const gl = this.GL;
    gl.deleteTexture(texture2.rawTexture().texture);
    this.textures.delete(texture2);
  }
  deleteFramebufferTextures(framebuffer2) {
    this._deleteFramebufferTexture(framebuffer2.color);
    if (framebuffer2.depth) this._deleteFramebufferTexture(framebuffer2.depth);
    const gl = this.GL;
    if (framebuffer2.colorRenderbuffer) gl.deleteRenderbuffer(framebuffer2.colorRenderbuffer);
    if (framebuffer2.depthRenderbuffer) gl.deleteRenderbuffer(framebuffer2.depthRenderbuffer);
  }
  deleteFramebufferResources(framebuffer2) {
    const gl = this.GL;
    gl.deleteFramebuffer(framebuffer2.framebuffer);
    if (framebuffer2.aaFramebuffer) {
      gl.deleteFramebuffer(framebuffer2.aaFramebuffer);
    }
    if (framebuffer2.depthRenderbuffer) {
      gl.deleteRenderbuffer(framebuffer2.depthRenderbuffer);
    }
    if (framebuffer2.colorRenderbuffer) {
      gl.deleteRenderbuffer(framebuffer2.colorRenderbuffer);
    }
  }
  getFramebufferToBind(framebuffer2) {
    if (framebuffer2.antialias) {
      return framebuffer2.aaFramebuffer;
    } else {
      return framebuffer2.framebuffer;
    }
  }
  updateFramebufferTexture(framebuffer2, property) {
    if (framebuffer2.antialias) {
      const gl = this.GL;
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer2.aaFramebuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer2.framebuffer);
      const partsToCopy = {
        colorTexture: [
          gl.COLOR_BUFFER_BIT,
          framebuffer2.colorP5Texture.magFilter === LINEAR ? gl.LINEAR : gl.NEAREST
        ]
      };
      if (framebuffer2.useDepth) {
        partsToCopy.depthTexture = [
          gl.DEPTH_BUFFER_BIT,
          framebuffer2.depthP5Texture.magFilter === LINEAR ? gl.LINEAR : gl.NEAREST
        ];
      }
      const [flag, filter] = partsToCopy[property];
      gl.blitFramebuffer(
        0,
        0,
        framebuffer2.width * framebuffer2.density,
        framebuffer2.height * framebuffer2.density,
        0,
        0,
        framebuffer2.width * framebuffer2.density,
        framebuffer2.height * framebuffer2.density,
        flag,
        filter
      );
      const activeFbo = this.activeFramebuffer();
      this.bindFramebuffer(activeFbo);
    }
  }
  bindFramebuffer(framebuffer2) {
    const gl = this.GL;
    gl.bindFramebuffer(
      gl.FRAMEBUFFER,
      framebuffer2 ? this.getFramebufferToBind(framebuffer2) : null
    );
  }
  framebufferYScale() {
    return -1;
  }
  readFramebufferPixels(framebuffer2) {
    const gl = this.GL;
    const prevFramebuffer = this.activeFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer2.framebuffer);
    const colorFormat = this._getFramebufferColorFormat(framebuffer2);
    const pixels2 = readPixelsWebGL(
      framebuffer2.pixels,
      gl,
      framebuffer2.framebuffer,
      0,
      0,
      framebuffer2.width * framebuffer2.density,
      framebuffer2.height * framebuffer2.density,
      colorFormat.format,
      colorFormat.type
    );
    this.bindFramebuffer(prevFramebuffer);
    return pixels2;
  }
  readFramebufferPixel(framebuffer2, x, y) {
    const colorFormat = this._getFramebufferColorFormat(framebuffer2);
    return readPixelWebGL(
      this.GL,
      framebuffer2.framebuffer,
      x,
      y,
      colorFormat.format,
      colorFormat.type
    );
  }
  readFramebufferRegion(framebuffer2, x, y, w, h) {
    const gl = this.GL;
    const colorFormat = this._getFramebufferColorFormat(framebuffer2);
    const rawData = readPixelsWebGL(
      void 0,
      gl,
      framebuffer2.framebuffer,
      x * framebuffer2.density,
      y * framebuffer2.density,
      w * framebuffer2.density,
      h * framebuffer2.density,
      colorFormat.format,
      colorFormat.type
    );
    const fullData = new Uint8ClampedArray(
      w * h * framebuffer2.density * framebuffer2.density * 4
    );
    fullData.fill(255);
    const channels = colorFormat.format === gl.RGB ? 3 : 4;
    for (let yPos = 0; yPos < h * framebuffer2.density; yPos++) {
      for (let xPos = 0; xPos < w * framebuffer2.density; xPos++) {
        for (let channel = 0; channel < 4; channel++) {
          const idx = (yPos * w * framebuffer2.density + xPos) * 4 + channel;
          if (channel < channels) {
            const rawDataIdx = channels === 4 ? idx : (yPos * w * framebuffer2.density + xPos) * channels + channel;
            fullData[idx] = rawData[rawDataIdx];
          }
        }
      }
    }
    const region = new Image(w * framebuffer2.density, h * framebuffer2.density);
    region.imageData = region.canvas.getContext("2d").createImageData(
      region.width,
      region.height
    );
    region.imageData.data.set(fullData);
    region.pixels = region.imageData.data;
    region.updatePixels();
    if (framebuffer2.density !== 1) {
      region.pixelDensity(framebuffer2.density);
    }
    return region;
  }
  updateFramebufferPixels(framebuffer2) {
    const gl = this.GL;
    framebuffer2.colorP5Texture.bindTexture();
    const colorFormat = this._getFramebufferColorFormat(framebuffer2);
    const channels = colorFormat.format === gl.RGBA ? 4 : 3;
    const len = framebuffer2.width * framebuffer2.height * framebuffer2.density * framebuffer2.density * channels;
    const TypedArrayClass = colorFormat.type === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
    if (!(framebuffer2.pixels instanceof TypedArrayClass) || framebuffer2.pixels.length !== len) {
      throw new Error(
        "The pixels array has not been set correctly. Please call loadPixels() before updatePixels()."
      );
    }
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      colorFormat.internalFormat,
      framebuffer2.width * framebuffer2.density,
      framebuffer2.height * framebuffer2.density,
      0,
      colorFormat.format,
      colorFormat.type,
      framebuffer2.pixels
    );
    framebuffer2.colorP5Texture.unbindTexture();
    framebuffer2.dirty.colorTexture = false;
    const prevFramebuffer = this.activeFramebuffer();
    if (framebuffer2.antialias) {
      framebuffer2.begin();
      this.push();
      this.states.setValue("imageMode", CORNER);
      this.setCamera(framebuffer2.filterCamera);
      this.resetMatrix();
      this.states.setValue("strokeColor", null);
      this.clear();
      this._drawingFilter = true;
      this.image(
        framebuffer2,
        0,
        0,
        framebuffer2.width,
        framebuffer2.height,
        -this.width / 2,
        -this.height / 2,
        this.width,
        this.height
      );
      this._drawingFilter = false;
      this.pop();
      if (framebuffer2.useDepth) {
        gl.clearDepth(1);
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      framebuffer2.end();
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer2.framebuffer);
      if (framebuffer2.useDepth) {
        gl.clearDepth(1);
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      this.bindFramebuffer(prevFramebuffer);
    }
  }
  getNoiseShaderSnippet() {
    return noiseGLSL;
  }
}
function rendererGL(p53, fn2) {
  p53.RendererGL = RendererGL;
  fn2.setAttributes = function(key, value) {
    return this._renderer._setAttributes(key, value);
  };
  fn2._assert3d = function(name) {
    if (!this._renderer.isP3D)
      throw new Error(
        `${name}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`
      );
  };
  p53.renderers[WEBGL] = p53.RendererGL;
  p53.renderers[WEBGL2] = p53.RendererGL;
}
if (typeof p5 !== "undefined") {
  rendererGL(p5, p5.prototype);
}
function webgl(p53) {
  p53.registerAddon(renderer3D);
  p53.registerAddon(rendererGL);
  p53.registerAddon(primitives3D);
  p53.registerAddon(interaction);
  p53.registerAddon(light);
  p53.registerAddon(loading$1);
  p53.registerAddon(material);
  p53.registerAddon(text);
  p53.registerAddon(renderBuffer);
  p53.registerAddon(quat);
  p53.registerAddon(matrix);
  p53.registerAddon(geometry);
  p53.registerAddon(camera);
  p53.registerAddon(framebuffer);
  p53.registerAddon(dataArray);
  p53.registerAddon(texture);
}
function type(p53) {
  p53.registerAddon(textCore);
  p53.registerAddon(font);
}
var escodegen$1 = {};
var estraverse = {};
var hasRequiredEstraverse;
function requireEstraverse() {
  if (hasRequiredEstraverse) return estraverse;
  hasRequiredEstraverse = 1;
  (function(exports$1) {
    (function clone2(exports$12) {
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE2;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array2, func) {
        var diff, len, i, current2;
        len = array2.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current2 = i + diff;
          if (func(array2[current2])) {
            len = diff;
          } else {
            i = current2 + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE2 = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE2
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove3() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element2(node, path2, wrap, ref2) {
        this.node = node;
        this.path = path2;
        this.wrap = wrap;
        this.ref = ref2;
      }
      function Controller2() {
      }
      Controller2.prototype.path = function path2() {
        var i, iz, j2, jz, result, element2;
        function addToPath(result2, path3) {
          if (Array.isArray(path3)) {
            for (j2 = 0, jz = path3.length; j2 < jz; ++j2) {
              result2.push(path3[j2]);
            }
          } else {
            result2.push(path3);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element2 = this.__leavelist[i];
          addToPath(result, element2.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller2.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller2.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller2.prototype.current = function current2() {
        return this.__current.node;
      };
      Controller2.prototype.__execute = function __execute(callback, element2) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element2;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element2.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller2.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller2.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller2.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller2.prototype.remove = function() {
        this.notify(REMOVE2);
      };
      Controller2.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
          if (leavelist[i].node === candidate) {
            return true;
          }
        }
        return false;
      }
      Controller2.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element2, node, nodeType, ret, key, current2, current22, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element2(root, null, null, null));
        leavelist.push(new Element2(null, null, null, null));
        while (worklist.length) {
          element2 = worklist.pop();
          if (element2 === sentinel) {
            element2 = leavelist.pop();
            ret = this.__execute(visitor.leave, element2);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element2.node) {
            ret = this.__execute(visitor.enter, element2);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element2);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element2.node;
            nodeType = node.type || element2.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current2 = candidates.length;
            while ((current2 -= 1) >= 0) {
              key = candidates[current2];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current22 = candidate.length;
                while ((current22 -= 1) >= 0) {
                  if (!candidate[current22]) {
                    continue;
                  }
                  if (candidateExistsInLeaveList(leavelist, candidate[current22])) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current2])) {
                    element2 = new Element2(candidate[current22], [key, current22], "Property", null);
                  } else if (isNode(candidate[current22])) {
                    element2 = new Element2(candidate[current22], [key, current22], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element2);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }
                worklist.push(new Element2(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller2.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element2, current2, current22, candidates, candidate, sentinel, outer, key;
        function removeElem(element3) {
          var i, key2, nextElem, parent;
          if (element3.ref.remove()) {
            key2 = element3.ref.key;
            parent = element3.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element2 = new Element2(root, null, null, new Reference(outer, "root"));
        worklist.push(element2);
        leavelist.push(element2);
        while (worklist.length) {
          element2 = worklist.pop();
          if (element2 === sentinel) {
            element2 = leavelist.pop();
            target = this.__execute(visitor.leave, element2);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE2) {
              element2.ref.replace(target);
            }
            if (this.__state === REMOVE2 || target === REMOVE2) {
              removeElem(element2);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element2);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE2) {
            element2.ref.replace(target);
            element2.node = target;
          }
          if (this.__state === REMOVE2 || target === REMOVE2) {
            removeElem(element2);
            element2.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element2.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element2);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element2.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current2 = candidates.length;
          while ((current2 -= 1) >= 0) {
            key = candidates[current2];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current22 = candidate.length;
              while ((current22 -= 1) >= 0) {
                if (!candidate[current22]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current2])) {
                  element2 = new Element2(candidate[current22], [key, current22], "Property", new Reference(candidate, current22));
                } else if (isNode(candidate[current22])) {
                  element2 = new Element2(candidate[current22], [key, current22], null, new Reference(candidate, current22));
                } else {
                  continue;
                }
                worklist.push(element2);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element2(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller2();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller2();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports$12.Syntax = Syntax;
      exports$12.traverse = traverse;
      exports$12.replace = replace;
      exports$12.attachComments = attachComments;
      exports$12.VisitorKeys = VisitorKeys;
      exports$12.VisitorOption = VisitorOption;
      exports$12.Controller = Controller2;
      exports$12.cloneEnvironment = function() {
        return clone2({});
      };
      return exports$12;
    })(exports$1);
  })(estraverse);
  return estraverse;
}
var utils = {};
var ast = { exports: {} };
var hasRequiredAst;
function requireAst() {
  if (hasRequiredAst) return ast.exports;
  hasRequiredAst = 1;
  (function() {
    function isExpression(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }
    function isIterationStatement(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }
    function isStatement(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === "FunctionDeclaration";
    }
    function trailingStatement(node) {
      switch (node.type) {
        case "IfStatement":
          if (node.alternate != null) {
            return node.alternate;
          }
          return node.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return node.body;
      }
      return null;
    }
    function isProblematicIfStatement(node) {
      var current2;
      if (node.type !== "IfStatement") {
        return false;
      }
      if (node.alternate == null) {
        return false;
      }
      current2 = node.consequent;
      do {
        if (current2.type === "IfStatement") {
          if (current2.alternate == null) {
            return true;
          }
        }
        current2 = trailingStatement(current2);
      } while (current2);
      return false;
    }
    ast.exports = {
      isExpression,
      isStatement,
      isIterationStatement,
      isSourceElement,
      isProblematicIfStatement,
      trailingStatement
    };
  })();
  return ast.exports;
}
var code = { exports: {} };
var hasRequiredCode;
function requireCode() {
  if (hasRequiredCode) return code.exports;
  hasRequiredCode = 1;
  (function() {
    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
    ES5Regex = {
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };
    ES6Regex = {
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function isDecimalDigit2(ch2) {
      return 48 <= ch2 && ch2 <= 57;
    }
    function isHexDigit2(ch2) {
      return 48 <= ch2 && ch2 <= 57 || // 0..9
      97 <= ch2 && ch2 <= 102 || // a..f
      65 <= ch2 && ch2 <= 70;
    }
    function isOctalDigit2(ch2) {
      return ch2 >= 48 && ch2 <= 55;
    }
    NON_ASCII_WHITESPACES = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function isWhiteSpace(ch2) {
      return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
    }
    function isLineTerminator(ch2) {
      return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
    }
    function fromCodePoint(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      }
      var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
      var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
      return cu1 + cu2;
    }
    IDENTIFIER_START = new Array(128);
    for (ch = 0; ch < 128; ++ch) {
      IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
      ch >= 65 && ch <= 90 || // A..Z
      ch === 36 || ch === 95;
    }
    IDENTIFIER_PART = new Array(128);
    for (ch = 0; ch < 128; ++ch) {
      IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
      ch >= 65 && ch <= 90 || // A..Z
      ch >= 48 && ch <= 57 || // 0..9
      ch === 36 || ch === 95;
    }
    function isIdentifierStartES5(ch2) {
      return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
    }
    function isIdentifierPartES5(ch2) {
      return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
    }
    function isIdentifierStartES6(ch2) {
      return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
    }
    function isIdentifierPartES6(ch2) {
      return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
    }
    code.exports = {
      isDecimalDigit: isDecimalDigit2,
      isHexDigit: isHexDigit2,
      isOctalDigit: isOctalDigit2,
      isWhiteSpace,
      isLineTerminator,
      isIdentifierStartES5,
      isIdentifierPartES5,
      isIdentifierStartES6,
      isIdentifierPartES6
    };
  })();
  return code.exports;
}
var keyword = { exports: {} };
var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword.exports;
  hasRequiredKeyword = 1;
  (function() {
    var code2 = requireCode();
    function isStrictModeReservedWordES6(id) {
      switch (id) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return true;
        default:
          return false;
      }
    }
    function isKeywordES5(id, strict) {
      if (!strict && id === "yield") {
        return false;
      }
      return isKeywordES6(id, strict);
    }
    function isKeywordES6(id, strict) {
      if (strict && isStrictModeReservedWordES6(id)) {
        return true;
      }
      switch (id.length) {
        case 2:
          return id === "if" || id === "in" || id === "do";
        case 3:
          return id === "var" || id === "for" || id === "new" || id === "try";
        case 4:
          return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
        case 5:
          return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
        case 6:
          return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
        case 7:
          return id === "default" || id === "finally" || id === "extends";
        case 8:
          return id === "function" || id === "continue" || id === "debugger";
        case 10:
          return id === "instanceof";
        default:
          return false;
      }
    }
    function isReservedWordES5(id, strict) {
      return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
    }
    function isReservedWordES6(id, strict) {
      return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
    }
    function isRestrictedWord(id) {
      return id === "eval" || id === "arguments";
    }
    function isIdentifierNameES5(id) {
      var i, iz, ch;
      if (id.length === 0) {
        return false;
      }
      ch = id.charCodeAt(0);
      if (!code2.isIdentifierStartES5(ch)) {
        return false;
      }
      for (i = 1, iz = id.length; i < iz; ++i) {
        ch = id.charCodeAt(i);
        if (!code2.isIdentifierPartES5(ch)) {
          return false;
        }
      }
      return true;
    }
    function decodeUtf16(lead, trail) {
      return (lead - 55296) * 1024 + (trail - 56320) + 65536;
    }
    function isIdentifierNameES6(id) {
      var i, iz, ch, lowCh, check2;
      if (id.length === 0) {
        return false;
      }
      check2 = code2.isIdentifierStartES6;
      for (i = 0, iz = id.length; i < iz; ++i) {
        ch = id.charCodeAt(i);
        if (55296 <= ch && ch <= 56319) {
          ++i;
          if (i >= iz) {
            return false;
          }
          lowCh = id.charCodeAt(i);
          if (!(56320 <= lowCh && lowCh <= 57343)) {
            return false;
          }
          ch = decodeUtf16(ch, lowCh);
        }
        if (!check2(ch)) {
          return false;
        }
        check2 = code2.isIdentifierPartES6;
      }
      return true;
    }
    function isIdentifierES5(id, strict) {
      return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }
    function isIdentifierES6(id, strict) {
      return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }
    keyword.exports = {
      isKeywordES5,
      isKeywordES6,
      isReservedWordES5,
      isReservedWordES6,
      isRestrictedWord,
      isIdentifierNameES5,
      isIdentifierNameES6,
      isIdentifierES5,
      isIdentifierES6
    };
  })();
  return keyword.exports;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function() {
    utils.ast = requireAst();
    utils.code = requireCode();
    utils.keyword = requireKeyword();
  })();
  return utils;
}
var sourceMap = {};
var sourceMapGenerator = {};
var base64Vlq = {};
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  base64.encode = function(number2) {
    if (0 <= number2 && number2 < intToCharMap.length) {
      return intToCharMap[number2];
    }
    throw new TypeError("Must be between 0 and 63: " + number2);
  };
  base64.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
  return base64;
}
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  var base642 = requireBase64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base642.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base642.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return base64Vlq;
}
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports$1) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports$1.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports$1.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports$1.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path2 = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path2 = url.path;
      }
      var isAbsolute = exports$1.isAbsolute(path2);
      var parts = path2.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path2 = parts.join("/");
      if (path2 === "") {
        path2 = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path2;
        return urlGenerate(url);
      }
      return path2;
    }
    exports$1.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports$1.join = join;
    exports$1.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports$1.relative = relative;
    var supportsNullProto = (function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    })();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports$1.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports$1.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports$1.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports$1.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports$1.computeSourceURL = computeSourceURL;
  })(util);
  return util;
}
var arraySet = {};
var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  var util2 = requireUtil();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set2 = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set2.add(aArray[i], aAllowDuplicates);
    }
    return set2;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util2.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util2.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet;
  return arraySet;
}
var mappingList = {};
var hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  var util2 = requireUtil();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util2.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList;
  return mappingList;
}
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  var base64VLQ = requireBase64Vlq();
  var util2 = requireUtil();
  var ArraySet = requireArraySet().ArraySet;
  var MappingList = requireMappingList().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util2.getArg(aArgs, "file", null);
    this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util2.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util2.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util2.getArg(aArgs, "generated");
    var original = util2.getArg(aArgs, "original", null);
    var source = util2.getArg(aArgs, "source", null);
    var name = util2.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util2.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = /* @__PURE__ */ Object.create(null);
      }
      this._sourcesContents[util2.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util2.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util2.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util2.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util2.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util2.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util2.relative(aSourceRoot, source);
      }
      var key = util2.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map2 = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map2.file = this._file;
    }
    if (this._sourceRoot != null) {
      map2.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
    }
    return map2;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  return sourceMapGenerator;
}
var sourceMapConsumer = {};
var binarySearch = {};
var hasRequiredBinarySearch;
function requireBinarySearch() {
  if (hasRequiredBinarySearch) return binarySearch;
  hasRequiredBinarySearch = 1;
  (function(exports$1) {
    exports$1.GREATEST_LOWER_BOUND = 1;
    exports$1.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports$1.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports$1.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports$1.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports$1.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  })(binarySearch);
  return binarySearch;
}
var quickSort = {};
var hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort) return quickSort;
  hasRequiredQuickSort = 1;
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p2, r) {
    if (p2 < r) {
      var pivotIndex = randomIntInRange(p2, r);
      var i = p2 - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j2 = p2; j2 < r; j2++) {
        if (comparator(ary[j2], pivot) <= 0) {
          i += 1;
          swap(ary, i, j2);
        }
      }
      swap(ary, i + 1, j2);
      var q = i + 1;
      doQuickSort(ary, comparator, p2, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  quickSort.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
  return quickSort;
}
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  var util2 = requireUtil();
  var binarySearch2 = requireBinarySearch();
  var ArraySet = requireArraySet().ArraySet;
  var base64VLQ = requireBase64Vlq();
  var quickSort2 = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    return sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context2 = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util2.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context2);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util2.getArg(aArgs, "line");
    var needle = {
      source: util2.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util2.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      binarySearch2.LEAST_UPPER_BOUND
    );
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === void 0) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    var version2 = util2.getArg(sourceMap2, "version");
    var sources = util2.getArg(sourceMap2, "sources");
    var names = util2.getArg(sourceMap2, "names", []);
    var sourceRoot = util2.getArg(sourceMap2, "sourceRoot", null);
    var sourcesContent = util2.getArg(sourceMap2, "sourcesContent", null);
    var mappings = util2.getArg(sourceMap2, "mappings");
    var file2 = util2.getArg(sourceMap2, "file", null);
    if (version2 != this._version) {
      throw new Error("Unsupported version: " + version2);
    }
    if (sourceRoot) {
      sourceRoot = util2.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util2.normalize).map(function(source) {
      return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source) ? util2.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util2.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file2;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util2.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(
      smc._sources.toArray(),
      smc.sourceRoot
    );
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util2.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort2(smc.__originalMappings, util2.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort2(generatedMappings, util2.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort2(originalMappings, util2.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    };
    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util2.compareByGeneratedPositionsDeflated,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util2.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util2.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util2.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util2.getArg(mapping, "originalLine", null),
          column: util2.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util2.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util2.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util2.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util2.getArg(aArgs, "line"),
      originalColumn: util2.getArg(aArgs, "column")
    };
    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util2.getArg(mapping, "generatedLine", null),
          column: util2.getArg(mapping, "generatedColumn", null),
          lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    var version2 = util2.getArg(sourceMap2, "version");
    var sections = util2.getArg(sourceMap2, "sections");
    if (version2 != this._version) {
      throw new Error("Unsupported version: " + version2);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset2 = util2.getArg(s, "offset");
      var offsetLine = util2.getArg(offset2, "line");
      var offsetColumn = util2.getArg(offset2, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset2;
      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util2.getArg(s, "map"), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j2 = 0; j2 < this._sections[i].consumer.sources.length; j2++) {
          sources.push(this._sections[i].consumer.sources[j2]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch2.search(
      needle,
      this._sections,
      function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      }
    );
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j2 = 0; j2 < sectionMappings.length; j2++) {
        var mapping = sectionMappings[j2];
        var source = section.consumer._sources.at(mapping.source);
        source = util2.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort2(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
    quickSort2(this.__originalMappings, util2.compareByOriginalPositions);
  };
  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  return sourceMapConsumer;
}
var sourceNode = {};
var hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode) return sourceNode;
  hasRequiredSourceNode = 1;
  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  var util2 = requireUtil();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code2 = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code2);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util2.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code2) {
      if (mapping === null || mapping.source === void 0) {
        node.add(code2);
      } else {
        var source = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(
          mapping.originalLine,
          mapping.originalColumn,
          source,
          code2,
          mapping.name
        ));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util2.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map2 = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map2.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map2.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map2.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map2.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map: map2 };
  };
  sourceNode.SourceNode = SourceNode;
  return sourceNode;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  sourceMap.SourceNode = requireSourceNode().SourceNode;
  return sourceMap;
}
const version$1 = "2.1.0";
const require$$3 = {
  version: version$1
};
var hasRequiredEscodegen;
function requireEscodegen() {
  if (hasRequiredEscodegen) return escodegen$1;
  hasRequiredEscodegen = 1;
  (function(exports$1) {
    (function() {
      var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse2, esutils, base2, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse4, sourceMap2, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
      estraverse2 = requireEstraverse();
      esutils = requireUtils();
      Syntax = estraverse2.Syntax;
      function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
      }
      function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
      }
      Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        Coalesce: 3,
        LogicalOR: 4,
        LogicalAND: 5,
        BitwiseOR: 6,
        BitwiseXOR: 7,
        BitwiseAND: 8,
        Equality: 9,
        Relational: 10,
        BitwiseSHIFT: 11,
        Additive: 12,
        Multiplicative: 13,
        Exponentiation: 14,
        Await: 15,
        Unary: 15,
        Postfix: 16,
        OptionalChaining: 17,
        Call: 18,
        New: 19,
        TaggedTemplate: 20,
        Member: 21,
        Primary: 22
      };
      BinaryPrecedence = {
        "??": Precedence.Coalesce,
        "||": Precedence.LogicalOR,
        "&&": Precedence.LogicalAND,
        "|": Precedence.BitwiseOR,
        "^": Precedence.BitwiseXOR,
        "&": Precedence.BitwiseAND,
        "==": Precedence.Equality,
        "!=": Precedence.Equality,
        "===": Precedence.Equality,
        "!==": Precedence.Equality,
        "is": Precedence.Equality,
        "isnt": Precedence.Equality,
        "<": Precedence.Relational,
        ">": Precedence.Relational,
        "<=": Precedence.Relational,
        ">=": Precedence.Relational,
        "in": Precedence.Relational,
        "instanceof": Precedence.Relational,
        "<<": Precedence.BitwiseSHIFT,
        ">>": Precedence.BitwiseSHIFT,
        ">>>": Precedence.BitwiseSHIFT,
        "+": Precedence.Additive,
        "-": Precedence.Additive,
        "*": Precedence.Multiplicative,
        "%": Precedence.Multiplicative,
        "/": Precedence.Multiplicative,
        "**": Precedence.Exponentiation
      };
      var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5, F_FOUND_COALESCE = 1 << 6;
      var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
      var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
      function getDefaultOptions() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: false,
          format: {
            indent: {
              style: "    ",
              base: 0,
              adjustMultilineComment: false
            },
            newline: "\n",
            space: " ",
            json: false,
            renumber: false,
            hexadecimal: false,
            quotes: "single",
            escapeless: false,
            compact: false,
            parentheses: true,
            semicolons: true,
            safeConcatenation: false,
            preserveBlankLines: false
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: false,
            starlessGenerator: false
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: false,
          directive: false,
          raw: true,
          verbatim: null,
          sourceCode: null
        };
      }
      function stringRepeat(str, num) {
        var result = "";
        for (num |= 0; num > 0; num >>>= 1, str += str) {
          if (num & 1) {
            result += str;
          }
        }
        return result;
      }
      function hasLineTerminator(str) {
        return /[\r\n]/g.test(str);
      }
      function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
      }
      function merge2(target, override) {
        var key;
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            target[key] = override[key];
          }
        }
        return target;
      }
      function updateDeeply(target, override) {
        var key, val;
        function isHashObject(target2) {
          return typeof target2 === "object" && target2 instanceof Object && !(target2 instanceof RegExp);
        }
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            val = override[key];
            if (isHashObject(val)) {
              if (isHashObject(target[key])) {
                updateDeeply(target[key], val);
              } else {
                target[key] = updateDeeply({}, val);
              }
            } else {
              target[key] = val;
            }
          }
        }
        return target;
      }
      function generateNumber(value) {
        var result, point, temp, exponent, pos;
        if (value !== value) {
          throw new Error("Numeric literal whose value is NaN");
        }
        if (value < 0 || value === 0 && 1 / value < 0) {
          throw new Error("Numeric literal whose value is negative");
        }
        if (value === 1 / 0) {
          return json ? "null" : renumber ? "1e400" : "1e+400";
        }
        result = "" + value;
        if (!renumber || result.length < 3) {
          return result;
        }
        point = result.indexOf(".");
        if (!json && result.charCodeAt(0) === 48 && point === 1) {
          point = 0;
          result = result.slice(1);
        }
        temp = result;
        result = result.replace("e+", "e");
        exponent = 0;
        if ((pos = temp.indexOf("e")) > 0) {
          exponent = +temp.slice(pos + 1);
          temp = temp.slice(0, pos);
        }
        if (point >= 0) {
          exponent -= temp.length - point - 1;
          temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 48) {
          --pos;
        }
        if (pos !== 0) {
          exponent -= pos;
          temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
          temp += "e" + exponent;
        }
        if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) {
          result = temp;
        }
        return result;
      }
      function escapeRegExpCharacter(ch, previousIsBackslash) {
        if ((ch & -2) === 8232) {
          return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
        } else if (ch === 10 || ch === 13) {
          return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
        }
        return String.fromCharCode(ch);
      }
      function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
        result = reg.toString();
        if (reg.source) {
          match = result.match(/\/([^/]*)$/);
          if (!match) {
            return result;
          }
          flags = match[1];
          result = "";
          characterInBrack = false;
          previousIsBackslash = false;
          for (i = 0, iz = reg.source.length; i < iz; ++i) {
            ch = reg.source.charCodeAt(i);
            if (!previousIsBackslash) {
              if (characterInBrack) {
                if (ch === 93) {
                  characterInBrack = false;
                }
              } else {
                if (ch === 47) {
                  result += "\\";
                } else if (ch === 91) {
                  characterInBrack = true;
                }
              }
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = ch === 92;
            } else {
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = false;
            }
          }
          return "/" + result + "/" + flags;
        }
        return result;
      }
      function escapeAllowedCharacter(code2, next) {
        var hex;
        if (code2 === 8) {
          return "\\b";
        }
        if (code2 === 12) {
          return "\\f";
        }
        if (code2 === 9) {
          return "\\t";
        }
        hex = code2.toString(16).toUpperCase();
        if (json || code2 > 255) {
          return "\\u" + "0000".slice(hex.length) + hex;
        } else if (code2 === 0 && !esutils.code.isDecimalDigit(next)) {
          return "\\0";
        } else if (code2 === 11) {
          return "\\x0B";
        } else {
          return "\\x" + "00".slice(hex.length) + hex;
        }
      }
      function escapeDisallowedCharacter(code2) {
        if (code2 === 92) {
          return "\\\\";
        }
        if (code2 === 10) {
          return "\\n";
        }
        if (code2 === 13) {
          return "\\r";
        }
        if (code2 === 8232) {
          return "\\u2028";
        }
        if (code2 === 8233) {
          return "\\u2029";
        }
        throw new Error("Incorrectly classified character");
      }
      function escapeDirective(str) {
        var i, iz, code2, quote;
        quote = quotes === "double" ? '"' : "'";
        for (i = 0, iz = str.length; i < iz; ++i) {
          code2 = str.charCodeAt(i);
          if (code2 === 39) {
            quote = '"';
            break;
          } else if (code2 === 34) {
            quote = "'";
            break;
          } else if (code2 === 92) {
            ++i;
          }
        }
        return quote + str + quote;
      }
      function escapeString(str) {
        var result = "", i, len, code2, singleQuotes = 0, doubleQuotes = 0, single, quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code2 = str.charCodeAt(i);
          if (code2 === 39) {
            ++singleQuotes;
          } else if (code2 === 34) {
            ++doubleQuotes;
          } else if (code2 === 47 && json) {
            result += "\\";
          } else if (esutils.code.isLineTerminator(code2) || code2 === 92) {
            result += escapeDisallowedCharacter(code2);
            continue;
          } else if (!esutils.code.isIdentifierPartES5(code2) && (json && code2 < 32 || !json && !escapeless && (code2 < 32 || code2 > 126))) {
            result += escapeAllowedCharacter(code2, str.charCodeAt(i + 1));
            continue;
          }
          result += String.fromCharCode(code2);
        }
        single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
        quote = single ? "'" : '"';
        if (!(single ? singleQuotes : doubleQuotes)) {
          return quote + result + quote;
        }
        str = result;
        result = quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code2 = str.charCodeAt(i);
          if (code2 === 39 && single || code2 === 34 && !single) {
            result += "\\";
          }
          result += String.fromCharCode(code2);
        }
        return result + quote;
      }
      function flattenToString(arr2) {
        var i, iz, elem, result = "";
        for (i = 0, iz = arr2.length; i < iz; ++i) {
          elem = arr2[i];
          result += Array.isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
      }
      function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap2) {
          if (Array.isArray(generated)) {
            return flattenToString(generated);
          } else {
            return generated;
          }
        }
        if (node == null) {
          if (generated instanceof SourceNode) {
            return generated;
          } else {
            node = {};
          }
        }
        if (node.loc == null) {
          return new SourceNode(null, null, sourceMap2, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap2 === true ? node.loc.source || null : sourceMap2, generated, node.name || null);
      }
      function noEmptySpace() {
        return space ? space : " ";
      }
      function join(left, right) {
        var leftSource, rightSource, leftCharCode, rightCharCode;
        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
          return [right];
        }
        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
          return [left];
        }
        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);
        if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
          return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
          return [left, right];
        }
        return [left, space, right];
      }
      function addIndent(stmt) {
        return [base2, stmt];
      }
      function withIndent(fn2) {
        var previousBase;
        previousBase = base2;
        base2 += indent;
        fn2(base2);
        base2 = previousBase;
      }
      function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
          if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
            break;
          }
        }
        return str.length - 1 - i;
      }
      function adjustMultilineComment(value, specialBase) {
        var array2, i, len, line, j2, spaces, previousBase, sn;
        array2 = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;
        for (i = 1, len = array2.length; i < len; ++i) {
          line = array2[i];
          j2 = 0;
          while (j2 < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j2))) {
            ++j2;
          }
          if (spaces > j2) {
            spaces = j2;
          }
        }
        if (typeof specialBase !== "undefined") {
          previousBase = base2;
          if (array2[1][spaces] === "*") {
            specialBase += " ";
          }
          base2 = specialBase;
        } else {
          if (spaces & 1) {
            --spaces;
          }
          previousBase = base2;
        }
        for (i = 1, len = array2.length; i < len; ++i) {
          sn = toSourceNodeWhenNeeded(addIndent(array2[i].slice(spaces)));
          array2[i] = sourceMap2 ? sn.join("") : sn;
        }
        base2 = previousBase;
        return array2.join("\n");
      }
      function generateComment(comment, specialBase) {
        if (comment.type === "Line") {
          if (endsWithLineTerminator(comment.value)) {
            return "//" + comment.value;
          } else {
            var result = "//" + comment.value;
            if (!preserveBlankLines) {
              result += "\n";
            }
            return result;
          }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
          return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
        }
        return "/*" + comment.value + "*/";
      }
      function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range2, prevRange, prefix, infix, suffix, count;
        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
          save = result;
          if (preserveBlankLines) {
            comment = stmt.leadingComments[0];
            result = [];
            extRange = comment.extendedRange;
            range2 = comment.range;
            prefix = sourceCode.substring(extRange[0], range2[0]);
            count = (prefix.match(/\n/g) || []).length;
            if (count > 0) {
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
            } else {
              result.push(prefix);
              result.push(generateComment(comment));
            }
            prevRange = range2;
            for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
              comment = stmt.leadingComments[i];
              range2 = comment.range;
              infix = sourceCode.substring(prevRange[1], range2[0]);
              count = (infix.match(/\n/g) || []).length;
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
              prevRange = range2;
            }
            suffix = sourceCode.substring(range2[1], extRange[1]);
            count = (suffix.match(/\n/g) || []).length;
            result.push(stringRepeat("\n", count));
          } else {
            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
              result.push("\n");
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push("\n");
            }
            for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
              comment = stmt.leadingComments[i];
              fragment = [generateComment(comment)];
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                fragment.push("\n");
              }
              result.push(addIndent(fragment));
            }
          }
          result.push(addIndent(save));
        }
        if (stmt.trailingComments) {
          if (preserveBlankLines) {
            comment = stmt.trailingComments[0];
            extRange = comment.extendedRange;
            range2 = comment.range;
            prefix = sourceCode.substring(extRange[0], range2[0]);
            count = (prefix.match(/\n/g) || []).length;
            if (count > 0) {
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
            } else {
              result.push(prefix);
              result.push(generateComment(comment));
            }
          } else {
            tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
            specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base2, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
              comment = stmt.trailingComments[i];
              if (tailingToStatement) {
                if (i === 0) {
                  result = [result, indent];
                } else {
                  result = [result, specialBase];
                }
                result.push(generateComment(comment, specialBase));
              } else {
                result = [result, addIndent(generateComment(comment))];
              }
              if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result = [result, "\n"];
              }
            }
          }
        }
        return result;
      }
      function generateBlankLines(start2, end, result) {
        var j2, newlineCount = 0;
        for (j2 = start2; j2 < end; j2++) {
          if (sourceCode[j2] === "\n") {
            newlineCount++;
          }
        }
        for (j2 = 1; j2 < newlineCount; j2++) {
          result.push(newline);
        }
      }
      function parenthesize(text2, current2, should) {
        if (current2 < should) {
          return ["(", text2, ")"];
        }
        return text2;
      }
      function generateVerbatimString(string2) {
        var i, iz, result;
        result = string2.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
          result[i] = newline + base2 + result[i];
        }
        return result;
      }
      function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];
        if (typeof verbatim === "string") {
          result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
          result = generateVerbatimString(verbatim.content);
          prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
          result = parenthesize(result, prec, precedence);
        }
        return toSourceNodeWhenNeeded(result, expr);
      }
      function CodeGenerator() {
      }
      CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;
        noLeadingComment = !extra.comment || !stmt.leadingComments;
        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
          return [space, this.generateStatement(stmt, flags)];
        }
        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
          return ";";
        }
        withIndent(function() {
          result = [
            newline,
            addIndent(that.generateStatement(stmt, flags))
          ];
        });
        return result;
      };
      CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
          return [result, space];
        }
        if (ends) {
          return [result, base2];
        }
        return [result, newline, base2];
      };
      function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
      }
      function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
      }
      function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? "*" + space : "";
      }
      function generateMethodPrefix(prop) {
        var func = prop.value, prefix = "";
        if (func.async) {
          prefix += generateAsyncPrefix(func, !prop.computed);
        }
        if (func.generator) {
          prefix += generateStarSuffix(func) ? "*" : "";
        }
        return prefix;
      }
      CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
          return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
      };
      CodeGenerator.prototype.generateFunctionParams = function(node) {
        var i, iz, result, hasDefault;
        hasDefault = false;
        if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
          result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
          result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
          result.push("(");
          if (node.defaults) {
            hasDefault = true;
          }
          for (i = 0, iz = node.params.length; i < iz; ++i) {
            if (hasDefault && node.defaults[i]) {
              result.push(this.generateAssignment(node.params[i], node.defaults[i], "=", Precedence.Assignment, E_TTT));
            } else {
              result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
            }
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          if (node.rest) {
            if (node.params.length) {
              result.push("," + space);
            }
            result.push("...");
            result.push(generateIdentifier(node.rest));
          }
          result.push(")");
        }
        return result;
      };
      CodeGenerator.prototype.generateFunctionBody = function(node) {
        var result, expr;
        result = this.generateFunctionParams(node);
        if (node.type === Syntax.ArrowFunctionExpression) {
          result.push(space);
          result.push("=>");
        }
        if (node.expression) {
          result.push(space);
          expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
          if (expr.toString().charAt(0) === "{") {
            expr = ["(", expr, ")"];
          }
          result.push(expr);
        } else {
          result.push(this.maybeBlock(node.body, S_TTFF));
        }
        return result;
      };
      CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
        var result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("], that = this;
        withIndent(function() {
          if (stmt.left.type === Syntax.VariableDeclaration) {
            withIndent(function() {
              result.push(stmt.left.kind + noEmptySpace());
              result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
            });
          } else {
            result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
          }
          result = join(result, operator);
          result = [join(
            result,
            that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
          ), ")"];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
      };
      CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
        var result = [];
        if (computed) {
          result.push("[");
        }
        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
        if (computed) {
          result.push("]");
        }
        return result;
      };
      CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
          flags |= F_ALLOW_IN;
        }
        return parenthesize(
          [
            this.generateExpression(left, Precedence.Call, flags),
            space + operator + space,
            this.generateExpression(right, Precedence.Assignment, flags)
          ],
          Precedence.Assignment,
          precedence
        );
      };
      CodeGenerator.prototype.semicolon = function(flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
          return "";
        }
        return ";";
      };
      CodeGenerator.Statement = {
        BlockStatement: function(stmt, flags) {
          var range2, content, result = ["{", newline], that = this;
          withIndent(function() {
            if (stmt.body.length === 0 && preserveBlankLines) {
              range2 = stmt.range;
              if (range2[1] - range2[0] > 2) {
                content = sourceCode.substring(range2[0] + 1, range2[1] - 1);
                if (content[0] === "\n") {
                  result = ["{"];
                }
                result.push(content);
              }
            }
            var i, iz, fragment, bodyFlags;
            bodyFlags = S_TFFF;
            if (flags & F_FUNC_BODY) {
              bodyFlags |= F_DIRECTIVE_CTX;
            }
            for (i = 0, iz = stmt.body.length; i < iz; ++i) {
              if (preserveBlankLines) {
                if (i === 0) {
                  if (stmt.body[0].leadingComments) {
                    range2 = stmt.body[0].leadingComments[0].extendedRange;
                    content = sourceCode.substring(range2[0], range2[1]);
                    if (content[0] === "\n") {
                      result = ["{"];
                    }
                  }
                  if (!stmt.body[0].leadingComments) {
                    generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                  }
                }
                if (i > 0) {
                  if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                    generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                  }
                }
              }
              if (i === iz - 1) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              if (stmt.body[i].leadingComments && preserveBlankLines) {
                fragment = that.generateStatement(stmt.body[i], bodyFlags);
              } else {
                fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
              }
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                if (preserveBlankLines && i < iz - 1) {
                  if (!stmt.body[i + 1].leadingComments) {
                    result.push(newline);
                  }
                } else {
                  result.push(newline);
                }
              }
              if (preserveBlankLines) {
                if (i === iz - 1) {
                  if (!stmt.body[i].trailingComments) {
                    generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                  }
                }
              }
            }
          });
          result.push(addIndent("}"));
          return result;
        },
        BreakStatement: function(stmt, flags) {
          if (stmt.label) {
            return "break " + stmt.label.name + this.semicolon(flags);
          }
          return "break" + this.semicolon(flags);
        },
        ContinueStatement: function(stmt, flags) {
          if (stmt.label) {
            return "continue " + stmt.label.name + this.semicolon(flags);
          }
          return "continue" + this.semicolon(flags);
        },
        ClassBody: function(stmt, flags) {
          var result = ["{", newline], that = this;
          withIndent(function(indent2) {
            var i, iz;
            for (i = 0, iz = stmt.body.length; i < iz; ++i) {
              result.push(indent2);
              result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
              if (i + 1 < iz) {
                result.push(newline);
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base2);
          result.push("}");
          return result;
        },
        ClassDeclaration: function(stmt, flags) {
          var result, fragment;
          result = ["class"];
          if (stmt.id) {
            result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
          }
          if (stmt.superClass) {
            fragment = join("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
            result = join(result, fragment);
          }
          result.push(space);
          result.push(this.generateStatement(stmt.body, S_TFFT));
          return result;
        },
        DirectiveStatement: function(stmt, flags) {
          if (extra.raw && stmt.raw) {
            return stmt.raw + this.semicolon(flags);
          }
          return escapeDirective(stmt.directive) + this.semicolon(flags);
        },
        DoWhileStatement: function(stmt, flags) {
          var result = join("do", this.maybeBlock(stmt.body, S_TFFF));
          result = this.maybeBlockSuffix(stmt.body, result);
          return join(result, [
            "while" + space + "(",
            this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")" + this.semicolon(flags)
          ]);
        },
        CatchClause: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            var guard;
            if (stmt.param) {
              result = [
                "catch" + space + "(",
                that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                ")"
              ];
              if (stmt.guard) {
                guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                result.splice(2, 0, " if ", guard);
              }
            } else {
              result = ["catch"];
            }
          });
          result.push(this.maybeBlock(stmt.body, S_TFFF));
          return result;
        },
        DebuggerStatement: function(stmt, flags) {
          return "debugger" + this.semicolon(flags);
        },
        EmptyStatement: function(stmt, flags) {
          return ";";
        },
        ExportDefaultDeclaration: function(stmt, flags) {
          var result = ["export"], bodyFlags;
          bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
          result = join(result, "default");
          if (isStatement(stmt.declaration)) {
            result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
          } else {
            result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
          }
          return result;
        },
        ExportNamedDeclaration: function(stmt, flags) {
          var result = ["export"], bodyFlags, that = this;
          bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
          if (stmt.declaration) {
            return join(result, this.generateStatement(stmt.declaration, bodyFlags));
          }
          if (stmt.specifiers) {
            if (stmt.specifiers.length === 0) {
              result = join(result, "{" + space + "}");
            } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
              result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
            } else {
              result = join(result, "{");
              withIndent(function(indent2) {
                var i, iz;
                result.push(newline);
                for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                  result.push(indent2);
                  result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                  if (i + 1 < iz) {
                    result.push("," + newline);
                  }
                }
              });
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
              }
              result.push(base2 + "}");
            }
            if (stmt.source) {
              result = join(result, [
                "from" + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
              ]);
            } else {
              result.push(this.semicolon(flags));
            }
          }
          return result;
        },
        ExportAllDeclaration: function(stmt, flags) {
          return [
            "export" + space,
            "*" + space,
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ];
        },
        ExpressionStatement: function(stmt, flags) {
          var result, fragment;
          function isClassPrefixed(fragment2) {
            var code2;
            if (fragment2.slice(0, 5) !== "class") {
              return false;
            }
            code2 = fragment2.charCodeAt(5);
            return code2 === 123 || esutils.code.isWhiteSpace(code2) || esutils.code.isLineTerminator(code2);
          }
          function isFunctionPrefixed(fragment2) {
            var code2;
            if (fragment2.slice(0, 8) !== "function") {
              return false;
            }
            code2 = fragment2.charCodeAt(8);
            return code2 === 40 || esutils.code.isWhiteSpace(code2) || code2 === 42 || esutils.code.isLineTerminator(code2);
          }
          function isAsyncPrefixed(fragment2) {
            var code2, i, iz;
            if (fragment2.slice(0, 5) !== "async") {
              return false;
            }
            if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(5))) {
              return false;
            }
            for (i = 6, iz = fragment2.length; i < iz; ++i) {
              if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(i))) {
                break;
              }
            }
            if (i === iz) {
              return false;
            }
            if (fragment2.slice(i, i + 8) !== "function") {
              return false;
            }
            code2 = fragment2.charCodeAt(i + 8);
            return code2 === 40 || esutils.code.isWhiteSpace(code2) || code2 === 42 || esutils.code.isLineTerminator(code2);
          }
          result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
          fragment = toSourceNodeWhenNeeded(result).toString();
          if (fragment.charCodeAt(0) === 123 || // ObjectExpression
          isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string") {
            result = ["(", result, ")" + this.semicolon(flags)];
          } else {
            result.push(this.semicolon(flags));
          }
          return result;
        },
        ImportDeclaration: function(stmt, flags) {
          var result, cursor, that = this;
          if (stmt.specifiers.length === 0) {
            return [
              "import",
              space,
              // ModuleSpecifier
              this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
              this.semicolon(flags)
            ];
          }
          result = [
            "import"
          ];
          cursor = 0;
          if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
            result = join(result, [
              this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
            ]);
            ++cursor;
          }
          if (stmt.specifiers[cursor]) {
            if (cursor !== 0) {
              result.push(",");
            }
            if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
              result = join(result, [
                space,
                this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
              ]);
            } else {
              result.push(space + "{");
              if (stmt.specifiers.length - cursor === 1) {
                result.push(space);
                result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                result.push(space + "}" + space);
              } else {
                withIndent(function(indent2) {
                  var i, iz;
                  result.push(newline);
                  for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                    result.push(indent2);
                    result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                      result.push("," + newline);
                    }
                  }
                });
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result.push(newline);
                }
                result.push(base2 + "}" + space);
              }
            }
          }
          result = join(result, [
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ]);
          return result;
        },
        VariableDeclarator: function(stmt, flags) {
          var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
          if (stmt.init) {
            return [
              this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
              space,
              "=",
              space,
              this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
            ];
          }
          return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },
        VariableDeclaration: function(stmt, flags) {
          var result, i, iz, node, bodyFlags, that = this;
          result = [stmt.kind];
          bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
          function block() {
            node = stmt.declarations[0];
            if (extra.comment && node.leadingComments) {
              result.push("\n");
              result.push(addIndent(that.generateStatement(node, bodyFlags)));
            } else {
              result.push(noEmptySpace());
              result.push(that.generateStatement(node, bodyFlags));
            }
            for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
              node = stmt.declarations[i];
              if (extra.comment && node.leadingComments) {
                result.push("," + newline);
                result.push(addIndent(that.generateStatement(node, bodyFlags)));
              } else {
                result.push("," + space);
                result.push(that.generateStatement(node, bodyFlags));
              }
            }
          }
          if (stmt.declarations.length > 1) {
            withIndent(block);
          } else {
            block();
          }
          result.push(this.semicolon(flags));
          return result;
        },
        ThrowStatement: function(stmt, flags) {
          return [join(
            "throw",
            this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
          ), this.semicolon(flags)];
        },
        TryStatement: function(stmt, flags) {
          var result, i, iz, guardedHandlers;
          result = ["try", this.maybeBlock(stmt.block, S_TFFF)];
          result = this.maybeBlockSuffix(stmt.block, result);
          if (stmt.handlers) {
            for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
              result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
              }
            }
          } else {
            guardedHandlers = stmt.guardedHandlers || [];
            for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
              result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
              }
            }
            if (stmt.handler) {
              if (Array.isArray(stmt.handler)) {
                for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                  result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                  if (stmt.finalizer || i + 1 !== iz) {
                    result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                  }
                }
              } else {
                result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                if (stmt.finalizer) {
                  result = this.maybeBlockSuffix(stmt.handler.body, result);
                }
              }
            }
          }
          if (stmt.finalizer) {
            result = join(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
          }
          return result;
        },
        SwitchStatement: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags, that = this;
          withIndent(function() {
            result = [
              "switch" + space + "(",
              that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
              ")" + space + "{" + newline
            ];
          });
          if (stmt.cases) {
            bodyFlags = S_TFFF;
            for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
              if (i === iz - 1) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          }
          result.push(addIndent("}"));
          return result;
        },
        SwitchCase: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags, that = this;
          withIndent(function() {
            if (stmt.test) {
              result = [
                join("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                ":"
              ];
            } else {
              result = ["default:"];
            }
            i = 0;
            iz = stmt.consequent.length;
            if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
              fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
              result.push(fragment);
              i = 1;
            }
            if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            bodyFlags = S_TFFF;
            for (; i < iz; ++i) {
              if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
              result.push(fragment);
              if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          });
          return result;
        },
        IfStatement: function(stmt, flags) {
          var result, bodyFlags, semicolonOptional, that = this;
          withIndent(function() {
            result = [
              "if" + space + "(",
              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          semicolonOptional = flags & F_SEMICOLON_OPT;
          bodyFlags = S_TFFF;
          if (semicolonOptional) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          if (stmt.alternate) {
            result.push(this.maybeBlock(stmt.consequent, S_TFFF));
            result = this.maybeBlockSuffix(stmt.consequent, result);
            if (stmt.alternate.type === Syntax.IfStatement) {
              result = join(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
            } else {
              result = join(result, join("else", this.maybeBlock(stmt.alternate, bodyFlags)));
            }
          } else {
            result.push(this.maybeBlock(stmt.consequent, bodyFlags));
          }
          return result;
        },
        ForStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = ["for" + space + "("];
            if (stmt.init) {
              if (stmt.init.type === Syntax.VariableDeclaration) {
                result.push(that.generateStatement(stmt.init, S_FFFF));
              } else {
                result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                result.push(";");
              }
            } else {
              result.push(";");
            }
            if (stmt.test) {
              result.push(space);
              result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
              result.push(";");
            } else {
              result.push(";");
            }
            if (stmt.update) {
              result.push(space);
              result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
              result.push(")");
            } else {
              result.push(")");
            }
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        },
        ForInStatement: function(stmt, flags) {
          return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        ForOfStatement: function(stmt, flags) {
          return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        LabeledStatement: function(stmt, flags) {
          return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },
        Program: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags;
          iz = stmt.body.length;
          result = [safeConcatenation && iz > 0 ? "\n" : ""];
          bodyFlags = S_TFTF;
          for (i = 0; i < iz; ++i) {
            if (!safeConcatenation && i === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            if (preserveBlankLines) {
              if (i === 0) {
                if (!stmt.body[0].leadingComments) {
                  generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                }
              }
              if (i > 0) {
                if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                  generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                }
              }
            }
            fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
            result.push(fragment);
            if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              if (preserveBlankLines) {
                if (!stmt.body[i + 1].leadingComments) {
                  result.push(newline);
                }
              } else {
                result.push(newline);
              }
            }
            if (preserveBlankLines) {
              if (i === iz - 1) {
                if (!stmt.body[i].trailingComments) {
                  generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                }
              }
            }
          }
          return result;
        },
        FunctionDeclaration: function(stmt, flags) {
          return [
            generateAsyncPrefix(stmt, true),
            "function",
            generateStarSuffix(stmt) || noEmptySpace(),
            stmt.id ? generateIdentifier(stmt.id) : "",
            this.generateFunctionBody(stmt)
          ];
        },
        ReturnStatement: function(stmt, flags) {
          if (stmt.argument) {
            return [join(
              "return",
              this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
          }
          return ["return" + this.semicolon(flags)];
        },
        WhileStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = [
              "while" + space + "(",
              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        },
        WithStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = [
              "with" + space + "(",
              that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        }
      };
      merge2(CodeGenerator.prototype, CodeGenerator.Statement);
      CodeGenerator.Expression = {
        SequenceExpression: function(expr, precedence, flags) {
          var result, i, iz;
          if (Precedence.Sequence < precedence) {
            flags |= F_ALLOW_IN;
          }
          result = [];
          for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
            result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          return parenthesize(result, Precedence.Sequence, precedence);
        },
        AssignmentExpression: function(expr, precedence, flags) {
          return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },
        ArrowFunctionExpression: function(expr, precedence, flags) {
          return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },
        ConditionalExpression: function(expr, precedence, flags) {
          if (Precedence.Conditional < precedence) {
            flags |= F_ALLOW_IN;
          }
          return parenthesize(
            [
              this.generateExpression(expr.test, Precedence.Coalesce, flags),
              space + "?" + space,
              this.generateExpression(expr.consequent, Precedence.Assignment, flags),
              space + ":" + space,
              this.generateExpression(expr.alternate, Precedence.Assignment, flags)
            ],
            Precedence.Conditional,
            precedence
          );
        },
        LogicalExpression: function(expr, precedence, flags) {
          if (expr.operator === "??") {
            flags |= F_FOUND_COALESCE;
          }
          return this.BinaryExpression(expr, precedence, flags);
        },
        BinaryExpression: function(expr, precedence, flags) {
          var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
          currentPrecedence = BinaryPrecedence[expr.operator];
          leftPrecedence = expr.operator === "**" ? Precedence.Postfix : currentPrecedence;
          rightPrecedence = expr.operator === "**" ? currentPrecedence : currentPrecedence + 1;
          if (currentPrecedence < precedence) {
            flags |= F_ALLOW_IN;
          }
          fragment = this.generateExpression(expr.left, leftPrecedence, flags);
          leftSource = fragment.toString();
          if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
            result = [fragment, noEmptySpace(), expr.operator];
          } else {
            result = join(fragment, expr.operator);
          }
          fragment = this.generateExpression(expr.right, rightPrecedence, flags);
          if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
            result.push(noEmptySpace());
            result.push(fragment);
          } else {
            result = join(result, fragment);
          }
          if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
            return ["(", result, ")"];
          }
          if ((expr.operator === "||" || expr.operator === "&&") && flags & F_FOUND_COALESCE) {
            return ["(", result, ")"];
          }
          return parenthesize(result, currentPrecedence, precedence);
        },
        CallExpression: function(expr, precedence, flags) {
          var result, i, iz;
          result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
          if (expr.optional) {
            result.push("?.");
          }
          result.push("(");
          for (i = 0, iz = expr["arguments"].length; i < iz; ++i) {
            result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          result.push(")");
          if (!(flags & F_ALLOW_CALL)) {
            return ["(", result, ")"];
          }
          return parenthesize(result, Precedence.Call, precedence);
        },
        ChainExpression: function(expr, precedence, flags) {
          if (Precedence.OptionalChaining < precedence) {
            flags |= F_ALLOW_CALL;
          }
          var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
          return parenthesize(result, Precedence.OptionalChaining, precedence);
        },
        NewExpression: function(expr, precedence, flags) {
          var result, length, i, iz, itemFlags;
          length = expr["arguments"].length;
          itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
          result = join(
            "new",
            this.generateExpression(expr.callee, Precedence.New, itemFlags)
          );
          if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
            result.push("(");
            for (i = 0, iz = length; i < iz; ++i) {
              result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
              if (i + 1 < iz) {
                result.push("," + space);
              }
            }
            result.push(")");
          }
          return parenthesize(result, Precedence.New, precedence);
        },
        MemberExpression: function(expr, precedence, flags) {
          var result, fragment;
          result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];
          if (expr.computed) {
            if (expr.optional) {
              result.push("?.");
            }
            result.push("[");
            result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
            result.push("]");
          } else {
            if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
              fragment = toSourceNodeWhenNeeded(result).toString();
              if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
                result.push(" ");
              }
            }
            result.push(expr.optional ? "?." : ".");
            result.push(generateIdentifier(expr.property));
          }
          return parenthesize(result, Precedence.Member, precedence);
        },
        MetaProperty: function(expr, precedence, flags) {
          var result;
          result = [];
          result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
          result.push(".");
          result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
          return parenthesize(result, Precedence.Member, precedence);
        },
        UnaryExpression: function(expr, precedence, flags) {
          var result, fragment, rightCharCode, leftSource, leftCharCode;
          fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
          if (space === "") {
            result = join(expr.operator, fragment);
          } else {
            result = [expr.operator];
            if (expr.operator.length > 2) {
              result = join(result, fragment);
            } else {
              leftSource = toSourceNodeWhenNeeded(result).toString();
              leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
              rightCharCode = fragment.toString().charCodeAt(0);
              if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {
                result.push(noEmptySpace());
                result.push(fragment);
              } else {
                result.push(fragment);
              }
            }
          }
          return parenthesize(result, Precedence.Unary, precedence);
        },
        YieldExpression: function(expr, precedence, flags) {
          var result;
          if (expr.delegate) {
            result = "yield*";
          } else {
            result = "yield";
          }
          if (expr.argument) {
            result = join(
              result,
              this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
            );
          }
          return parenthesize(result, Precedence.Yield, precedence);
        },
        AwaitExpression: function(expr, precedence, flags) {
          var result = join(
            expr.all ? "await*" : "await",
            this.generateExpression(expr.argument, Precedence.Await, E_TTT)
          );
          return parenthesize(result, Precedence.Await, precedence);
        },
        UpdateExpression: function(expr, precedence, flags) {
          if (expr.prefix) {
            return parenthesize(
              [
                expr.operator,
                this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
              ],
              Precedence.Unary,
              precedence
            );
          }
          return parenthesize(
            [
              this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
              expr.operator
            ],
            Precedence.Postfix,
            precedence
          );
        },
        FunctionExpression: function(expr, precedence, flags) {
          var result = [
            generateAsyncPrefix(expr, true),
            "function"
          ];
          if (expr.id) {
            result.push(generateStarSuffix(expr) || noEmptySpace());
            result.push(generateIdentifier(expr.id));
          } else {
            result.push(generateStarSuffix(expr) || space);
          }
          result.push(this.generateFunctionBody(expr));
          return result;
        },
        ArrayPattern: function(expr, precedence, flags) {
          return this.ArrayExpression(expr, precedence, flags, true);
        },
        ArrayExpression: function(expr, precedence, flags, isPattern) {
          var result, multiline, that = this;
          if (!expr.elements.length) {
            return "[]";
          }
          multiline = isPattern ? false : expr.elements.length > 1;
          result = ["[", multiline ? newline : ""];
          withIndent(function(indent2) {
            var i, iz;
            for (i = 0, iz = expr.elements.length; i < iz; ++i) {
              if (!expr.elements[i]) {
                if (multiline) {
                  result.push(indent2);
                }
                if (i + 1 === iz) {
                  result.push(",");
                }
              } else {
                result.push(multiline ? indent2 : "");
                result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
              }
              if (i + 1 < iz) {
                result.push("," + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base2 : "");
          result.push("]");
          return result;
        },
        RestElement: function(expr, precedence, flags) {
          return "..." + this.generatePattern(expr.argument);
        },
        ClassExpression: function(expr, precedence, flags) {
          var result, fragment;
          result = ["class"];
          if (expr.id) {
            result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
          }
          if (expr.superClass) {
            fragment = join("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
            result = join(result, fragment);
          }
          result.push(space);
          result.push(this.generateStatement(expr.body, S_TFFT));
          return result;
        },
        MethodDefinition: function(expr, precedence, flags) {
          var result, fragment;
          if (expr["static"]) {
            result = ["static" + space];
          } else {
            result = [];
          }
          if (expr.kind === "get" || expr.kind === "set") {
            fragment = [
              join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
              this.generateFunctionBody(expr.value)
            ];
          } else {
            fragment = [
              generateMethodPrefix(expr),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          return join(result, fragment);
        },
        Property: function(expr, precedence, flags) {
          if (expr.kind === "get" || expr.kind === "set") {
            return [
              expr.kind,
              noEmptySpace(),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          if (expr.shorthand) {
            if (expr.value.type === "AssignmentPattern") {
              return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
            }
            return this.generatePropertyKey(expr.key, expr.computed);
          }
          if (expr.method) {
            return [
              generateMethodPrefix(expr),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          return [
            this.generatePropertyKey(expr.key, expr.computed),
            ":" + space,
            this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
          ];
        },
        ObjectExpression: function(expr, precedence, flags) {
          var multiline, result, fragment, that = this;
          if (!expr.properties.length) {
            return "{}";
          }
          multiline = expr.properties.length > 1;
          withIndent(function() {
            fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
          });
          if (!multiline) {
            if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              return ["{", space, fragment, space, "}"];
            }
          }
          withIndent(function(indent2) {
            var i, iz;
            result = ["{", newline, indent2, fragment];
            if (multiline) {
              result.push("," + newline);
              for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                result.push(indent2);
                result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                if (i + 1 < iz) {
                  result.push("," + newline);
                }
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base2);
          result.push("}");
          return result;
        },
        AssignmentPattern: function(expr, precedence, flags) {
          return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
        },
        ObjectPattern: function(expr, precedence, flags) {
          var result, i, iz, multiline, property, that = this;
          if (!expr.properties.length) {
            return "{}";
          }
          multiline = false;
          if (expr.properties.length === 1) {
            property = expr.properties[0];
            if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {
              multiline = true;
            }
          } else {
            for (i = 0, iz = expr.properties.length; i < iz; ++i) {
              property = expr.properties[i];
              if (property.type === Syntax.Property && !property.shorthand) {
                multiline = true;
                break;
              }
            }
          }
          result = ["{", multiline ? newline : ""];
          withIndent(function(indent2) {
            var i2, iz2;
            for (i2 = 0, iz2 = expr.properties.length; i2 < iz2; ++i2) {
              result.push(multiline ? indent2 : "");
              result.push(that.generateExpression(expr.properties[i2], Precedence.Sequence, E_TTT));
              if (i2 + 1 < iz2) {
                result.push("," + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base2 : "");
          result.push("}");
          return result;
        },
        ThisExpression: function(expr, precedence, flags) {
          return "this";
        },
        Super: function(expr, precedence, flags) {
          return "super";
        },
        Identifier: function(expr, precedence, flags) {
          return generateIdentifier(expr);
        },
        ImportDefaultSpecifier: function(expr, precedence, flags) {
          return generateIdentifier(expr.id || expr.local);
        },
        ImportNamespaceSpecifier: function(expr, precedence, flags) {
          var result = ["*"];
          var id = expr.id || expr.local;
          if (id) {
            result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
          }
          return result;
        },
        ImportSpecifier: function(expr, precedence, flags) {
          var imported = expr.imported;
          var result = [imported.name];
          var local = expr.local;
          if (local && local.name !== imported.name) {
            result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
          }
          return result;
        },
        ExportSpecifier: function(expr, precedence, flags) {
          var local = expr.local;
          var result = [local.name];
          var exported = expr.exported;
          if (exported && exported.name !== local.name) {
            result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
          }
          return result;
        },
        Literal: function(expr, precedence, flags) {
          var raw;
          if (expr.hasOwnProperty("raw") && parse4 && extra.raw) {
            try {
              raw = parse4(expr.raw).body[0].expression;
              if (raw.type === Syntax.Literal) {
                if (raw.value === expr.value) {
                  return expr.raw;
                }
              }
            } catch (e2) {
            }
          }
          if (expr.regex) {
            return "/" + expr.regex.pattern + "/" + expr.regex.flags;
          }
          if (typeof expr.value === "bigint") {
            return expr.value.toString() + "n";
          }
          if (expr.bigint) {
            return expr.bigint + "n";
          }
          if (expr.value === null) {
            return "null";
          }
          if (typeof expr.value === "string") {
            return escapeString(expr.value);
          }
          if (typeof expr.value === "number") {
            return generateNumber(expr.value);
          }
          if (typeof expr.value === "boolean") {
            return expr.value ? "true" : "false";
          }
          return generateRegExp(expr.value);
        },
        GeneratorExpression: function(expr, precedence, flags) {
          return this.ComprehensionExpression(expr, precedence, flags);
        },
        ComprehensionExpression: function(expr, precedence, flags) {
          var result, i, iz, fragment, that = this;
          result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["];
          if (extra.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
            result.push(fragment);
          }
          if (expr.blocks) {
            withIndent(function() {
              for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                  result = join(result, fragment);
                } else {
                  result.push(fragment);
                }
              }
            });
          }
          if (expr.filter) {
            result = join(result, "if" + space);
            fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
            result = join(result, ["(", fragment, ")"]);
          }
          if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
            result = join(result, fragment);
          }
          result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]");
          return result;
        },
        ComprehensionBlock: function(expr, precedence, flags) {
          var fragment;
          if (expr.left.type === Syntax.VariableDeclaration) {
            fragment = [
              expr.left.kind,
              noEmptySpace(),
              this.generateStatement(expr.left.declarations[0], S_FFFF)
            ];
          } else {
            fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
          }
          fragment = join(fragment, expr.of ? "of" : "in");
          fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
          return ["for" + space + "(", fragment, ")"];
        },
        SpreadElement: function(expr, precedence, flags) {
          return [
            "...",
            this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
          ];
        },
        TaggedTemplateExpression: function(expr, precedence, flags) {
          var itemFlags = E_TTF;
          if (!(flags & F_ALLOW_CALL)) {
            itemFlags = E_TFF;
          }
          var result = [
            this.generateExpression(expr.tag, Precedence.Call, itemFlags),
            this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
          ];
          return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },
        TemplateElement: function(expr, precedence, flags) {
          return expr.value.raw;
        },
        TemplateLiteral: function(expr, precedence, flags) {
          var result, i, iz;
          result = ["`"];
          for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
            result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
            if (i + 1 < iz) {
              result.push("${" + space);
              result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
              result.push(space + "}");
            }
          }
          result.push("`");
          return result;
        },
        ModuleSpecifier: function(expr, precedence, flags) {
          return this.Literal(expr, precedence, flags);
        },
        ImportExpression: function(expr, precedence, flag) {
          return parenthesize([
            "import(",
            this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
            ")"
          ], Precedence.Call, precedence);
        }
      };
      merge2(CodeGenerator.prototype, CodeGenerator.Expression);
      CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
        var result, type2;
        type2 = expr.type || Syntax.Property;
        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
          return generateVerbatim(expr, precedence);
        }
        result = this[type2](expr, precedence, flags);
        if (extra.comment) {
          result = addComments(expr, result);
        }
        return toSourceNodeWhenNeeded(result, expr);
      };
      CodeGenerator.prototype.generateStatement = function(stmt, flags) {
        var result, fragment;
        result = this[stmt.type](stmt, flags);
        if (extra.comment) {
          result = addComments(stmt, result);
        }
        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") {
          result = sourceMap2 ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
        }
        return toSourceNodeWhenNeeded(result, stmt);
      };
      function generateInternal(node) {
        var codegen;
        codegen = new CodeGenerator();
        if (isStatement(node)) {
          return codegen.generateStatement(node, S_TFFF);
        }
        if (isExpression(node)) {
          return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }
        throw new Error("Unknown node type: " + node.type);
      }
      function generate(node, options2) {
        var defaultOptions2 = getDefaultOptions(), result, pair;
        if (options2 != null) {
          if (typeof options2.indent === "string") {
            defaultOptions2.format.indent.style = options2.indent;
          }
          if (typeof options2.base === "number") {
            defaultOptions2.format.indent.base = options2.base;
          }
          options2 = updateDeeply(defaultOptions2, options2);
          indent = options2.format.indent.style;
          if (typeof options2.base === "string") {
            base2 = options2.base;
          } else {
            base2 = stringRepeat(indent, options2.format.indent.base);
          }
        } else {
          options2 = defaultOptions2;
          indent = options2.format.indent.style;
          base2 = stringRepeat(indent, options2.format.indent.base);
        }
        json = options2.format.json;
        renumber = options2.format.renumber;
        hexadecimal = json ? false : options2.format.hexadecimal;
        quotes = json ? "double" : options2.format.quotes;
        escapeless = options2.format.escapeless;
        newline = options2.format.newline;
        space = options2.format.space;
        if (options2.format.compact) {
          newline = space = indent = base2 = "";
        }
        parentheses = options2.format.parentheses;
        semicolons = options2.format.semicolons;
        safeConcatenation = options2.format.safeConcatenation;
        directive = options2.directive;
        parse4 = json ? null : options2.parse;
        sourceMap2 = options2.sourceMap;
        sourceCode = options2.sourceCode;
        preserveBlankLines = options2.format.preserveBlankLines && sourceCode !== null;
        extra = options2;
        if (sourceMap2) {
          if (!exports$1.browser) {
            SourceNode = requireSourceMap().SourceNode;
          } else {
            SourceNode = commonjsGlobal.sourceMap.SourceNode;
          }
        }
        result = generateInternal(node);
        if (!sourceMap2) {
          pair = { code: result.toString(), map: null };
          return options2.sourceMapWithCode ? pair : pair.code;
        }
        pair = result.toStringWithSourceMap({
          file: options2.file,
          sourceRoot: options2.sourceMapRoot
        });
        if (options2.sourceContent) {
          pair.map.setSourceContent(
            options2.sourceMap,
            options2.sourceContent
          );
        }
        if (options2.sourceMapWithCode) {
          return pair;
        }
        return pair.map.toString();
      }
      FORMAT_MINIFY = {
        indent: {
          style: "",
          base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: "auto",
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
      };
      FORMAT_DEFAULTS = getDefaultOptions().format;
      exports$1.version = require$$3.version;
      exports$1.generate = generate;
      exports$1.attachComments = estraverse2.attachComments;
      exports$1.Precedence = updateDeeply({}, Precedence);
      exports$1.browser = false;
      exports$1.FORMAT_MINIFY = FORMAT_MINIFY;
      exports$1.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
    })();
  })(escodegen$1);
  return escodegen$1;
}
var escodegenExports = requireEscodegen();
const escodegen = /* @__PURE__ */ getDefaultExportFromCjs(escodegenExports);
let blockVarCounter = 0;
let loopVarCounter = 0;
function replaceBinaryOperator(codeSource) {
  switch (codeSource) {
    case "+":
      return "add";
    case "-":
      return "sub";
    case "*":
      return "mult";
    case "/":
      return "div";
    case "%":
      return "mod";
    case "==":
    case "===":
      return "equalTo";
    case "!=":
    case "!==":
      return "notEqual";
    case ">":
      return "greaterThan";
    case ">=":
      return "greaterEqual";
    case "<":
      return "lessThan";
    case "<=":
      return "lessEqual";
    case "&&":
      return "and";
    case "||":
      return "or";
  }
}
function nodeIsUniform(ancestor2) {
  return ancestor2.type === "CallExpression" && // Global mode
  (ancestor2.callee?.type === "Identifier" && ancestor2.callee?.name.startsWith("uniform") || // Instance mode
  ancestor2.callee?.type === "MemberExpression" && ancestor2.callee?.property.name.startsWith("uniform"));
}
function nodeIsVarying(node) {
  return node?.type === "CallExpression" && // Global mode
  (node.callee?.type === "Identifier" && (node.callee?.name.startsWith("varying") || node.callee?.name.startsWith("shared")) || // Instance mode
  node.callee?.type === "MemberExpression" && (node.callee?.property.name.startsWith("varying") || node.callee?.property.name.startsWith("shared")));
}
function statementContainsStrandsControlFlow(stmt) {
  if (stmt.type === "VariableDeclaration") {
    const match = stmt.declarations.some(
      (decl) => decl.init?.type === "CallExpression" && (decl.init?.callee?.type === "MemberExpression" && decl.init?.callee?.object?.type === "Identifier" && decl.init?.callee?.object?.name === "__p5" && (decl.init?.callee?.property?.name === "strandsFor" || decl.init?.callee?.property?.name === "strandsIf") || decl.init?.callee?.type === "Identifier" && (decl.init?.callee?.name === "__p5.strandsFor" || decl.init?.callee?.name === "__p5.strandsIf"))
    );
    return match;
  }
  return false;
}
function isSwizzle(propertyName) {
  if (!propertyName || typeof propertyName !== "string") return false;
  const swizzleSets = [
    ["x", "y", "z", "w"],
    ["r", "g", "b", "a"],
    ["s", "t", "p", "q"]
  ];
  return swizzleSets.some(
    (set2) => [...propertyName].every((char) => set2.includes(char))
  );
}
function buildPropertyPath(memberExpr) {
  const parts = [];
  let current2 = memberExpr;
  while (current2.type === "MemberExpression") {
    if (current2.computed) {
      return null;
    }
    const propName = current2.property.name || current2.property.value;
    if (isSwizzle(propName)) {
      current2 = current2.object;
      break;
    }
    parts.unshift(propName);
    current2 = current2.object;
  }
  if (current2.type === "Identifier") {
    parts.unshift(current2.name);
  } else {
    return null;
  }
  return parts.join(".");
}
function replaceReferences(node, tempVarMap) {
  const internalReplaceReferences = (node2) => {
    if (!node2 || typeof node2 !== "object") return;
    if (node2.type === "MemberExpression") {
      const propName = node2.property.name || node2.property.value;
      if (isSwizzle(propName)) {
        internalReplaceReferences(node2.object);
        return;
      }
      const propertyPath = buildPropertyPath(node2);
      if (propertyPath && tempVarMap.has(propertyPath)) {
        Object.assign(node2, {
          type: "Identifier",
          name: tempVarMap.get(propertyPath)
        });
        return;
      }
    }
    if (node2.type === "Identifier" && tempVarMap.has(node2.name)) {
      node2.name = tempVarMap.get(node2.name);
    }
    if (node2.type === "AssignmentExpression") {
      let leftPath = null;
      if (node2.left.type === "Identifier") {
        leftPath = node2.left.name;
      } else if (node2.left.type === "MemberExpression") {
        leftPath = buildPropertyPath(node2.left);
      }
      if (leftPath && tempVarMap.has(leftPath) && (node2.right.type === "Literal" || node2.right.type === "ArrayExpression")) {
        node2.right = {
          type: "CallExpression",
          callee: {
            type: "Identifier",
            name: "__p5.strandsNode"
          },
          arguments: [node2.right]
        };
      }
    }
    for (const key in node2) {
      if (node2.hasOwnProperty(key) && key !== "parent") {
        if (node2.type === "MemberExpression" && key === "property" && !node2.computed) {
          continue;
        }
        if (Array.isArray(node2[key])) {
          node2[key].forEach(internalReplaceReferences);
        } else if (typeof node2[key] === "object") {
          internalReplaceReferences(node2[key]);
        }
      }
    }
  };
  internalReplaceReferences(node);
}
const ASTCallbacks = {
  UnaryExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const unaryFnName = UnarySymbolToName[node.operator];
    const standardReplacement = (node2) => {
      node2.type = "CallExpression";
      node2.callee = {
        type: "Identifier",
        name: `__p5.${unaryFnName}`
      };
      node2.arguments = [node2.argument];
    };
    if (node.type === "MemberExpression") {
      const property = node.argument.property.name;
      const swizzleSets = [
        ["x", "y", "z", "w"],
        ["r", "g", "b", "a"],
        ["s", "t", "p", "q"]
      ];
      let isSwizzle2 = swizzleSets.some(
        (set2) => [...property].every((char) => set2.includes(char))
      ) && node.argument.type === "MemberExpression";
      if (isSwizzle2) {
        node.type = "MemberExpression";
        node.object = {
          type: "CallExpression",
          callee: {
            type: "Identifier",
            name: `__p5.${unaryFnName}`
          },
          arguments: [node.argument.object]
        };
        node.property = {
          type: "Identifier",
          name: property
        };
      } else {
        standardReplacement(node);
      }
    } else {
      standardReplacement(node);
    }
    delete node.argument;
    delete node.operator;
  },
  BreakStatement(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    node.callee = {
      type: "Identifier",
      name: "__p5.break"
    };
    node.arguments = [];
    node.type = "CallExpression";
  },
  VariableDeclarator(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    if (nodeIsUniform(node.init)) {
      if (node.init.arguments.length === 0 || node.init.arguments[0].type !== "Literal" || typeof node.init.arguments[0].value !== "string") {
        const uniformNameLiteral = {
          type: "Literal",
          value: node.id.name
        };
        node.init.arguments.unshift(uniformNameLiteral);
      }
    }
    if (nodeIsVarying(node.init)) {
      if (node.init.arguments.length === 0 || node.init.arguments[0].type !== "Literal" || typeof node.init.arguments[0].value !== "string") {
        const varyingNameLiteral = {
          type: "Literal",
          value: node.id.name
        };
        node.init.arguments.unshift(varyingNameLiteral);
        _state.varyings[node.id.name] = varyingNameLiteral;
      } else {
        _state.varyings[node.id.name] = node.init.arguments[0];
      }
    }
  },
  Identifier(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    if (_state.varyings[node.name] && !ancestors.some((a) => a.type === "AssignmentExpression" && a.left === node)) {
      node.type = "CallExpression";
      node.callee = {
        type: "MemberExpression",
        object: {
          type: "Identifier",
          name: node.name
        },
        property: {
          type: "Identifier",
          name: "getValue"
        }
      };
      node.arguments = [];
    }
  },
  // The callbacks for AssignmentExpression and BinaryExpression handle
  // operator overloading including +=, *= assignment expressions
  ArrayExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const original = JSON.parse(JSON.stringify(node));
    node.type = "CallExpression";
    node.callee = {
      type: "Identifier",
      name: "__p5.strandsNode"
    };
    node.arguments = [original];
  },
  AssignmentExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const unsafeTypes = ["Literal", "ArrayExpression", "Identifier"];
    if (node.operator !== "=") {
      const methodName = replaceBinaryOperator(node.operator.replace("=", ""));
      const rightReplacementNode = {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: unsafeTypes.includes(node.left.type) ? {
            type: "CallExpression",
            callee: {
              type: "Identifier",
              name: "__p5.strandsNode"
            },
            arguments: [node.left]
          } : node.left,
          property: {
            type: "Identifier",
            name: methodName
          }
        },
        arguments: [node.right]
      };
      node.operator = "=";
      node.right = rightReplacementNode;
    }
    if (_state.varyings[node.left.name]) {
      node.type = "ExpressionStatement";
      node.expression = {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: {
            type: "Identifier",
            name: node.left.name
          },
          property: {
            type: "Identifier",
            name: "bridge"
          }
        },
        arguments: [node.right]
      };
    } else if (node.left.type === "MemberExpression") {
      let varyingName = null;
      if (node.left.object.type === "Identifier" && _state.varyings[node.left.object.name]) {
        varyingName = node.left.object.name;
      } else if (node.left.object.type === "CallExpression" && node.left.object.callee?.type === "MemberExpression" && node.left.object.callee.property?.name === "getValue" && node.left.object.callee.object?.type === "Identifier" && _state.varyings[node.left.object.callee.object.name]) {
        varyingName = node.left.object.callee.object.name;
      }
      if (varyingName) {
        const swizzlePattern = node.left.property.name;
        node.type = "ExpressionStatement";
        node.expression = {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: varyingName
            },
            property: {
              type: "Identifier",
              name: "bridgeSwizzle"
            }
          },
          arguments: [
            {
              type: "Literal",
              value: swizzlePattern
            },
            node.right
          ]
        };
      }
    }
  },
  BinaryExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const unsafeTypes = ["Literal", "ArrayExpression", "Identifier"];
    if (unsafeTypes.includes(node.left.type)) {
      const leftReplacementNode = {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "__p5.strandsNode"
        },
        arguments: [node.left]
      };
      node.left = leftReplacementNode;
    }
    node.type = "CallExpression";
    node.callee = {
      type: "MemberExpression",
      object: node.left,
      property: {
        type: "Identifier",
        name: replaceBinaryOperator(node.operator)
      }
    };
    node.arguments = [node.right];
  },
  LogicalExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const unsafeTypes = ["Literal", "ArrayExpression", "Identifier"];
    if (unsafeTypes.includes(node.left.type)) {
      const leftReplacementNode = {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "__p5.strandsNode"
        },
        arguments: [node.left]
      };
      node.left = leftReplacementNode;
    }
    node.type = "CallExpression";
    node.callee = {
      type: "MemberExpression",
      object: node.left,
      property: {
        type: "Identifier",
        name: replaceBinaryOperator(node.operator)
      }
    };
    node.arguments = [node.right];
  },
  IfStatement(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const condition = node.test;
    const thenFunction = {
      type: "ArrowFunctionExpression",
      params: [],
      body: node.consequent.type === "BlockStatement" ? node.consequent : {
        type: "BlockStatement",
        body: [node.consequent]
      }
    };
    let callExpression = {
      type: "CallExpression",
      callee: {
        type: "Identifier",
        name: "__p5.strandsIf"
      },
      arguments: [condition, thenFunction]
    };
    let elseFunction;
    if (node.alternate) {
      elseFunction = {
        type: "ArrowFunctionExpression",
        params: [],
        body: node.alternate.type === "BlockStatement" ? node.alternate : {
          type: "BlockStatement",
          body: [node.alternate]
        }
      };
    } else {
      elseFunction = {
        type: "ArrowFunctionExpression",
        params: [],
        body: {
          type: "BlockStatement",
          body: []
        }
      };
    }
    callExpression = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: callExpression,
        property: {
          type: "Identifier",
          name: "Else"
        }
      },
      arguments: [elseFunction]
    };
    const assignedVars = /* @__PURE__ */ new Set();
    const analyzeBranch = (functionBody) => {
      const localVars = /* @__PURE__ */ new Set();
      ancestor(functionBody, {
        VariableDeclarator(node2, ancestors2) {
          if (ancestors2.some(statementContainsStrandsControlFlow)) return;
          if (node2.id.type === "Identifier") {
            localVars.add(node2.id.name);
          }
        }
      });
      ancestor(functionBody, {
        AssignmentExpression(node2, ancestors2) {
          if (ancestors2.some(statementContainsStrandsControlFlow)) return;
          const left = node2.left;
          if (left.type === "Identifier") {
            if (!localVars.has(left.name)) {
              assignedVars.add(left.name);
            }
          } else if (left.type === "MemberExpression") {
            const propertyPath = buildPropertyPath(left);
            if (propertyPath) {
              const baseName = propertyPath.split(".")[0];
              if (!localVars.has(baseName)) {
                assignedVars.add(propertyPath);
              }
            }
          }
        }
      });
    };
    analyzeBranch(thenFunction.body);
    analyzeBranch(elseFunction.body);
    if (assignedVars.size > 0) {
      const addCopyingAndReturn = (functionBody, varsToReturn) => {
        if (functionBody.type === "BlockStatement") {
          const tempVarMap = /* @__PURE__ */ new Map();
          const copyStatements = [];
          for (const varPath of varsToReturn) {
            const parts = varPath.split(".");
            const tempName = `__copy_${parts.join("_")}_${blockVarCounter++}`;
            tempVarMap.set(varPath, tempName);
            let sourceExpr = { type: "Identifier", name: parts[0] };
            for (let i = 1; i < parts.length; i++) {
              sourceExpr = {
                type: "MemberExpression",
                object: sourceExpr,
                property: { type: "Identifier", name: parts[i] },
                computed: false
              };
            }
            copyStatements.push({
              type: "VariableDeclaration",
              declarations: [{
                type: "VariableDeclarator",
                id: { type: "Identifier", name: tempName },
                init: {
                  type: "CallExpression",
                  callee: {
                    type: "MemberExpression",
                    object: sourceExpr,
                    property: { type: "Identifier", name: "copy" },
                    computed: false
                  },
                  arguments: []
                }
              }],
              kind: "let"
            });
          }
          functionBody.body.forEach((node2) => replaceReferences(node2, tempVarMap));
          functionBody.body.unshift(...copyStatements);
          const returnObj = {
            type: "ObjectExpression",
            properties: Array.from(varsToReturn).map((varPath) => ({
              type: "Property",
              key: { type: "Literal", value: varPath },
              value: { type: "Identifier", name: tempVarMap.get(varPath) },
              kind: "init",
              computed: false,
              shorthand: false
            }))
          };
          functionBody.body.push({
            type: "ReturnStatement",
            argument: returnObj
          });
        }
      };
      addCopyingAndReturn(thenFunction.body, assignedVars);
      addCopyingAndReturn(elseFunction.body, assignedVars);
      const blockVar = `__block_${blockVarCounter++}`;
      const statements = [];
      for (const varPath of assignedVars) {
        const parts = varPath.split(".");
        let leftExpr = { type: "Identifier", name: parts[0] };
        for (let i = 1; i < parts.length; i++) {
          leftExpr = {
            type: "MemberExpression",
            object: leftExpr,
            property: { type: "Identifier", name: parts[i] },
            computed: false
          };
        }
        let rightArgExpr = { type: "Identifier", name: parts[0] };
        for (let i = 1; i < parts.length; i++) {
          rightArgExpr = {
            type: "MemberExpression",
            object: rightArgExpr,
            property: { type: "Identifier", name: parts[i] },
            computed: false
          };
        }
        statements.push({
          type: "ExpressionStatement",
          expression: {
            type: "AssignmentExpression",
            operator: "=",
            left: leftExpr,
            right: {
              type: "CallExpression",
              callee: { type: "Identifier", name: "__p5.strandsNode" },
              arguments: [rightArgExpr]
            }
          }
        });
      }
      statements.push({
        type: "VariableDeclaration",
        declarations: [{
          type: "VariableDeclarator",
          id: { type: "Identifier", name: blockVar },
          init: callExpression
        }],
        kind: "const"
      });
      for (const varPath of assignedVars) {
        const parts = varPath.split(".");
        let leftExpr = { type: "Identifier", name: parts[0] };
        for (let i = 1; i < parts.length; i++) {
          leftExpr = {
            type: "MemberExpression",
            object: leftExpr,
            property: { type: "Identifier", name: parts[i] },
            computed: false
          };
        }
        const rightExpr = {
          type: "MemberExpression",
          object: { type: "Identifier", name: blockVar },
          property: { type: "Literal", value: varPath },
          computed: true
        };
        statements.push({
          type: "ExpressionStatement",
          expression: {
            type: "AssignmentExpression",
            operator: "=",
            left: leftExpr,
            right: rightExpr
          }
        });
      }
      node.type = "BlockStatement";
      node.body = statements;
    } else {
      node.type = "ExpressionStatement";
      node.expression = callExpression;
    }
    delete node.test;
    delete node.consequent;
    delete node.alternate;
  },
  UpdateExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    let operator;
    if (node.operator === "++") {
      operator = "+";
    } else if (node.operator === "--") {
      operator = "-";
    } else {
      return;
    }
    const assignmentExpr = {
      type: "AssignmentExpression",
      operator: "=",
      left: node.argument,
      right: {
        type: "BinaryExpression",
        operator,
        left: node.argument,
        right: {
          type: "Literal",
          value: 1
        }
      }
    };
    Object.assign(node, assignmentExpr);
    delete node.prefix;
    this.BinaryExpression(node.right, _state, [...ancestors, node]);
    this.AssignmentExpression(node, _state, ancestors);
  },
  ForStatement(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const uniqueLoopVar = `loopVar${loopVarCounter++}`;
    let initialFunction;
    if (node.init && node.init.type === "VariableDeclaration") {
      const declaration = node.init.declarations[0];
      let initValue = declaration.init;
      const initAst = { body: [{ type: "ExpressionStatement", expression: initValue }] };
      initValue = initAst.body[0].expression;
      initialFunction = {
        type: "ArrowFunctionExpression",
        params: [],
        body: {
          type: "BlockStatement",
          body: [{
            type: "ReturnStatement",
            argument: initValue
          }]
        }
      };
    } else {
      initialFunction = {
        type: "ArrowFunctionExpression",
        params: [],
        body: {
          type: "BlockStatement",
          body: [{
            type: "ReturnStatement",
            argument: {
              type: "Literal",
              value: 0
            }
          }]
        }
      };
    }
    let conditionBody = node.test || { type: "Literal", value: true };
    if (node.init?.type === "VariableDeclaration") {
      const loopVarName = node.init.declarations[0].id.name;
      conditionBody = this.replaceIdentifierReferences(conditionBody, loopVarName, uniqueLoopVar);
    }
    const conditionAst = { body: [{ type: "ExpressionStatement", expression: conditionBody }] };
    conditionBody = conditionAst.body[0].expression;
    const conditionFunction = {
      type: "ArrowFunctionExpression",
      params: [{ type: "Identifier", name: uniqueLoopVar }],
      body: conditionBody
    };
    let updateFunction;
    if (node.update) {
      let updateExpr = node.update;
      if (node.init?.type === "VariableDeclaration") {
        const loopVarName = node.init.declarations[0].id.name;
        updateExpr = this.replaceIdentifierReferences(updateExpr, loopVarName, uniqueLoopVar);
      }
      const updateAst = { body: [{ type: "ExpressionStatement", expression: updateExpr }] };
      updateExpr = updateAst.body[0].expression;
      updateFunction = {
        type: "ArrowFunctionExpression",
        params: [{ type: "Identifier", name: uniqueLoopVar }],
        body: {
          type: "BlockStatement",
          body: [{
            type: "ReturnStatement",
            argument: updateExpr
          }]
        }
      };
    } else {
      updateFunction = {
        type: "ArrowFunctionExpression",
        params: [{ type: "Identifier", name: uniqueLoopVar }],
        body: {
          type: "BlockStatement",
          body: [{
            type: "ReturnStatement",
            argument: { type: "Identifier", name: uniqueLoopVar }
          }]
        }
      };
    }
    let bodyBlock = node.body.type === "BlockStatement" ? node.body : {
      type: "BlockStatement",
      body: [node.body]
    };
    if (node.init?.type === "VariableDeclaration") {
      const loopVarName = node.init.declarations[0].id.name;
      bodyBlock = this.replaceIdentifierReferences(bodyBlock, loopVarName, uniqueLoopVar);
    }
    const bodyFunction = {
      type: "ArrowFunctionExpression",
      params: [
        { type: "Identifier", name: uniqueLoopVar },
        { type: "Identifier", name: "vars" }
      ],
      body: bodyBlock
    };
    const assignedVars = /* @__PURE__ */ new Set();
    const localVars = /* @__PURE__ */ new Set();
    ancestor(bodyFunction.body, {
      VariableDeclarator(node2, ancestors2) {
        if (ancestors2.some(statementContainsStrandsControlFlow)) return;
        if (node2.id.type === "Identifier") {
          localVars.add(node2.id.name);
        }
      }
    });
    ancestor(bodyFunction.body, {
      AssignmentExpression(node2, ancestors2) {
        if (ancestors2.some(statementContainsStrandsControlFlow)) {
          return;
        }
        const left = node2.left;
        if (left.type === "Identifier") {
          if (!localVars.has(left.name)) {
            assignedVars.add(left.name);
          }
        } else if (left.type === "MemberExpression") {
          const propertyPath = buildPropertyPath(left);
          if (propertyPath) {
            const baseName = propertyPath.split(".")[0];
            if (!localVars.has(baseName)) {
              assignedVars.add(propertyPath);
            }
          }
        }
      }
    });
    if (assignedVars.size > 0) {
      const addCopyingAndReturn = (functionBody, varsToReturn) => {
        if (functionBody.type === "BlockStatement") {
          const tempVarMap = /* @__PURE__ */ new Map();
          const copyStatements = [];
          for (const varPath of varsToReturn) {
            const parts = varPath.split(".");
            const tempName = `__copy_${parts.join("_")}_${blockVarCounter++}`;
            tempVarMap.set(varPath, tempName);
            let sourceExpr = { type: "Identifier", name: "vars" };
            for (const part of parts) {
              sourceExpr = {
                type: "MemberExpression",
                object: sourceExpr,
                property: { type: "Identifier", name: part },
                computed: false
              };
            }
            copyStatements.push({
              type: "VariableDeclaration",
              declarations: [{
                type: "VariableDeclarator",
                id: { type: "Identifier", name: tempName },
                init: {
                  type: "CallExpression",
                  callee: {
                    type: "MemberExpression",
                    object: sourceExpr,
                    property: { type: "Identifier", name: "copy" },
                    computed: false
                  },
                  arguments: []
                }
              }],
              kind: "let"
            });
          }
          functionBody.body.forEach((node2) => replaceReferences(node2, tempVarMap));
          functionBody.body.unshift(...copyStatements);
          const returnObj = {
            type: "ObjectExpression",
            properties: Array.from(varsToReturn).map((varPath) => ({
              type: "Property",
              key: { type: "Literal", value: varPath },
              value: { type: "Identifier", name: tempVarMap.get(varPath) },
              kind: "init",
              computed: false,
              shorthand: false
            }))
          };
          functionBody.body.push({
            type: "ReturnStatement",
            argument: returnObj
          });
        }
      };
      addCopyingAndReturn(bodyFunction.body, assignedVars);
      const blockVar = `__block_${blockVarCounter++}`;
      const statements = [];
      const initialVarsObject = {
        type: "ObjectExpression",
        properties: Array.from(assignedVars).map((varPath) => {
          const parts = varPath.split(".");
          let expr = { type: "Identifier", name: parts[0] };
          for (let i = 1; i < parts.length; i++) {
            expr = {
              type: "MemberExpression",
              object: expr,
              property: { type: "Identifier", name: parts[i] },
              computed: false
            };
          }
          const wrappedExpr = {
            type: "CallExpression",
            callee: { type: "Identifier", name: "__p5.strandsNode" },
            arguments: [expr]
          };
          return {
            type: "Property",
            key: { type: "Literal", value: varPath },
            value: wrappedExpr,
            kind: "init",
            computed: false,
            shorthand: false
          };
        })
      };
      const callExpression = {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "__p5.strandsFor"
        },
        arguments: [initialFunction, conditionFunction, updateFunction, bodyFunction, initialVarsObject]
      };
      statements.push({
        type: "VariableDeclaration",
        declarations: [{
          type: "VariableDeclarator",
          id: { type: "Identifier", name: blockVar },
          init: callExpression
        }],
        kind: "const"
      });
      for (const varPath of assignedVars) {
        const parts = varPath.split(".");
        let leftExpr = { type: "Identifier", name: parts[0] };
        for (let i = 1; i < parts.length; i++) {
          leftExpr = {
            type: "MemberExpression",
            object: leftExpr,
            property: { type: "Identifier", name: parts[i] },
            computed: false
          };
        }
        let rightExpr = { type: "Identifier", name: blockVar };
        for (const part of parts) {
          rightExpr = {
            type: "MemberExpression",
            object: rightExpr,
            property: { type: "Identifier", name: part },
            computed: false
          };
        }
        statements.push({
          type: "ExpressionStatement",
          expression: {
            type: "AssignmentExpression",
            operator: "=",
            left: leftExpr,
            right: rightExpr
          }
        });
      }
      node.type = "BlockStatement";
      node.body = statements;
    } else {
      node.type = "ExpressionStatement";
      node.expression = {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "__p5.strandsFor"
        },
        arguments: [initialFunction, conditionFunction, updateFunction, bodyFunction, {
          type: "ObjectExpression",
          properties: []
        }]
      };
    }
    delete node.init;
    delete node.test;
    delete node.update;
  },
  // Helper method to replace identifier references in AST nodes
  replaceIdentifierReferences(node, oldName, newName) {
    if (!node || typeof node !== "object") return node;
    const replaceInNode = (n2) => {
      if (!n2 || typeof n2 !== "object") return n2;
      if (n2.type === "Identifier" && n2.name === oldName) {
        return { ...n2, name: newName };
      }
      const newNode = { ...n2 };
      for (const key in n2) {
        if (n2.hasOwnProperty(key) && key !== "parent") {
          if (Array.isArray(n2[key])) {
            newNode[key] = n2[key].map(replaceInNode);
          } else if (typeof n2[key] === "object") {
            newNode[key] = replaceInNode(n2[key]);
          }
        }
      }
      return newNode;
    };
    return replaceInNode(node);
  }
};
function transpileStrandsToJS(p53, sourceString, srcLocations, scope) {
  blockVarCounter = 0;
  loopVarCounter = 0;
  const ast2 = parse3(sourceString, {
    ecmaVersion: 2021,
    locations: srcLocations
  });
  const nonControlFlowCallbacks = { ...ASTCallbacks };
  delete nonControlFlowCallbacks.IfStatement;
  delete nonControlFlowCallbacks.ForStatement;
  ancestor(ast2, nonControlFlowCallbacks, void 0, { varyings: {} });
  const postOrderControlFlowTransform = {
    IfStatement(node, state, c) {
      state.inControlFlow++;
      if (node.test) c(node.test, state);
      if (node.consequent) c(node.consequent, state);
      if (node.alternate) c(node.alternate, state);
      ASTCallbacks.IfStatement(node, state, []);
      state.inControlFlow--;
    },
    ForStatement(node, state, c) {
      state.inControlFlow++;
      if (node.init) c(node.init, state);
      if (node.test) c(node.test, state);
      if (node.update) c(node.update, state);
      if (node.body) c(node.body, state);
      ASTCallbacks.ForStatement(node, state, []);
      state.inControlFlow--;
    },
    ReturnStatement(node, state, c) {
      if (!state.inControlFlow) return;
      node.type = "ExpressionStatement";
      node.expression = {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "__p5.strandsEarlyReturn"
        },
        arguments: node.argument ? [node.argument] : []
      };
      delete node.argument;
    }
  };
  recursive(ast2, { varyings: {}, inControlFlow: 0 }, postOrderControlFlowTransform);
  const transpiledSource = escodegen.generate(ast2);
  const scopeKeys = Object.keys(scope);
  const match = /\(?\s*(?:function)?\s*\w*\s*\(([^)]*)\)\s*(?:=>)?\s*{((?:.|\n)*)}\s*;?\s*\)?/.exec(transpiledSource);
  if (!match) {
    console.log(transpiledSource);
    throw new Error("Could not parse p5.strands function!");
  }
  const params = match[1].split(/,\s*/).filter((param) => !!param.trim());
  let paramVals, paramNames;
  if (params.length > 0) {
    paramNames = params;
    paramVals = [scope];
  } else {
    paramNames = scopeKeys;
    paramVals = scopeKeys.map((key) => scope[key]);
  }
  const body = match[2];
  try {
    const internalStrandsCallback = new Function(
      // Create a parameter called __p5, not just p5, because users of instance mode
      // may pass in a variable called p5 as a scope variable. If we rely on a variable called
      // p5, then the scope variable called p5 might accidentally override internal function
      // calls to p5 static methods.
      "__p5",
      ...paramNames,
      body
    );
    return () => internalStrandsCallback(p53, ...paramVals);
  } catch (e2) {
    console.error(e2);
    console.log(paramNames);
    console.log(body);
    throw new Error("Error transpiling p5.strands callback!");
  }
}
function generateShaderCode(strandsContext) {
  const {
    cfg,
    backend,
    vertexDeclarations,
    fragmentDeclarations
  } = strandsContext;
  const hooksObj = {
    uniforms: {},
    varyingVariables: []
  };
  for (const { name, typeInfo, defaultValue } of strandsContext.uniforms) {
    const key = backend.generateHookUniformKey(name, typeInfo);
    if (key !== null) {
      hooksObj.uniforms[key] = defaultValue;
    }
  }
  if (backend.addTextureBindingsToDeclarations) {
    backend.addTextureBindingsToDeclarations(strandsContext);
  }
  for (const { hookType, rootNodeID, entryBlockID, shaderContext } of strandsContext.hooks) {
    const generationContext = {
      indent: 1,
      codeLines: [],
      write(line) {
        this.codeLines.push("  ".repeat(this.indent) + line);
      },
      tempNames: {},
      declarations: [],
      nextTempID: 0,
      visitedNodes: /* @__PURE__ */ new Set(),
      shaderContext,
      // 'vertex' or 'fragment'
      strandsContext
      // For shared variable tracking
    };
    const blocks = sortCFG(cfg.outgoingEdges, entryBlockID);
    for (const blockID of blocks) {
      backend.generateBlock(blockID, strandsContext, generationContext);
    }
    for (const assignmentNodeID of strandsContext.globalAssignments) {
      if (!generationContext.visitedNodes.has(assignmentNodeID)) {
        backend.generateAssignment(generationContext, strandsContext.dag, assignmentNodeID);
        generationContext.visitedNodes.add(assignmentNodeID);
      }
    }
    strandsContext.globalAssignments = [];
    const firstLine = backend.hookEntry(hookType);
    let returnType;
    if (hookType.returnType.properties) {
      returnType = structType(hookType.returnType);
    } else {
      if (!hookType.returnType.dataType) {
        throw new Error(`Missing dataType for return type ${hookType.returnType.typeName}`);
      }
      returnType = hookType.returnType.dataType;
    }
    if (rootNodeID) {
      backend.generateReturnStatement(strandsContext, generationContext, rootNodeID, returnType);
    }
    hooksObj[`${hookType.returnType.typeName} ${hookType.name}`] = [firstLine, ...generationContext.codeLines, "}"].join("\n");
  }
  if (strandsContext.sharedVariables) {
    for (const [varName, varInfo] of strandsContext.sharedVariables) {
      if (varInfo.usedInVertex && varInfo.usedInFragment) {
        hooksObj.varyingVariables.push(backend.generateVaryingVariable(varName, varInfo.typeInfo));
      } else if (varInfo.usedInVertex) {
        vertexDeclarations.add(backend.generateLocalDeclaration(varName, varInfo.typeInfo));
      } else if (varInfo.usedInFragment) {
        fragmentDeclarations.add(backend.generateLocalDeclaration(varName, varInfo.typeInfo));
      }
    }
  }
  hooksObj.vertexDeclarations = [...vertexDeclarations].join("\n");
  hooksObj.fragmentDeclarations = [...fragmentDeclarations].join("\n");
  return hooksObj;
}
function createPhiNode(strandsContext, phiInputs, varName) {
  const validInputs = phiInputs.filter((input) => input.value.id !== null);
  if (validInputs.length === 0) {
    throw new Error(`No valid inputs for phi node for variable ${varName}`);
  }
  let firstInput = validInputs.map((input) => getNodeDataFromID(strandsContext.dag, input.value.id)).find((input) => input.dimension) ?? getNodeDataFromID(strandsContext.dag, validInputs[0].value.id);
  const dimension = firstInput.dimension;
  const baseType = firstInput.baseType;
  const nodeData = {
    nodeType: NodeType.PHI,
    dimension,
    baseType,
    dependsOn: phiInputs.map((input) => input.value.id).filter((id2) => id2 !== null),
    phiBlocks: phiInputs.map((input) => input.blockId)
  };
  const id = getOrCreateNode(strandsContext.dag, nodeData);
  recordInBasicBlock(strandsContext.cfg, strandsContext.cfg.currentBlock, id);
  return {
    id,
    dimension,
    baseType
  };
}
class StrandsConditional {
  constructor(strandsContext, condition, branchCallback) {
    this.branches = [{
      condition,
      branchCallback,
      blockType: BlockType.IF_BODY
    }];
    this.ctx = strandsContext;
  }
  ElseIf(condition, branchCallback) {
    this.branches.push({
      condition,
      branchCallback,
      blockType: BlockType.IF_BODY
    });
    return this;
  }
  Else(branchCallback = () => ({})) {
    this.branches.push({
      condition: null,
      branchCallback,
      blockType: BlockType.IF_BODY
    });
    const phiNodes = buildConditional(this.ctx, this);
    const assignments = {};
    for (const [varName, phiNode] of Object.entries(phiNodes)) {
      assignments[varName] = createStrandsNode(phiNode.id, phiNode.dimension, this.ctx);
    }
    return assignments;
  }
}
function buildConditional(strandsContext, conditional) {
  const cfg = strandsContext.cfg;
  const branches = conditional.branches;
  const mergeBlock = createBasicBlock(cfg, BlockType.MERGE);
  const results = [];
  const branchEndBlocks = [];
  const mergedAssignments = {};
  const phiBlockDependencies = {};
  const branchBlock = createBasicBlock(cfg, BlockType.BRANCH);
  addEdge(cfg, cfg.currentBlock, branchBlock);
  addEdge(cfg, branchBlock, mergeBlock);
  let previousBlock = branchBlock;
  for (let i = 0; i < branches.length; i++) {
    const { condition, branchCallback, blockType } = branches[i];
    if (condition !== null) {
      const conditionBlock = createBasicBlock(cfg, BlockType.IF_COND);
      addEdge(cfg, previousBlock, conditionBlock);
      pushBlock(cfg, conditionBlock);
      cfg.blockConditions[conditionBlock] = condition.id;
      previousBlock = conditionBlock;
      popBlock(cfg);
    } else {
      const elseCondBlock = createBasicBlock(cfg, BlockType.ELSE_COND);
      addEdge(cfg, previousBlock, elseCondBlock);
      previousBlock = elseCondBlock;
    }
    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);
    addEdge(cfg, previousBlock, scopeStartBlock);
    const branchContentBlock = createBasicBlock(cfg, blockType);
    addEdge(cfg, scopeStartBlock, branchContentBlock);
    pushBlock(cfg, branchContentBlock);
    const branchResults = branchCallback();
    for (const key in branchResults) {
      branchResults[key] = strandsContext.p5.strandsNode(branchResults[key]);
    }
    for (const key in branchResults) {
      if (!phiBlockDependencies[key]) {
        phiBlockDependencies[key] = [{ value: branchResults[key], blockId: branchContentBlock }];
      } else {
        phiBlockDependencies[key].push({ value: branchResults[key], blockId: branchContentBlock });
      }
    }
    results.push(branchResults);
    const branchEndBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, cfg.currentBlock, branchEndBlock);
    branchEndBlocks.push(branchEndBlock);
    popBlock(cfg);
    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);
    addEdge(cfg, branchEndBlock, scopeEndBlock);
    addEdge(cfg, scopeEndBlock, mergeBlock);
    previousBlock = scopeStartBlock;
  }
  pushBlockForModification(cfg, branchBlock);
  for (const key in phiBlockDependencies) {
    mergedAssignments[key] = createPhiNode(strandsContext, phiBlockDependencies[key], key);
  }
  popBlock(cfg);
  for (let i = 0; i < results.length; i++) {
    const branchResult = results[i];
    const branchEndBlockID = branchEndBlocks[i];
    pushBlockForModification(cfg, branchEndBlockID);
    for (const key in branchResult) {
      if (mergedAssignments[key]) {
        const phiNodeID = mergedAssignments[key].id;
        const sourceNodeID = branchResult[key].id;
        const assignmentNode = {
          nodeType: NodeType.ASSIGNMENT,
          dependsOn: [phiNodeID, sourceNodeID],
          phiBlocks: []
        };
        const assignmentID = getOrCreateNode(strandsContext.dag, assignmentNode);
        recordInBasicBlock(cfg, branchEndBlockID, assignmentID);
      }
    }
    popBlock(cfg);
  }
  pushBlock(cfg, mergeBlock);
  return mergedAssignments;
}
class StrandsFor {
  constructor(strandsContext, initialCb, conditionCb, updateCb, bodyCb, initialVars) {
    this.strandsContext = strandsContext;
    this.initialCb = initialCb;
    this.conditionCb = conditionCb;
    this.updateCb = updateCb;
    this.bodyCb = bodyCb;
    this.initialVars = initialVars;
  }
  build() {
    const cfg = this.strandsContext.cfg;
    const mergeBlock = createBasicBlock(cfg, BlockType.MERGE);
    const branchBlock = createBasicBlock(cfg, BlockType.BRANCH);
    addEdge(cfg, cfg.currentBlock, branchBlock);
    addEdge(cfg, branchBlock, mergeBlock);
    const { initialVar, phiNode } = this.initializeLoopVariable(cfg, branchBlock);
    pushBlock(cfg, cfg.currentBlock);
    const loopVarNode = createStrandsNode(phiNode.id, phiNode.dimension, this.strandsContext);
    const conditionNode = this.conditionCb(loopVarNode);
    const updateResult = this.updateCb(loopVarNode);
    popBlock(cfg);
    const isBounded = this.loopIsBounded(initialVar, conditionNode, updateResult);
    if (isBounded) {
      this.buildBoundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult);
    } else {
      this.buildUnboundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult);
    }
    const finalPhiNodes = this.phiNodesForBody;
    pushBlockForModification(cfg, branchBlock);
    for (const [varName, resultNode] of Object.entries(this.bodyResults)) {
      if (varName !== "loopVar" && finalPhiNodes[varName]) {
        const phiNodeID = finalPhiNodes[varName].id;
        const phiNodeData = getNodeDataFromID(this.strandsContext.dag, phiNodeID);
        if (phiNodeData.dependsOn.length > 1) {
          phiNodeData.dependsOn[1] = resultNode.id;
        }
        if (phiNodeData.phiInputs && phiNodeData.phiInputs.length > 1) {
          phiNodeData.phiInputs[1].value = resultNode;
        }
      }
    }
    popBlock(cfg);
    pushBlockForModification(cfg, branchBlock);
    for (const [varName, initialValueNode] of Object.entries(this.initialVars)) {
      if (varName !== "loopVar" && finalPhiNodes[varName]) {
        const phiNodeID = finalPhiNodes[varName].id;
        const sourceNodeID = initialValueNode.id;
        const assignmentNode = createNodeData({
          nodeType: NodeType.ASSIGNMENT,
          dependsOn: [phiNodeID, sourceNodeID],
          phiBlocks: []
        });
        const assignmentID = getOrCreateNode(this.strandsContext.dag, assignmentNode);
        recordInBasicBlock(cfg, branchBlock, assignmentID);
      }
    }
    popBlock(cfg);
    pushBlockForModification(cfg, this.finalBodyBlock);
    for (const [varName, resultNode] of Object.entries(this.bodyResults)) {
      if (varName !== "loopVar" && finalPhiNodes[varName]) {
        const phiNodeID = finalPhiNodes[varName].id;
        const sourceNodeID = resultNode.id;
        const assignmentNode = createNodeData({
          nodeType: NodeType.ASSIGNMENT,
          dependsOn: [phiNodeID, sourceNodeID],
          phiBlocks: []
        });
        const assignmentID = getOrCreateNode(this.strandsContext.dag, assignmentNode);
        recordInBasicBlock(cfg, this.finalBodyBlock, assignmentID);
      }
    }
    popBlock(cfg);
    const finalBodyResults = {};
    for (const [varName, phiNode2] of Object.entries(finalPhiNodes)) {
      finalBodyResults[varName] = createStrandsNode(phiNode2.id, phiNode2.dimension, this.strandsContext);
    }
    pushBlock(cfg, mergeBlock);
    return finalBodyResults;
  }
  buildBoundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult) {
    const forBlock = createBasicBlock(cfg, BlockType.FOR);
    addEdge(cfg, branchBlock, forBlock);
    pushBlock(cfg, forBlock);
    if (initialVar) {
      const initAssignmentNode = createNodeData({
        nodeType: NodeType.ASSIGNMENT,
        dependsOn: [phiNode.id, initialVar.id],
        phiBlocks: []
      });
      const initAssignmentID = getOrCreateNode(this.strandsContext.dag, initAssignmentNode);
      recordInBasicBlock(cfg, forBlock, initAssignmentID);
    }
    const conditionStatementNode = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.EXPRESSION,
      dependsOn: [conditionNode.id],
      phiBlocks: []
    });
    const conditionStatementID = getOrCreateNode(this.strandsContext.dag, conditionStatementNode);
    recordInBasicBlock(cfg, forBlock, conditionStatementID);
    const updateAssignmentNode = createNodeData({
      nodeType: NodeType.ASSIGNMENT,
      dependsOn: [phiNode.id, updateResult.id],
      phiBlocks: []
    });
    const updateAssignmentID = getOrCreateNode(this.strandsContext.dag, updateAssignmentNode);
    recordInBasicBlock(cfg, forBlock, updateAssignmentID);
    popBlock(cfg);
    const instructions = cfg.blockInstructions[forBlock] || [];
    const expectedLength = initialVar ? 3 : 2;
    if (instructions.length !== expectedLength) {
      throw new Error(`FOR block must have exactly ${expectedLength} statements, got ${instructions.length}`);
    }
    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);
    addEdge(cfg, forBlock, scopeStartBlock);
    const bodyBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    this.bodyBlock = bodyBlock;
    addEdge(cfg, scopeStartBlock, bodyBlock);
    this.executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode);
    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);
    addEdge(cfg, bodyBlock, scopeEndBlock);
    addEdge(cfg, scopeEndBlock, mergeBlock);
  }
  buildUnboundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult) {
    const forBlock = createBasicBlock(cfg, BlockType.FOR);
    addEdge(cfg, branchBlock, forBlock);
    pushBlock(cfg, forBlock);
    if (initialVar) {
      const initAssignmentNode = createNodeData({
        nodeType: NodeType.ASSIGNMENT,
        dependsOn: [phiNode.id, initialVar.id],
        phiBlocks: []
      });
      const initAssignmentID = getOrCreateNode(this.strandsContext.dag, initAssignmentNode);
      recordInBasicBlock(cfg, forBlock, initAssignmentID);
    } else {
      const emptyInitNode = createNodeData({
        nodeType: NodeType.STATEMENT,
        statementType: StatementType.EMPTY,
        dependsOn: [],
        phiBlocks: []
      });
      const emptyInitID = getOrCreateNode(this.strandsContext.dag, emptyInitNode);
      recordInBasicBlock(cfg, forBlock, emptyInitID);
    }
    const emptyConditionNode = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.EMPTY,
      dependsOn: [],
      phiBlocks: []
    });
    const emptyConditionID = getOrCreateNode(this.strandsContext.dag, emptyConditionNode);
    recordInBasicBlock(cfg, forBlock, emptyConditionID);
    const emptyUpdateNode = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.EMPTY,
      dependsOn: [],
      phiBlocks: []
    });
    const emptyUpdateID = getOrCreateNode(this.strandsContext.dag, emptyUpdateNode);
    recordInBasicBlock(cfg, forBlock, emptyUpdateID);
    popBlock(cfg);
    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);
    addEdge(cfg, forBlock, scopeStartBlock);
    const breakCheckBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, scopeStartBlock, breakCheckBlock);
    pushBlock(cfg, breakCheckBlock);
    const condition = conditionNode;
    const negatedCondition = this.createLogicalNotNode(condition);
    const breakConditionBlock = createBasicBlock(cfg, BlockType.IF_COND);
    addEdge(cfg, breakCheckBlock, breakConditionBlock);
    cfg.blockConditions[breakConditionBlock] = negatedCondition.id;
    const breakScopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);
    addEdge(cfg, breakConditionBlock, breakScopeStartBlock);
    const breakStatementBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, breakScopeStartBlock, breakStatementBlock);
    pushBlock(cfg, breakStatementBlock);
    const breakStatementNode = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.BREAK,
      dependsOn: [],
      phiBlocks: []
    });
    const breakStatementID = getOrCreateNode(this.strandsContext.dag, breakStatementNode);
    recordInBasicBlock(cfg, breakStatementBlock, breakStatementID);
    popBlock(cfg);
    const breakScopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);
    addEdge(cfg, breakStatementBlock, breakScopeEndBlock);
    addEdge(cfg, breakScopeEndBlock, mergeBlock);
    popBlock(cfg);
    const bodyBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    this.bodyBlock = bodyBlock;
    addEdge(cfg, breakCheckBlock, bodyBlock);
    this.executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode);
    const updateBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, bodyBlock, updateBlock);
    pushBlock(cfg, updateBlock);
    const updateAssignmentNode = createNodeData({
      nodeType: NodeType.ASSIGNMENT,
      dependsOn: [phiNode.id, updateResult.id],
      phiBlocks: []
    });
    const updateAssignmentID = getOrCreateNode(this.strandsContext.dag, updateAssignmentNode);
    recordInBasicBlock(cfg, updateBlock, updateAssignmentID);
    popBlock(cfg);
    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);
    addEdge(cfg, updateBlock, scopeEndBlock);
    addEdge(cfg, scopeEndBlock, mergeBlock);
    addEdge(cfg, breakCheckBlock, mergeBlock);
  }
  initializeLoopVariable(cfg, branchBlock) {
    pushBlock(cfg, branchBlock);
    let initialVar = this.initialCb();
    if (!(initialVar instanceof StrandsNode)) {
      const { id, dimension } = primitiveConstructorNode(this.strandsContext, { baseType: BaseType.FLOAT, dimension: 1 }, initialVar);
      initialVar = createStrandsNode(id, dimension, this.strandsContext);
    }
    const phiNode = createPhiNode(this.strandsContext, [
      { value: initialVar, blockId: branchBlock },
      { value: initialVar, blockId: branchBlock }
      // Placeholder, will be updated later
    ], "loopVar");
    popBlock(cfg);
    return { initialVar, phiNode };
  }
  createLogicalNotNode(conditionNode) {
    const notOperationNode = createNodeData({
      nodeType: NodeType.OPERATION,
      opCode: OpCode.Unary.LOGICAL_NOT,
      baseType: BaseType.BOOL,
      dimension: 1,
      dependsOn: [conditionNode.id],
      phiBlocks: [],
      usedBy: []
    });
    const notOperationID = getOrCreateNode(this.strandsContext.dag, notOperationNode);
    return createStrandsNode(notOperationID, 1, this.strandsContext);
  }
  executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode) {
    pushBlock(cfg, bodyBlock);
    const phiVars = {};
    const phiNodesForBody = {};
    pushBlockForModification(cfg, branchBlock);
    for (const [varName, initialValueNode] of Object.entries(this.initialVars)) {
      if (varName !== "loopVar") {
        const varPhiNode = createPhiNode(this.strandsContext, [
          { value: initialValueNode, blockId: branchBlock },
          // Initial value
          { value: initialValueNode, blockId: bodyBlock }
          // Placeholder - will update after body execution
        ], varName);
        phiNodesForBody[varName] = varPhiNode;
        phiVars[varName] = createStrandsNode(varPhiNode.id, varPhiNode.dimension, this.strandsContext);
      }
    }
    popBlock(cfg);
    const loopVarNode = createStrandsNode(phiNode.id, phiNode.dimension, this.strandsContext);
    this.bodyResults = this.bodyCb(loopVarNode, phiVars) || {};
    for (const key in this.bodyResults) {
      this.bodyResults[key] = this.strandsContext.p5.strandsNode(this.bodyResults[key]);
    }
    this.phiNodesForBody = phiNodesForBody;
    this.finalBodyBlock = cfg.currentBlock;
    popBlock(cfg);
  }
  loopIsBounded(initialVar, conditionNode, updateVar) {
    if (!conditionNode) return false;
    const conditionData = getNodeDataFromID(this.strandsContext.dag, conditionNode.id);
    if (conditionData.nodeType !== NodeType.OPERATION) {
      return false;
    }
    if (!conditionData.dependsOn || conditionData.dependsOn.length !== 2) {
      return false;
    }
    const leftOperand = createStrandsNode(conditionData.dependsOn[0], 1, this.strandsContext);
    const rightOperand = createStrandsNode(conditionData.dependsOn[1], 1, this.strandsContext);
    const leftUsesOnlyLiterals = this.nodeUsesOnlyLiterals(leftOperand);
    const rightUsesOnlyLiterals = this.nodeUsesOnlyLiterals(rightOperand);
    return leftUsesOnlyLiterals || rightUsesOnlyLiterals;
  }
  nodeUsesOnlyLiterals(node) {
    const nodeData = getNodeDataFromID(this.strandsContext.dag, node.id);
    switch (nodeData.nodeType) {
      case NodeType.LITERAL:
        return true;
      case NodeType.VARIABLE:
        return false;
      case NodeType.PHI:
        return false;
      case NodeType.OPERATION:
        if (nodeData.dependsOn) {
          for (const depId of nodeData.dependsOn) {
            const depNode = createStrandsNode(depId, 1, this.strandsContext);
            if (!this.nodeUsesOnlyLiterals(depNode)) {
              return false;
            }
          }
        }
        return true;
      default:
        return false;
    }
  }
}
function initGlobalStrandsAPI(p53, fn2, strandsContext) {
  for (const { name, arity, opCode } of OperatorTable) {
    if (arity === "binary") {
      StrandsNode.prototype[name] = function(...right) {
        const { id, dimension } = binaryOpNode(strandsContext, this, right, opCode);
        return createStrandsNode(id, dimension, strandsContext);
      };
    }
    if (arity === "unary") {
      p53[name] = function(nodeOrValue) {
        const { id, dimension } = unaryOpNode(strandsContext, nodeOrValue, opCode);
        return createStrandsNode(id, dimension, strandsContext);
      };
    }
  }
  fn2.discard = function() {
    statementNode(strandsContext, StatementType.DISCARD);
  };
  fn2.break = function() {
    statementNode(strandsContext, StatementType.BREAK);
  };
  p53.break = fn2.break;
  fn2.instanceID = function() {
    const node = variableNode(strandsContext, { baseType: BaseType.INT, dimension: 1 }, strandsContext.backend.instanceIdReference());
    return createStrandsNode(node.id, node.dimension, strandsContext);
  };
  p53.strandsIf = function(conditionNode, ifBody) {
    return new StrandsConditional(strandsContext, conditionNode, ifBody);
  };
  fn2.strandsIf = p53.strandsIf;
  p53.strandsFor = function(initialCb, conditionCb, updateCb, bodyCb, initialVars) {
    return new StrandsFor(strandsContext, initialCb, conditionCb, updateCb, bodyCb, initialVars).build();
  };
  fn2.strandsFor = p53.strandsFor;
  p53.strandsEarlyReturn = function(value) {
    const { dag, cfg } = strandsContext;
    if (!strandsContext.activeHook) {
      throw new Error("strandsEarlyReturn can only be used inside a hook callback");
    }
    const valueNode = value instanceof StrandsNode ? value : p53.strandsNode(value);
    const earlyReturnBlockID = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, cfg.currentBlock, earlyReturnBlockID);
    pushBlock(cfg, earlyReturnBlockID);
    const nodeData = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.EARLY_RETURN,
      dependsOn: [valueNode.id]
    });
    const earlyReturnID = getOrCreateNode(dag, nodeData);
    recordInBasicBlock(cfg, cfg.currentBlock, earlyReturnID);
    strandsContext.activeHook.earlyReturns.push({ earlyReturnID, valueNode });
    popBlock(cfg);
    return valueNode;
  };
  fn2.strandsEarlyReturn = p53.strandsEarlyReturn;
  p53.strandsNode = function(...args) {
    if (args.length === 1 && args[0] instanceof StrandsNode) {
      return args[0];
    }
    if (args.length > 4) {
      userError("type error", "It looks like you've tried to construct a p5.strands node implicitly, with more than 4 components. This is currently not supported.");
    }
    const { id, dimension } = primitiveConstructorNode(strandsContext, { baseType: BaseType.FLOAT, dimension: null }, args.flat());
    return createStrandsNode(id, dimension, strandsContext);
  };
  for (const [functionName, overrides] of Object.entries(strandsBuiltinFunctions)) {
    const isp5Function = overrides[0].isp5Function;
    if (isp5Function) {
      const originalFn = fn2[functionName];
      fn2[functionName] = function(...args) {
        if (strandsContext.active) {
          const { id, dimension } = functionCallNode(strandsContext, functionName, args);
          return createStrandsNode(id, dimension, strandsContext);
        } else {
          return originalFn.apply(this, args);
        }
      };
    } else {
      fn2[functionName] = function(...args) {
        if (strandsContext.active) {
          const { id, dimension } = functionCallNode(strandsContext, functionName, args);
          return createStrandsNode(id, dimension, strandsContext);
        } else {
          p53._friendlyError(
            `It looks like you've called ${functionName} outside of a shader's modify() function.`
          );
        }
      };
    }
  }
  fn2.getTexture = function(...rawArgs) {
    if (strandsContext.active) {
      const { id, dimension } = strandsContext.backend.createGetTextureCall(strandsContext, rawArgs);
      return createStrandsNode(id, dimension, strandsContext);
    } else {
      p53._friendlyError(
        `It looks like you've called getTexture outside of a shader's modify() function.`
      );
    }
  };
  const originalTexture = fn2.texture;
  fn2.texture = function(...args) {
    if (strandsContext.active) {
      return this.getTexture(...args);
    } else {
      return originalTexture.apply(this, args);
    }
  };
  const originalNoise = fn2.noise;
  const originalNoiseDetail = fn2.noiseDetail;
  strandsContext._noiseOctaves = null;
  strandsContext._noiseAmpFalloff = null;
  fn2.noiseDetail = function(lod, falloff) {
    if (!strandsContext.active) {
      return originalNoiseDetail.apply(this, arguments);
    }
    strandsContext._noiseOctaves = lod;
    strandsContext._noiseAmpFalloff = falloff;
  };
  fn2.noise = function(...args) {
    if (!strandsContext.active) {
      return originalNoise.apply(this, args);
    }
    const noiseSnippet = this._renderer.getNoiseShaderSnippet();
    strandsContext.vertexDeclarations.add(noiseSnippet);
    strandsContext.fragmentDeclarations.add(noiseSnippet);
    const strandsArgs = args.flat().map((arg) => p53.strandsNode(arg));
    let nodeArgs;
    if (strandsArgs.length === 3) {
      nodeArgs = [fn2.vec3(strandsArgs[0], strandsArgs[1], strandsArgs[2])];
    } else if (strandsArgs.length === 2) {
      nodeArgs = [fn2.vec3(strandsArgs[0], strandsArgs[1], 0)];
    } else if (strandsArgs.length === 1 && strandsArgs[0].dimension <= 3) {
      if (strandsArgs[0].dimension === 3) {
        nodeArgs = strandsArgs;
      } else if (strandsArgs[0].dimension === 2) {
        nodeArgs = [fn2.vec3(strandsArgs[0], 0)];
      } else {
        nodeArgs = [fn2.vec3(strandsArgs[0], 0, 0)];
      }
    } else {
      p53._friendlyError(
        `It looks like you've called noise() with ${args.length} arguments. It only supports 1D to 3D input.`
      );
    }
    const octaves = strandsContext._noiseOctaves !== null ? strandsContext._noiseOctaves : fn2._getNoiseOctaves();
    const falloff = strandsContext._noiseAmpFalloff !== null ? strandsContext._noiseAmpFalloff : fn2._getNoiseAmpFalloff();
    nodeArgs.push(octaves);
    nodeArgs.push(falloff);
    const { id, dimension } = functionCallNode(strandsContext, "noise", nodeArgs, {
      overloads: [{
        params: [DataType.float3, DataType.int1, DataType.float1],
        returnType: DataType.float1
      }]
    });
    return createStrandsNode(id, dimension, strandsContext);
  };
  for (const type2 in DataType) {
    if (type2 === BaseType.DEFER || type2 === "sampler") {
      continue;
    }
    const typeInfo = DataType[type2];
    const typeAliases = [];
    let pascalTypeName;
    if (/^[ib]vec/.test(typeInfo.fnName)) {
      pascalTypeName = typeInfo.fnName.slice(0, 2).toUpperCase() + typeInfo.fnName.slice(2).toLowerCase();
      typeAliases.push(pascalTypeName.replace("Vec", "Vector"));
    } else {
      pascalTypeName = typeInfo.fnName.charAt(0).toUpperCase() + typeInfo.fnName.slice(1);
      if (pascalTypeName === "Sampler2D") {
        typeAliases.push("Texture");
      } else if (/^vec/.test(typeInfo.fnName)) {
        typeAliases.push(pascalTypeName.replace("Vec", "Vector"));
      }
    }
    fn2[`uniform${pascalTypeName}`] = function(name, defaultValue) {
      const { id, dimension } = variableNode(strandsContext, typeInfo, name);
      strandsContext.uniforms.push({ name, typeInfo, defaultValue });
      return createStrandsNode(id, dimension, strandsContext);
    };
    fn2[`shared${pascalTypeName}`] = function(name) {
      const { id, dimension } = variableNode(strandsContext, typeInfo, name);
      if (!strandsContext.sharedVariables) {
        strandsContext.sharedVariables = /* @__PURE__ */ new Map();
      }
      strandsContext.sharedVariables.set(name, {
        typeInfo,
        usedInVertex: false,
        usedInFragment: false,
        declared: false
      });
      return createStrandsNode(id, dimension, strandsContext);
    };
    fn2[`varying${pascalTypeName}`] = fn2[`shared${pascalTypeName}`];
    for (const typeAlias of typeAliases) {
      fn2[`uniform${typeAlias}`] = fn2[`uniform${pascalTypeName}`];
      fn2[`varying${typeAlias}`] = fn2[`varying${pascalTypeName}`];
      fn2[`shared${typeAlias}`] = fn2[`shared${pascalTypeName}`];
    }
    const originalp5Fn = fn2[typeInfo.fnName];
    fn2[typeInfo.fnName] = function(...args) {
      if (strandsContext.active) {
        if (args.length === 1 && args[0].dimension && args[0].dimension === typeInfo.dimension) {
          const { id, dimension } = functionCallNode(strandsContext, typeInfo.fnName, args, {
            overloads: [{
              params: [args[0].typeInfo()],
              returnType: typeInfo
            }]
          });
          return createStrandsNode(id, dimension, strandsContext);
        } else {
          if (typeInfo.dimension > 1 && args.length === 1 && !Array.isArray(args[0]) && !(args[0] instanceof StrandsNode && args[0].dimension > 1) && (typeInfo.baseType === BaseType.FLOAT || typeInfo.baseType === BaseType.INT || typeInfo.baseType === BaseType.BOOL)) {
            args = Array(typeInfo.dimension).fill(args[0]);
          }
          const { id, dimension } = primitiveConstructorNode(strandsContext, typeInfo, args);
          return createStrandsNode(id, dimension, strandsContext);
        }
      } else if (originalp5Fn) {
        return originalp5Fn.apply(this, args);
      } else {
        p53._friendlyError(
          `It looks like you've called ${typeInfo.fnName} outside of a shader's modify() function.`
        );
      }
    };
  }
}
function createHookArguments(strandsContext, parameters) {
  const args = [];
  const dag = strandsContext.dag;
  for (const param of parameters) {
    if (isStructType(param.type)) {
      const structTypeInfo = structType(param);
      const { id, dimension } = structInstanceNode(strandsContext, structTypeInfo, param.name, []);
      const structNode = createStrandsNode(id, dimension, strandsContext);
      for (let i = 0; i < structTypeInfo.properties.length; i++) {
        const propertyType = structTypeInfo.properties[i];
        Object.defineProperty(structNode, propertyType.name, {
          get() {
            const propNode = getNodeDataFromID(dag, dag.dependsOn[structNode.id][i]);
            const onRebind = (newFieldID) => {
              const oldDeps = dag.dependsOn[structNode.id];
              const newDeps = oldDeps.slice();
              newDeps[i] = newFieldID;
              const rebuilt = structInstanceNode(strandsContext, structTypeInfo, param.name, newDeps);
              structNode.id = rebuilt.id;
            };
            return createStrandsNode(propNode.id, propNode.dimension, strandsContext, onRebind);
          },
          set(val) {
            const oldDependsOn = dag.dependsOn[structNode.id];
            const newDependsOn = [...oldDependsOn];
            let newValueID;
            if (val instanceof StrandsNode) {
              newValueID = val.id;
            } else {
              let newVal = primitiveConstructorNode(strandsContext, propertyType.dataType, val);
              newValueID = newVal.id;
            }
            newDependsOn[i] = newValueID;
            const newStructInfo = structInstanceNode(strandsContext, structTypeInfo, param.name, newDependsOn);
            structNode.id = newStructInfo.id;
          }
        });
      }
      args.push(structNode);
    } else {
      if (param.type.typeName === "sampler") {
        continue;
      }
      if (!param.type.dataType) {
        throw new Error(`Missing dataType for parameter ${param.name} of type ${param.type.typeName}`);
      }
      const typeInfo = param.type.dataType;
      const { id, dimension } = variableNode(strandsContext, typeInfo, param.name);
      const arg = createStrandsNode(id, dimension, strandsContext);
      args.push(arg);
    }
  }
  return args;
}
function enforceReturnTypeMatch(strandsContext, expectedType, returned, hookName) {
  if (!(returned instanceof StrandsNode)) {
    const result = primitiveConstructorNode(strandsContext, expectedType, returned);
    return result.id;
  }
  const dag = strandsContext.dag;
  let returnedNodeID = returned.id;
  const receivedType = {
    baseType: dag.baseTypes[returnedNodeID],
    dimension: dag.dimensions[returnedNodeID]
  };
  if (receivedType.dimension !== expectedType.dimension) {
    if (receivedType.dimension !== 1) {
      userError("type error", `You have returned a vector with ${receivedType.dimension} components in ${hookName} when a ${expectedType.baseType + expectedType.dimension} was expected!`);
    } else {
      const result = primitiveConstructorNode(strandsContext, expectedType, returned);
      returnedNodeID = result.id;
    }
  } else if (receivedType.baseType !== expectedType.baseType) {
    const result = primitiveConstructorNode(strandsContext, expectedType, returned);
    returnedNodeID = result.id;
  }
  return returnedNodeID;
}
function createShaderHooksFunctions(strandsContext, fn2, shader2) {
  const vertexHooksWithContext = Object.fromEntries(
    Object.entries(shader2.hooks.vertex).map(([name, hook]) => [name, { ...hook, shaderContext: "vertex" }])
  );
  const fragmentHooksWithContext = Object.fromEntries(
    Object.entries(shader2.hooks.fragment).map(([name, hook]) => [name, { ...hook, shaderContext: "fragment" }])
  );
  const availableHooks = {
    ...vertexHooksWithContext,
    ...fragmentHooksWithContext
  };
  const hookTypes = Object.keys(availableHooks).map((name) => shader2.hookTypes(name));
  const { cfg, dag } = strandsContext;
  for (const hookType of hookTypes) {
    const hookImplementation = function(hookUserCallback) {
      const entryBlockID = createBasicBlock(cfg, BlockType.FUNCTION);
      addEdge(cfg, cfg.currentBlock, entryBlockID);
      pushBlock(cfg, entryBlockID);
      const args = createHookArguments(strandsContext, hookType.parameters);
      strandsContext.activeHook = hookImplementation;
      const userReturned = hookUserCallback(...args);
      strandsContext.activeHook = void 0;
      const expectedReturnType = hookType.returnType;
      let rootNodeID = null;
      const handleRetVal = (retNode) => {
        if (isStructType(expectedReturnType)) {
          const expectedStructType = structType(expectedReturnType);
          if (retNode instanceof StrandsNode) {
            const returnedNode = getNodeDataFromID(strandsContext.dag, retNode.id);
            if (returnedNode.baseType !== expectedStructType.typeName) {
              userError("type error", `You have returned a ${retNode.baseType} from ${hookType.name} when a ${expectedStructType.typeName} was expected.`);
            }
            const newDeps = returnedNode.dependsOn.slice();
            for (let i = 0; i < expectedStructType.properties.length; i++) {
              const expectedType = expectedStructType.properties[i].dataType;
              const receivedNode = createStrandsNode(returnedNode.dependsOn[i], dag.dependsOn[retNode.id], strandsContext);
              newDeps[i] = enforceReturnTypeMatch(strandsContext, expectedType, receivedNode, hookType.name);
            }
            dag.dependsOn[retNode.id] = newDeps;
            return retNode.id;
          } else {
            const expectedProperties = expectedStructType.properties;
            const newStructDependencies = [];
            for (let i = 0; i < expectedProperties.length; i++) {
              const expectedProp = expectedProperties[i];
              const propName = expectedProp.name;
              const receivedValue = retNode[propName];
              if (receivedValue === void 0) {
                userError("type error", `You've returned an incomplete struct from ${hookType.name}.
Expected: { ${expectedReturnType.properties.map((p2) => p2.name).join(", ")} }
Received: { ${Object.keys(retNode).join(", ")} }
All of the properties are required!`);
              }
              const expectedTypeInfo = expectedProp.dataType;
              const returnedPropID = enforceReturnTypeMatch(strandsContext, expectedTypeInfo, receivedValue, hookType.name);
              newStructDependencies.push(returnedPropID);
            }
            const newStruct = structConstructorNode(strandsContext, expectedStructType, newStructDependencies);
            return newStruct.id;
          }
        } else {
          if (!expectedReturnType.dataType) {
            throw new Error(`Missing dataType for return type ${expectedReturnType.typeName}`);
          }
          const expectedTypeInfo = expectedReturnType.dataType;
          return enforceReturnTypeMatch(strandsContext, expectedTypeInfo, retNode, hookType.name);
        }
      };
      for (const { valueNode, earlyReturnID } of hookImplementation.earlyReturns) {
        const id = handleRetVal(valueNode);
        dag.dependsOn[earlyReturnID] = [id];
      }
      rootNodeID = userReturned ? handleRetVal(userReturned) : void 0;
      const fullHookName = `${hookType.returnType.typeName} ${hookType.name}`;
      const hookInfo = availableHooks[fullHookName];
      strandsContext.hooks.push({
        hookType,
        entryBlockID,
        rootNodeID,
        shaderContext: hookInfo?.shaderContext
        // 'vertex' or 'fragment'
      });
      popBlock(cfg);
    };
    hookImplementation.earlyReturns = [];
    strandsContext.windowOverrides[hookType.name] = window[hookType.name];
    strandsContext.fnOverrides[hookType.name] = fn2[hookType.name];
    window[hookType.name] = hookImplementation;
    fn2[hookType.name] = hookImplementation;
  }
}
function strands(p53, fn2) {
  function initStrandsContext(ctx, backend, { active = false, renderer: renderer2 = null, baseShader = null } = {}) {
    ctx.dag = createDirectedAcyclicGraph();
    ctx.cfg = createControlFlowGraph();
    ctx.uniforms = [];
    ctx.vertexDeclarations = /* @__PURE__ */ new Set();
    ctx.fragmentDeclarations = /* @__PURE__ */ new Set();
    ctx.hooks = [];
    ctx.globalAssignments = [];
    ctx.backend = backend;
    ctx.active = active;
    ctx.renderer = renderer2;
    ctx.baseShader = baseShader;
    ctx.previousFES = p53.disableFriendlyErrors;
    ctx.windowOverrides = {};
    ctx.fnOverrides = {};
    if (active) {
      p53.disableFriendlyErrors = true;
    }
    ctx.p5 = p53;
  }
  function deinitStrandsContext(ctx) {
    ctx.dag = createDirectedAcyclicGraph();
    ctx.cfg = createControlFlowGraph();
    ctx.uniforms = [];
    ctx.vertexDeclarations = /* @__PURE__ */ new Set();
    ctx.fragmentDeclarations = /* @__PURE__ */ new Set();
    ctx.hooks = [];
    ctx.globalAssignments = [];
    ctx.active = false;
    p53.disableFriendlyErrors = ctx.previousFES;
    for (const key in ctx.windowOverrides) {
      window[key] = ctx.windowOverrides[key];
    }
    for (const key in ctx.fnOverrides) {
      fn2[key] = ctx.fnOverrides[key];
    }
  }
  const strandsContext = {};
  initStrandsContext(strandsContext);
  initGlobalStrandsAPI(p53, fn2, strandsContext);
  const oldModify = p53.Shader.prototype.modify;
  p53.Shader.prototype.modify = function(shaderModifier, scope = {}) {
    try {
      if (shaderModifier instanceof Function || typeof shaderModifier === "string") {
        initStrandsContext(strandsContext, this._renderer.strandsBackend, {
          active: true,
          renderer: this._renderer,
          baseShader: this
        });
        createShaderHooksFunctions(strandsContext, fn2, this);
        const options2 = { parser: true, srcLocations: false };
        let strandsCallback;
        if (options2.parser) {
          const sourceString = typeof shaderModifier === "string" ? `(${shaderModifier})` : `(${shaderModifier.toString()})`;
          strandsCallback = transpileStrandsToJS(
            p53,
            sourceString,
            options2.srcLocations,
            scope
          );
        }
        const globalScope = createBasicBlock(
          strandsContext.cfg,
          BlockType.GLOBAL
        );
        pushBlock(strandsContext.cfg, globalScope);
        strandsCallback();
        popBlock(strandsContext.cfg);
        const hooksObject = generateShaderCode(strandsContext);
        return oldModify.call(this, hooksObject);
      } else {
        return oldModify.call(this, shaderModifier);
      }
    } finally {
      deinitStrandsContext(strandsContext);
    }
  };
}
if (typeof p5 !== "undefined") {
  p5.registerAddon(strands);
}
const _globalInit = () => {
  if (typeof window._setupDone !== "undefined") {
    console.warn(
      "p5.js seems to have been imported multiple times. Please remove the duplicate import"
    );
    return;
  }
  if (!window.mocha) {
    const p5ReadyEvent = new Event("p5Ready");
    window.dispatchEvent(p5ReadyEvent);
    if ((window.setup && typeof window.setup === "function" || window.draw && typeof window.draw === "function") && !p5$2.instance) {
      new p5$2();
    }
  }
};
const waitForDocumentReady = () => new Promise((resolve, reject) => {
  if (document.readyState === "complete") {
    resolve();
  } else {
    window.addEventListener("load", resolve, false);
  }
});
const waitingForTranslator = typeof IS_MINIFIED === "undefined" ? initialize() : Promise.resolve();
shape(p5$2);
accessibility(p5$2);
color(p5$2);
friendlyErrors(p5$2);
data(p5$2);
dom(p5$2);
events(p5$2);
image(p5$2);
io(p5$2);
math(p5$2);
utilities(p5$2);
webgl(p5$2);
type(p5$2);
p5$2.registerAddon(shader);
p5$2.registerAddon(strands);
Promise.all([waitForDocumentReady(), waitingForTranslator]).then(_globalInit);
class Controller {
  constructor(parent, object2, property, className, elementType = "div") {
    this.parent = parent;
    this.object = object2;
    this.property = property;
    this._disabled = false;
    this._hidden = false;
    this.initialValue = this.getValue();
    this.domElement = document.createElement(elementType);
    this.domElement.classList.add("lil-controller");
    this.domElement.classList.add(className);
    this.$name = document.createElement("div");
    this.$name.classList.add("lil-name");
    Controller.nextNameID = Controller.nextNameID || 0;
    this.$name.id = `lil-gui-name-${++Controller.nextNameID}`;
    this.$widget = document.createElement("div");
    this.$widget.classList.add("lil-widget");
    this.$disable = this.$widget;
    this.domElement.appendChild(this.$name);
    this.domElement.appendChild(this.$widget);
    this.domElement.addEventListener("keydown", (e2) => e2.stopPropagation());
    this.domElement.addEventListener("keyup", (e2) => e2.stopPropagation());
    this.parent.children.push(this);
    this.parent.controllers.push(this);
    this.parent.$children.appendChild(this.domElement);
    this._listenCallback = this._listenCallback.bind(this);
    this.name(property);
  }
  /**
   * Sets the name of the controller and its label in the GUI.
   * @param {string} name
   * @returns {this}
   */
  name(name) {
    this._name = name;
    this.$name.textContent = name;
    return this;
  }
  /**
   * Pass a function to be called whenever the value is modified by this controller.
   * The function receives the new value as its first parameter. The value of `this` will be the
   * controller.
   *
   * For function controllers, the `onChange` callback will be fired on click, after the function
   * executes.
   * @param {Function} callback
   * @returns {this}
   * @example
   * const controller = gui.add( object, 'property' );
   *
   * controller.onChange( function( v ) {
   * 	console.log( 'The value is now ' + v );
   * 	console.assert( this === controller );
   * } );
   */
  onChange(callback) {
    this._onChange = callback;
    return this;
  }
  /**
   * Calls the onChange methods of this controller and its parent GUI.
   * @protected
   */
  _callOnChange() {
    this.parent._callOnChange(this);
    if (this._onChange !== void 0) {
      this._onChange.call(this, this.getValue());
    }
    this._changed = true;
  }
  /**
   * Pass a function to be called after this controller has been modified and loses focus.
   * @param {Function} callback
   * @returns {this}
   * @example
   * const controller = gui.add( object, 'property' );
   *
   * controller.onFinishChange( function( v ) {
   * 	console.log( 'Changes complete: ' + v );
   * 	console.assert( this === controller );
   * } );
   */
  onFinishChange(callback) {
    this._onFinishChange = callback;
    return this;
  }
  /**
   * Should be called by Controller when its widgets lose focus.
   * @protected
   */
  _callOnFinishChange() {
    if (this._changed) {
      this.parent._callOnFinishChange(this);
      if (this._onFinishChange !== void 0) {
        this._onFinishChange.call(this, this.getValue());
      }
    }
    this._changed = false;
  }
  /**
   * Sets the controller back to its initial value.
   * @returns {this}
   */
  reset() {
    this.setValue(this.initialValue);
    this._callOnFinishChange();
    return this;
  }
  /**
   * Enables this controller.
   * @param {boolean} enabled
   * @returns {this}
   * @example
   * controller.enable();
   * controller.enable( false ); // disable
   * controller.enable( controller._disabled ); // toggle
   */
  enable(enabled = true) {
    return this.disable(!enabled);
  }
  /**
   * Disables this controller.
   * @param {boolean} disabled
   * @returns {this}
   * @example
   * controller.disable();
   * controller.disable( false ); // enable
   * controller.disable( !controller._disabled ); // toggle
   */
  disable(disabled = true) {
    if (disabled === this._disabled) return this;
    this._disabled = disabled;
    this.domElement.classList.toggle("lil-disabled", disabled);
    this.$disable.toggleAttribute("disabled", disabled);
    return this;
  }
  /**
   * Shows the Controller after it's been hidden.
   * @param {boolean} show
   * @returns {this}
   * @example
   * controller.show();
   * controller.show( false ); // hide
   * controller.show( controller._hidden ); // toggle
   */
  show(show = true) {
    this._hidden = !show;
    this.domElement.style.display = this._hidden ? "none" : "";
    return this;
  }
  /**
   * Hides the Controller.
   * @returns {this}
   */
  hide() {
    return this.show(false);
  }
  /**
   * Changes this controller into a dropdown of options.
   *
   * Calling this method on an option controller will simply update the options. However, if this
   * controller was not already an option controller, old references to this controller are
   * destroyed, and a new controller is added to the end of the GUI.
   * @example
   * // safe usage
   *
   * gui.add( obj, 'prop1' ).options( [ 'a', 'b', 'c' ] );
   * gui.add( obj, 'prop2' ).options( { Big: 10, Small: 1 } );
   * gui.add( obj, 'prop3' );
   *
   * // danger
   *
   * const ctrl1 = gui.add( obj, 'prop1' );
   * gui.add( obj, 'prop2' );
   *
   * // calling options out of order adds a new controller to the end...
   * const ctrl2 = ctrl1.options( [ 'a', 'b', 'c' ] );
   *
   * // ...and ctrl1 now references a controller that doesn't exist
   * assert( ctrl2 !== ctrl1 )
   * @param {object|Array} options
   * @returns {Controller}
   */
  options(options2) {
    const controller = this.parent.add(this.object, this.property, options2);
    controller.name(this._name);
    this.destroy();
    return controller;
  }
  /**
   * Sets the minimum value. Only works on number controllers.
   * @param {number} min
   * @returns {this}
   */
  min(min) {
    return this;
  }
  /**
   * Sets the maximum value. Only works on number controllers.
   * @param {number} max
   * @returns {this}
   */
  max(max) {
    return this;
  }
  /**
   * Values set by this controller will be rounded to multiples of `step`. Only works on number
   * controllers.
   * @param {number} step
   * @returns {this}
   */
  step(step) {
    return this;
  }
  /**
   * Rounds the displayed value to a fixed number of decimals, without affecting the actual value
   * like `step()`. Only works on number controllers.
   * @example
   * gui.add( object, 'property' ).listen().decimals( 4 );
   * @param {number} decimals
   * @returns {this}
   */
  decimals(decimals) {
    return this;
  }
  /**
   * Calls `updateDisplay()` every animation frame. Pass `false` to stop listening.
   * @param {boolean} listen
   * @returns {this}
   */
  listen(listen = true) {
    this._listening = listen;
    if (this._listenCallbackID !== void 0) {
      cancelAnimationFrame(this._listenCallbackID);
      this._listenCallbackID = void 0;
    }
    if (this._listening) {
      this._listenCallback();
    }
    return this;
  }
  _listenCallback() {
    this._listenCallbackID = requestAnimationFrame(this._listenCallback);
    const curValue = this.save();
    if (curValue !== this._listenPrevValue) {
      this.updateDisplay();
    }
    this._listenPrevValue = curValue;
  }
  /**
   * Returns `object[ property ]`.
   * @returns {any}
   */
  getValue() {
    return this.object[this.property];
  }
  /**
   * Sets the value of `object[ property ]`, invokes any `onChange` handlers and updates the display.
   * @param {any} value
   * @returns {this}
   */
  setValue(value) {
    if (this.getValue() !== value) {
      this.object[this.property] = value;
      this._callOnChange();
      this.updateDisplay();
    }
    return this;
  }
  /**
   * Updates the display to keep it in sync with the current value. Useful for updating your
   * controllers when their values have been modified outside of the GUI.
   * @returns {this}
   */
  updateDisplay() {
    return this;
  }
  load(value) {
    this.setValue(value);
    this._callOnFinishChange();
    return this;
  }
  save() {
    return this.getValue();
  }
  /**
   * Destroys this controller and removes it from the parent GUI.
   */
  destroy() {
    this.listen(false);
    this.parent.children.splice(this.parent.children.indexOf(this), 1);
    this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1);
    this.parent.$children.removeChild(this.domElement);
  }
}
class BooleanController extends Controller {
  constructor(parent, object2, property) {
    super(parent, object2, property, "lil-boolean", "label");
    this.$input = document.createElement("input");
    this.$input.setAttribute("type", "checkbox");
    this.$input.setAttribute("aria-labelledby", this.$name.id);
    this.$widget.appendChild(this.$input);
    this.$input.addEventListener("change", () => {
      this.setValue(this.$input.checked);
      this._callOnFinishChange();
    });
    this.$disable = this.$input;
    this.updateDisplay();
  }
  updateDisplay() {
    this.$input.checked = this.getValue();
    return this;
  }
}
function normalizeColorString(string2) {
  let match, result;
  if (match = string2.match(/(#|0x)?([a-f0-9]{6})/i)) {
    result = match[2];
  } else if (match = string2.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) {
    result = parseInt(match[1]).toString(16).padStart(2, 0) + parseInt(match[2]).toString(16).padStart(2, 0) + parseInt(match[3]).toString(16).padStart(2, 0);
  } else if (match = string2.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) {
    result = match[1] + match[1] + match[2] + match[2] + match[3] + match[3];
  }
  if (result) {
    return "#" + result;
  }
  return false;
}
const STRING = {
  isPrimitive: true,
  match: (v) => typeof v === "string",
  fromHexString: normalizeColorString,
  toHexString: normalizeColorString
};
const INT = {
  isPrimitive: true,
  match: (v) => typeof v === "number",
  fromHexString: (string2) => parseInt(string2.substring(1), 16),
  toHexString: (value) => "#" + value.toString(16).padStart(6, 0)
};
const ARRAY = {
  isPrimitive: false,
  match: (v) => Array.isArray(v) || ArrayBuffer.isView(v),
  fromHexString(string2, target, rgbScale = 1) {
    const int2 = INT.fromHexString(string2);
    target[0] = (int2 >> 16 & 255) / 255 * rgbScale;
    target[1] = (int2 >> 8 & 255) / 255 * rgbScale;
    target[2] = (int2 & 255) / 255 * rgbScale;
  },
  toHexString([r, g2, b2], rgbScale = 1) {
    rgbScale = 255 / rgbScale;
    const int2 = r * rgbScale << 16 ^ g2 * rgbScale << 8 ^ b2 * rgbScale << 0;
    return INT.toHexString(int2);
  }
};
const OBJECT = {
  isPrimitive: false,
  match: (v) => Object(v) === v,
  fromHexString(string2, target, rgbScale = 1) {
    const int2 = INT.fromHexString(string2);
    target.r = (int2 >> 16 & 255) / 255 * rgbScale;
    target.g = (int2 >> 8 & 255) / 255 * rgbScale;
    target.b = (int2 & 255) / 255 * rgbScale;
  },
  toHexString({ r, g: g2, b: b2 }, rgbScale = 1) {
    rgbScale = 255 / rgbScale;
    const int2 = r * rgbScale << 16 ^ g2 * rgbScale << 8 ^ b2 * rgbScale << 0;
    return INT.toHexString(int2);
  }
};
const FORMATS = [STRING, INT, ARRAY, OBJECT];
function getColorFormat(value) {
  return FORMATS.find((format) => format.match(value));
}
class ColorController extends Controller {
  constructor(parent, object2, property, rgbScale) {
    super(parent, object2, property, "lil-color");
    this.$input = document.createElement("input");
    this.$input.setAttribute("type", "color");
    this.$input.setAttribute("tabindex", -1);
    this.$input.setAttribute("aria-labelledby", this.$name.id);
    this.$text = document.createElement("input");
    this.$text.setAttribute("type", "text");
    this.$text.setAttribute("spellcheck", "false");
    this.$text.setAttribute("aria-labelledby", this.$name.id);
    this.$display = document.createElement("div");
    this.$display.classList.add("lil-display");
    this.$display.appendChild(this.$input);
    this.$widget.appendChild(this.$display);
    this.$widget.appendChild(this.$text);
    this._format = getColorFormat(this.initialValue);
    this._rgbScale = rgbScale;
    this._initialValueHexString = this.save();
    this._textFocused = false;
    this.$input.addEventListener("input", () => {
      this._setValueFromHexString(this.$input.value);
    });
    this.$input.addEventListener("blur", () => {
      this._callOnFinishChange();
    });
    this.$text.addEventListener("input", () => {
      const tryParse = normalizeColorString(this.$text.value);
      if (tryParse) {
        this._setValueFromHexString(tryParse);
      }
    });
    this.$text.addEventListener("focus", () => {
      this._textFocused = true;
      this.$text.select();
    });
    this.$text.addEventListener("blur", () => {
      this._textFocused = false;
      this.updateDisplay();
      this._callOnFinishChange();
    });
    this.$disable = this.$text;
    this.updateDisplay();
  }
  reset() {
    this._setValueFromHexString(this._initialValueHexString);
    return this;
  }
  _setValueFromHexString(value) {
    if (this._format.isPrimitive) {
      const newValue = this._format.fromHexString(value);
      this.setValue(newValue);
    } else {
      this._format.fromHexString(value, this.getValue(), this._rgbScale);
      this._callOnChange();
      this.updateDisplay();
    }
  }
  save() {
    return this._format.toHexString(this.getValue(), this._rgbScale);
  }
  load(value) {
    this._setValueFromHexString(value);
    this._callOnFinishChange();
    return this;
  }
  updateDisplay() {
    this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale);
    if (!this._textFocused) {
      this.$text.value = this.$input.value.substring(1);
    }
    this.$display.style.backgroundColor = this.$input.value;
    return this;
  }
}
class FunctionController extends Controller {
  constructor(parent, object2, property) {
    super(parent, object2, property, "lil-function");
    this.$button = document.createElement("button");
    this.$button.appendChild(this.$name);
    this.$widget.appendChild(this.$button);
    this.$button.addEventListener("click", (e2) => {
      e2.preventDefault();
      this.getValue().call(this.object);
      this._callOnChange();
    });
    this.$button.addEventListener("touchstart", () => {
    }, { passive: true });
    this.$disable = this.$button;
  }
}
class NumberController extends Controller {
  constructor(parent, object2, property, min, max, step) {
    super(parent, object2, property, "lil-number");
    this._initInput();
    this.min(min);
    this.max(max);
    const stepExplicit = step !== void 0;
    this.step(stepExplicit ? step : this._getImplicitStep(), stepExplicit);
    this.updateDisplay();
  }
  decimals(decimals) {
    this._decimals = decimals;
    this.updateDisplay();
    return this;
  }
  min(min) {
    this._min = min;
    this._onUpdateMinMax();
    return this;
  }
  max(max) {
    this._max = max;
    this._onUpdateMinMax();
    return this;
  }
  step(step, explicit = true) {
    this._step = step;
    this._stepExplicit = explicit;
    return this;
  }
  updateDisplay() {
    const value = this.getValue();
    if (this._hasSlider) {
      let percent = (value - this._min) / (this._max - this._min);
      percent = Math.max(0, Math.min(percent, 1));
      this.$fill.style.width = percent * 100 + "%";
    }
    if (!this._inputFocused) {
      this.$input.value = this._decimals === void 0 ? value : value.toFixed(this._decimals);
    }
    return this;
  }
  _initInput() {
    this.$input = document.createElement("input");
    this.$input.setAttribute("type", "text");
    this.$input.setAttribute("aria-labelledby", this.$name.id);
    const isTouch = window.matchMedia("(pointer: coarse)").matches;
    if (isTouch) {
      this.$input.setAttribute("type", "number");
      this.$input.setAttribute("step", "any");
    }
    this.$widget.appendChild(this.$input);
    this.$disable = this.$input;
    const onInput = () => {
      let value = parseFloat(this.$input.value);
      if (isNaN(value)) return;
      if (this._stepExplicit) {
        value = this._snap(value);
      }
      this.setValue(this._clamp(value));
    };
    const increment = (delta) => {
      const value = parseFloat(this.$input.value);
      if (isNaN(value)) return;
      this._snapClampSetValue(value + delta);
      this.$input.value = this.getValue();
    };
    const onKeyDown = (e2) => {
      if (e2.key === "Enter") {
        this.$input.blur();
      }
      if (e2.code === "ArrowUp") {
        e2.preventDefault();
        increment(this._step * this._arrowKeyMultiplier(e2));
      }
      if (e2.code === "ArrowDown") {
        e2.preventDefault();
        increment(this._step * this._arrowKeyMultiplier(e2) * -1);
      }
    };
    const onWheel = (e2) => {
      if (this._inputFocused) {
        e2.preventDefault();
        increment(this._step * this._normalizeMouseWheel(e2));
      }
    };
    let testingForVerticalDrag = false, initClientX, initClientY, prevClientY, initValue, dragDelta;
    const DRAG_THRESH = 5;
    const onMouseDown = (e2) => {
      initClientX = e2.clientX;
      initClientY = prevClientY = e2.clientY;
      testingForVerticalDrag = true;
      initValue = this.getValue();
      dragDelta = 0;
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
    };
    const onMouseMove = (e2) => {
      if (testingForVerticalDrag) {
        const dx = e2.clientX - initClientX;
        const dy = e2.clientY - initClientY;
        if (Math.abs(dy) > DRAG_THRESH) {
          e2.preventDefault();
          this.$input.blur();
          testingForVerticalDrag = false;
          this._setDraggingStyle(true, "vertical");
        } else if (Math.abs(dx) > DRAG_THRESH) {
          onMouseUp();
        }
      }
      if (!testingForVerticalDrag) {
        const dy = e2.clientY - prevClientY;
        dragDelta -= dy * this._step * this._arrowKeyMultiplier(e2);
        if (initValue + dragDelta > this._max) {
          dragDelta = this._max - initValue;
        } else if (initValue + dragDelta < this._min) {
          dragDelta = this._min - initValue;
        }
        this._snapClampSetValue(initValue + dragDelta);
      }
      prevClientY = e2.clientY;
    };
    const onMouseUp = () => {
      this._setDraggingStyle(false, "vertical");
      this._callOnFinishChange();
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
    };
    const onFocus = () => {
      this._inputFocused = true;
    };
    const onBlur = () => {
      this._inputFocused = false;
      this.updateDisplay();
      this._callOnFinishChange();
    };
    this.$input.addEventListener("input", onInput);
    this.$input.addEventListener("keydown", onKeyDown);
    this.$input.addEventListener("wheel", onWheel, { passive: false });
    this.$input.addEventListener("mousedown", onMouseDown);
    this.$input.addEventListener("focus", onFocus);
    this.$input.addEventListener("blur", onBlur);
  }
  _initSlider() {
    this._hasSlider = true;
    this.$slider = document.createElement("div");
    this.$slider.classList.add("lil-slider");
    this.$fill = document.createElement("div");
    this.$fill.classList.add("lil-fill");
    this.$slider.appendChild(this.$fill);
    this.$widget.insertBefore(this.$slider, this.$input);
    this.domElement.classList.add("lil-has-slider");
    const map2 = (v, a, b2, c, d2) => {
      return (v - a) / (b2 - a) * (d2 - c) + c;
    };
    const setValueFromX = (clientX) => {
      const rect = this.$slider.getBoundingClientRect();
      let value = map2(clientX, rect.left, rect.right, this._min, this._max);
      this._snapClampSetValue(value);
    };
    const mouseDown = (e2) => {
      this._setDraggingStyle(true);
      setValueFromX(e2.clientX);
      window.addEventListener("mousemove", mouseMove);
      window.addEventListener("mouseup", mouseUp);
    };
    const mouseMove = (e2) => {
      setValueFromX(e2.clientX);
    };
    const mouseUp = () => {
      this._callOnFinishChange();
      this._setDraggingStyle(false);
      window.removeEventListener("mousemove", mouseMove);
      window.removeEventListener("mouseup", mouseUp);
    };
    let testingForScroll = false, prevClientX, prevClientY;
    const beginTouchDrag = (e2) => {
      e2.preventDefault();
      this._setDraggingStyle(true);
      setValueFromX(e2.touches[0].clientX);
      testingForScroll = false;
    };
    const onTouchStart = (e2) => {
      if (e2.touches.length > 1) return;
      if (this._hasScrollBar) {
        prevClientX = e2.touches[0].clientX;
        prevClientY = e2.touches[0].clientY;
        testingForScroll = true;
      } else {
        beginTouchDrag(e2);
      }
      window.addEventListener("touchmove", onTouchMove, { passive: false });
      window.addEventListener("touchend", onTouchEnd);
    };
    const onTouchMove = (e2) => {
      if (testingForScroll) {
        const dx = e2.touches[0].clientX - prevClientX;
        const dy = e2.touches[0].clientY - prevClientY;
        if (Math.abs(dx) > Math.abs(dy)) {
          beginTouchDrag(e2);
        } else {
          window.removeEventListener("touchmove", onTouchMove);
          window.removeEventListener("touchend", onTouchEnd);
        }
      } else {
        e2.preventDefault();
        setValueFromX(e2.touches[0].clientX);
      }
    };
    const onTouchEnd = () => {
      this._callOnFinishChange();
      this._setDraggingStyle(false);
      window.removeEventListener("touchmove", onTouchMove);
      window.removeEventListener("touchend", onTouchEnd);
    };
    const callOnFinishChange = this._callOnFinishChange.bind(this);
    const WHEEL_DEBOUNCE_TIME = 400;
    let wheelFinishChangeTimeout;
    const onWheel = (e2) => {
      const isVertical = Math.abs(e2.deltaX) < Math.abs(e2.deltaY);
      if (isVertical && this._hasScrollBar) return;
      e2.preventDefault();
      const delta = this._normalizeMouseWheel(e2) * this._step;
      this._snapClampSetValue(this.getValue() + delta);
      this.$input.value = this.getValue();
      clearTimeout(wheelFinishChangeTimeout);
      wheelFinishChangeTimeout = setTimeout(callOnFinishChange, WHEEL_DEBOUNCE_TIME);
    };
    this.$slider.addEventListener("mousedown", mouseDown);
    this.$slider.addEventListener("touchstart", onTouchStart, { passive: false });
    this.$slider.addEventListener("wheel", onWheel, { passive: false });
  }
  _setDraggingStyle(active, axis = "horizontal") {
    if (this.$slider) {
      this.$slider.classList.toggle("lil-active", active);
    }
    document.body.classList.toggle("lil-dragging", active);
    document.body.classList.toggle(`lil-${axis}`, active);
  }
  _getImplicitStep() {
    if (this._hasMin && this._hasMax) {
      return (this._max - this._min) / 1e3;
    }
    return 0.1;
  }
  _onUpdateMinMax() {
    if (!this._hasSlider && this._hasMin && this._hasMax) {
      if (!this._stepExplicit) {
        this.step(this._getImplicitStep(), false);
      }
      this._initSlider();
      this.updateDisplay();
    }
  }
  _normalizeMouseWheel(e2) {
    let { deltaX, deltaY } = e2;
    if (Math.floor(e2.deltaY) !== e2.deltaY && e2.wheelDelta) {
      deltaX = 0;
      deltaY = -e2.wheelDelta / 120;
      deltaY *= this._stepExplicit ? 1 : 10;
    }
    const wheel = deltaX + -deltaY;
    return wheel;
  }
  _arrowKeyMultiplier(e2) {
    let mult = this._stepExplicit ? 1 : 10;
    if (e2.shiftKey) {
      mult *= 10;
    } else if (e2.altKey) {
      mult /= 10;
    }
    return mult;
  }
  _snap(value) {
    let offset2 = 0;
    if (this._hasMin) {
      offset2 = this._min;
    } else if (this._hasMax) {
      offset2 = this._max;
    }
    value -= offset2;
    value = Math.round(value / this._step) * this._step;
    value += offset2;
    value = parseFloat(value.toPrecision(15));
    return value;
  }
  _clamp(value) {
    if (value < this._min) value = this._min;
    if (value > this._max) value = this._max;
    return value;
  }
  _snapClampSetValue(value) {
    this.setValue(this._clamp(this._snap(value)));
  }
  get _hasScrollBar() {
    const root = this.parent.root.$children;
    return root.scrollHeight > root.clientHeight;
  }
  get _hasMin() {
    return this._min !== void 0;
  }
  get _hasMax() {
    return this._max !== void 0;
  }
}
class OptionController extends Controller {
  constructor(parent, object2, property, options2) {
    super(parent, object2, property, "lil-option");
    this.$select = document.createElement("select");
    this.$select.setAttribute("aria-labelledby", this.$name.id);
    this.$display = document.createElement("div");
    this.$display.classList.add("lil-display");
    this.$select.addEventListener("change", () => {
      this.setValue(this._values[this.$select.selectedIndex]);
      this._callOnFinishChange();
    });
    this.$select.addEventListener("focus", () => {
      this.$display.classList.add("lil-focus");
    });
    this.$select.addEventListener("blur", () => {
      this.$display.classList.remove("lil-focus");
    });
    this.$widget.appendChild(this.$select);
    this.$widget.appendChild(this.$display);
    this.$disable = this.$select;
    this.options(options2);
  }
  options(options2) {
    this._values = Array.isArray(options2) ? options2 : Object.values(options2);
    this._names = Array.isArray(options2) ? options2 : Object.keys(options2);
    this.$select.replaceChildren();
    this._names.forEach((name) => {
      const $option = document.createElement("option");
      $option.textContent = name;
      this.$select.appendChild($option);
    });
    this.updateDisplay();
    return this;
  }
  updateDisplay() {
    const value = this.getValue();
    const index = this._values.indexOf(value);
    this.$select.selectedIndex = index;
    this.$display.textContent = index === -1 ? value : this._names[index];
    return this;
  }
}
class StringController extends Controller {
  constructor(parent, object2, property) {
    super(parent, object2, property, "lil-string");
    this.$input = document.createElement("input");
    this.$input.setAttribute("type", "text");
    this.$input.setAttribute("spellcheck", "false");
    this.$input.setAttribute("aria-labelledby", this.$name.id);
    this.$input.addEventListener("input", () => {
      this.setValue(this.$input.value);
    });
    this.$input.addEventListener("keydown", (e2) => {
      if (e2.code === "Enter") {
        this.$input.blur();
      }
    });
    this.$input.addEventListener("blur", () => {
      this._callOnFinishChange();
    });
    this.$widget.appendChild(this.$input);
    this.$disable = this.$input;
    this.updateDisplay();
  }
  updateDisplay() {
    this.$input.value = this.getValue();
    return this;
  }
}
var stylesheet = `.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.lil-root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.lil-root > .lil-title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.lil-root > .lil-children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.lil-root > .lil-children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.lil-root > .lil-children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.lil-allow-touch-styles, .lil-gui.lil-allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.lil-force-touch-styles, .lil-gui.lil-force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.lil-auto-place, .lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-controller.lil-disabled {
  opacity: 0.5;
}
.lil-controller.lil-disabled, .lil-controller.lil-disabled * {
  pointer-events: none !important;
}
.lil-controller > .lil-name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-controller .lil-widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-controller.lil-string input {
  color: var(--string-color);
}
.lil-controller.lil-boolean {
  cursor: pointer;
}
.lil-controller.lil-color .lil-display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-controller.lil-color .lil-display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-controller.lil-color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-controller.lil-color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-controller.lil-option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-controller.lil-option .lil-display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-controller.lil-option .lil-display.lil-focus {
    background: var(--focus-color);
  }
}
.lil-controller.lil-option .lil-display.lil-active {
  background: var(--focus-color);
}
.lil-controller.lil-option .lil-display:after {
  font-family: "lil-gui";
  content: "↕";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-controller.lil-option .lil-widget,
.lil-controller.lil-option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-controller.lil-option .lil-widget:hover .lil-display {
    background: var(--hover-color);
  }
}
.lil-controller.lil-number input {
  color: var(--number-color);
}
.lil-controller.lil-number.lil-has-slider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-controller.lil-number .lil-slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-controller.lil-number .lil-slider:hover {
    background: var(--hover-color);
  }
}
.lil-controller.lil-number .lil-slider.lil-active {
  background: var(--focus-color);
}
.lil-controller.lil-number .lil-slider.lil-active .lil-fill {
  opacity: 0.95;
}
.lil-controller.lil-number .lil-fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-dragging * {
  cursor: ew-resize !important;
}
.lil-dragging.lil-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .lil-title {
  height: var(--title-height);
  font-weight: 600;
  padding: 0 var(--padding);
  width: 100%;
  text-align: left;
  background: none;
  text-decoration-skip: objects;
}
.lil-gui .lil-title:before {
  font-family: "lil-gui";
  content: "▾";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .lil-title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-dragging) .lil-gui .lil-title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .lil-title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.lil-root > .lil-title:focus {
  text-decoration: none !important;
}
.lil-gui.lil-closed > .lil-title:before {
  content: "▸";
}
.lil-gui.lil-closed > .lil-children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.lil-closed:not(.lil-transition) > .lil-children {
  display: none;
}
.lil-gui.lil-transition > .lil-children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .lil-children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.lil-root > .lil-children > .lil-gui > .lil-title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.lil-root > .lil-children > .lil-gui.lil-closed > .lil-title {
  border-bottom-color: transparent;
}
.lil-gui + .lil-controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .lil-title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .lil-children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .lil-controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "✓";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  border: none;
}
.lil-gui .lil-controller button {
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
}
@media (hover: hover) {
  .lil-gui .lil-controller button:hover {
    background: var(--hover-color);
  }
  .lil-gui .lil-controller button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui .lil-controller button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff2;charset=utf-8;base64,d09GMgABAAAAAALkAAsAAAAABtQAAAKVAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFQGYACDMgqBBIEbATYCJAMUCwwABCAFhAoHgQQbHAbIDiUFEYVARAAAYQTVWNmz9MxhEgodq49wYRUFKE8GWNiUBxI2LBRaVnc51U83Gmhs0Q7JXWMiz5eteLwrKwuxHO8VFxUX9UpZBs6pa5ABRwHA+t3UxUnH20EvVknRerzQgX6xC/GH6ZUvTcAjAv122dF28OTqCXrPuyaDER30YBA1xnkVutDDo4oCi71Ca7rrV9xS8dZHbPHefsuwIyCpmT7j+MnjAH5X3984UZoFFuJ0yiZ4XEJFxjagEBeqs+e1iyK8Xf/nOuwF+vVK0ur765+vf7txotUi0m3N0m/84RGSrBCNrh8Ee5GjODjF4gnWP+dJrH/Lk9k4oT6d+gr6g/wssA2j64JJGP6cmx554vUZnpZfn6ZfX2bMwPPrlANsB86/DiHjhl0OP+c87+gaJo/gY084s3HoYL/ZkWHTRfBXvvoHnnkHvngKun4KBE/ede7tvq3/vQOxDXB1/fdNz6XbPdcr0Vhpojj9dG+owuSKFsslCi1tgEjirjXdwMiov2EioadxmqTHUCIwo8NgQaeIasAi0fTYSPTbSmwbMOFduyh9wvBrESGY0MtgRjtgQR8Q1bRPohn2UoCRZf9wyYANMXFeJTysqAe0I4mrherOekFdKMrYvJjLvOIUM9SuwYB5DVZUwwVjJJOaUnZCmcEkIZZrKqNvRGRMvmFZsmhP4VMKCSXBhSqUBxgMS7h0cZvEd71AWkEhGWaeMFcNnpqyJkyXgYL7PQ1MoSq0wDAkRtJIijkZSmqYTiSImfLiSWXIZwhRh3Rug2X0kk1Dgj+Iu43u5p98ghopcpSo0Uyc8SnjlYX59WUeaMoDqmVD2TOWD9a4pCRAzf2ECgwGcrHjPOWY9bNxq/OL3I/QjwEAAAA=") format("woff2");
}`;
function _injectStyles(cssContent) {
  const injected = document.createElement("style");
  injected.innerHTML = cssContent;
  const before = document.querySelector("head link[rel=stylesheet], head style");
  if (before) {
    document.head.insertBefore(injected, before);
  } else {
    document.head.appendChild(injected);
  }
}
let stylesInjected = false;
class GUI {
  /**
   * Creates a panel that holds controllers.
   * @example
   * new GUI();
   * new GUI( { container: document.getElementById( 'custom' ) } );
   *
   * @param {object} [options]
   * @param {boolean} [options.autoPlace=true]
   * Adds the GUI to `document.body` and fixes it to the top right of the page.
   *
   * @param {Node} [options.container]
   * Adds the GUI to this DOM element. Overrides `autoPlace`.
   *
   * @param {number} [options.width=245]
   * Width of the GUI in pixels, usually set when name labels become too long. Note that you can make
   * name labels wider in CSS with `.lil‑gui { ‑‑name‑width: 55% }`.
   *
   * @param {string} [options.title=Controls]
   * Name to display in the title bar.
   *
   * @param {boolean} [options.closeFolders=false]
   * Pass `true` to close all folders in this GUI by default.
   *
   * @param {boolean} [options.injectStyles=true]
   * Injects the default stylesheet into the page if this is the first GUI.
   * Pass `false` to use your own stylesheet.
   *
   * @param {number} [options.touchStyles=true]
   * Makes controllers larger on touch devices. Pass `false` to disable touch styles.
   *
   * @param {GUI} [options.parent]
   * Adds this GUI as a child in another GUI. Usually this is done for you by `addFolder()`.
   */
  constructor({
    parent,
    autoPlace = parent === void 0,
    container,
    width,
    title = "Controls",
    closeFolders = false,
    injectStyles = true,
    touchStyles = true
  } = {}) {
    this.parent = parent;
    this.root = parent ? parent.root : this;
    this.children = [];
    this.controllers = [];
    this.folders = [];
    this._closed = false;
    this._hidden = false;
    this.domElement = document.createElement("div");
    this.domElement.classList.add("lil-gui");
    this.$title = document.createElement("button");
    this.$title.classList.add("lil-title");
    this.$title.setAttribute("aria-expanded", true);
    this.$title.addEventListener("click", () => this.openAnimated(this._closed));
    this.$title.addEventListener("touchstart", () => {
    }, { passive: true });
    this.$children = document.createElement("div");
    this.$children.classList.add("lil-children");
    this.domElement.appendChild(this.$title);
    this.domElement.appendChild(this.$children);
    this.title(title);
    if (this.parent) {
      this.parent.children.push(this);
      this.parent.folders.push(this);
      this.parent.$children.appendChild(this.domElement);
      return;
    }
    this.domElement.classList.add("lil-root");
    if (touchStyles) {
      this.domElement.classList.add("lil-allow-touch-styles");
    }
    if (!stylesInjected && injectStyles) {
      _injectStyles(stylesheet);
      stylesInjected = true;
    }
    if (container) {
      container.appendChild(this.domElement);
    } else if (autoPlace) {
      this.domElement.classList.add("lil-auto-place", "autoPlace");
      document.body.appendChild(this.domElement);
    }
    if (width) {
      this.domElement.style.setProperty("--width", width + "px");
    }
    this._closeFolders = closeFolders;
  }
  /**
   * Adds a controller to the GUI, inferring controller type using the `typeof` operator.
   * @example
   * gui.add( object, 'property' );
   * gui.add( object, 'number', 0, 100, 1 );
   * gui.add( object, 'options', [ 1, 2, 3 ] );
   *
   * @param {object} object The object the controller will modify.
   * @param {string} property Name of the property to control.
   * @param {number|object|Array} [$1] Minimum value for number controllers, or the set of
   * selectable values for a dropdown.
   * @param {number} [max] Maximum value for number controllers.
   * @param {number} [step] Step value for number controllers.
   * @returns {Controller}
   */
  add(object2, property, $1, max, step) {
    if (Object($1) === $1) {
      return new OptionController(this, object2, property, $1);
    }
    const initialValue = object2[property];
    switch (typeof initialValue) {
      case "number":
        return new NumberController(this, object2, property, $1, max, step);
      case "boolean":
        return new BooleanController(this, object2, property);
      case "string":
        return new StringController(this, object2, property);
      case "function":
        return new FunctionController(this, object2, property);
    }
    console.error(`gui.add failed
	property:`, property, `
	object:`, object2, `
	value:`, initialValue);
  }
  /**
   * Adds a color controller to the GUI.
   * @example
   * params = {
   * 	cssColor: '#ff00ff',
   * 	rgbColor: { r: 0, g: 0.2, b: 0.4 },
   * 	customRange: [ 0, 127, 255 ],
   * };
   *
   * gui.addColor( params, 'cssColor' );
   * gui.addColor( params, 'rgbColor' );
   * gui.addColor( params, 'customRange', 255 );
   *
   * @param {object} object The object the controller will modify.
   * @param {string} property Name of the property to control.
   * @param {number} rgbScale Maximum value for a color channel when using an RGB color. You may
   * need to set this to 255 if your colors are too bright.
   * @returns {Controller}
   */
  addColor(object2, property, rgbScale = 1) {
    return new ColorController(this, object2, property, rgbScale);
  }
  /**
   * Adds a folder to the GUI, which is just another GUI. This method returns
   * the nested GUI so you can add controllers to it.
   * @example
   * const folder = gui.addFolder( 'Position' );
   * folder.add( position, 'x' );
   * folder.add( position, 'y' );
   * folder.add( position, 'z' );
   *
   * @param {string} title Name to display in the folder's title bar.
   * @returns {GUI}
   */
  addFolder(title) {
    const folder = new GUI({ parent: this, title });
    if (this.root._closeFolders) folder.close();
    return folder;
  }
  /**
   * Recalls values that were saved with `gui.save()`.
   * @param {object} obj
   * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
   * @returns {this}
   */
  load(obj, recursive2 = true) {
    if (obj.controllers) {
      this.controllers.forEach((c) => {
        if (c instanceof FunctionController) return;
        if (c._name in obj.controllers) {
          c.load(obj.controllers[c._name]);
        }
      });
    }
    if (recursive2 && obj.folders) {
      this.folders.forEach((f) => {
        if (f._title in obj.folders) {
          f.load(obj.folders[f._title]);
        }
      });
    }
    return this;
  }
  /**
   * Returns an object mapping controller names to values. The object can be passed to `gui.load()` to
   * recall these values.
   * @example
   * {
   * 	controllers: {
   * 		prop1: 1,
   * 		prop2: 'value',
   * 		...
   * 	},
   * 	folders: {
   * 		folderName1: { controllers, folders },
   * 		folderName2: { controllers, folders }
   * 		...
   * 	}
   * }
   *
   * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
   * @returns {object}
   */
  save(recursive2 = true) {
    const obj = {
      controllers: {},
      folders: {}
    };
    this.controllers.forEach((c) => {
      if (c instanceof FunctionController) return;
      if (c._name in obj.controllers) {
        throw new Error(`Cannot save GUI with duplicate property "${c._name}"`);
      }
      obj.controllers[c._name] = c.save();
    });
    if (recursive2) {
      this.folders.forEach((f) => {
        if (f._title in obj.folders) {
          throw new Error(`Cannot save GUI with duplicate folder "${f._title}"`);
        }
        obj.folders[f._title] = f.save();
      });
    }
    return obj;
  }
  /**
   * Opens a GUI or folder. GUI and folders are open by default.
   * @param {boolean} open Pass false to close.
   * @returns {this}
   * @example
   * gui.open(); // open
   * gui.open( false ); // close
   * gui.open( gui._closed ); // toggle
   */
  open(open = true) {
    this._setClosed(!open);
    this.$title.setAttribute("aria-expanded", !this._closed);
    this.domElement.classList.toggle("lil-closed", this._closed);
    return this;
  }
  /**
   * Closes the GUI.
   * @returns {this}
   */
  close() {
    return this.open(false);
  }
  _setClosed(closed) {
    if (this._closed === closed) return;
    this._closed = closed;
    this._callOnOpenClose(this);
  }
  /**
   * Shows the GUI after it's been hidden.
   * @param {boolean} show
   * @returns {this}
   * @example
   * gui.show();
   * gui.show( false ); // hide
   * gui.show( gui._hidden ); // toggle
   */
  show(show = true) {
    this._hidden = !show;
    this.domElement.style.display = this._hidden ? "none" : "";
    return this;
  }
  /**
   * Hides the GUI.
   * @returns {this}
   */
  hide() {
    return this.show(false);
  }
  openAnimated(open = true) {
    this._setClosed(!open);
    this.$title.setAttribute("aria-expanded", !this._closed);
    requestAnimationFrame(() => {
      const initialHeight = this.$children.clientHeight;
      this.$children.style.height = initialHeight + "px";
      this.domElement.classList.add("lil-transition");
      const onTransitionEnd = (e2) => {
        if (e2.target !== this.$children) return;
        this.$children.style.height = "";
        this.domElement.classList.remove("lil-transition");
        this.$children.removeEventListener("transitionend", onTransitionEnd);
      };
      this.$children.addEventListener("transitionend", onTransitionEnd);
      const targetHeight = !open ? 0 : this.$children.scrollHeight;
      this.domElement.classList.toggle("lil-closed", !open);
      requestAnimationFrame(() => {
        this.$children.style.height = targetHeight + "px";
      });
    });
    return this;
  }
  /**
   * Change the title of this GUI.
   * @param {string} title
   * @returns {this}
   */
  title(title) {
    this._title = title;
    this.$title.textContent = title;
    return this;
  }
  /**
   * Resets all controllers to their initial values.
   * @param {boolean} recursive Pass false to exclude folders descending from this GUI.
   * @returns {this}
   */
  reset(recursive2 = true) {
    const controllers = recursive2 ? this.controllersRecursive() : this.controllers;
    controllers.forEach((c) => c.reset());
    return this;
  }
  /**
   * Pass a function to be called whenever a controller in this GUI changes.
   * @param {function({object:object, property:string, value:any, controller:Controller})} callback
   * @returns {this}
   * @example
   * gui.onChange( event => {
   * 	event.object     // object that was modified
   * 	event.property   // string, name of property
   * 	event.value      // new value of controller
   * 	event.controller // controller that was modified
   * } );
   */
  onChange(callback) {
    this._onChange = callback;
    return this;
  }
  _callOnChange(controller) {
    if (this.parent) {
      this.parent._callOnChange(controller);
    }
    if (this._onChange !== void 0) {
      this._onChange.call(this, {
        object: controller.object,
        property: controller.property,
        value: controller.getValue(),
        controller
      });
    }
  }
  /**
   * Pass a function to be called whenever a controller in this GUI has finished changing.
   * @param {function({object:object, property:string, value:any, controller:Controller})} callback
   * @returns {this}
   * @example
   * gui.onFinishChange( event => {
   * 	event.object     // object that was modified
   * 	event.property   // string, name of property
   * 	event.value      // new value of controller
   * 	event.controller // controller that was modified
   * } );
   */
  onFinishChange(callback) {
    this._onFinishChange = callback;
    return this;
  }
  _callOnFinishChange(controller) {
    if (this.parent) {
      this.parent._callOnFinishChange(controller);
    }
    if (this._onFinishChange !== void 0) {
      this._onFinishChange.call(this, {
        object: controller.object,
        property: controller.property,
        value: controller.getValue(),
        controller
      });
    }
  }
  /**
   * Pass a function to be called when this GUI or its descendants are opened or closed.
   * @param {function(GUI)} callback
   * @returns {this}
   * @example
   * gui.onOpenClose( changedGUI => {
   * 	console.log( changedGUI._closed );
   * } );
   */
  onOpenClose(callback) {
    this._onOpenClose = callback;
    return this;
  }
  _callOnOpenClose(changedGUI) {
    if (this.parent) {
      this.parent._callOnOpenClose(changedGUI);
    }
    if (this._onOpenClose !== void 0) {
      this._onOpenClose.call(this, changedGUI);
    }
  }
  /**
   * Destroys all DOM elements and event listeners associated with this GUI.
   */
  destroy() {
    if (this.parent) {
      this.parent.children.splice(this.parent.children.indexOf(this), 1);
      this.parent.folders.splice(this.parent.folders.indexOf(this), 1);
    }
    if (this.domElement.parentElement) {
      this.domElement.parentElement.removeChild(this.domElement);
    }
    Array.from(this.children).forEach((c) => c.destroy());
  }
  /**
   * Returns an array of controllers contained by this GUI and its descendents.
   * @returns {Controller[]}
   */
  controllersRecursive() {
    let controllers = Array.from(this.controllers);
    this.folders.forEach((f) => {
      controllers = controllers.concat(f.controllersRecursive());
    });
    return controllers;
  }
  /**
   * Returns an array of folders contained by this GUI and its descendents.
   * @returns {GUI[]}
   */
  foldersRecursive() {
    let folders = Array.from(this.folders);
    this.folders.forEach((f) => {
      folders = folders.concat(f.foldersRecursive());
    });
    return folders;
  }
}
const version = "15.1.22";
const createExtendedExponentialRampToValueAutomationEvent = (value, endTime, insertTime) => {
  return { endTime, insertTime, type: "exponentialRampToValue", value };
};
const createExtendedLinearRampToValueAutomationEvent = (value, endTime, insertTime) => {
  return { endTime, insertTime, type: "linearRampToValue", value };
};
const createSetValueAutomationEvent = (value, startTime) => {
  return { startTime, type: "setValue", value };
};
const createSetValueCurveAutomationEvent = (values, startTime, duration2) => {
  return { duration: duration2, startTime, type: "setValueCurve", values };
};
const getTargetValueAtTime = (time2, valueAtStartTime, { startTime, target, timeConstant }) => {
  return target + (valueAtStartTime - target) * Math.exp((startTime - time2) / timeConstant);
};
const isExponentialRampToValueAutomationEvent = (automationEvent) => {
  return automationEvent.type === "exponentialRampToValue";
};
const isLinearRampToValueAutomationEvent = (automationEvent) => {
  return automationEvent.type === "linearRampToValue";
};
const isAnyRampToValueAutomationEvent = (automationEvent) => {
  return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);
};
const isSetValueAutomationEvent = (automationEvent) => {
  return automationEvent.type === "setValue";
};
const isSetValueCurveAutomationEvent = (automationEvent) => {
  return automationEvent.type === "setValueCurve";
};
const getValueOfAutomationEventAtIndexAtTime = (automationEvents, index, time2, defaultValue) => {
  const automationEvent = automationEvents[index];
  return automationEvent === void 0 ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time2, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);
};
const getEndTimeAndValueOfPreviousAutomationEvent = (automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) => {
  return currentAutomationEvent === void 0 ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [
    currentAutomationEvent.startTime + currentAutomationEvent.duration,
    currentAutomationEvent.values[currentAutomationEvent.values.length - 1]
  ] : [
    currentAutomationEvent.startTime,
    getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)
  ];
};
const isCancelAndHoldAutomationEvent = (automationEvent) => {
  return automationEvent.type === "cancelAndHold";
};
const isCancelScheduledValuesAutomationEvent = (automationEvent) => {
  return automationEvent.type === "cancelScheduledValues";
};
const getEventTime = (automationEvent) => {
  if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
    return automationEvent.cancelTime;
  }
  if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {
    return automationEvent.endTime;
  }
  return automationEvent.startTime;
};
const getExponentialRampValueAtTime = (time2, startTime, valueAtStartTime, { endTime, value }) => {
  if (valueAtStartTime === value) {
    return value;
  }
  if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {
    return valueAtStartTime * (value / valueAtStartTime) ** ((time2 - startTime) / (endTime - startTime));
  }
  return 0;
};
const getLinearRampValueAtTime = (time2, startTime, valueAtStartTime, { endTime, value }) => {
  return valueAtStartTime + (time2 - startTime) / (endTime - startTime) * (value - valueAtStartTime);
};
const interpolateValue = (values, theoreticIndex) => {
  const lowerIndex = Math.floor(theoreticIndex);
  const upperIndex = Math.ceil(theoreticIndex);
  if (lowerIndex === upperIndex) {
    return values[lowerIndex];
  }
  return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];
};
const getValueCurveValueAtTime = (time2, { duration: duration2, startTime, values }) => {
  const theoreticIndex = (time2 - startTime) / duration2 * (values.length - 1);
  return interpolateValue(values, theoreticIndex);
};
const isSetTargetAutomationEvent = (automationEvent) => {
  return automationEvent.type === "setTarget";
};
class AutomationEventList {
  constructor(defaultValue) {
    this._automationEvents = [];
    this._currenTime = 0;
    this._defaultValue = defaultValue;
  }
  [Symbol.iterator]() {
    return this._automationEvents[Symbol.iterator]();
  }
  add(automationEvent) {
    const eventTime = getEventTime(automationEvent);
    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
      const index = this._automationEvents.findIndex((currentAutomationEvent) => {
        if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {
          return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;
        }
        return getEventTime(currentAutomationEvent) >= eventTime;
      });
      const removedAutomationEvent = this._automationEvents[index];
      if (index !== -1) {
        this._automationEvents = this._automationEvents.slice(0, index);
      }
      if (isCancelAndHoldAutomationEvent(automationEvent)) {
        const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];
        if (removedAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {
          if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {
            throw new Error("The internal list is malformed.");
          }
          const startTime = lastAutomationEvent === void 0 ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);
          const startValue = lastAutomationEvent === void 0 ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;
          const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);
          const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);
          this._automationEvents.push(truncatedAutomationEvent);
        }
        if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {
          this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));
        }
        if (lastAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {
          const duration2 = eventTime - lastAutomationEvent.startTime;
          const ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;
          const length = Math.max(2, 1 + Math.ceil(duration2 * ratio));
          const fraction = duration2 / (length - 1) * ratio;
          const values = lastAutomationEvent.values.slice(0, length);
          if (fraction < 1) {
            for (let i = 1; i < length; i += 1) {
              const factor = fraction * i % 1;
              values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;
            }
          }
          this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration2);
        }
      }
    } else {
      const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);
      const previousAutomationEvent = index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index - 1];
      if (previousAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {
        return false;
      }
      const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;
      if (index === -1) {
        this._automationEvents.push(persistentAutomationEvent);
      } else {
        if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[index])) {
          return false;
        }
        this._automationEvents.splice(index, 0, persistentAutomationEvent);
      }
    }
    return true;
  }
  flush(time2) {
    const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time2);
    if (index > 1) {
      const remainingAutomationEvents = this._automationEvents.slice(index - 1);
      const firstRemainingAutomationEvent = remainingAutomationEvents[0];
      if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {
        remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));
      }
      this._automationEvents = remainingAutomationEvents;
    }
  }
  getValue(time2) {
    if (this._automationEvents.length === 0) {
      return this._defaultValue;
    }
    const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time2);
    const nextAutomationEvent = this._automationEvents[indexOfNextEvent];
    const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;
    const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];
    if (currentAutomationEvent !== void 0 && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time2)) {
      return getTargetValueAtTime(time2, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);
    }
    if (currentAutomationEvent !== void 0 && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
      return currentAutomationEvent.value;
    }
    if (currentAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time2)) {
      if (time2 < currentAutomationEvent.startTime + currentAutomationEvent.duration) {
        return getValueCurveValueAtTime(time2, currentAutomationEvent);
      }
      return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];
    }
    if (currentAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
      return currentAutomationEvent.value;
    }
    if (nextAutomationEvent !== void 0 && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {
      const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);
      return getExponentialRampValueAtTime(time2, startTime, value, nextAutomationEvent);
    }
    if (nextAutomationEvent !== void 0 && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {
      const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);
      return getLinearRampValueAtTime(time2, startTime, value, nextAutomationEvent);
    }
    return this._defaultValue;
  }
}
const createCancelAndHoldAutomationEvent = (cancelTime) => {
  return { cancelTime, type: "cancelAndHold" };
};
const createCancelScheduledValuesAutomationEvent = (cancelTime) => {
  return { cancelTime, type: "cancelScheduledValues" };
};
const createExponentialRampToValueAutomationEvent = (value, endTime) => {
  return { endTime, type: "exponentialRampToValue", value };
};
const createLinearRampToValueAutomationEvent = (value, endTime) => {
  return { endTime, type: "linearRampToValue", value };
};
const createSetTargetAutomationEvent = (target, startTime, timeConstant) => {
  return { startTime, target, timeConstant, type: "setTarget" };
};
const createAbortError = () => new DOMException("", "AbortError");
const createAddActiveInputConnectionToAudioNode = (insertElementInSet2) => {
  return (activeInputs, source, [output2, input, eventListener], ignoreDuplicates) => {
    insertElementInSet2(activeInputs[input], [source, output2, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output2, ignoreDuplicates);
  };
};
const createAddAudioNodeConnections = (audioNodeConnectionsStore) => {
  return (audioNode, audioNodeRenderer, nativeAudioNode) => {
    const activeInputs = [];
    for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {
      activeInputs.push(/* @__PURE__ */ new Set());
    }
    audioNodeConnectionsStore.set(audioNode, {
      activeInputs,
      outputs: /* @__PURE__ */ new Set(),
      passiveInputs: /* @__PURE__ */ new WeakMap(),
      renderer: audioNodeRenderer
    });
  };
};
const createAddAudioParamConnections = (audioParamConnectionsStore) => {
  return (audioParam, audioParamRenderer) => {
    audioParamConnectionsStore.set(audioParam, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: audioParamRenderer });
  };
};
const ACTIVE_AUDIO_NODE_STORE = /* @__PURE__ */ new WeakSet();
const AUDIO_NODE_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();
const AUDIO_NODE_STORE = /* @__PURE__ */ new WeakMap();
const AUDIO_PARAM_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();
const AUDIO_PARAM_STORE = /* @__PURE__ */ new WeakMap();
const CONTEXT_STORE = /* @__PURE__ */ new WeakMap();
const EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();
const CYCLE_COUNTERS = /* @__PURE__ */ new WeakMap();
const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = /* @__PURE__ */ new WeakMap();
const NODE_TO_PROCESSOR_MAPS = /* @__PURE__ */ new WeakMap();
const handler = {
  construct() {
    return handler;
  }
};
const isConstructible = (constructible) => {
  try {
    const proxy = new Proxy(constructible, handler);
    new proxy();
  } catch {
    return false;
  }
  return true;
};
const IMPORT_STATEMENT_REGEX = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/;
const splitImportStatements = (source, url) => {
  const importStatements = [];
  let sourceWithoutImportStatements = source.replace(/^[\s]+/, "");
  let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
  while (result !== null) {
    const unresolvedUrl = result[1].slice(1, -1);
    const importStatementWithResolvedUrl = result[0].replace(/([\s]+)?;?$/, "").replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());
    importStatements.push(importStatementWithResolvedUrl);
    sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\s]+/, "");
    result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
  }
  return [importStatements.join(";"), sourceWithoutImportStatements];
};
const verifyParameterDescriptors = (parameterDescriptors) => {
  if (parameterDescriptors !== void 0 && !Array.isArray(parameterDescriptors)) {
    throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
  }
};
const verifyProcessorCtor = (processorCtor) => {
  if (!isConstructible(processorCtor)) {
    throw new TypeError("The given value for processorCtor should be a constructor.");
  }
  if (processorCtor.prototype === null || typeof processorCtor.prototype !== "object") {
    throw new TypeError("The given value for processorCtor should have a prototype.");
  }
};
const createAddAudioWorkletModule = (cacheTestResult2, createNotSupportedError2, evaluateSource, exposeCurrentFrameAndCurrentTime2, fetchSource, getNativeContext2, getOrCreateBackupOfflineAudioContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window2) => {
  let index = 0;
  return (context2, moduleURL, options2 = { credentials: "omit" }) => {
    const resolvedRequestsOfContext = resolvedRequests.get(context2);
    if (resolvedRequestsOfContext !== void 0 && resolvedRequestsOfContext.has(moduleURL)) {
      return Promise.resolve();
    }
    const ongoingRequestsOfContext = ongoingRequests.get(context2);
    if (ongoingRequestsOfContext !== void 0) {
      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);
      if (promiseOfOngoingRequest !== void 0) {
        return promiseOfOngoingRequest;
      }
    }
    const nativeContext = getNativeContext2(context2);
    const promise = nativeContext.audioWorklet === void 0 ? fetchSource(moduleURL).then(([source, absoluteUrl]) => {
      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}
})})(window,'_AWGS')`;
      return evaluateSource(wrappedSource);
    }).then(() => {
      const evaluateAudioWorkletGlobalScope = window2._AWGS.pop();
      if (evaluateAudioWorkletGlobalScope === void 0) {
        throw new SyntaxError();
      }
      exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {
      }, void 0, (name, processorCtor) => {
        if (name.trim() === "") {
          throw createNotSupportedError2();
        }
        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
        if (nodeNameToProcessorConstructorMap !== void 0) {
          if (nodeNameToProcessorConstructorMap.has(name)) {
            throw createNotSupportedError2();
          }
          verifyProcessorCtor(processorCtor);
          verifyParameterDescriptors(processorCtor.parameterDescriptors);
          nodeNameToProcessorConstructorMap.set(name, processorCtor);
        } else {
          verifyProcessorCtor(processorCtor);
          verifyParameterDescriptors(processorCtor.parameterDescriptors);
          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, /* @__PURE__ */ new Map([[name, processorCtor]]));
        }
      }, nativeContext.sampleRate, void 0, void 0));
    }) : Promise.all([
      fetchSource(moduleURL),
      Promise.resolve(cacheTestResult2(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))
    ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {
      const currentIndex = index + 1;
      index = currentIndex;
      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
      const patchedAudioWorkletProcessor = isSupportingPostMessage ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}";
      const memberDefinition = isSupportingPostMessage ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));";
      const bufferRegistration = isSupportingPostMessage ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));";
      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}
})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;
      const blob = new Blob([wrappedSource], { type: "application/javascript; charset=utf-8" });
      const url = URL.createObjectURL(blob);
      return nativeContext.audioWorklet.addModule(url, options2).then(() => {
        if (isNativeOfflineAudioContext2(nativeContext)) {
          return nativeContext;
        }
        const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext2(nativeContext);
        return backupOfflineAudioContext.audioWorklet.addModule(url, options2).then(() => backupOfflineAudioContext);
      }).then((nativeContextOrBackupOfflineAudioContext) => {
        if (nativeAudioWorkletNodeConstructor2 === null) {
          throw new SyntaxError();
        }
        try {
          new nativeAudioWorkletNodeConstructor2(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`);
        } catch {
          throw new SyntaxError();
        }
      }).finally(() => URL.revokeObjectURL(url));
    });
    if (ongoingRequestsOfContext === void 0) {
      ongoingRequests.set(context2, /* @__PURE__ */ new Map([[moduleURL, promise]]));
    } else {
      ongoingRequestsOfContext.set(moduleURL, promise);
    }
    promise.then(() => {
      const updatedResolvedRequestsOfContext = resolvedRequests.get(context2);
      if (updatedResolvedRequestsOfContext === void 0) {
        resolvedRequests.set(context2, /* @__PURE__ */ new Set([moduleURL]));
      } else {
        updatedResolvedRequestsOfContext.add(moduleURL);
      }
    }).finally(() => {
      const updatedOngoingRequestsOfContext = ongoingRequests.get(context2);
      if (updatedOngoingRequestsOfContext !== void 0) {
        updatedOngoingRequestsOfContext.delete(moduleURL);
      }
    });
    return promise;
  };
};
const getValueForKey = (map2, key) => {
  const value = map2.get(key);
  if (value === void 0) {
    throw new Error("A value with the given key could not be found.");
  }
  return value;
};
const pickElementFromSet = (set2, predicate) => {
  const matchingElements = Array.from(set2).filter(predicate);
  if (matchingElements.length > 1) {
    throw Error("More than one element was found.");
  }
  if (matchingElements.length === 0) {
    throw Error("No element was found.");
  }
  const [matchingElement] = matchingElements;
  set2.delete(matchingElement);
  return matchingElement;
};
const deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output2, input) => {
  const passiveInputConnections = getValueForKey(passiveInputs, source);
  const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output2 && passiveInputConnection[1] === input);
  if (passiveInputConnections.size === 0) {
    passiveInputs.delete(source);
  }
  return matchingConnection;
};
const getEventListenersOfAudioNode = (audioNode) => {
  return getValueForKey(EVENT_LISTENERS, audioNode);
};
const setInternalStateToActive = (audioNode) => {
  if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
    throw new Error("The AudioNode is already stored.");
  }
  ACTIVE_AUDIO_NODE_STORE.add(audioNode);
  getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));
};
const isAudioWorkletNode = (audioNode) => {
  return "port" in audioNode;
};
const setInternalStateToPassive = (audioNode) => {
  if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
    throw new Error("The AudioNode is not stored.");
  }
  ACTIVE_AUDIO_NODE_STORE.delete(audioNode);
  getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));
};
const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {
  if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {
    setInternalStateToPassive(audioNode);
  }
};
const createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode2, addPassiveInputConnectionToAudioNode2, connectNativeAudioNodeToNativeAudioNode2, deleteActiveInputConnectionToAudioNode2, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getAudioNodeTailTime2, getEventListenersOfAudioNode2, getNativeAudioNode2, insertElementInSet2, isActiveAudioNode2, isPartOfACycle2, isPassiveAudioNode2) => {
  const tailTimeTimeoutIds = /* @__PURE__ */ new WeakMap();
  return (source, destination, output2, input, isOffline) => {
    const { activeInputs, passiveInputs } = getAudioNodeConnections2(destination);
    const { outputs: outputs2 } = getAudioNodeConnections2(source);
    const eventListeners = getEventListenersOfAudioNode2(source);
    const eventListener = (isActive) => {
      const nativeDestinationAudioNode = getNativeAudioNode2(destination);
      const nativeSourceAudioNode = getNativeAudioNode2(source);
      if (isActive) {
        const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output2, input);
        addActiveInputConnectionToAudioNode2(activeInputs, source, partialConnection, false);
        if (!isOffline && !isPartOfACycle2(source)) {
          connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output2, input);
        }
        if (isPassiveAudioNode2(destination)) {
          setInternalStateToActive(destination);
        }
      } else {
        const partialConnection = deleteActiveInputConnectionToAudioNode2(activeInputs, source, output2, input);
        addPassiveInputConnectionToAudioNode2(passiveInputs, input, partialConnection, false);
        if (!isOffline && !isPartOfACycle2(source)) {
          disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output2, input);
        }
        const tailTime = getAudioNodeTailTime2(destination);
        if (tailTime === 0) {
          if (isActiveAudioNode2(destination)) {
            setInternalStateToPassiveWhenNecessary(destination, activeInputs);
          }
        } else {
          const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);
          if (tailTimeTimeoutId !== void 0) {
            clearTimeout(tailTimeTimeoutId);
          }
          tailTimeTimeoutIds.set(destination, setTimeout(() => {
            if (isActiveAudioNode2(destination)) {
              setInternalStateToPassiveWhenNecessary(destination, activeInputs);
            }
          }, tailTime * 1e3));
        }
      }
    };
    if (insertElementInSet2(outputs2, [destination, output2, input], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output2 && outputConnection[2] === input, true)) {
      eventListeners.add(eventListener);
      if (isActiveAudioNode2(source)) {
        addActiveInputConnectionToAudioNode2(activeInputs, source, [output2, input, eventListener], true);
      } else {
        addPassiveInputConnectionToAudioNode2(passiveInputs, input, [source, output2, eventListener], true);
      }
      return true;
    }
    return false;
  };
};
const createAddPassiveInputConnectionToAudioNode = (insertElementInSet2) => {
  return (passiveInputs, input, [source, output2, eventListener], ignoreDuplicates) => {
    const passiveInputConnections = passiveInputs.get(source);
    if (passiveInputConnections === void 0) {
      passiveInputs.set(source, /* @__PURE__ */ new Set([[output2, input, eventListener]]));
    } else {
      insertElementInSet2(passiveInputConnections, [output2, input, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output2 && passiveInputConnection[1] === input, ignoreDuplicates);
    }
  };
};
const createAddSilentConnection = (createNativeGainNode2) => {
  return (nativeContext, nativeAudioScheduledSourceNode) => {
    const nativeGainNode = createNativeGainNode2(nativeContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: 0
    });
    nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);
    const disconnect2 = () => {
      nativeAudioScheduledSourceNode.removeEventListener("ended", disconnect2);
      nativeAudioScheduledSourceNode.disconnect(nativeGainNode);
      nativeGainNode.disconnect();
    };
    nativeAudioScheduledSourceNode.addEventListener("ended", disconnect2);
  };
};
const createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
  return (nativeContext, audioWorkletNode) => {
    getUnrenderedAudioWorkletNodes2(nativeContext).add(audioWorkletNode);
  };
};
const DEFAULT_OPTIONS$j = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  fftSize: 2048,
  maxDecibels: -30,
  minDecibels: -100,
  smoothingTimeConstant: 0.8
};
const createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer2, createIndexSizeError2, createNativeAnalyserNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class AnalyserNode extends audionNodeConstructor {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$j, ...options2 };
      const nativeAnalyserNode = createNativeAnalyserNode2(nativeContext, mergedOptions);
      const analyserNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createAnalyserNodeRenderer2() : null;
      super(context2, false, nativeAnalyserNode, analyserNodeRenderer);
      this._nativeAnalyserNode = nativeAnalyserNode;
    }
    get fftSize() {
      return this._nativeAnalyserNode.fftSize;
    }
    set fftSize(value) {
      this._nativeAnalyserNode.fftSize = value;
    }
    get frequencyBinCount() {
      return this._nativeAnalyserNode.frequencyBinCount;
    }
    get maxDecibels() {
      return this._nativeAnalyserNode.maxDecibels;
    }
    set maxDecibels(value) {
      const maxDecibels = this._nativeAnalyserNode.maxDecibels;
      this._nativeAnalyserNode.maxDecibels = value;
      if (!(value > this._nativeAnalyserNode.minDecibels)) {
        this._nativeAnalyserNode.maxDecibels = maxDecibels;
        throw createIndexSizeError2();
      }
    }
    get minDecibels() {
      return this._nativeAnalyserNode.minDecibels;
    }
    set minDecibels(value) {
      const minDecibels = this._nativeAnalyserNode.minDecibels;
      this._nativeAnalyserNode.minDecibels = value;
      if (!(this._nativeAnalyserNode.maxDecibels > value)) {
        this._nativeAnalyserNode.minDecibels = minDecibels;
        throw createIndexSizeError2();
      }
    }
    get smoothingTimeConstant() {
      return this._nativeAnalyserNode.smoothingTimeConstant;
    }
    set smoothingTimeConstant(value) {
      this._nativeAnalyserNode.smoothingTimeConstant = value;
    }
    getByteFrequencyData(array2) {
      this._nativeAnalyserNode.getByteFrequencyData(array2);
    }
    getByteTimeDomainData(array2) {
      this._nativeAnalyserNode.getByteTimeDomainData(array2);
    }
    getFloatFrequencyData(array2) {
      this._nativeAnalyserNode.getFloatFrequencyData(array2);
    }
    getFloatTimeDomainData(array2) {
      this._nativeAnalyserNode.getFloatTimeDomainData(array2);
    }
  };
};
const isOwnedByContext = (nativeAudioNode, nativeContext) => {
  return nativeAudioNode.context === nativeContext;
};
const createAnalyserNodeRendererFactory = (createNativeAnalyserNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeAnalyserNodes = /* @__PURE__ */ new WeakMap();
    const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAnalyserNode = getNativeAudioNode2(proxy);
      const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);
      if (!nativeAnalyserNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeAnalyserNode.channelCount,
          channelCountMode: nativeAnalyserNode.channelCountMode,
          channelInterpretation: nativeAnalyserNode.channelInterpretation,
          fftSize: nativeAnalyserNode.fftSize,
          maxDecibels: nativeAnalyserNode.maxDecibels,
          minDecibels: nativeAnalyserNode.minDecibels,
          smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant
        };
        nativeAnalyserNode = createNativeAnalyserNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAnalyserNode);
      return nativeAnalyserNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAnalyserNode !== void 0) {
          return Promise.resolve(renderedNativeAnalyserNode);
        }
        return createAnalyserNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {
  try {
    nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);
  } catch {
    return false;
  }
  return true;
};
const createIndexSizeError = () => new DOMException("", "IndexSizeError");
const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {
  audioBuffer.getChannelData = /* @__PURE__ */ ((getChannelData) => {
    return (channel) => {
      try {
        return getChannelData.call(audioBuffer, channel);
      } catch (err) {
        if (err.code === 12) {
          throw createIndexSizeError();
        }
        throw err;
      }
    };
  })(audioBuffer.getChannelData);
};
const DEFAULT_OPTIONS$i = {
  numberOfChannels: 1
};
const createAudioBufferConstructor = (audioBufferStore2, cacheTestResult2, createNotSupportedError2, nativeAudioBufferConstructor2, nativeOfflineAudioContextConstructor2, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
  let nativeOfflineAudioContext = null;
  return class AudioBuffer {
    constructor(options2) {
      if (nativeOfflineAudioContextConstructor2 === null) {
        throw new Error("Missing the native OfflineAudioContext constructor.");
      }
      const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS$i, ...options2 };
      if (nativeOfflineAudioContext === null) {
        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
      }
      const audioBuffer = nativeAudioBufferConstructor2 !== null && cacheTestResult2(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor2({ length, numberOfChannels, sampleRate }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
      if (audioBuffer.numberOfChannels === 0) {
        throw createNotSupportedError2();
      }
      if (typeof audioBuffer.copyFromChannel !== "function") {
        wrapAudioBufferCopyChannelMethods2(audioBuffer);
        wrapAudioBufferGetChannelDataMethod(audioBuffer);
      } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {
        wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
      }
      audioBufferStore2.add(audioBuffer);
      return audioBuffer;
    }
    static [Symbol.hasInstance](instance) {
      return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore2.has(instance);
    }
  };
};
const MOST_NEGATIVE_SINGLE_FLOAT = -34028234663852886e22;
const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;
const isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);
const DEFAULT_OPTIONS$h = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  // Bug #149: Safari does not yet support the detune AudioParam.
  loop: false,
  loopEnd: 0,
  loopStart: 0,
  playbackRate: 1
};
const createAudioBufferSourceNodeConstructor = (audioNodeConstructor2, createAudioBufferSourceNodeRenderer2, createAudioParam2, createInvalidStateError2, createNativeAudioBufferSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
  return class AudioBufferSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$h, ...options2 };
      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer2() : null;
      super(context2, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);
      this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;
      this._isBufferNullified = false;
      this._isBufferSet = mergedOptions.buffer !== null;
      this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;
      this._onended = null;
      this._playbackRate = createAudioParam2(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
    }
    get buffer() {
      if (this._isBufferNullified) {
        return null;
      }
      return this._nativeAudioBufferSourceNode.buffer;
    }
    set buffer(value) {
      this._nativeAudioBufferSourceNode.buffer = value;
      if (value !== null) {
        if (this._isBufferSet) {
          throw createInvalidStateError2();
        }
        this._isBufferSet = true;
      }
    }
    get loop() {
      return this._nativeAudioBufferSourceNode.loop;
    }
    set loop(value) {
      this._nativeAudioBufferSourceNode.loop = value;
    }
    get loopEnd() {
      return this._nativeAudioBufferSourceNode.loopEnd;
    }
    set loopEnd(value) {
      this._nativeAudioBufferSourceNode.loopEnd = value;
    }
    get loopStart() {
      return this._nativeAudioBufferSourceNode.loopStart;
    }
    set loopStart(value) {
      this._nativeAudioBufferSourceNode.loopStart = value;
    }
    get onended() {
      return this._onended;
    }
    set onended(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeAudioBufferSourceNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }
    get playbackRate() {
      return this._playbackRate;
    }
    start(when = 0, offset2 = 0, duration2) {
      this._nativeAudioBufferSourceNode.start(when, offset2, duration2);
      if (this._audioBufferSourceNodeRenderer !== null) {
        this._audioBufferSourceNodeRenderer.start = duration2 === void 0 ? [when, offset2] : [when, offset2, duration2];
      }
      if (this.context.state !== "closed") {
        setInternalStateToActive(this);
        const resetInternalStateToPassive = () => {
          this._nativeAudioBufferSourceNode.removeEventListener("ended", resetInternalStateToPassive);
          if (isActiveAudioNode(this)) {
            setInternalStateToPassive(this);
          }
        };
        this._nativeAudioBufferSourceNode.addEventListener("ended", resetInternalStateToPassive);
      }
    }
    stop(when = 0) {
      this._nativeAudioBufferSourceNode.stop(when);
      if (this._audioBufferSourceNodeRenderer !== null) {
        this._audioBufferSourceNodeRenderer.stop = when;
      }
    }
  };
};
const createAudioBufferSourceNodeRendererFactory = (connectAudioParam2, createNativeAudioBufferSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeAudioBufferSourceNodes = /* @__PURE__ */ new WeakMap();
    let start2 = null;
    let stop = null;
    const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioBufferSourceNode = getNativeAudioNode2(proxy);
      const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);
      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
        const options2 = {
          buffer: nativeAudioBufferSourceNode.buffer,
          channelCount: nativeAudioBufferSourceNode.channelCount,
          channelCountMode: nativeAudioBufferSourceNode.channelCountMode,
          channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,
          // Bug #149: Safari does not yet support the detune AudioParam.
          loop: nativeAudioBufferSourceNode.loop,
          loopEnd: nativeAudioBufferSourceNode.loopEnd,
          loopStart: nativeAudioBufferSourceNode.loopStart,
          playbackRate: nativeAudioBufferSourceNode.playbackRate.value
        };
        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, options2);
        if (start2 !== null) {
          nativeAudioBufferSourceNode.start(...start2);
        }
        if (stop !== null) {
          nativeAudioBufferSourceNode.stop(stop);
        }
      }
      renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);
      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);
      return nativeAudioBufferSourceNode;
    };
    return {
      set start(value) {
        start2 = value;
      },
      set stop(value) {
        stop = value;
      },
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioBufferSourceNode !== void 0) {
          return Promise.resolve(renderedNativeAudioBufferSourceNode);
        }
        return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const isAudioBufferSourceNode = (audioNode) => {
  return "playbackRate" in audioNode;
};
const isBiquadFilterNode = (audioNode) => {
  return "frequency" in audioNode && "gain" in audioNode;
};
const isConstantSourceNode = (audioNode) => {
  return "offset" in audioNode;
};
const isGainNode = (audioNode) => {
  return !("frequency" in audioNode) && "gain" in audioNode;
};
const isOscillatorNode = (audioNode) => {
  return "detune" in audioNode && "frequency" in audioNode && !("gain" in audioNode);
};
const isStereoPannerNode = (audioNode) => {
  return "pan" in audioNode;
};
const getAudioNodeConnections = (audioNode) => {
  return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);
};
const getAudioParamConnections = (audioParam) => {
  return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);
};
const deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {
  const { activeInputs } = getAudioNodeConnections(audioNode);
  activeInputs.forEach((connections) => connections.forEach(([source]) => {
    if (!trace.includes(audioNode)) {
      deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);
    }
  }));
  const audioParams = isAudioBufferSourceNode(audioNode) ? [
    // Bug #149: Safari does not yet support the detune AudioParam.
    audioNode.playbackRate
  ] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];
  for (const audioParam of audioParams) {
    const audioParamConnections = getAudioParamConnections(audioParam);
    if (audioParamConnections !== void 0) {
      audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));
    }
  }
  if (isActiveAudioNode(audioNode)) {
    setInternalStateToPassive(audioNode);
  }
};
const deactivateAudioGraph = (context2) => {
  deactivateActiveAudioNodeInputConnections(context2.destination, []);
};
const isValidLatencyHint = (latencyHint) => {
  return latencyHint === void 0 || typeof latencyHint === "number" || typeof latencyHint === "string" && (latencyHint === "balanced" || latencyHint === "interactive" || latencyHint === "playback");
};
const createAudioContextConstructor = (baseAudioContextConstructor2, createInvalidStateError2, createNotSupportedError2, createUnknownError2, mediaElementAudioSourceNodeConstructor2, mediaStreamAudioDestinationNodeConstructor2, mediaStreamAudioSourceNodeConstructor2, mediaStreamTrackAudioSourceNodeConstructor2, nativeAudioContextConstructor2) => {
  return class AudioContext extends baseAudioContextConstructor2 {
    constructor(options2 = {}) {
      if (nativeAudioContextConstructor2 === null) {
        throw new Error("Missing the native AudioContext constructor.");
      }
      let nativeAudioContext;
      try {
        nativeAudioContext = new nativeAudioContextConstructor2(options2);
      } catch (err) {
        if (err.code === 12 && err.message === "sampleRate is not in range") {
          throw createNotSupportedError2();
        }
        throw err;
      }
      if (nativeAudioContext === null) {
        throw createUnknownError2();
      }
      if (!isValidLatencyHint(options2.latencyHint)) {
        throw new TypeError(`The provided value '${options2.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
      }
      if (options2.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options2.sampleRate) {
        throw createNotSupportedError2();
      }
      super(nativeAudioContext, 2);
      const { latencyHint } = options2;
      const { sampleRate } = nativeAudioContext;
      this._baseLatency = typeof nativeAudioContext.baseLatency === "number" ? nativeAudioContext.baseLatency : latencyHint === "balanced" ? 512 / sampleRate : latencyHint === "interactive" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === "playback" ? 1024 / sampleRate : (
        /*
         * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
         * ScriptProcessorNode.
         */
        Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate
      );
      this._nativeAudioContext = nativeAudioContext;
      if (nativeAudioContextConstructor2.name === "webkitAudioContext") {
        this._nativeGainNode = nativeAudioContext.createGain();
        this._nativeOscillatorNode = nativeAudioContext.createOscillator();
        this._nativeGainNode.gain.value = 1e-37;
        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);
        this._nativeOscillatorNode.start();
      } else {
        this._nativeGainNode = null;
        this._nativeOscillatorNode = null;
      }
      this._state = null;
      if (nativeAudioContext.state === "running") {
        this._state = "suspended";
        const revokeState = () => {
          if (this._state === "suspended") {
            this._state = null;
          }
          nativeAudioContext.removeEventListener("statechange", revokeState);
        };
        nativeAudioContext.addEventListener("statechange", revokeState);
      }
    }
    get baseLatency() {
      return this._baseLatency;
    }
    get state() {
      return this._state !== null ? this._state : this._nativeAudioContext.state;
    }
    close() {
      if (this.state === "closed") {
        return this._nativeAudioContext.close().then(() => {
          throw createInvalidStateError2();
        });
      }
      if (this._state === "suspended") {
        this._state = null;
      }
      return this._nativeAudioContext.close().then(() => {
        if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
          this._nativeOscillatorNode.stop();
          this._nativeGainNode.disconnect();
          this._nativeOscillatorNode.disconnect();
        }
        deactivateAudioGraph(this);
      });
    }
    createMediaElementSource(mediaElement) {
      return new mediaElementAudioSourceNodeConstructor2(this, { mediaElement });
    }
    createMediaStreamDestination() {
      return new mediaStreamAudioDestinationNodeConstructor2(this);
    }
    createMediaStreamSource(mediaStream) {
      return new mediaStreamAudioSourceNodeConstructor2(this, { mediaStream });
    }
    createMediaStreamTrackSource(mediaStreamTrack) {
      return new mediaStreamTrackAudioSourceNodeConstructor2(this, { mediaStreamTrack });
    }
    resume() {
      if (this._state === "suspended") {
        return new Promise((resolve, reject) => {
          const resolvePromise = () => {
            this._nativeAudioContext.removeEventListener("statechange", resolvePromise);
            if (this._nativeAudioContext.state === "running") {
              resolve();
            } else {
              this.resume().then(resolve, reject);
            }
          };
          this._nativeAudioContext.addEventListener("statechange", resolvePromise);
        });
      }
      return this._nativeAudioContext.resume().catch((err) => {
        if (err === void 0 || err.code === 15) {
          throw createInvalidStateError2();
        }
        throw err;
      });
    }
    suspend() {
      return this._nativeAudioContext.suspend().catch((err) => {
        if (err === void 0) {
          throw createInvalidStateError2();
        }
        throw err;
      });
    }
  };
};
const createAudioDestinationNodeConstructor = (audioNodeConstructor2, createAudioDestinationNodeRenderer2, createIndexSizeError2, createInvalidStateError2, createNativeAudioDestinationNode, getNativeContext2, isNativeOfflineAudioContext2, renderInputsOfAudioNode2) => {
  return class AudioDestinationNode extends audioNodeConstructor2 {
    constructor(context2, channelCount) {
      const nativeContext = getNativeContext2(context2);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);
      const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer2(renderInputsOfAudioNode2) : null;
      super(context2, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);
      this._isNodeOfNativeOfflineAudioContext = isOffline;
      this._nativeAudioDestinationNode = nativeAudioDestinationNode;
    }
    get channelCount() {
      return this._nativeAudioDestinationNode.channelCount;
    }
    set channelCount(value) {
      if (this._isNodeOfNativeOfflineAudioContext) {
        throw createInvalidStateError2();
      }
      if (value > this._nativeAudioDestinationNode.maxChannelCount) {
        throw createIndexSizeError2();
      }
      this._nativeAudioDestinationNode.channelCount = value;
    }
    get channelCountMode() {
      return this._nativeAudioDestinationNode.channelCountMode;
    }
    set channelCountMode(value) {
      if (this._isNodeOfNativeOfflineAudioContext) {
        throw createInvalidStateError2();
      }
      this._nativeAudioDestinationNode.channelCountMode = value;
    }
    get maxChannelCount() {
      return this._nativeAudioDestinationNode.maxChannelCount;
    }
  };
};
const createAudioDestinationNodeRenderer = (renderInputsOfAudioNode2) => {
  const renderedNativeAudioDestinationNodes = /* @__PURE__ */ new WeakMap();
  const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {
    const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;
    renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);
    await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);
    return nativeAudioDestinationNode;
  };
  return {
    render(proxy, nativeOfflineAudioContext) {
      const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);
      if (renderedNativeAudioDestinationNode !== void 0) {
        return Promise.resolve(renderedNativeAudioDestinationNode);
      }
      return createAudioDestinationNode(proxy, nativeOfflineAudioContext);
    }
  };
};
const createAudioListenerFactory = (createAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeScriptProcessorNode2, createNotSupportedError2, getFirstSample2, isNativeOfflineAudioContext2, overwriteAccessors2) => {
  return (context2, nativeContext) => {
    const nativeListener = nativeContext.listener;
    const createFakeAudioParams = () => {
      const buffer = new Float32Array(1);
      const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        numberOfInputs: 9
      });
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      let isScriptProcessorNodeCreated = false;
      let lastOrientation = [0, 0, -1, 0, 1, 0];
      let lastPosition = [0, 0, 0];
      const createScriptProcessorNode = () => {
        if (isScriptProcessorNodeCreated) {
          return;
        }
        isScriptProcessorNodeCreated = true;
        const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 9, 0);
        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
          const orientation = [
            getFirstSample2(inputBuffer, buffer, 0),
            getFirstSample2(inputBuffer, buffer, 1),
            getFirstSample2(inputBuffer, buffer, 2),
            getFirstSample2(inputBuffer, buffer, 3),
            getFirstSample2(inputBuffer, buffer, 4),
            getFirstSample2(inputBuffer, buffer, 5)
          ];
          if (orientation.some((value, index) => value !== lastOrientation[index])) {
            nativeListener.setOrientation(...orientation);
            lastOrientation = orientation;
          }
          const positon = [
            getFirstSample2(inputBuffer, buffer, 6),
            getFirstSample2(inputBuffer, buffer, 7),
            getFirstSample2(inputBuffer, buffer, 8)
          ];
          if (positon.some((value, index) => value !== lastPosition[index])) {
            nativeListener.setPosition(...positon);
            lastPosition = positon;
          }
        };
        channelMergerNode.connect(scriptProcessorNode);
      };
      const createSetOrientation = (index) => (value) => {
        if (value !== lastOrientation[index]) {
          lastOrientation[index] = value;
          nativeListener.setOrientation(...lastOrientation);
        }
      };
      const createSetPosition = (index) => (value) => {
        if (value !== lastPosition[index]) {
          lastPosition[index] = value;
          nativeListener.setPosition(...lastPosition);
        }
      };
      const createFakeAudioParam = (input, initialValue, setValue) => {
        const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          offset: initialValue
        });
        constantSourceNode.connect(channelMergerNode, 0, input);
        constantSourceNode.start();
        Object.defineProperty(constantSourceNode.offset, "defaultValue", {
          get() {
            return initialValue;
          }
        });
        const audioParam = createAudioParam2({ context: context2 }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        overwriteAccessors2(audioParam, "value", (get2) => () => get2.call(audioParam), (set2) => (value) => {
          try {
            set2.call(audioParam, value);
          } catch (err) {
            if (err.code !== 9) {
              throw err;
            }
          }
          createScriptProcessorNode();
          if (isOffline) {
            setValue(value);
          }
        });
        audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = cancelAndHoldAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.cancelAndHoldAtTime);
        audioParam.cancelScheduledValues = ((cancelScheduledValues) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = cancelScheduledValues.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.cancelScheduledValues);
        audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = exponentialRampToValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.exponentialRampToValueAtTime);
        audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = linearRampToValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.linearRampToValueAtTime);
        audioParam.setTargetAtTime = ((setTargetAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = setTargetAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setTargetAtTime);
        audioParam.setValueAtTime = ((setValueAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = setValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setValueAtTime);
        audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError2();
            };
          }
          return (...args) => {
            const value = setValueCurveAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setValueCurveAtTime);
        return audioParam;
      };
      return {
        forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),
        forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),
        forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),
        positionX: createFakeAudioParam(6, 0, createSetPosition(0)),
        positionY: createFakeAudioParam(7, 0, createSetPosition(1)),
        positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),
        upX: createFakeAudioParam(3, 0, createSetOrientation(3)),
        upY: createFakeAudioParam(4, 1, createSetOrientation(4)),
        upZ: createFakeAudioParam(5, 0, createSetOrientation(5))
      };
    };
    const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === void 0 ? createFakeAudioParams() : nativeListener;
    return {
      get forwardX() {
        return forwardX;
      },
      get forwardY() {
        return forwardY;
      },
      get forwardZ() {
        return forwardZ;
      },
      get positionX() {
        return positionX;
      },
      get positionY() {
        return positionY;
      },
      get positionZ() {
        return positionZ;
      },
      get upX() {
        return upX;
      },
      get upY() {
        return upY;
      },
      get upZ() {
        return upZ;
      }
    };
  };
};
const isAudioNode$1 = (audioNodeOrAudioParam) => {
  return "context" in audioNodeOrAudioParam;
};
const isAudioNodeOutputConnection = (outputConnection) => {
  return isAudioNode$1(outputConnection[0]);
};
const insertElementInSet = (set2, element2, predicate, ignoreDuplicates) => {
  for (const lmnt of set2) {
    if (predicate(lmnt)) {
      if (ignoreDuplicates) {
        return false;
      }
      throw Error("The set contains at least one similar element.");
    }
  }
  set2.add(element2);
  return true;
};
const addActiveInputConnectionToAudioParam = (activeInputs, source, [output2, eventListener], ignoreDuplicates) => {
  insertElementInSet(activeInputs, [source, output2, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output2, ignoreDuplicates);
};
const addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output2, eventListener], ignoreDuplicates) => {
  const passiveInputConnections = passiveInputs.get(source);
  if (passiveInputConnections === void 0) {
    passiveInputs.set(source, /* @__PURE__ */ new Set([[output2, eventListener]]));
  } else {
    insertElementInSet(passiveInputConnections, [output2, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output2, ignoreDuplicates);
  }
};
const isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {
  return "inputs" in nativeAudioNodeOrNativeAudioNodeFaker;
};
const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output2, input) => {
  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
    const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];
    nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output2, 0);
    return [fakeNativeDestinationAudioNode, output2, 0];
  }
  nativeSourceAudioNode.connect(nativeDestinationAudioNode, output2, input);
  return [nativeDestinationAudioNode, output2, input];
};
const deleteActiveInputConnection = (activeInputConnections, source, output2) => {
  for (const activeInputConnection of activeInputConnections) {
    if (activeInputConnection[0] === source && activeInputConnection[1] === output2) {
      activeInputConnections.delete(activeInputConnection);
      return activeInputConnection;
    }
  }
  return null;
};
const deleteActiveInputConnectionToAudioParam = (activeInputs, source, output2) => {
  return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output2);
};
const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {
  const eventListeners = getEventListenersOfAudioNode(audioNode);
  if (!eventListeners.delete(eventListener)) {
    throw new Error("Missing the expected event listener.");
  }
};
const deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output2) => {
  const passiveInputConnections = getValueForKey(passiveInputs, source);
  const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output2);
  if (passiveInputConnections.size === 0) {
    passiveInputs.delete(source);
  }
  return matchingConnection;
};
const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output2, input) => {
  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output2, 0);
  } else {
    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output2, input);
  }
};
const getNativeAudioNode = (audioNode) => {
  return getValueForKey(AUDIO_NODE_STORE, audioNode);
};
const getNativeAudioParam = (audioParam) => {
  return getValueForKey(AUDIO_PARAM_STORE, audioParam);
};
const isPartOfACycle = (audioNode) => {
  return CYCLE_COUNTERS.has(audioNode);
};
const isPassiveAudioNode = (audioNode) => {
  return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);
};
const testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor2) => {
  return new Promise((resolve) => {
    if (nativeAudioWorkletNodeConstructor2 !== null) {
      resolve(true);
    } else {
      const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);
      const dummy = nativeAudioContext.createGain();
      const ones = nativeAudioContext.createBuffer(1, 2, 44100);
      const channelData = ones.getChannelData(0);
      channelData[0] = 1;
      channelData[1] = 1;
      const source = nativeAudioContext.createBufferSource();
      source.buffer = ones;
      source.loop = true;
      source.connect(analyzer).connect(nativeAudioContext.destination);
      source.connect(dummy);
      source.disconnect(dummy);
      analyzer.onaudioprocess = (event) => {
        const chnnlDt = event.inputBuffer.getChannelData(0);
        if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {
          resolve(true);
        } else {
          resolve(false);
        }
        source.stop();
        analyzer.onaudioprocess = null;
        source.disconnect(analyzer);
        analyzer.disconnect(nativeAudioContext.destination);
      };
      source.start();
    }
  });
};
const visitEachAudioNodeOnce = (cycles, visitor) => {
  const counts = /* @__PURE__ */ new Map();
  for (const cycle of cycles) {
    for (const audioNode of cycle) {
      const count = counts.get(audioNode);
      counts.set(audioNode, count === void 0 ? 1 : count + 1);
    }
  }
  counts.forEach((count, audioNode) => visitor(audioNode, count));
};
const isNativeAudioNode$1 = (nativeAudioNodeOrAudioParam) => {
  return "context" in nativeAudioNodeOrAudioParam;
};
const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {
  const connections = /* @__PURE__ */ new Map();
  nativeAudioNode.connect = /* @__PURE__ */ ((connect2) => {
    return (destination, output2 = 0, input = 0) => {
      const returnValue = isNativeAudioNode$1(destination) ? connect2(destination, output2, input) : connect2(destination, output2);
      const connectionsToDestination = connections.get(destination);
      if (connectionsToDestination === void 0) {
        connections.set(destination, [{ input, output: output2 }]);
      } else {
        if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output2)) {
          connectionsToDestination.push({ input, output: output2 });
        }
      }
      return returnValue;
    };
  })(nativeAudioNode.connect.bind(nativeAudioNode));
  nativeAudioNode.disconnect = /* @__PURE__ */ ((disconnect2) => {
    return (destinationOrOutput, output2, input) => {
      disconnect2.apply(nativeAudioNode);
      if (destinationOrOutput === void 0) {
        connections.clear();
      } else if (typeof destinationOrOutput === "number") {
        for (const [destination, connectionsToDestination] of connections) {
          const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);
          if (filteredConnections.length === 0) {
            connections.delete(destination);
          } else {
            connections.set(destination, filteredConnections);
          }
        }
      } else if (connections.has(destinationOrOutput)) {
        if (output2 === void 0) {
          connections.delete(destinationOrOutput);
        } else {
          const connectionsToDestination = connections.get(destinationOrOutput);
          if (connectionsToDestination !== void 0) {
            const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output2 && (connection.input !== input || input === void 0));
            if (filteredConnections.length === 0) {
              connections.delete(destinationOrOutput);
            } else {
              connections.set(destinationOrOutput, filteredConnections);
            }
          }
        }
      }
      for (const [destination, connectionsToDestination] of connections) {
        connectionsToDestination.forEach((connection) => {
          if (isNativeAudioNode$1(destination)) {
            nativeAudioNode.connect(destination, connection.output, connection.input);
          } else {
            nativeAudioNode.connect(destination, connection.output);
          }
        });
      }
    };
  })(nativeAudioNode.disconnect);
};
const addConnectionToAudioParamOfAudioContext = (source, destination, output2, isOffline) => {
  const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
  const { outputs: outputs2 } = getAudioNodeConnections(source);
  const eventListeners = getEventListenersOfAudioNode(source);
  const eventListener = (isActive) => {
    const nativeAudioNode = getNativeAudioNode(source);
    const nativeAudioParam = getNativeAudioParam(destination);
    if (isActive) {
      const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output2);
      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);
      if (!isOffline && !isPartOfACycle(source)) {
        nativeAudioNode.connect(nativeAudioParam, output2);
      }
    } else {
      const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output2);
      addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);
      if (!isOffline && !isPartOfACycle(source)) {
        nativeAudioNode.disconnect(nativeAudioParam, output2);
      }
    }
  };
  if (insertElementInSet(outputs2, [destination, output2], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output2, true)) {
    eventListeners.add(eventListener);
    if (isActiveAudioNode(source)) {
      addActiveInputConnectionToAudioParam(activeInputs, source, [output2, eventListener], true);
    } else {
      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output2, eventListener], true);
    }
    return true;
  }
  return false;
};
const deleteInputConnectionOfAudioNode = (source, destination, output2, input) => {
  const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);
  const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output2);
  if (activeInputConnection === null) {
    const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output2, input);
    return [passiveInputConnection[2], false];
  }
  return [activeInputConnection[2], true];
};
const deleteInputConnectionOfAudioParam = (source, destination, output2) => {
  const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
  const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output2);
  if (activeInputConnection === null) {
    const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output2);
    return [passiveInputConnection[1], false];
  }
  return [activeInputConnection[2], true];
};
const deleteInputsOfAudioNode = (source, isOffline, destination, output2, input) => {
  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output2, input);
  if (listener !== null) {
    deleteEventListenerOfAudioNode(source, listener);
    if (isActive && !isOffline && !isPartOfACycle(source)) {
      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output2, input);
    }
  }
  if (isActiveAudioNode(destination)) {
    const { activeInputs } = getAudioNodeConnections(destination);
    setInternalStateToPassiveWhenNecessary(destination, activeInputs);
  }
};
const deleteInputsOfAudioParam = (source, isOffline, destination, output2) => {
  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output2);
  if (listener !== null) {
    deleteEventListenerOfAudioNode(source, listener);
    if (isActive && !isOffline && !isPartOfACycle(source)) {
      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output2);
    }
  }
};
const deleteAnyConnection = (source, isOffline) => {
  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
  const destinations = [];
  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
    if (isAudioNodeOutputConnection(outputConnection)) {
      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
    } else {
      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
    }
    destinations.push(outputConnection[0]);
  }
  audioNodeConnectionsOfSource.outputs.clear();
  return destinations;
};
const deleteConnectionAtOutput = (source, isOffline, output2) => {
  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
  const destinations = [];
  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
    if (outputConnection[1] === output2) {
      if (isAudioNodeOutputConnection(outputConnection)) {
        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
      } else {
        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
      }
      destinations.push(outputConnection[0]);
      audioNodeConnectionsOfSource.outputs.delete(outputConnection);
    }
  }
  return destinations;
};
const deleteConnectionToDestination = (source, isOffline, destination, output2, input) => {
  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
  return Array.from(audioNodeConnectionsOfSource.outputs).filter((outputConnection) => outputConnection[0] === destination && (output2 === void 0 || outputConnection[1] === output2) && (input === void 0 || outputConnection[2] === input)).map((outputConnection) => {
    if (isAudioNodeOutputConnection(outputConnection)) {
      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
    } else {
      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
    }
    audioNodeConnectionsOfSource.outputs.delete(outputConnection);
    return outputConnection[0];
  });
};
const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult2, createIncrementCycleCounter, createIndexSizeError2, createInvalidAccessError2, createNotSupportedError2, decrementCycleCounter, detectCycles, eventTargetConstructor2, getNativeContext2, isNativeAudioContext2, isNativeAudioNode2, isNativeAudioParam2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2) => {
  return class AudioNode extends eventTargetConstructor2 {
    constructor(context2, isActive, nativeAudioNode, audioNodeRenderer) {
      super(nativeAudioNode);
      this._context = context2;
      this._nativeAudioNode = nativeAudioNode;
      const nativeContext = getNativeContext2(context2);
      if (isNativeAudioContext2(nativeContext) && true !== cacheTestResult2(testAudioNodeDisconnectMethodSupport, () => {
        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor2);
      })) {
        wrapAudioNodeDisconnectMethod(nativeAudioNode);
      }
      AUDIO_NODE_STORE.set(this, nativeAudioNode);
      EVENT_LISTENERS.set(this, /* @__PURE__ */ new Set());
      if (context2.state !== "closed" && isActive) {
        setInternalStateToActive(this);
      }
      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);
    }
    get channelCount() {
      return this._nativeAudioNode.channelCount;
    }
    set channelCount(value) {
      this._nativeAudioNode.channelCount = value;
    }
    get channelCountMode() {
      return this._nativeAudioNode.channelCountMode;
    }
    set channelCountMode(value) {
      this._nativeAudioNode.channelCountMode = value;
    }
    get channelInterpretation() {
      return this._nativeAudioNode.channelInterpretation;
    }
    set channelInterpretation(value) {
      this._nativeAudioNode.channelInterpretation = value;
    }
    get context() {
      return this._context;
    }
    get numberOfInputs() {
      return this._nativeAudioNode.numberOfInputs;
    }
    get numberOfOutputs() {
      return this._nativeAudioNode.numberOfOutputs;
    }
    // tslint:disable-next-line:invalid-void
    connect(destination, output2 = 0, input = 0) {
      if (output2 < 0 || output2 >= this._nativeAudioNode.numberOfOutputs) {
        throw createIndexSizeError2();
      }
      const nativeContext = getNativeContext2(this._context);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      if (isNativeAudioNode2(destination) || isNativeAudioParam2(destination)) {
        throw createInvalidAccessError2();
      }
      if (isAudioNode$1(destination)) {
        const nativeDestinationAudioNode = getNativeAudioNode(destination);
        try {
          const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output2, input);
          const isPassive = isPassiveAudioNode(this);
          if (isOffline || isPassive) {
            this._nativeAudioNode.disconnect(...connection);
          }
          if (this.context.state !== "closed" && !isPassive && isPassiveAudioNode(destination)) {
            setInternalStateToActive(destination);
          }
        } catch (err) {
          if (err.code === 12) {
            throw createInvalidAccessError2();
          }
          throw err;
        }
        const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output2, input, isOffline);
        if (isNewConnectionToAudioNode) {
          const cycles = detectCycles([this], destination);
          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
        }
        return destination;
      }
      const nativeAudioParam = getNativeAudioParam(destination);
      if (nativeAudioParam.name === "playbackRate" && nativeAudioParam.maxValue === 1024) {
        throw createNotSupportedError2();
      }
      try {
        this._nativeAudioNode.connect(nativeAudioParam, output2);
        if (isOffline || isPassiveAudioNode(this)) {
          this._nativeAudioNode.disconnect(nativeAudioParam, output2);
        }
      } catch (err) {
        if (err.code === 12) {
          throw createInvalidAccessError2();
        }
        throw err;
      }
      const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output2, isOffline);
      if (isNewConnectionToAudioParam) {
        const cycles = detectCycles([this], destination);
        visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
      }
    }
    disconnect(destinationOrOutput, output2, input) {
      let destinations;
      const nativeContext = getNativeContext2(this._context);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      if (destinationOrOutput === void 0) {
        destinations = deleteAnyConnection(this, isOffline);
      } else if (typeof destinationOrOutput === "number") {
        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {
          throw createIndexSizeError2();
        }
        destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);
      } else {
        if (output2 !== void 0 && (output2 < 0 || output2 >= this.numberOfOutputs)) {
          throw createIndexSizeError2();
        }
        if (isAudioNode$1(destinationOrOutput) && input !== void 0 && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {
          throw createIndexSizeError2();
        }
        destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output2, input);
        if (destinations.length === 0) {
          throw createInvalidAccessError2();
        }
      }
      for (const destination of destinations) {
        const cycles = detectCycles([this], destination);
        visitEachAudioNodeOnce(cycles, decrementCycleCounter);
      }
    }
  };
};
const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore2, audioParamStore, createAudioParamRenderer2, createCancelAndHoldAutomationEvent2, createCancelScheduledValuesAutomationEvent2, createExponentialRampToValueAutomationEvent2, createLinearRampToValueAutomationEvent2, createSetTargetAutomationEvent2, createSetValueAutomationEvent2, createSetValueCurveAutomationEvent2, nativeAudioContextConstructor2, setValueAtTimeUntilPossible2) => {
  return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {
    const defaultValue = nativeAudioParam.value;
    const automationEventList = new AutomationEventList(defaultValue);
    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer2(automationEventList) : null;
    const audioParam = {
      get defaultValue() {
        return defaultValue;
      },
      get maxValue() {
        return maxValue === null ? nativeAudioParam.maxValue : maxValue;
      },
      get minValue() {
        return minValue === null ? nativeAudioParam.minValue : minValue;
      },
      get value() {
        return nativeAudioParam.value;
      },
      set value(value) {
        nativeAudioParam.value = value;
        audioParam.setValueAtTime(value, audioNode.context.currentTime);
      },
      cancelAndHoldAtTime(cancelTime) {
        if (typeof nativeAudioParam.cancelAndHoldAtTime === "function") {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
          nativeAudioParam.cancelAndHoldAtTime(cancelTime);
        } else {
          const previousLastEvent = Array.from(automationEventList).pop();
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
          const currentLastEvent = Array.from(automationEventList).pop();
          nativeAudioParam.cancelScheduledValues(cancelTime);
          if (previousLastEvent !== currentLastEvent && currentLastEvent !== void 0) {
            if (currentLastEvent.type === "exponentialRampToValue") {
              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
            } else if (currentLastEvent.type === "linearRampToValue") {
              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
            } else if (currentLastEvent.type === "setValue") {
              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);
            } else if (currentLastEvent.type === "setValueCurve") {
              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);
            }
          }
        }
        return audioParam;
      },
      cancelScheduledValues(cancelTime) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }
        automationEventList.add(createCancelScheduledValuesAutomationEvent2(cancelTime));
        nativeAudioParam.cancelScheduledValues(cancelTime);
        return audioParam;
      },
      exponentialRampToValueAtTime(value, endTime) {
        if (value === 0) {
          throw new RangeError();
        }
        if (!Number.isFinite(endTime) || endTime < 0) {
          throw new RangeError();
        }
        const currentTime = audioNode.context.currentTime;
        if (audioParamRenderer === null) {
          automationEventList.flush(currentTime);
        }
        if (Array.from(automationEventList).length === 0) {
          automationEventList.add(createSetValueAutomationEvent2(defaultValue, currentTime));
          nativeAudioParam.setValueAtTime(defaultValue, currentTime);
        }
        automationEventList.add(createExponentialRampToValueAutomationEvent2(value, endTime));
        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
        return audioParam;
      },
      linearRampToValueAtTime(value, endTime) {
        const currentTime = audioNode.context.currentTime;
        if (audioParamRenderer === null) {
          automationEventList.flush(currentTime);
        }
        if (Array.from(automationEventList).length === 0) {
          automationEventList.add(createSetValueAutomationEvent2(defaultValue, currentTime));
          nativeAudioParam.setValueAtTime(defaultValue, currentTime);
        }
        automationEventList.add(createLinearRampToValueAutomationEvent2(value, endTime));
        nativeAudioParam.linearRampToValueAtTime(value, endTime);
        return audioParam;
      },
      setTargetAtTime(target, startTime, timeConstant) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }
        automationEventList.add(createSetTargetAutomationEvent2(target, startTime, timeConstant));
        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
        return audioParam;
      },
      setValueAtTime(value, startTime) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }
        automationEventList.add(createSetValueAutomationEvent2(value, startTime));
        nativeAudioParam.setValueAtTime(value, startTime);
        return audioParam;
      },
      setValueCurveAtTime(values, startTime, duration2) {
        const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);
        if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
          const endTime = startTime + duration2;
          const sampleRate = audioNode.context.sampleRate;
          const firstSample = Math.ceil(startTime * sampleRate);
          const lastSample = Math.floor(endTime * sampleRate);
          const numberOfInterpolatedValues = lastSample - firstSample;
          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);
          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {
            const theoreticIndex = (convertedValues.length - 1) / duration2 * ((firstSample + i) / sampleRate - startTime);
            const lowerIndex = Math.floor(theoreticIndex);
            const upperIndex = Math.ceil(theoreticIndex);
            interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];
          }
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createSetValueCurveAutomationEvent2(interpolatedValues, startTime, duration2));
          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration2);
          const timeOfLastSample = lastSample / sampleRate;
          if (timeOfLastSample < endTime) {
            setValueAtTimeUntilPossible2(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);
          }
          setValueAtTimeUntilPossible2(audioParam, convertedValues[convertedValues.length - 1], endTime);
        } else {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }
          automationEventList.add(createSetValueCurveAutomationEvent2(convertedValues, startTime, duration2));
          nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration2);
        }
        return audioParam;
      }
    };
    audioParamStore.set(audioParam, nativeAudioParam);
    audioParamAudioNodeStore2.set(audioParam, audioNode);
    addAudioParamConnections(audioParam, audioParamRenderer);
    return audioParam;
  };
};
const createAudioParamRenderer = (automationEventList) => {
  return {
    replay(audioParam) {
      for (const automationEvent of automationEventList) {
        if (automationEvent.type === "exponentialRampToValue") {
          const { endTime, value } = automationEvent;
          audioParam.exponentialRampToValueAtTime(value, endTime);
        } else if (automationEvent.type === "linearRampToValue") {
          const { endTime, value } = automationEvent;
          audioParam.linearRampToValueAtTime(value, endTime);
        } else if (automationEvent.type === "setTarget") {
          const { startTime, target, timeConstant } = automationEvent;
          audioParam.setTargetAtTime(target, startTime, timeConstant);
        } else if (automationEvent.type === "setValue") {
          const { startTime, value } = automationEvent;
          audioParam.setValueAtTime(value, startTime);
        } else if (automationEvent.type === "setValueCurve") {
          const { duration: duration2, startTime, values } = automationEvent;
          audioParam.setValueCurveAtTime(values, startTime, duration2);
        } else {
          throw new Error("Can't apply an unknown automation.");
        }
      }
    }
  };
};
class ReadOnlyMap {
  constructor(parameters) {
    this._map = new Map(parameters);
  }
  get size() {
    return this._map.size;
  }
  entries() {
    return this._map.entries();
  }
  forEach(callback, thisArg = null) {
    return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));
  }
  get(name) {
    return this._map.get(name);
  }
  has(name) {
    return this._map.has(name);
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.values();
  }
}
const DEFAULT_OPTIONS$g = {
  channelCount: 2,
  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 1,
  numberOfOutputs: 1,
  parameterData: {},
  processorOptions: {}
};
const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode2, audioNodeConstructor2, createAudioParam2, createAudioWorkletNodeRenderer2, createNativeAudioWorkletNode2, getAudioNodeConnections2, getBackupOfflineAudioContext2, getNativeContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, sanitizeAudioWorkletNodeOptions2, setActiveAudioWorkletNodeInputs2, testAudioWorkletNodeOptionsClonability2, wrapEventListener2) => {
  return class AudioWorkletNode extends audioNodeConstructor2 {
    constructor(context2, name, options2) {
      var _a;
      const nativeContext = getNativeContext2(context2);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const mergedOptions = sanitizeAudioWorkletNodeOptions2({ ...DEFAULT_OPTIONS$g, ...options2 });
      testAudioWorkletNodeOptionsClonability2(mergedOptions);
      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
      const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);
      const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== "closed" ? nativeContext : (_a = getBackupOfflineAudioContext2(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;
      const nativeAudioWorkletNode = createNativeAudioWorkletNode2(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context2.baseLatency, nativeAudioWorkletNodeConstructor2, name, processorConstructor, mergedOptions);
      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer2(name, mergedOptions, processorConstructor) : null;
      super(context2, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);
      const parameters = [];
      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {
        const audioParam = createAudioParam2(this, isOffline, nativeAudioParam);
        parameters.push([nm, audioParam]);
      });
      this._nativeAudioWorkletNode = nativeAudioWorkletNode;
      this._onprocessorerror = null;
      this._parameters = new ReadOnlyMap(parameters);
      if (isOffline) {
        addUnrenderedAudioWorkletNode2(nativeContext, this);
      }
      const { activeInputs } = getAudioNodeConnections2(this);
      setActiveAudioWorkletNodeInputs2(nativeAudioWorkletNode, activeInputs);
    }
    get onprocessorerror() {
      return this._onprocessorerror;
    }
    set onprocessorerror(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;
      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;
      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;
    }
    get parameters() {
      if (this._parameters === null) {
        return this._nativeAudioWorkletNode.parameters;
      }
      return this._parameters;
    }
    get port() {
      return this._nativeAudioWorkletNode.port;
    }
  };
};
function copyFromChannel(audioBuffer, parent, key, channelNumber, bufferOffset) {
  if (typeof audioBuffer.copyFromChannel === "function") {
    if (parent[key].byteLength === 0) {
      parent[key] = new Float32Array(128);
    }
    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);
  } else {
    const channelData = audioBuffer.getChannelData(channelNumber);
    if (parent[key].byteLength === 0) {
      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);
    } else {
      const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);
      parent[key].set(slicedInput);
    }
  }
}
const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {
  if (typeof audioBuffer.copyToChannel === "function") {
    if (parent[key].byteLength !== 0) {
      audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);
    }
  } else {
    if (parent[key].byteLength !== 0) {
      audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);
    }
  }
};
const createNestedArrays = (x, y) => {
  const arrays = [];
  for (let i = 0; i < x; i += 1) {
    const array2 = [];
    const length = typeof y === "number" ? y : y[i];
    for (let j2 = 0; j2 < length; j2 += 1) {
      array2.push(new Float32Array(128));
    }
    arrays.push(array2);
  }
  return arrays;
};
const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {
  const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);
  const nativeAudioWorkletNode = getNativeAudioNode(proxy);
  return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);
};
const processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options2, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2) => {
  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;
  const numberOfInputChannels = options2.channelCount * options2.numberOfInputs;
  const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);
  if (processorConstructor === void 0) {
    throw new Error("Missing the processor constructor.");
  }
  const audioNodeConnections = getAudioNodeConnections(proxy);
  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);
  const inputs = createNestedArrays(options2.numberOfInputs, options2.channelCount);
  const outputs2 = createNestedArrays(options2.numberOfOutputs, outputChannelCount);
  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});
  for (let i = 0; i < length; i += 128) {
    if (options2.numberOfInputs > 0 && renderedBuffer !== null) {
      for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
        for (let k = 0; k < options2.channelCount; k += 1) {
          copyFromChannel(renderedBuffer, inputs[j2], k, k, i);
        }
      }
    }
    if (processorConstructor.parameterDescriptors !== void 0 && renderedBuffer !== null) {
      processorConstructor.parameterDescriptors.forEach(({ name }, index) => {
        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);
      });
    }
    for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
      for (let k = 0; k < outputChannelCount[j2]; k += 1) {
        if (outputs2[j2][k].byteLength === 0) {
          outputs2[j2][k] = new Float32Array(128);
        }
      }
    }
    try {
      const potentiallyEmptyInputs = inputs.map((input, index) => {
        if (audioNodeConnections.activeInputs[index].size === 0) {
          return [];
        }
        return input;
      });
      const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs2, parameters));
      if (processedBuffer !== null) {
        for (let j2 = 0, outputChannelSplitterNodeOutput = 0; j2 < options2.numberOfOutputs; j2 += 1) {
          for (let k = 0; k < outputChannelCount[j2]; k += 1) {
            copyToChannel(processedBuffer, outputs2[j2], k, outputChannelSplitterNodeOutput + k, i);
          }
          outputChannelSplitterNodeOutput += outputChannelCount[j2];
        }
      }
      if (!activeSourceFlag) {
        break;
      }
    } catch (error2) {
      proxy.dispatchEvent(new ErrorEvent("processorerror", {
        colno: error2.colno,
        filename: error2.filename,
        lineno: error2.lineno,
        message: error2.message
      }));
      break;
    }
  }
  return processedBuffer;
};
const createAudioWorkletNodeRendererFactory = (connectAudioParam2, connectMultipleOutputs2, createNativeAudioBufferSourceNode2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, deleteUnrenderedAudioWorkletNode2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getNativeAudioNode2, nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
  return (name, options2, processorConstructor) => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    let processedBufferPromise = null;
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioWorkletNode = getNativeAudioNode2(proxy);
      let nativeOutputNodes = null;
      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);
      const outputChannelCount = Array.isArray(options2.outputChannelCount) ? options2.outputChannelCount : Array.from(options2.outputChannelCount);
      if (nativeAudioWorkletNodeConstructor2 === null) {
        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
        const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, {
          channelCount: Math.max(1, numberOfOutputChannels),
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          numberOfOutputs: Math.max(1, numberOfOutputChannels)
        });
        const outputChannelMergerNodes = [];
        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {
          outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeOfflineAudioContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: outputChannelCount[i]
          }));
        }
        const outputGainNode = createNativeGainNode2(nativeOfflineAudioContext, {
          channelCount: options2.channelCount,
          channelCountMode: options2.channelCountMode,
          channelInterpretation: options2.channelInterpretation,
          gain: 1
        });
        outputGainNode.connect = connectMultipleOutputs2.bind(null, outputChannelMergerNodes);
        outputGainNode.disconnect = disconnectMultipleOutputs2.bind(null, outputChannelMergerNodes);
        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];
      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {
        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeOfflineAudioContext, name);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);
      if (nativeOutputNodes !== null) {
        if (processedBufferPromise === null) {
          if (processorConstructor === void 0) {
            throw new Error("Missing the processor constructor.");
          }
          if (nativeOfflineAudioContextConstructor2 === null) {
            throw new Error("Missing the native OfflineAudioContext constructor.");
          }
          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;
          const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
          const numberOfChannels = numberOfInputChannels + numberOfParameters;
          const renderBuffer2 = async () => {
            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(
              numberOfChannels,
              // Ceil the length to the next full render quantum.
              // Bug #17: Safari does not yet expose the length.
              Math.ceil(proxy.context.length / 128) * 128,
              nativeOfflineAudioContext.sampleRate
            );
            const gainNodes = [];
            const inputChannelSplitterNodes = [];
            for (let i = 0; i < options2.numberOfInputs; i += 1) {
              gainNodes.push(createNativeGainNode2(partialOfflineAudioContext, {
                channelCount: options2.channelCount,
                channelCountMode: options2.channelCountMode,
                channelInterpretation: options2.channelInterpretation,
                gain: 1
              }));
              inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(partialOfflineAudioContext, {
                channelCount: options2.channelCount,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                numberOfOutputs: options2.channelCount
              }));
            }
            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {
              const constantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                offset: audioParam.value
              });
              await renderAutomation2(partialOfflineAudioContext, audioParam, constantSourceNode.offset);
              return constantSourceNode;
            }));
            const inputChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "speakers",
              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
            });
            for (let i = 0; i < options2.numberOfInputs; i += 1) {
              gainNodes[i].connect(inputChannelSplitterNodes[i]);
              for (let j2 = 0; j2 < options2.channelCount; j2 += 1) {
                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j2, i * options2.channelCount + j2);
              }
            }
            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {
              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);
              constantSourceNode.start(0);
            }
            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);
            await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, gainNode)));
            return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
          };
          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer2(), nativeOfflineAudioContext, options2, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2);
        }
        const processedBuffer = await processedBufferPromise;
        const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
          buffer: null,
          channelCount: 2,
          channelCountMode: "max",
          channelInterpretation: "speakers",
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        });
        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;
        if (processedBuffer !== null) {
          audioBufferSourceNode.buffer = processedBuffer;
          audioBufferSourceNode.start(0);
        }
        audioBufferSourceNode.connect(outputChannelSplitterNode);
        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {
          const outputChannelMergerNode = outputChannelMergerNodes[i];
          for (let j2 = 0; j2 < outputChannelCount[i]; j2 += 1) {
            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
          }
          outputChannelSplitterNodeOutput += outputChannelCount[i];
        }
        return outputGainNode;
      }
      if (!nativeAudioWorkletNodeIsOwnedByContext) {
        for (const [nm, audioParam] of proxy.parameters.entries()) {
          await renderAutomation2(
            nativeOfflineAudioContext,
            audioParam,
            // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
            nativeAudioWorkletNode.parameters.get(nm)
          );
        }
      } else {
        for (const [nm, audioParam] of proxy.parameters.entries()) {
          await connectAudioParam2(
            nativeOfflineAudioContext,
            audioParam,
            // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
            nativeAudioWorkletNode.parameters.get(nm)
          );
        }
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);
      return nativeAudioWorkletNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        deleteUnrenderedAudioWorkletNode2(nativeOfflineAudioContext, proxy);
        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioWorkletNodeOrGainNode !== void 0) {
          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createBaseAudioContextConstructor = (addAudioWorkletModule2, analyserNodeConstructor2, audioBufferConstructor2, audioBufferSourceNodeConstructor2, biquadFilterNodeConstructor2, channelMergerNodeConstructor2, channelSplitterNodeConstructor2, constantSourceNodeConstructor2, convolverNodeConstructor2, decodeAudioData2, delayNodeConstructor2, dynamicsCompressorNodeConstructor2, gainNodeConstructor2, iIRFilterNodeConstructor2, minimalBaseAudioContextConstructor2, oscillatorNodeConstructor2, pannerNodeConstructor2, periodicWaveConstructor2, stereoPannerNodeConstructor2, waveShaperNodeConstructor2) => {
  return class BaseAudioContext extends minimalBaseAudioContextConstructor2 {
    constructor(_nativeContext, numberOfChannels) {
      super(_nativeContext, numberOfChannels);
      this._nativeContext = _nativeContext;
      this._audioWorklet = addAudioWorkletModule2 === void 0 ? void 0 : {
        addModule: (moduleURL, options2) => {
          return addAudioWorkletModule2(this, moduleURL, options2);
        }
      };
    }
    get audioWorklet() {
      return this._audioWorklet;
    }
    createAnalyser() {
      return new analyserNodeConstructor2(this);
    }
    createBiquadFilter() {
      return new biquadFilterNodeConstructor2(this);
    }
    createBuffer(numberOfChannels, length, sampleRate) {
      return new audioBufferConstructor2({ length, numberOfChannels, sampleRate });
    }
    createBufferSource() {
      return new audioBufferSourceNodeConstructor2(this);
    }
    createChannelMerger(numberOfInputs = 6) {
      return new channelMergerNodeConstructor2(this, { numberOfInputs });
    }
    createChannelSplitter(numberOfOutputs = 6) {
      return new channelSplitterNodeConstructor2(this, { numberOfOutputs });
    }
    createConstantSource() {
      return new constantSourceNodeConstructor2(this);
    }
    createConvolver() {
      return new convolverNodeConstructor2(this);
    }
    createDelay(maxDelayTime = 1) {
      return new delayNodeConstructor2(this, { maxDelayTime });
    }
    createDynamicsCompressor() {
      return new dynamicsCompressorNodeConstructor2(this);
    }
    createGain() {
      return new gainNodeConstructor2(this);
    }
    createIIRFilter(feedforward, feedback) {
      return new iIRFilterNodeConstructor2(this, { feedback, feedforward });
    }
    createOscillator() {
      return new oscillatorNodeConstructor2(this);
    }
    createPanner() {
      return new pannerNodeConstructor2(this);
    }
    createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {
      return new periodicWaveConstructor2(this, { ...constraints, imag, real });
    }
    createStereoPanner() {
      return new stereoPannerNodeConstructor2(this);
    }
    createWaveShaper() {
      return new waveShaperNodeConstructor2(this);
    }
    decodeAudioData(audioData, successCallback, errorCallback) {
      return decodeAudioData2(this._nativeContext, audioData).then((audioBuffer) => {
        if (typeof successCallback === "function") {
          successCallback(audioBuffer);
        }
        return audioBuffer;
      }, (err) => {
        if (typeof errorCallback === "function") {
          errorCallback(err);
        }
        throw err;
      });
    }
  };
};
const DEFAULT_OPTIONS$f = {
  Q: 1,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  detune: 0,
  frequency: 350,
  gain: 0,
  type: "lowpass"
};
const createBiquadFilterNodeConstructor = (audioNodeConstructor2, createAudioParam2, createBiquadFilterNodeRenderer2, createInvalidAccessError2, createNativeBiquadFilterNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class BiquadFilterNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$f, ...options2 };
      const nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer2() : null;
      super(context2, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);
      this._Q = createAudioParam2(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._detune = createAudioParam2(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));
      this._frequency = createAudioParam2(this, isOffline, nativeBiquadFilterNode.frequency, context2.sampleRate / 2, 0);
      this._gain = createAudioParam2(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);
      this._nativeBiquadFilterNode = nativeBiquadFilterNode;
      setAudioNodeTailTime2(this, 1);
    }
    get detune() {
      return this._detune;
    }
    get frequency() {
      return this._frequency;
    }
    get gain() {
      return this._gain;
    }
    get Q() {
      return this._Q;
    }
    get type() {
      return this._nativeBiquadFilterNode.type;
    }
    set type(value) {
      this._nativeBiquadFilterNode.type = value;
    }
    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
      try {
        this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
      } catch (err) {
        if (err.code === 11) {
          throw createInvalidAccessError2();
        }
        throw err;
      }
      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
        throw createInvalidAccessError2();
      }
    }
  };
};
const createBiquadFilterNodeRendererFactory = (connectAudioParam2, createNativeBiquadFilterNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeBiquadFilterNodes = /* @__PURE__ */ new WeakMap();
    const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeBiquadFilterNode = getNativeAudioNode2(proxy);
      const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);
      if (!nativeBiquadFilterNodeIsOwnedByContext) {
        const options2 = {
          Q: nativeBiquadFilterNode.Q.value,
          channelCount: nativeBiquadFilterNode.channelCount,
          channelCountMode: nativeBiquadFilterNode.channelCountMode,
          channelInterpretation: nativeBiquadFilterNode.channelInterpretation,
          detune: nativeBiquadFilterNode.detune.value,
          frequency: nativeBiquadFilterNode.frequency.value,
          gain: nativeBiquadFilterNode.gain.value,
          type: nativeBiquadFilterNode.type
        };
        nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);
      if (!nativeBiquadFilterNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
        await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
        await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
        await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);
      return nativeBiquadFilterNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);
        if (renderedNativeBiquadFilterNode !== void 0) {
          return Promise.resolve(renderedNativeBiquadFilterNode);
        }
        return createBiquadFilterNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createCacheTestResult = (ongoingTests, testResults) => {
  return (tester, test) => {
    const cachedTestResult = testResults.get(tester);
    if (cachedTestResult !== void 0) {
      return cachedTestResult;
    }
    const ongoingTest = ongoingTests.get(tester);
    if (ongoingTest !== void 0) {
      return ongoingTest;
    }
    try {
      const synchronousTestResult = test();
      if (synchronousTestResult instanceof Promise) {
        ongoingTests.set(tester, synchronousTestResult);
        return synchronousTestResult.catch(() => false).then((finalTestResult) => {
          ongoingTests.delete(tester);
          testResults.set(tester, finalTestResult);
          return finalTestResult;
        });
      }
      testResults.set(tester, synchronousTestResult);
      return synchronousTestResult;
    } catch {
      testResults.set(tester, false);
      return false;
    }
  };
};
const DEFAULT_OPTIONS$e = {
  channelCount: 1,
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 6
};
const createChannelMergerNodeConstructor = (audioNodeConstructor2, createChannelMergerNodeRenderer2, createNativeChannelMergerNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class ChannelMergerNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$e, ...options2 };
      const nativeChannelMergerNode = createNativeChannelMergerNode2(nativeContext, mergedOptions);
      const channelMergerNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelMergerNodeRenderer2() : null;
      super(context2, false, nativeChannelMergerNode, channelMergerNodeRenderer);
    }
  };
};
const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioNode = getNativeAudioNode2(proxy);
      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
      if (!nativeAudioNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeAudioNode.channelCount,
          channelCountMode: nativeAudioNode.channelCountMode,
          channelInterpretation: nativeAudioNode.channelInterpretation,
          numberOfInputs: nativeAudioNode.numberOfInputs
        };
        nativeAudioNode = createNativeChannelMergerNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
      return nativeAudioNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioNode !== void 0) {
          return Promise.resolve(renderedNativeAudioNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const DEFAULT_OPTIONS$d = {
  channelCount: 6,
  channelCountMode: "explicit",
  channelInterpretation: "discrete",
  numberOfOutputs: 6
};
const createChannelSplitterNodeConstructor = (audioNodeConstructor2, createChannelSplitterNodeRenderer2, createNativeChannelSplitterNode2, getNativeContext2, isNativeOfflineAudioContext2, sanitizeChannelSplitterOptions2) => {
  return class ChannelSplitterNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = sanitizeChannelSplitterOptions2({ ...DEFAULT_OPTIONS$d, ...options2 });
      const nativeChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, mergedOptions);
      const channelSplitterNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelSplitterNodeRenderer2() : null;
      super(context2, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);
    }
  };
};
const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioNode = getNativeAudioNode2(proxy);
      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
      if (!nativeAudioNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeAudioNode.channelCount,
          channelCountMode: nativeAudioNode.channelCountMode,
          channelInterpretation: nativeAudioNode.channelInterpretation,
          numberOfOutputs: nativeAudioNode.numberOfOutputs
        };
        nativeAudioNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
      return nativeAudioNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioNode !== void 0) {
          return Promise.resolve(renderedNativeAudioNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createConnectAudioParam = (renderInputsOfAudioParam2) => {
  return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
    return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
  };
};
const createConnectMultipleOutputs = (createIndexSizeError2) => {
  return (outputAudioNodes, destination, output2 = 0, input = 0) => {
    const outputAudioNode = outputAudioNodes[output2];
    if (outputAudioNode === void 0) {
      throw createIndexSizeError2();
    }
    if (isNativeAudioNode$1(destination)) {
      return outputAudioNode.connect(destination, 0, input);
    }
    return outputAudioNode.connect(destination, 0);
  };
};
const createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode2) => {
  return (nativeContext, nativeAudioNode) => {
    const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    });
    const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);
    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
    nativeAudioBufferSourceNode.loop = true;
    nativeAudioBufferSourceNode.connect(nativeAudioNode);
    nativeAudioBufferSourceNode.start();
    return () => {
      nativeAudioBufferSourceNode.stop();
      nativeAudioBufferSourceNode.disconnect(nativeAudioNode);
    };
  };
};
const DEFAULT_OPTIONS$c = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  offset: 1
};
const createConstantSourceNodeConstructor = (audioNodeConstructor2, createAudioParam2, createConstantSourceNodeRendererFactory2, createNativeConstantSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
  return class ConstantSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$c, ...options2 };
      const nativeConstantSourceNode = createNativeConstantSourceNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory2() : null;
      super(context2, false, nativeConstantSourceNode, constantSourceNodeRenderer);
      this._constantSourceNodeRenderer = constantSourceNodeRenderer;
      this._nativeConstantSourceNode = nativeConstantSourceNode;
      this._offset = createAudioParam2(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._onended = null;
    }
    get offset() {
      return this._offset;
    }
    get onended() {
      return this._onended;
    }
    set onended(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeConstantSourceNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeConstantSourceNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }
    start(when = 0) {
      this._nativeConstantSourceNode.start(when);
      if (this._constantSourceNodeRenderer !== null) {
        this._constantSourceNodeRenderer.start = when;
      }
      if (this.context.state !== "closed") {
        setInternalStateToActive(this);
        const resetInternalStateToPassive = () => {
          this._nativeConstantSourceNode.removeEventListener("ended", resetInternalStateToPassive);
          if (isActiveAudioNode(this)) {
            setInternalStateToPassive(this);
          }
        };
        this._nativeConstantSourceNode.addEventListener("ended", resetInternalStateToPassive);
      }
    }
    stop(when = 0) {
      this._nativeConstantSourceNode.stop(when);
      if (this._constantSourceNodeRenderer !== null) {
        this._constantSourceNodeRenderer.stop = when;
      }
    }
  };
};
const createConstantSourceNodeRendererFactory = (connectAudioParam2, createNativeConstantSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeConstantSourceNodes = /* @__PURE__ */ new WeakMap();
    let start2 = null;
    let stop = null;
    const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeConstantSourceNode = getNativeAudioNode2(proxy);
      const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);
      if (!nativeConstantSourceNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeConstantSourceNode.channelCount,
          channelCountMode: nativeConstantSourceNode.channelCountMode,
          channelInterpretation: nativeConstantSourceNode.channelInterpretation,
          offset: nativeConstantSourceNode.offset.value
        };
        nativeConstantSourceNode = createNativeConstantSourceNode2(nativeOfflineAudioContext, options2);
        if (start2 !== null) {
          nativeConstantSourceNode.start(start2);
        }
        if (stop !== null) {
          nativeConstantSourceNode.stop(stop);
        }
      }
      renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);
      if (!nativeConstantSourceNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);
      return nativeConstantSourceNode;
    };
    return {
      set start(value) {
        start2 = value;
      },
      set stop(value) {
        stop = value;
      },
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);
        if (renderedNativeConstantSourceNode !== void 0) {
          return Promise.resolve(renderedNativeConstantSourceNode);
        }
        return createConstantSourceNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createConvertNumberToUnsignedLong = (unit32Array) => {
  return (value) => {
    unit32Array[0] = value;
    return unit32Array[0];
  };
};
const DEFAULT_OPTIONS$b = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  disableNormalization: false
};
const createConvolverNodeConstructor = (audioNodeConstructor2, createConvolverNodeRenderer2, createNativeConvolverNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class ConvolverNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$b, ...options2 };
      const nativeConvolverNode = createNativeConvolverNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const convolverNodeRenderer = isOffline ? createConvolverNodeRenderer2() : null;
      super(context2, false, nativeConvolverNode, convolverNodeRenderer);
      this._isBufferNullified = false;
      this._nativeConvolverNode = nativeConvolverNode;
      if (mergedOptions.buffer !== null) {
        setAudioNodeTailTime2(this, mergedOptions.buffer.duration);
      }
    }
    get buffer() {
      if (this._isBufferNullified) {
        return null;
      }
      return this._nativeConvolverNode.buffer;
    }
    set buffer(value) {
      this._nativeConvolverNode.buffer = value;
      if (value === null && this._nativeConvolverNode.buffer !== null) {
        const nativeContext = this._nativeConvolverNode.context;
        this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);
        this._isBufferNullified = true;
        setAudioNodeTailTime2(this, 0);
      } else {
        this._isBufferNullified = false;
        setAudioNodeTailTime2(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
      }
    }
    get normalize() {
      return this._nativeConvolverNode.normalize;
    }
    set normalize(value) {
      this._nativeConvolverNode.normalize = value;
    }
  };
};
const createConvolverNodeRendererFactory = (createNativeConvolverNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeConvolverNodes = /* @__PURE__ */ new WeakMap();
    const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeConvolverNode = getNativeAudioNode2(proxy);
      const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);
      if (!nativeConvolverNodeIsOwnedByContext) {
        const options2 = {
          buffer: nativeConvolverNode.buffer,
          channelCount: nativeConvolverNode.channelCount,
          channelCountMode: nativeConvolverNode.channelCountMode,
          channelInterpretation: nativeConvolverNode.channelInterpretation,
          disableNormalization: !nativeConvolverNode.normalize
        };
        nativeConvolverNode = createNativeConvolverNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);
      if (isNativeAudioNodeFaker(nativeConvolverNode)) {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode);
      }
      return nativeConvolverNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);
        if (renderedNativeConvolverNode !== void 0) {
          return Promise.resolve(renderedNativeConvolverNode);
        }
        return createConvolverNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createCreateNativeOfflineAudioContext = (createNotSupportedError2, nativeOfflineAudioContextConstructor2) => {
  return (numberOfChannels, length, sampleRate) => {
    if (nativeOfflineAudioContextConstructor2 === null) {
      throw new Error("Missing the native OfflineAudioContext constructor.");
    }
    try {
      return new nativeOfflineAudioContextConstructor2(numberOfChannels, length, sampleRate);
    } catch (err) {
      if (err.name === "SyntaxError") {
        throw createNotSupportedError2();
      }
      throw err;
    }
  };
};
const createDataCloneError = () => new DOMException("", "DataCloneError");
const detachArrayBuffer = (arrayBuffer) => {
  const { port1, port2 } = new MessageChannel();
  return new Promise((resolve) => {
    const closeAndResolve = () => {
      port2.onmessage = null;
      port1.close();
      port2.close();
      resolve();
    };
    port2.onmessage = () => closeAndResolve();
    try {
      port1.postMessage(arrayBuffer, [arrayBuffer]);
    } catch {
    } finally {
      closeAndResolve();
    }
  });
};
const createDecodeAudioData = (audioBufferStore2, cacheTestResult2, createDataCloneError2, createEncodingError2, detachedArrayBuffers, getNativeContext2, isNativeContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, testPromiseSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
  return (anyContext, audioData) => {
    const nativeContext = isNativeContext2(anyContext) ? anyContext : getNativeContext2(anyContext);
    if (detachedArrayBuffers.has(audioData)) {
      const err = createDataCloneError2();
      return Promise.reject(err);
    }
    try {
      detachedArrayBuffers.add(audioData);
    } catch {
    }
    if (cacheTestResult2(testPromiseSupport2, () => testPromiseSupport2(nativeContext))) {
      return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {
        detachArrayBuffer(audioData).catch(() => {
        });
        if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
          wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
        }
        audioBufferStore2.add(audioBuffer);
        return audioBuffer;
      });
    }
    return new Promise((resolve, reject) => {
      const complete = async () => {
        try {
          await detachArrayBuffer(audioData);
        } catch {
        }
      };
      const fail = (err) => {
        reject(err);
        complete();
      };
      try {
        nativeContext.decodeAudioData(audioData, (audioBuffer) => {
          if (typeof audioBuffer.copyFromChannel !== "function") {
            wrapAudioBufferCopyChannelMethods2(audioBuffer);
            wrapAudioBufferGetChannelDataMethod(audioBuffer);
          }
          audioBufferStore2.add(audioBuffer);
          complete().then(() => resolve(audioBuffer));
        }, (err) => {
          if (err === null) {
            fail(createEncodingError2());
          } else {
            fail(err);
          }
        });
      } catch (err) {
        fail(err);
      }
    });
  };
};
const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode2, cycleCounters, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, getNativeContext2, isActiveAudioNode2, isNativeOfflineAudioContext2) => {
  return (audioNode, count) => {
    const cycleCounter = cycleCounters.get(audioNode);
    if (cycleCounter === void 0) {
      throw new Error("Missing the expected cycle count.");
    }
    const nativeContext = getNativeContext2(audioNode.context);
    const isOffline = isNativeOfflineAudioContext2(nativeContext);
    if (cycleCounter === count) {
      cycleCounters.delete(audioNode);
      if (!isOffline && isActiveAudioNode2(audioNode)) {
        const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
        const { outputs: outputs2 } = getAudioNodeConnections2(audioNode);
        for (const output2 of outputs2) {
          if (isAudioNodeOutputConnection(output2)) {
            const nativeDestinationAudioNode = getNativeAudioNode2(output2[0]);
            connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output2[1], output2[2]);
          } else {
            const nativeDestinationAudioParam = getNativeAudioParam2(output2[0]);
            nativeSourceAudioNode.connect(nativeDestinationAudioParam, output2[1]);
          }
        }
      }
    } else {
      cycleCounters.set(audioNode, cycleCounter - count);
    }
  };
};
const DEFAULT_OPTIONS$a = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  delayTime: 0,
  maxDelayTime: 1
};
const createDelayNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDelayNodeRenderer2, createNativeDelayNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class DelayNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$a, ...options2 };
      const nativeDelayNode = createNativeDelayNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const delayNodeRenderer = isOffline ? createDelayNodeRenderer2(mergedOptions.maxDelayTime) : null;
      super(context2, false, nativeDelayNode, delayNodeRenderer);
      this._delayTime = createAudioParam2(this, isOffline, nativeDelayNode.delayTime);
      setAudioNodeTailTime2(this, mergedOptions.maxDelayTime);
    }
    get delayTime() {
      return this._delayTime;
    }
  };
};
const createDelayNodeRendererFactory = (connectAudioParam2, createNativeDelayNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return (maxDelayTime) => {
    const renderedNativeDelayNodes = /* @__PURE__ */ new WeakMap();
    const createDelayNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeDelayNode = getNativeAudioNode2(proxy);
      const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);
      if (!nativeDelayNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeDelayNode.channelCount,
          channelCountMode: nativeDelayNode.channelCountMode,
          channelInterpretation: nativeDelayNode.channelInterpretation,
          delayTime: nativeDelayNode.delayTime.value,
          maxDelayTime
        };
        nativeDelayNode = createNativeDelayNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);
      if (!nativeDelayNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDelayNode);
      return nativeDelayNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);
        if (renderedNativeDelayNode !== void 0) {
          return Promise.resolve(renderedNativeDelayNode);
        }
        return createDelayNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet2) => {
  return (activeInputs, source, output2, input) => {
    return pickElementFromSet2(activeInputs[input], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output2);
  };
};
const createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
  return (nativeContext, audioWorkletNode) => {
    getUnrenderedAudioWorkletNodes2(nativeContext).delete(audioWorkletNode);
  };
};
const isDelayNode = (audioNode) => {
  return "delayTime" in audioNode;
};
const createDetectCycles = (audioParamAudioNodeStore2, getAudioNodeConnections2, getValueForKey2) => {
  return function detectCycles(chain, nextLink) {
    const audioNode = isAudioNode$1(nextLink) ? nextLink : getValueForKey2(audioParamAudioNodeStore2, nextLink);
    if (isDelayNode(audioNode)) {
      return [];
    }
    if (chain[0] === audioNode) {
      return [chain];
    }
    if (chain.includes(audioNode)) {
      return [];
    }
    const { outputs: outputs2 } = getAudioNodeConnections2(audioNode);
    return Array.from(outputs2).map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);
  };
};
const getOutputAudioNodeAtIndex = (createIndexSizeError2, outputAudioNodes, output2) => {
  const outputAudioNode = outputAudioNodes[output2];
  if (outputAudioNode === void 0) {
    throw createIndexSizeError2();
  }
  return outputAudioNode;
};
const createDisconnectMultipleOutputs = (createIndexSizeError2) => {
  return (outputAudioNodes, destinationOrOutput = void 0, output2 = void 0, input = 0) => {
    if (destinationOrOutput === void 0) {
      return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());
    }
    if (typeof destinationOrOutput === "number") {
      return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, destinationOrOutput).disconnect();
    }
    if (isNativeAudioNode$1(destinationOrOutput)) {
      if (output2 === void 0) {
        return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
      }
      if (input === void 0) {
        return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output2).disconnect(destinationOrOutput, 0);
      }
      return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output2).disconnect(destinationOrOutput, 0, input);
    }
    if (output2 === void 0) {
      return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
    }
    return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output2).disconnect(destinationOrOutput, 0);
  };
};
const DEFAULT_OPTIONS$9 = {
  attack: 3e-3,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  knee: 30,
  ratio: 12,
  release: 0.25,
  threshold: -24
};
const createDynamicsCompressorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDynamicsCompressorNodeRenderer2, createNativeDynamicsCompressorNode2, createNotSupportedError2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class DynamicsCompressorNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$9, ...options2 };
      const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer2() : null;
      super(context2, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);
      this._attack = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.attack);
      this._knee = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.knee);
      this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;
      this._ratio = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.ratio);
      this._release = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.release);
      this._threshold = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.threshold);
      setAudioNodeTailTime2(this, 6e-3);
    }
    get attack() {
      return this._attack;
    }
    // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.
    get channelCount() {
      return this._nativeDynamicsCompressorNode.channelCount;
    }
    set channelCount(value) {
      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;
      this._nativeDynamicsCompressorNode.channelCount = value;
      if (value > 2) {
        this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;
        throw createNotSupportedError2();
      }
    }
    /*
     * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be
     * overwritten here.
     */
    get channelCountMode() {
      return this._nativeDynamicsCompressorNode.channelCountMode;
    }
    set channelCountMode(value) {
      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;
      this._nativeDynamicsCompressorNode.channelCountMode = value;
      if (value === "max") {
        this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;
        throw createNotSupportedError2();
      }
    }
    get knee() {
      return this._knee;
    }
    get ratio() {
      return this._ratio;
    }
    get reduction() {
      if (typeof this._nativeDynamicsCompressorNode.reduction.value === "number") {
        return this._nativeDynamicsCompressorNode.reduction.value;
      }
      return this._nativeDynamicsCompressorNode.reduction;
    }
    get release() {
      return this._release;
    }
    get threshold() {
      return this._threshold;
    }
  };
};
const createDynamicsCompressorNodeRendererFactory = (connectAudioParam2, createNativeDynamicsCompressorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeDynamicsCompressorNodes = /* @__PURE__ */ new WeakMap();
    const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeDynamicsCompressorNode = getNativeAudioNode2(proxy);
      const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);
      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
        const options2 = {
          attack: nativeDynamicsCompressorNode.attack.value,
          channelCount: nativeDynamicsCompressorNode.channelCount,
          channelCountMode: nativeDynamicsCompressorNode.channelCountMode,
          channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,
          knee: nativeDynamicsCompressorNode.knee.value,
          ratio: nativeDynamicsCompressorNode.ratio.value,
          release: nativeDynamicsCompressorNode.release.value,
          threshold: nativeDynamicsCompressorNode.threshold.value
        };
        nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);
      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
        await renderAutomation2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
        await renderAutomation2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
        await renderAutomation2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
        await renderAutomation2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);
      return nativeDynamicsCompressorNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);
        if (renderedNativeDynamicsCompressorNode !== void 0) {
          return Promise.resolve(renderedNativeDynamicsCompressorNode);
        }
        return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createEncodingError = () => new DOMException("", "EncodingError");
const createEvaluateSource = (window2) => {
  return (source) => new Promise((resolve, reject) => {
    if (window2 === null) {
      reject(new SyntaxError());
      return;
    }
    const head = window2.document.head;
    if (head === null) {
      reject(new SyntaxError());
    } else {
      const script = window2.document.createElement("script");
      const blob = new Blob([source], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      const originalOnErrorHandler = window2.onerror;
      const removeErrorEventListenerAndRevokeUrl = () => {
        window2.onerror = originalOnErrorHandler;
        URL.revokeObjectURL(url);
      };
      window2.onerror = (message, src, lineno, colno, error2) => {
        if (src === url || src === window2.location.href && lineno === 1 && colno === 1) {
          removeErrorEventListenerAndRevokeUrl();
          reject(error2);
          return false;
        }
        if (originalOnErrorHandler !== null) {
          return originalOnErrorHandler(message, src, lineno, colno, error2);
        }
      };
      script.onerror = () => {
        removeErrorEventListenerAndRevokeUrl();
        reject(new SyntaxError());
      };
      script.onload = () => {
        removeErrorEventListenerAndRevokeUrl();
        resolve();
      };
      script.src = url;
      script.type = "module";
      head.appendChild(script);
    }
  });
};
const createEventTargetConstructor = (wrapEventListener2) => {
  return class EventTarget {
    constructor(_nativeEventTarget) {
      this._nativeEventTarget = _nativeEventTarget;
      this._listeners = /* @__PURE__ */ new WeakMap();
    }
    addEventListener(type2, listener, options2) {
      if (listener !== null) {
        let wrappedEventListener = this._listeners.get(listener);
        if (wrappedEventListener === void 0) {
          wrappedEventListener = wrapEventListener2(this, listener);
          if (typeof listener === "function") {
            this._listeners.set(listener, wrappedEventListener);
          }
        }
        this._nativeEventTarget.addEventListener(type2, wrappedEventListener, options2);
      }
    }
    dispatchEvent(event) {
      return this._nativeEventTarget.dispatchEvent(event);
    }
    removeEventListener(type2, listener, options2) {
      const wrappedEventListener = listener === null ? void 0 : this._listeners.get(listener);
      this._nativeEventTarget.removeEventListener(type2, wrappedEventListener === void 0 ? null : wrappedEventListener, options2);
    }
  };
};
const createExposeCurrentFrameAndCurrentTime = (window2) => {
  return (currentTime, sampleRate, fn2) => {
    Object.defineProperties(window2, {
      currentFrame: {
        configurable: true,
        get() {
          return Math.round(currentTime * sampleRate);
        }
      },
      currentTime: {
        configurable: true,
        get() {
          return currentTime;
        }
      }
    });
    try {
      return fn2();
    } finally {
      if (window2 !== null) {
        delete window2.currentFrame;
        delete window2.currentTime;
      }
    }
  };
};
const createFetchSource = (createAbortError2) => {
  return async (url) => {
    try {
      const response = await fetch(url);
      if (response.ok) {
        return [await response.text(), response.url];
      }
    } catch {
    }
    throw createAbortError2();
  };
};
const DEFAULT_OPTIONS$8 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  gain: 1
};
const createGainNodeConstructor = (audioNodeConstructor2, createAudioParam2, createGainNodeRenderer2, createNativeGainNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class GainNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$8, ...options2 };
      const nativeGainNode = createNativeGainNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const gainNodeRenderer = isOffline ? createGainNodeRenderer2() : null;
      super(context2, false, nativeGainNode, gainNodeRenderer);
      this._gain = createAudioParam2(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
    }
    get gain() {
      return this._gain;
    }
  };
};
const createGainNodeRendererFactory = (connectAudioParam2, createNativeGainNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeGainNodes = /* @__PURE__ */ new WeakMap();
    const createGainNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeGainNode = getNativeAudioNode2(proxy);
      const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);
      if (!nativeGainNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeGainNode.channelCount,
          channelCountMode: nativeGainNode.channelCountMode,
          channelInterpretation: nativeGainNode.channelInterpretation,
          gain: nativeGainNode.gain.value
        };
        nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);
      if (!nativeGainNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeGainNode);
      return nativeGainNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);
        if (renderedNativeGainNode !== void 0) {
          return Promise.resolve(renderedNativeGainNode);
        }
        return createGainNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2, getValueForKey2) => {
  return (nativeAudioWorkletNode) => getValueForKey2(activeAudioWorkletNodeInputsStore2, nativeAudioWorkletNode);
};
const createGetAudioNodeRenderer = (getAudioNodeConnections2) => {
  return (audioNode) => {
    const audioNodeConnections = getAudioNodeConnections2(audioNode);
    if (audioNodeConnections.renderer === null) {
      throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
    }
    return audioNodeConnections.renderer;
  };
};
const createGetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
  return (audioNode) => {
    var _a;
    return (_a = audioNodeTailTimeStore2.get(audioNode)) !== null && _a !== void 0 ? _a : 0;
  };
};
const createGetAudioParamRenderer = (getAudioParamConnections2) => {
  return (audioParam) => {
    const audioParamConnections = getAudioParamConnections2(audioParam);
    if (audioParamConnections.renderer === null) {
      throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
    }
    return audioParamConnections.renderer;
  };
};
const createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore2) => {
  return (nativeContext) => {
    return backupOfflineAudioContextStore2.get(nativeContext);
  };
};
const createInvalidStateError = () => new DOMException("", "InvalidStateError");
const createGetNativeContext = (contextStore) => {
  return (context2) => {
    const nativeContext = contextStore.get(context2);
    if (nativeContext === void 0) {
      throw createInvalidStateError();
    }
    return nativeContext;
  };
};
const createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore2, nativeOfflineAudioContextConstructor2) => {
  return (nativeContext) => {
    let backupOfflineAudioContext = backupOfflineAudioContextStore2.get(nativeContext);
    if (backupOfflineAudioContext !== void 0) {
      return backupOfflineAudioContext;
    }
    if (nativeOfflineAudioContextConstructor2 === null) {
      throw new Error("Missing the native OfflineAudioContext constructor.");
    }
    backupOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
    backupOfflineAudioContextStore2.set(nativeContext, backupOfflineAudioContext);
    return backupOfflineAudioContext;
  };
};
const createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore2) => {
  return (nativeContext) => {
    const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore2.get(nativeContext);
    if (unrenderedAudioWorkletNodes === void 0) {
      throw new Error("The context has no set of AudioWorkletNodes.");
    }
    return unrenderedAudioWorkletNodes;
  };
};
const createInvalidAccessError = () => new DOMException("", "InvalidAccessError");
const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {
  nativeIIRFilterNode.getFrequencyResponse = /* @__PURE__ */ ((getFrequencyResponse) => {
    return (frequencyHz, magResponse, phaseResponse) => {
      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
        throw createInvalidAccessError();
      }
      return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);
    };
  })(nativeIIRFilterNode.getFrequencyResponse);
};
const DEFAULT_OPTIONS$7 = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers"
};
const createIIRFilterNodeConstructor = (audioNodeConstructor2, createNativeIIRFilterNode2, createIIRFilterNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class IIRFilterNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const mergedOptions = { ...DEFAULT_OPTIONS$7, ...options2 };
      const nativeIIRFilterNode = createNativeIIRFilterNode2(nativeContext, isOffline ? null : context2.baseLatency, mergedOptions);
      const iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer2(mergedOptions.feedback, mergedOptions.feedforward) : null;
      super(context2, false, nativeIIRFilterNode, iirFilterNodeRenderer);
      wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);
      this._nativeIIRFilterNode = nativeIIRFilterNode;
      setAudioNodeTailTime2(this, 1);
    }
    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
      return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
    }
  };
};
const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output2) => {
  const inputLength = input.length;
  let i = bufferIndex;
  for (let j2 = 0; j2 < inputLength; j2 += 1) {
    let y = feedforward[0] * input[j2];
    for (let k = 1; k < minLength; k += 1) {
      const x = i - k & bufferLength - 1;
      y += feedforward[k] * xBuffer[x];
      y -= feedback[k] * yBuffer[x];
    }
    for (let k = minLength; k < feedforwardLength; k += 1) {
      y += feedforward[k] * xBuffer[i - k & bufferLength - 1];
    }
    for (let k = minLength; k < feedbackLength; k += 1) {
      y -= feedback[k] * yBuffer[i - k & bufferLength - 1];
    }
    xBuffer[i] = input[j2];
    yBuffer[i] = y;
    i = i + 1 & bufferLength - 1;
    output2[j2] = y;
  }
  return i;
};
const filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {
  const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
  const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
  const feedbackLength = convertedFeedback.length;
  const feedforwardLength = convertedFeedforward.length;
  const minLength = Math.min(feedbackLength, feedforwardLength);
  if (convertedFeedback[0] !== 1) {
    for (let i = 0; i < feedbackLength; i += 1) {
      convertedFeedforward[i] /= convertedFeedback[0];
    }
    for (let i = 1; i < feedforwardLength; i += 1) {
      convertedFeedback[i] /= convertedFeedback[0];
    }
  }
  const bufferLength = 32;
  const xBuffer = new Float32Array(bufferLength);
  const yBuffer = new Float32Array(bufferLength);
  const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
  const numberOfChannels = renderedBuffer.numberOfChannels;
  for (let i = 0; i < numberOfChannels; i += 1) {
    const input = renderedBuffer.getChannelData(i);
    const output2 = filteredBuffer.getChannelData(i);
    xBuffer.fill(0);
    yBuffer.fill(0);
    filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output2);
  }
  return filteredBuffer;
};
const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
  return (feedback, feedforward) => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    let filteredBufferPromise = null;
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioBufferSourceNode = null;
      let nativeIIRFilterNode = getNativeAudioNode2(proxy);
      const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);
      if (nativeOfflineAudioContext.createIIRFilter === void 0) {
        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
          buffer: null,
          channelCount: 2,
          channelCountMode: "max",
          channelInterpretation: "speakers",
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        });
      } else if (!nativeIIRFilterNodeIsOwnedByContext) {
        nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);
      if (nativeAudioBufferSourceNode !== null) {
        if (filteredBufferPromise === null) {
          if (nativeOfflineAudioContextConstructor2 === null) {
            throw new Error("Missing the native OfflineAudioContext constructor.");
          }
          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(
            // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.
            proxy.context.destination.channelCount,
            // Bug #17: Safari does not yet expose the length.
            proxy.context.length,
            nativeOfflineAudioContext.sampleRate
          );
          filteredBufferPromise = (async () => {
            await renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);
            const renderedBuffer = await renderNativeOfflineAudioContext2(partialOfflineAudioContext);
            return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);
          })();
        }
        const filteredBuffer = await filteredBufferPromise;
        nativeAudioBufferSourceNode.buffer = filteredBuffer;
        nativeAudioBufferSourceNode.start(0);
        return nativeAudioBufferSourceNode;
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);
      return nativeIIRFilterNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeAudioNode !== void 0) {
          return Promise.resolve(renderedNativeAudioNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, isActiveAudioNode2) => {
  return (isOffline) => {
    return (audioNode, count) => {
      const cycleCounter = cycleCounters.get(audioNode);
      if (cycleCounter === void 0) {
        if (!isOffline && isActiveAudioNode2(audioNode)) {
          const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
          const { outputs: outputs2 } = getAudioNodeConnections2(audioNode);
          for (const output2 of outputs2) {
            if (isAudioNodeOutputConnection(output2)) {
              const nativeDestinationAudioNode = getNativeAudioNode2(output2[0]);
              disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output2[1], output2[2]);
            } else {
              const nativeDestinationAudioParam = getNativeAudioParam2(output2[0]);
              nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output2[1]);
            }
          }
        }
        cycleCounters.set(audioNode, count);
      } else {
        cycleCounters.set(audioNode, cycleCounter + count);
      }
    };
  };
};
const createIsAnyAudioContext = (contextStore, isNativeAudioContext2) => {
  return (anything) => {
    const nativeContext = contextStore.get(anything);
    return isNativeAudioContext2(nativeContext) || isNativeAudioContext2(anything);
  };
};
const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode2) => {
  return (anything) => audioNodeStore.has(anything) || isNativeAudioNode2(anything);
};
const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam2) => {
  return (anything) => audioParamStore.has(anything) || isNativeAudioParam2(anything);
};
const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext2) => {
  return (anything) => {
    const nativeContext = contextStore.get(anything);
    return isNativeOfflineAudioContext2(nativeContext) || isNativeOfflineAudioContext2(anything);
  };
};
const createIsNativeAudioContext = (nativeAudioContextConstructor2) => {
  return (anything) => {
    return nativeAudioContextConstructor2 !== null && anything instanceof nativeAudioContextConstructor2;
  };
};
const createIsNativeAudioNode = (window2) => {
  return (anything) => {
    return window2 !== null && typeof window2.AudioNode === "function" && anything instanceof window2.AudioNode;
  };
};
const createIsNativeAudioParam = (window2) => {
  return (anything) => {
    return window2 !== null && typeof window2.AudioParam === "function" && anything instanceof window2.AudioParam;
  };
};
const createIsNativeContext = (isNativeAudioContext2, isNativeOfflineAudioContext2) => {
  return (anything) => {
    return isNativeAudioContext2(anything) || isNativeOfflineAudioContext2(anything);
  };
};
const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor2) => {
  return (anything) => {
    return nativeOfflineAudioContextConstructor2 !== null && anything instanceof nativeOfflineAudioContextConstructor2;
  };
};
const createIsSecureContext = (window2) => window2 !== null && window2.isSecureContext;
const createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaElementAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class MediaElementAudioSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode2(nativeContext, options2);
      if (isNativeOfflineAudioContext2(nativeContext)) {
        throw TypeError();
      }
      super(context2, true, nativeMediaElementAudioSourceNode, null);
      this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;
    }
    get mediaElement() {
      return this._nativeMediaElementAudioSourceNode.mediaElement;
    }
  };
};
const DEFAULT_OPTIONS$6 = {
  channelCount: 2,
  channelCountMode: "explicit",
  channelInterpretation: "speakers"
};
const createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioDestinationNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class MediaStreamAudioDestinationNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      if (isNativeOfflineAudioContext2(nativeContext)) {
        throw new TypeError();
      }
      const mergedOptions = { ...DEFAULT_OPTIONS$6, ...options2 };
      const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode2(nativeContext, mergedOptions);
      super(context2, false, nativeMediaStreamAudioDestinationNode, null);
      this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;
    }
    get stream() {
      return this._nativeMediaStreamAudioDestinationNode.stream;
    }
  };
};
const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class MediaStreamAudioSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode2(nativeContext, options2);
      if (isNativeOfflineAudioContext2(nativeContext)) {
        throw new TypeError();
      }
      super(context2, true, nativeMediaStreamAudioSourceNode, null);
      this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;
    }
    get mediaStream() {
      return this._nativeMediaStreamAudioSourceNode.mediaStream;
    }
  };
};
const createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamTrackAudioSourceNode2, getNativeContext2) => {
  return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode2(nativeContext, options2);
      super(context2, true, nativeMediaStreamTrackAudioSourceNode, null);
    }
  };
};
const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor2, createAudioListener2, eventTargetConstructor2, isNativeOfflineAudioContext2, unrenderedAudioWorkletNodeStore2, wrapEventListener2) => {
  return class MinimalBaseAudioContext extends eventTargetConstructor2 {
    constructor(_nativeContext, numberOfChannels) {
      super(_nativeContext);
      this._nativeContext = _nativeContext;
      CONTEXT_STORE.set(this, _nativeContext);
      if (isNativeOfflineAudioContext2(_nativeContext)) {
        unrenderedAudioWorkletNodeStore2.set(_nativeContext, /* @__PURE__ */ new Set());
      }
      this._destination = new audioDestinationNodeConstructor2(this, numberOfChannels);
      this._listener = createAudioListener2(this, _nativeContext);
      this._onstatechange = null;
    }
    get currentTime() {
      return this._nativeContext.currentTime;
    }
    get destination() {
      return this._destination;
    }
    get listener() {
      return this._listener;
    }
    get onstatechange() {
      return this._onstatechange;
    }
    set onstatechange(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeContext.onstatechange = wrappedListener;
      const nativeOnStateChange = this._nativeContext.onstatechange;
      this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;
    }
    get sampleRate() {
      return this._nativeContext.sampleRate;
    }
    get state() {
      return this._nativeContext.state;
    }
  };
};
const testPromiseSupport = (nativeContext) => {
  const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
  try {
    const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {
    });
    if (promise === void 0) {
      return false;
    }
    promise.catch(() => {
    });
    return true;
  } catch {
  }
  return false;
};
const createMonitorConnections = (insertElementInSet2, isNativeAudioNode2) => {
  return (nativeAudioNode, whenConnected, whenDisconnected) => {
    const connections = /* @__PURE__ */ new Set();
    nativeAudioNode.connect = /* @__PURE__ */ ((connect2) => {
      return (destination, output2 = 0, input = 0) => {
        const wasDisconnected = connections.size === 0;
        if (isNativeAudioNode2(destination)) {
          connect2.call(nativeAudioNode, destination, output2, input);
          insertElementInSet2(connections, [destination, output2, input], (connection) => connection[0] === destination && connection[1] === output2 && connection[2] === input, true);
          if (wasDisconnected) {
            whenConnected();
          }
          return destination;
        }
        connect2.call(nativeAudioNode, destination, output2);
        insertElementInSet2(connections, [destination, output2], (connection) => connection[0] === destination && connection[1] === output2, true);
        if (wasDisconnected) {
          whenConnected();
        }
        return;
      };
    })(nativeAudioNode.connect);
    nativeAudioNode.disconnect = /* @__PURE__ */ ((disconnect2) => {
      return (destinationOrOutput, output2, input) => {
        const wasConnected = connections.size > 0;
        if (destinationOrOutput === void 0) {
          disconnect2.apply(nativeAudioNode);
          connections.clear();
        } else if (typeof destinationOrOutput === "number") {
          disconnect2.call(nativeAudioNode, destinationOrOutput);
          for (const connection of connections) {
            if (connection[1] === destinationOrOutput) {
              connections.delete(connection);
            }
          }
        } else {
          if (isNativeAudioNode2(destinationOrOutput)) {
            disconnect2.call(nativeAudioNode, destinationOrOutput, output2, input);
          } else {
            disconnect2.call(nativeAudioNode, destinationOrOutput, output2);
          }
          for (const connection of connections) {
            if (connection[0] === destinationOrOutput && (output2 === void 0 || connection[1] === output2) && (input === void 0 || connection[2] === input)) {
              connections.delete(connection);
            }
          }
        }
        const isDisconnected = connections.size === 0;
        if (wasConnected && isDisconnected) {
          whenDisconnected();
        }
      };
    })(nativeAudioNode.disconnect);
    return nativeAudioNode;
  };
};
const assignNativeAudioNodeOption = (nativeAudioNode, options2, option) => {
  const value = options2[option];
  if (value !== void 0 && value !== nativeAudioNode[option]) {
    nativeAudioNode[option] = value;
  }
};
const assignNativeAudioNodeOptions = (nativeAudioNode, options2) => {
  assignNativeAudioNodeOption(nativeAudioNode, options2, "channelCount");
  assignNativeAudioNodeOption(nativeAudioNode, options2, "channelCountMode");
  assignNativeAudioNodeOption(nativeAudioNode, options2, "channelInterpretation");
};
const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {
  return typeof nativeAnalyserNode.getFloatTimeDomainData === "function";
};
const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {
  nativeAnalyserNode.getFloatTimeDomainData = (array2) => {
    const byteTimeDomainData = new Uint8Array(array2.length);
    nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);
    const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);
    for (let i = 0; i < length; i += 1) {
      array2[i] = (byteTimeDomainData[i] - 128) * 78125e-7;
    }
    return array2;
  };
};
const createNativeAnalyserNodeFactory = (cacheTestResult2, createIndexSizeError2) => {
  return (nativeContext, options2) => {
    const nativeAnalyserNode = nativeContext.createAnalyser();
    assignNativeAudioNodeOptions(nativeAnalyserNode, options2);
    if (!(options2.maxDecibels > options2.minDecibels)) {
      throw createIndexSizeError2();
    }
    assignNativeAudioNodeOption(nativeAnalyserNode, options2, "fftSize");
    assignNativeAudioNodeOption(nativeAnalyserNode, options2, "maxDecibels");
    assignNativeAudioNodeOption(nativeAnalyserNode, options2, "minDecibels");
    assignNativeAudioNodeOption(nativeAnalyserNode, options2, "smoothingTimeConstant");
    if (!cacheTestResult2(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {
      wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);
    }
    return nativeAnalyserNode;
  };
};
const createNativeAudioBufferConstructor = (window2) => {
  if (window2 === null) {
    return null;
  }
  if (window2.hasOwnProperty("AudioBuffer")) {
    return window2.AudioBuffer;
  }
  return null;
};
const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options2, audioParam) => {
  const value = options2[audioParam];
  if (value !== void 0 && value !== nativeAudioNode[audioParam].value) {
    nativeAudioNode[audioParam].value = value;
  }
};
const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {
  nativeAudioBufferSourceNode.start = /* @__PURE__ */ ((start2) => {
    let isScheduled = false;
    return (when = 0, offset2 = 0, duration2) => {
      if (isScheduled) {
        throw createInvalidStateError();
      }
      start2.call(nativeAudioBufferSourceNode, when, offset2, duration2);
      isScheduled = true;
    };
  })(nativeAudioBufferSourceNode.start);
};
const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
  nativeAudioScheduledSourceNode.start = /* @__PURE__ */ ((start2) => {
    return (when = 0, offset2 = 0, duration2) => {
      if (typeof duration2 === "number" && duration2 < 0 || offset2 < 0 || when < 0) {
        throw new RangeError("The parameters can't be negative.");
      }
      start2.call(nativeAudioScheduledSourceNode, when, offset2, duration2);
    };
  })(nativeAudioScheduledSourceNode.start);
};
const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
  nativeAudioScheduledSourceNode.stop = /* @__PURE__ */ ((stop) => {
    return (when = 0) => {
      if (when < 0) {
        throw new RangeError("The parameter can't be negative.");
      }
      stop.call(nativeAudioScheduledSourceNode, when);
    };
  })(nativeAudioScheduledSourceNode.stop);
};
const createNativeAudioBufferSourceNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
  return (nativeContext, options2) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options2, "playbackRate");
    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "buffer");
    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loop");
    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loopEnd");
    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options2, "loopStart");
    if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2(nativeContext))) {
      wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);
    }
    if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport2(nativeContext))) {
      wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);
    }
    if (!cacheTestResult2(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2(nativeContext))) {
      wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeAudioBufferSourceNode, nativeContext);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);
    }
    addSilentConnection2(nativeContext, nativeAudioBufferSourceNode);
    return nativeAudioBufferSourceNode;
  };
};
const createNativeAudioContextConstructor = (window2) => {
  if (window2 === null) {
    return null;
  }
  if (window2.hasOwnProperty("AudioContext")) {
    return window2.AudioContext;
  }
  return window2.hasOwnProperty("webkitAudioContext") ? window2.webkitAudioContext : null;
};
const createNativeAudioDestinationNodeFactory = (createNativeGainNode2, overwriteAccessors2) => {
  return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {
    const nativeAudioDestinationNode = nativeContext.destination;
    if (nativeAudioDestinationNode.channelCount !== channelCount) {
      try {
        nativeAudioDestinationNode.channelCount = channelCount;
      } catch {
      }
    }
    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== "explicit") {
      nativeAudioDestinationNode.channelCountMode = "explicit";
    }
    if (nativeAudioDestinationNode.maxChannelCount === 0) {
      Object.defineProperty(nativeAudioDestinationNode, "maxChannelCount", {
        value: channelCount
      });
    }
    const gainNode = createNativeGainNode2(nativeContext, {
      channelCount,
      channelCountMode: nativeAudioDestinationNode.channelCountMode,
      channelInterpretation: nativeAudioDestinationNode.channelInterpretation,
      gain: 1
    });
    overwriteAccessors2(gainNode, "channelCount", (get2) => () => get2.call(gainNode), (set2) => (value) => {
      set2.call(gainNode, value);
      try {
        nativeAudioDestinationNode.channelCount = value;
      } catch (err) {
        if (value > nativeAudioDestinationNode.maxChannelCount) {
          throw err;
        }
      }
    });
    overwriteAccessors2(gainNode, "channelCountMode", (get2) => () => get2.call(gainNode), (set2) => (value) => {
      set2.call(gainNode, value);
      nativeAudioDestinationNode.channelCountMode = value;
    });
    overwriteAccessors2(gainNode, "channelInterpretation", (get2) => () => get2.call(gainNode), (set2) => (value) => {
      set2.call(gainNode, value);
      nativeAudioDestinationNode.channelInterpretation = value;
    });
    Object.defineProperty(gainNode, "maxChannelCount", {
      get: () => nativeAudioDestinationNode.maxChannelCount
    });
    gainNode.connect(nativeAudioDestinationNode);
    return gainNode;
  };
};
const createNativeAudioWorkletNodeConstructor = (window2) => {
  if (window2 === null) {
    return null;
  }
  return window2.hasOwnProperty("AudioWorkletNode") ? window2.AudioWorkletNode : null;
};
const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
  const { port1 } = new MessageChannel();
  try {
    port1.postMessage(audioWorkletNodeOptions);
  } finally {
    port1.close();
  }
};
const createNativeAudioWorkletNodeFactory = (createInvalidStateError2, createNativeAudioWorkletNodeFaker2, createNativeGainNode2, createNotSupportedError2, monitorConnections2) => {
  return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor2, name, processorConstructor, options2) => {
    if (nativeAudioWorkletNodeConstructor2 !== null) {
      try {
        const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeContext, name, options2);
        const patchedEventListeners = /* @__PURE__ */ new Map();
        let onprocessorerror = null;
        Object.defineProperties(nativeAudioWorkletNode, {
          /*
           * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some
           * browsers have no native implementation to achieve a consistent behavior.
           */
          channelCount: {
            get: () => options2.channelCount,
            set: () => {
              throw createInvalidStateError2();
            }
          },
          channelCountMode: {
            get: () => "explicit",
            set: () => {
              throw createInvalidStateError2();
            }
          },
          // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.
          onprocessorerror: {
            get: () => onprocessorerror,
            set: (value) => {
              if (typeof onprocessorerror === "function") {
                nativeAudioWorkletNode.removeEventListener("processorerror", onprocessorerror);
              }
              onprocessorerror = typeof value === "function" ? value : null;
              if (typeof onprocessorerror === "function") {
                nativeAudioWorkletNode.addEventListener("processorerror", onprocessorerror);
              }
            }
          }
        });
        nativeAudioWorkletNode.addEventListener = /* @__PURE__ */ ((addEventListener) => {
          return (...args) => {
            if (args[0] === "processorerror") {
              const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
              if (unpatchedEventListener !== null) {
                const patchedEventListener = patchedEventListeners.get(args[1]);
                if (patchedEventListener !== void 0) {
                  args[1] = patchedEventListener;
                } else {
                  args[1] = (event) => {
                    if (event.type === "error") {
                      Object.defineProperties(event, {
                        type: { value: "processorerror" }
                      });
                      unpatchedEventListener(event);
                    } else {
                      unpatchedEventListener(new ErrorEvent(args[0], { ...event }));
                    }
                  };
                  patchedEventListeners.set(unpatchedEventListener, args[1]);
                }
              }
            }
            addEventListener.call(nativeAudioWorkletNode, "error", args[1], args[2]);
            return addEventListener.call(nativeAudioWorkletNode, ...args);
          };
        })(nativeAudioWorkletNode.addEventListener);
        nativeAudioWorkletNode.removeEventListener = /* @__PURE__ */ ((removeEventListener) => {
          return (...args) => {
            if (args[0] === "processorerror") {
              const patchedEventListener = patchedEventListeners.get(args[1]);
              if (patchedEventListener !== void 0) {
                patchedEventListeners.delete(args[1]);
                args[1] = patchedEventListener;
              }
            }
            removeEventListener.call(nativeAudioWorkletNode, "error", args[1], args[2]);
            return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);
          };
        })(nativeAudioWorkletNode.removeEventListener);
        if (options2.numberOfOutputs !== 0) {
          const nativeGainNode = createNativeGainNode2(nativeContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            gain: 0
          });
          nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);
          const whenConnected = () => nativeGainNode.disconnect();
          const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);
          return monitorConnections2(nativeAudioWorkletNode, whenConnected, whenDisconnected);
        }
        return nativeAudioWorkletNode;
      } catch (err) {
        if (err.code === 11) {
          throw createNotSupportedError2();
        }
        throw err;
      }
    }
    if (processorConstructor === void 0) {
      throw createNotSupportedError2();
    }
    testClonabilityOfAudioWorkletNodeOptions(options2);
    return createNativeAudioWorkletNodeFaker2(nativeContext, baseLatency, processorConstructor, options2);
  };
};
const computeBufferSize = (baseLatency, sampleRate) => {
  if (baseLatency === null) {
    return 512;
  }
  return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));
};
const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
  return new Promise((resolve, reject) => {
    const { port1, port2 } = new MessageChannel();
    port1.onmessage = ({ data: data2 }) => {
      port1.close();
      port2.close();
      resolve(data2);
    };
    port1.onmessageerror = ({ data: data2 }) => {
      port1.close();
      port2.close();
      reject(data2);
    };
    port2.postMessage(audioWorkletNodeOptions);
  });
};
const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {
  const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);
  return new processorConstructor(clonedAudioWorkletNodeOptions);
};
const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {
  let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);
  if (nodeToProcessorMap === void 0) {
    nodeToProcessorMap = /* @__PURE__ */ new WeakMap();
    NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);
  }
  const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);
  nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);
  return audioWorkletProcessorPromise;
};
const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs2, createIndexSizeError2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNotSupportedError2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getActiveAudioWorkletNodeInputs2, monitorConnections2) => {
  return (nativeContext, baseLatency, processorConstructor, options2) => {
    if (options2.numberOfInputs === 0 && options2.numberOfOutputs === 0) {
      throw createNotSupportedError2();
    }
    const outputChannelCount = Array.isArray(options2.outputChannelCount) ? options2.outputChannelCount : Array.from(options2.outputChannelCount);
    if (outputChannelCount.some((channelCount) => channelCount < 1)) {
      throw createNotSupportedError2();
    }
    if (outputChannelCount.length !== options2.numberOfOutputs) {
      throw createIndexSizeError2();
    }
    if (options2.channelCountMode !== "explicit") {
      throw createNotSupportedError2();
    }
    const numberOfInputChannels = options2.channelCount * options2.numberOfInputs;
    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
    const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {
      throw createNotSupportedError2();
    }
    const messageChannel = new MessageChannel();
    const gainNodes = [];
    const inputChannelSplitterNodes = [];
    for (let i = 0; i < options2.numberOfInputs; i += 1) {
      gainNodes.push(createNativeGainNode2(nativeContext, {
        channelCount: options2.channelCount,
        channelCountMode: options2.channelCountMode,
        channelInterpretation: options2.channelInterpretation,
        gain: 1
      }));
      inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(nativeContext, {
        channelCount: options2.channelCount,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: options2.channelCount
      }));
    }
    const constantSourceNodes = [];
    if (processorConstructor.parameterDescriptors !== void 0) {
      for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {
        const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          offset: options2.parameterData[name] !== void 0 ? options2.parameterData[name] : defaultValue === void 0 ? 0 : defaultValue
        });
        Object.defineProperties(constantSourceNode.offset, {
          defaultValue: {
            get: () => defaultValue === void 0 ? 0 : defaultValue
          },
          maxValue: {
            get: () => maxValue === void 0 ? MOST_POSITIVE_SINGLE_FLOAT : maxValue
          },
          minValue: {
            get: () => minValue === void 0 ? MOST_NEGATIVE_SINGLE_FLOAT : minValue
          }
        });
        constantSourceNodes.push(constantSourceNode);
      }
    }
    const inputChannelMergerNode = createNativeChannelMergerNode2(nativeContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
    });
    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
    const scriptProcessorNode = createNativeScriptProcessorNode2(
      nativeContext,
      bufferSize,
      numberOfInputChannels + numberOfParameters,
      // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.
      Math.max(1, numberOfOutputChannels)
    );
    const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
      channelCount: Math.max(1, numberOfOutputChannels),
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: Math.max(1, numberOfOutputChannels)
    });
    const outputChannelMergerNodes = [];
    for (let i = 0; i < options2.numberOfOutputs; i += 1) {
      outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "speakers",
        numberOfInputs: outputChannelCount[i]
      }));
    }
    for (let i = 0; i < options2.numberOfInputs; i += 1) {
      gainNodes[i].connect(inputChannelSplitterNodes[i]);
      for (let j2 = 0; j2 < options2.channelCount; j2 += 1) {
        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j2, i * options2.channelCount + j2);
      }
    }
    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.map(({ name }, index) => {
      const constantSourceNode = constantSourceNodes[index];
      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);
      constantSourceNode.start(0);
      return [name, constantSourceNode.offset];
    }));
    inputChannelMergerNode.connect(scriptProcessorNode);
    let channelInterpretation = options2.channelInterpretation;
    let onprocessorerror = null;
    const outputAudioNodes = options2.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;
    const nativeAudioWorkletNodeFaker = {
      get bufferSize() {
        return bufferSize;
      },
      get channelCount() {
        return options2.channelCount;
      },
      set channelCount(_23) {
        throw createInvalidStateError2();
      },
      get channelCountMode() {
        return options2.channelCountMode;
      },
      set channelCountMode(_23) {
        throw createInvalidStateError2();
      },
      get channelInterpretation() {
        return channelInterpretation;
      },
      set channelInterpretation(value) {
        for (const gainNode of gainNodes) {
          gainNode.channelInterpretation = value;
        }
        channelInterpretation = value;
      },
      get context() {
        return scriptProcessorNode.context;
      },
      get inputs() {
        return gainNodes;
      },
      get numberOfInputs() {
        return options2.numberOfInputs;
      },
      get numberOfOutputs() {
        return options2.numberOfOutputs;
      },
      get onprocessorerror() {
        return onprocessorerror;
      },
      set onprocessorerror(value) {
        if (typeof onprocessorerror === "function") {
          nativeAudioWorkletNodeFaker.removeEventListener("processorerror", onprocessorerror);
        }
        onprocessorerror = typeof value === "function" ? value : null;
        if (typeof onprocessorerror === "function") {
          nativeAudioWorkletNodeFaker.addEventListener("processorerror", onprocessorerror);
        }
      },
      get parameters() {
        return parameterMap;
      },
      get port() {
        return messageChannel.port2;
      },
      addEventListener(...args) {
        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
      },
      connect: connectMultipleOutputs2.bind(null, outputAudioNodes),
      disconnect: disconnectMultipleOutputs2.bind(null, outputAudioNodes),
      dispatchEvent(...args) {
        return scriptProcessorNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    const patchedEventListeners = /* @__PURE__ */ new Map();
    messageChannel.port1.addEventListener = /* @__PURE__ */ ((addEventListener) => {
      return (...args) => {
        if (args[0] === "message") {
          const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
          if (unpatchedEventListener !== null) {
            const patchedEventListener = patchedEventListeners.get(args[1]);
            if (patchedEventListener !== void 0) {
              args[1] = patchedEventListener;
            } else {
              args[1] = (event) => {
                exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));
              };
              patchedEventListeners.set(unpatchedEventListener, args[1]);
            }
          }
        }
        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
      };
    })(messageChannel.port1.addEventListener);
    messageChannel.port1.removeEventListener = /* @__PURE__ */ ((removeEventListener) => {
      return (...args) => {
        if (args[0] === "message") {
          const patchedEventListener = patchedEventListeners.get(args[1]);
          if (patchedEventListener !== void 0) {
            patchedEventListeners.delete(args[1]);
            args[1] = patchedEventListener;
          }
        }
        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
      };
    })(messageChannel.port1.removeEventListener);
    let onmessage = null;
    Object.defineProperty(messageChannel.port1, "onmessage", {
      get: () => onmessage,
      set: (value) => {
        if (typeof onmessage === "function") {
          messageChannel.port1.removeEventListener("message", onmessage);
        }
        onmessage = typeof value === "function" ? value : null;
        if (typeof onmessage === "function") {
          messageChannel.port1.addEventListener("message", onmessage);
          messageChannel.port1.start();
        }
      }
    });
    processorConstructor.prototype.port = messageChannel.port1;
    let audioWorkletProcessor = null;
    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options2);
    audioWorkletProcessorPromise.then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);
    const inputs = createNestedArrays(options2.numberOfInputs, options2.channelCount);
    const outputs2 = createNestedArrays(options2.numberOfOutputs, outputChannelCount);
    const parameters = processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});
    let isActive = true;
    const disconnectOutputsGraph = () => {
      if (options2.numberOfOutputs > 0) {
        scriptProcessorNode.disconnect(outputChannelSplitterNode);
      }
      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options2.numberOfOutputs; i += 1) {
        const outputChannelMergerNode = outputChannelMergerNodes[i];
        for (let j2 = 0; j2 < outputChannelCount[i]; j2 += 1) {
          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
        }
        outputChannelSplitterNodeOutput += outputChannelCount[i];
      }
    };
    const activeInputIndexes = /* @__PURE__ */ new Map();
    scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {
      if (audioWorkletProcessor !== null) {
        const activeInputs = getActiveAudioWorkletNodeInputs2(nativeAudioWorkletNodeFaker);
        for (let i = 0; i < bufferSize; i += 128) {
          for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
            for (let k = 0; k < options2.channelCount; k += 1) {
              copyFromChannel(inputBuffer, inputs[j2], k, k, i);
            }
          }
          if (processorConstructor.parameterDescriptors !== void 0) {
            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {
              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);
            });
          }
          for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
            for (let k = 0; k < outputChannelCount[j2]; k += 1) {
              if (outputs2[j2][k].byteLength === 0) {
                outputs2[j2][k] = new Float32Array(128);
              }
            }
          }
          try {
            const potentiallyEmptyInputs = inputs.map((input, index) => {
              const activeInput = activeInputs[index];
              if (activeInput.size > 0) {
                activeInputIndexes.set(index, bufferSize / 128);
                return input;
              }
              const count = activeInputIndexes.get(index);
              if (count === void 0) {
                return [];
              }
              if (input.every((channelData) => channelData.every((sample) => sample === 0))) {
                if (count === 1) {
                  activeInputIndexes.delete(index);
                } else {
                  activeInputIndexes.set(index, count - 1);
                }
              }
              return input;
            });
            const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs2, parameters));
            isActive = activeSourceFlag;
            for (let j2 = 0, outputChannelSplitterNodeOutput = 0; j2 < options2.numberOfOutputs; j2 += 1) {
              for (let k = 0; k < outputChannelCount[j2]; k += 1) {
                copyToChannel(outputBuffer, outputs2[j2], k, outputChannelSplitterNodeOutput + k, i);
              }
              outputChannelSplitterNodeOutput += outputChannelCount[j2];
            }
          } catch (error2) {
            isActive = false;
            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent("processorerror", {
              colno: error2.colno,
              filename: error2.filename,
              lineno: error2.lineno,
              message: error2.message
            }));
          }
          if (!isActive) {
            for (let j2 = 0; j2 < options2.numberOfInputs; j2 += 1) {
              gainNodes[j2].disconnect(inputChannelSplitterNodes[j2]);
              for (let k = 0; k < options2.channelCount; k += 1) {
                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j2 * options2.channelCount + k);
              }
            }
            if (processorConstructor.parameterDescriptors !== void 0) {
              const length = processorConstructor.parameterDescriptors.length;
              for (let j2 = 0; j2 < length; j2 += 1) {
                const constantSourceNode = constantSourceNodes[j2];
                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j2);
                constantSourceNode.stop();
              }
            }
            inputChannelMergerNode.disconnect(scriptProcessorNode);
            scriptProcessorNode.onaudioprocess = null;
            if (isConnected) {
              disconnectOutputsGraph();
            } else {
              disconnectFakeGraph();
            }
            break;
          }
        }
      }
    };
    let isConnected = false;
    const nativeGainNode = createNativeGainNode2(nativeContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: 0
    });
    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);
    const disconnectFakeGraph = () => {
      scriptProcessorNode.disconnect(nativeGainNode);
      nativeGainNode.disconnect();
    };
    const whenConnected = () => {
      if (isActive) {
        disconnectFakeGraph();
        if (options2.numberOfOutputs > 0) {
          scriptProcessorNode.connect(outputChannelSplitterNode);
        }
        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options2.numberOfOutputs; i += 1) {
          const outputChannelMergerNode = outputChannelMergerNodes[i];
          for (let j2 = 0; j2 < outputChannelCount[i]; j2 += 1) {
            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j2, j2);
          }
          outputChannelSplitterNodeOutput += outputChannelCount[i];
        }
      }
      isConnected = true;
    };
    const whenDisconnected = () => {
      if (isActive) {
        connectFakeGraph();
        disconnectOutputsGraph();
      }
      isConnected = false;
    };
    connectFakeGraph();
    return monitorConnections2(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);
  };
};
const createNativeBiquadFilterNode = (nativeContext, options2) => {
  const nativeBiquadFilterNode = nativeContext.createBiquadFilter();
  assignNativeAudioNodeOptions(nativeBiquadFilterNode, options2);
  assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "Q");
  assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "detune");
  assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "frequency");
  assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options2, "gain");
  assignNativeAudioNodeOption(nativeBiquadFilterNode, options2, "type");
  return nativeBiquadFilterNode;
};
const createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor2, wrapChannelMergerNode2) => {
  return (nativeContext, options2) => {
    const nativeChannelMergerNode = nativeContext.createChannelMerger(options2.numberOfInputs);
    if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
      wrapChannelMergerNode2(nativeContext, nativeChannelMergerNode);
    }
    assignNativeAudioNodeOptions(nativeChannelMergerNode, options2);
    return nativeChannelMergerNode;
  };
};
const wrapChannelSplitterNode = (channelSplitterNode) => {
  const channelCount = channelSplitterNode.numberOfOutputs;
  Object.defineProperty(channelSplitterNode, "channelCount", {
    get: () => channelCount,
    set: (value) => {
      if (value !== channelCount) {
        throw createInvalidStateError();
      }
    }
  });
  Object.defineProperty(channelSplitterNode, "channelCountMode", {
    get: () => "explicit",
    set: (value) => {
      if (value !== "explicit") {
        throw createInvalidStateError();
      }
    }
  });
  Object.defineProperty(channelSplitterNode, "channelInterpretation", {
    get: () => "discrete",
    set: (value) => {
      if (value !== "discrete") {
        throw createInvalidStateError();
      }
    }
  });
};
const createNativeChannelSplitterNode = (nativeContext, options2) => {
  const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options2.numberOfOutputs);
  assignNativeAudioNodeOptions(nativeChannelSplitterNode, options2);
  wrapChannelSplitterNode(nativeChannelSplitterNode);
  return nativeChannelSplitterNode;
};
const createNativeConstantSourceNodeFactory = (addSilentConnection2, cacheTestResult2, createNativeConstantSourceNodeFaker2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2) => {
  return (nativeContext, options2) => {
    if (nativeContext.createConstantSource === void 0) {
      return createNativeConstantSourceNodeFaker2(nativeContext, options2);
    }
    const nativeConstantSourceNode = nativeContext.createConstantSource();
    assignNativeAudioNodeOptions(nativeConstantSourceNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options2, "offset");
    if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);
    }
    addSilentConnection2(nativeContext, nativeConstantSourceNode);
    return nativeConstantSourceNode;
  };
};
const interceptConnections = (original, interceptor) => {
  original.connect = interceptor.connect.bind(interceptor);
  original.disconnect = interceptor.disconnect.bind(interceptor);
  return original;
};
const createNativeConstantSourceNodeFakerFactory = (addSilentConnection2, createNativeAudioBufferSourceNode2, createNativeGainNode2, monitorConnections2) => {
  return (nativeContext, { offset: offset2, ...audioNodeOptions }) => {
    const audioBuffer = nativeContext.createBuffer(1, 2, 44100);
    const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    });
    const gainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: offset2 });
    const channelData = audioBuffer.getChannelData(0);
    channelData[0] = 1;
    channelData[1] = 1;
    audioBufferSourceNode.buffer = audioBuffer;
    audioBufferSourceNode.loop = true;
    const nativeConstantSourceNodeFaker = {
      get bufferSize() {
        return void 0;
      },
      get channelCount() {
        return gainNode.channelCount;
      },
      set channelCount(value) {
        gainNode.channelCount = value;
      },
      get channelCountMode() {
        return gainNode.channelCountMode;
      },
      set channelCountMode(value) {
        gainNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return gainNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        gainNode.channelInterpretation = value;
      },
      get context() {
        return gainNode.context;
      },
      get inputs() {
        return [];
      },
      get numberOfInputs() {
        return audioBufferSourceNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return gainNode.numberOfOutputs;
      },
      get offset() {
        return gainNode.gain;
      },
      get onended() {
        return audioBufferSourceNode.onended;
      },
      set onended(value) {
        audioBufferSourceNode.onended = value;
      },
      addEventListener(...args) {
        return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return audioBufferSourceNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);
      },
      start(when = 0) {
        audioBufferSourceNode.start.call(audioBufferSourceNode, when);
      },
      stop(when = 0) {
        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);
      }
    };
    const whenConnected = () => audioBufferSourceNode.connect(gainNode);
    const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);
    addSilentConnection2(nativeContext, audioBufferSourceNode);
    return monitorConnections2(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);
  };
};
const createNativeConvolverNodeFactory = (createNotSupportedError2, overwriteAccessors2) => {
  return (nativeContext, options2) => {
    const nativeConvolverNode = nativeContext.createConvolver();
    assignNativeAudioNodeOptions(nativeConvolverNode, options2);
    if (options2.disableNormalization === nativeConvolverNode.normalize) {
      nativeConvolverNode.normalize = !options2.disableNormalization;
    }
    assignNativeAudioNodeOption(nativeConvolverNode, options2, "buffer");
    if (options2.channelCount > 2) {
      throw createNotSupportedError2();
    }
    overwriteAccessors2(nativeConvolverNode, "channelCount", (get2) => () => get2.call(nativeConvolverNode), (set2) => (value) => {
      if (value > 2) {
        throw createNotSupportedError2();
      }
      return set2.call(nativeConvolverNode, value);
    });
    if (options2.channelCountMode === "max") {
      throw createNotSupportedError2();
    }
    overwriteAccessors2(nativeConvolverNode, "channelCountMode", (get2) => () => get2.call(nativeConvolverNode), (set2) => (value) => {
      if (value === "max") {
        throw createNotSupportedError2();
      }
      return set2.call(nativeConvolverNode, value);
    });
    return nativeConvolverNode;
  };
};
const createNativeDelayNode = (nativeContext, options2) => {
  const nativeDelayNode = nativeContext.createDelay(options2.maxDelayTime);
  assignNativeAudioNodeOptions(nativeDelayNode, options2);
  assignNativeAudioNodeAudioParamValue(nativeDelayNode, options2, "delayTime");
  return nativeDelayNode;
};
const createNativeDynamicsCompressorNodeFactory = (createNotSupportedError2) => {
  return (nativeContext, options2) => {
    const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();
    assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options2);
    if (options2.channelCount > 2) {
      throw createNotSupportedError2();
    }
    if (options2.channelCountMode === "max") {
      throw createNotSupportedError2();
    }
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "attack");
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "knee");
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "ratio");
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "release");
    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options2, "threshold");
    return nativeDynamicsCompressorNode;
  };
};
const createNativeGainNode = (nativeContext, options2) => {
  const nativeGainNode = nativeContext.createGain();
  assignNativeAudioNodeOptions(nativeGainNode, options2);
  assignNativeAudioNodeAudioParamValue(nativeGainNode, options2, "gain");
  return nativeGainNode;
};
const createNativeIIRFilterNodeFactory = (createNativeIIRFilterNodeFaker2) => {
  return (nativeContext, baseLatency, options2) => {
    if (nativeContext.createIIRFilter === void 0) {
      return createNativeIIRFilterNodeFaker2(nativeContext, baseLatency, options2);
    }
    const nativeIIRFilterNode = nativeContext.createIIRFilter(options2.feedforward, options2.feedback);
    assignNativeAudioNodeOptions(nativeIIRFilterNode, options2);
    return nativeIIRFilterNode;
  };
};
function divide(a, b2) {
  const denominator = b2[0] * b2[0] + b2[1] * b2[1];
  return [(a[0] * b2[0] + a[1] * b2[1]) / denominator, (a[1] * b2[0] - a[0] * b2[1]) / denominator];
}
function multiply(a, b2) {
  return [a[0] * b2[0] - a[1] * b2[1], a[0] * b2[1] + a[1] * b2[0]];
}
function evaluatePolynomial(coefficient, z) {
  let result = [0, 0];
  for (let i = coefficient.length - 1; i >= 0; i -= 1) {
    result = multiply(result, z);
    result[0] += coefficient[i];
  }
  return result;
}
const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError2, createInvalidStateError2, createNativeScriptProcessorNode2, createNotSupportedError2) => {
  return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {
    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
    const feedbackLength = convertedFeedback.length;
    const feedforwardLength = convertedFeedforward.length;
    const minLength = Math.min(feedbackLength, feedforwardLength);
    if (feedbackLength === 0 || feedbackLength > 20) {
      throw createNotSupportedError2();
    }
    if (convertedFeedback[0] === 0) {
      throw createInvalidStateError2();
    }
    if (feedforwardLength === 0 || feedforwardLength > 20) {
      throw createNotSupportedError2();
    }
    if (convertedFeedforward[0] === 0) {
      throw createInvalidStateError2();
    }
    if (convertedFeedback[0] !== 1) {
      for (let i = 0; i < feedforwardLength; i += 1) {
        convertedFeedforward[i] /= convertedFeedback[0];
      }
      for (let i = 1; i < feedbackLength; i += 1) {
        convertedFeedback[i] /= convertedFeedback[0];
      }
    }
    const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, bufferSize, channelCount, channelCount);
    scriptProcessorNode.channelCount = channelCount;
    scriptProcessorNode.channelCountMode = channelCountMode;
    scriptProcessorNode.channelInterpretation = channelInterpretation;
    const bufferLength = 32;
    const bufferIndexes = [];
    const xBuffers = [];
    const yBuffers = [];
    for (let i = 0; i < channelCount; i += 1) {
      bufferIndexes.push(0);
      const xBuffer = new Float32Array(bufferLength);
      const yBuffer = new Float32Array(bufferLength);
      xBuffer.fill(0);
      yBuffer.fill(0);
      xBuffers.push(xBuffer);
      yBuffers.push(yBuffer);
    }
    scriptProcessorNode.onaudioprocess = (event) => {
      const inputBuffer = event.inputBuffer;
      const outputBuffer = event.outputBuffer;
      const numberOfChannels = inputBuffer.numberOfChannels;
      for (let i = 0; i < numberOfChannels; i += 1) {
        const input = inputBuffer.getChannelData(i);
        const output2 = outputBuffer.getChannelData(i);
        bufferIndexes[i] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output2);
      }
    };
    const nyquist = nativeContext.sampleRate / 2;
    const nativeIIRFilterNodeFaker = {
      get bufferSize() {
        return bufferSize;
      },
      get channelCount() {
        return scriptProcessorNode.channelCount;
      },
      set channelCount(value) {
        scriptProcessorNode.channelCount = value;
      },
      get channelCountMode() {
        return scriptProcessorNode.channelCountMode;
      },
      set channelCountMode(value) {
        scriptProcessorNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return scriptProcessorNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        scriptProcessorNode.channelInterpretation = value;
      },
      get context() {
        return scriptProcessorNode.context;
      },
      get inputs() {
        return [scriptProcessorNode];
      },
      get numberOfInputs() {
        return scriptProcessorNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return scriptProcessorNode.numberOfOutputs;
      },
      addEventListener(...args) {
        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return scriptProcessorNode.dispatchEvent(args[0]);
      },
      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
          throw createInvalidAccessError2();
        }
        const length = frequencyHz.length;
        for (let i = 0; i < length; i += 1) {
          const omega = -Math.PI * (frequencyHz[i] / nyquist);
          const z = [Math.cos(omega), Math.sin(omega)];
          const numerator = evaluatePolynomial(convertedFeedforward, z);
          const denominator = evaluatePolynomial(convertedFeedback, z);
          const response = divide(numerator, denominator);
          magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
          phaseResponse[i] = Math.atan2(response[1], response[0]);
        }
      },
      removeEventListener(...args) {
        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);
  };
};
const createNativeMediaElementAudioSourceNode = (nativeAudioContext, options2) => {
  return nativeAudioContext.createMediaElementSource(options2.mediaElement);
};
const createNativeMediaStreamAudioDestinationNode = (nativeAudioContext, options2) => {
  const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();
  assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options2);
  if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {
    Object.defineProperty(nativeMediaStreamAudioDestinationNode, "numberOfOutputs", { get: () => 0 });
  }
  return nativeMediaStreamAudioDestinationNode;
};
const createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {
  const audioStreamTracks = mediaStream.getAudioTracks();
  audioStreamTracks.sort((a, b2) => a.id < b2.id ? -1 : a.id > b2.id ? 1 : 0);
  const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);
  const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));
  Object.defineProperty(nativeMediaStreamAudioSourceNode, "mediaStream", { value: mediaStream });
  return nativeMediaStreamAudioSourceNode;
};
const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError2, isNativeOfflineAudioContext2) => {
  return (nativeAudioContext, { mediaStreamTrack }) => {
    if (typeof nativeAudioContext.createMediaStreamTrackSource === "function") {
      return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);
    }
    const mediaStream = new MediaStream([mediaStreamTrack]);
    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);
    if (mediaStreamTrack.kind !== "audio") {
      throw createInvalidStateError2();
    }
    if (isNativeOfflineAudioContext2(nativeAudioContext)) {
      throw new TypeError();
    }
    return nativeMediaStreamAudioSourceNode;
  };
};
const createNativeOfflineAudioContextConstructor = (window2) => {
  if (window2 === null) {
    return null;
  }
  if (window2.hasOwnProperty("OfflineAudioContext")) {
    return window2.OfflineAudioContext;
  }
  return window2.hasOwnProperty("webkitOfflineAudioContext") ? window2.webkitOfflineAudioContext : null;
};
const createNativeOscillatorNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
  return (nativeContext, options2) => {
    const nativeOscillatorNode = nativeContext.createOscillator();
    assignNativeAudioNodeOptions(nativeOscillatorNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options2, "detune");
    assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options2, "frequency");
    if (options2.periodicWave !== void 0) {
      nativeOscillatorNode.setPeriodicWave(options2.periodicWave);
    } else {
      assignNativeAudioNodeOption(nativeOscillatorNode, options2, "type");
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeOscillatorNode, nativeContext);
    }
    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);
    }
    addSilentConnection2(nativeContext, nativeOscillatorNode);
    return nativeOscillatorNode;
  };
};
const createNativePannerNodeFactory = (createNativePannerNodeFaker2) => {
  return (nativeContext, options2) => {
    const nativePannerNode = nativeContext.createPanner();
    if (nativePannerNode.orientationX === void 0) {
      return createNativePannerNodeFaker2(nativeContext, options2);
    }
    assignNativeAudioNodeOptions(nativePannerNode, options2);
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationX");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationY");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "orientationZ");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionX");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionY");
    assignNativeAudioNodeAudioParamValue(nativePannerNode, options2, "positionZ");
    assignNativeAudioNodeOption(nativePannerNode, options2, "coneInnerAngle");
    assignNativeAudioNodeOption(nativePannerNode, options2, "coneOuterAngle");
    assignNativeAudioNodeOption(nativePannerNode, options2, "coneOuterGain");
    assignNativeAudioNodeOption(nativePannerNode, options2, "distanceModel");
    assignNativeAudioNodeOption(nativePannerNode, options2, "maxDistance");
    assignNativeAudioNodeOption(nativePannerNode, options2, "panningModel");
    assignNativeAudioNodeOption(nativePannerNode, options2, "refDistance");
    assignNativeAudioNodeOption(nativePannerNode, options2, "rolloffFactor");
    return nativePannerNode;
  };
};
const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNativeWaveShaperNode2, createNotSupportedError2, disconnectNativeAudioNodeFromNativeAudioNode2, getFirstSample2, monitorConnections2) => {
  return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {
    const pannerNode = nativeContext.createPanner();
    if (audioNodeOptions.channelCount > 2) {
      throw createNotSupportedError2();
    }
    if (audioNodeOptions.channelCountMode === "max") {
      throw createNotSupportedError2();
    }
    assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);
    const SINGLE_CHANNEL_OPTIONS = {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete"
    };
    const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
      ...SINGLE_CHANNEL_OPTIONS,
      channelInterpretation: "speakers",
      numberOfInputs: 6
    });
    const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
    const orientationXGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });
    const orientationYGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const orientationZGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const positionXGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const positionYGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const positionZGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 6, 1);
    const waveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_OPTIONS,
      curve: new Float32Array([1, 1]),
      oversample: "none"
    });
    let lastOrientation = [orientationX, orientationY, orientationZ];
    let lastPosition = [positionX, positionY, positionZ];
    const buffer = new Float32Array(1);
    scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
      const orientation = [
        getFirstSample2(inputBuffer, buffer, 0),
        getFirstSample2(inputBuffer, buffer, 1),
        getFirstSample2(inputBuffer, buffer, 2)
      ];
      if (orientation.some((value, index) => value !== lastOrientation[index])) {
        pannerNode.setOrientation(...orientation);
        lastOrientation = orientation;
      }
      const positon = [
        getFirstSample2(inputBuffer, buffer, 3),
        getFirstSample2(inputBuffer, buffer, 4),
        getFirstSample2(inputBuffer, buffer, 5)
      ];
      if (positon.some((value, index) => value !== lastPosition[index])) {
        pannerNode.setPosition(...positon);
        lastPosition = positon;
      }
    };
    Object.defineProperty(orientationYGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(orientationZGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(positionXGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(positionYGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(positionZGainNode.gain, "defaultValue", { get: () => 0 });
    const nativePannerNodeFaker = {
      get bufferSize() {
        return void 0;
      },
      get channelCount() {
        return pannerNode.channelCount;
      },
      set channelCount(value) {
        if (value > 2) {
          throw createNotSupportedError2();
        }
        inputGainNode.channelCount = value;
        pannerNode.channelCount = value;
      },
      get channelCountMode() {
        return pannerNode.channelCountMode;
      },
      set channelCountMode(value) {
        if (value === "max") {
          throw createNotSupportedError2();
        }
        inputGainNode.channelCountMode = value;
        pannerNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return pannerNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
        pannerNode.channelInterpretation = value;
      },
      get coneInnerAngle() {
        return pannerNode.coneInnerAngle;
      },
      set coneInnerAngle(value) {
        pannerNode.coneInnerAngle = value;
      },
      get coneOuterAngle() {
        return pannerNode.coneOuterAngle;
      },
      set coneOuterAngle(value) {
        pannerNode.coneOuterAngle = value;
      },
      get coneOuterGain() {
        return pannerNode.coneOuterGain;
      },
      set coneOuterGain(value) {
        if (value < 0 || value > 1) {
          throw createInvalidStateError2();
        }
        pannerNode.coneOuterGain = value;
      },
      get context() {
        return pannerNode.context;
      },
      get distanceModel() {
        return pannerNode.distanceModel;
      },
      set distanceModel(value) {
        pannerNode.distanceModel = value;
      },
      get inputs() {
        return [inputGainNode];
      },
      get maxDistance() {
        return pannerNode.maxDistance;
      },
      set maxDistance(value) {
        if (value < 0) {
          throw new RangeError();
        }
        pannerNode.maxDistance = value;
      },
      get numberOfInputs() {
        return pannerNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return pannerNode.numberOfOutputs;
      },
      get orientationX() {
        return orientationXGainNode.gain;
      },
      get orientationY() {
        return orientationYGainNode.gain;
      },
      get orientationZ() {
        return orientationZGainNode.gain;
      },
      get panningModel() {
        return pannerNode.panningModel;
      },
      set panningModel(value) {
        pannerNode.panningModel = value;
      },
      get positionX() {
        return positionXGainNode.gain;
      },
      get positionY() {
        return positionYGainNode.gain;
      },
      get positionZ() {
        return positionZGainNode.gain;
      },
      get refDistance() {
        return pannerNode.refDistance;
      },
      set refDistance(value) {
        if (value < 0) {
          throw new RangeError();
        }
        pannerNode.refDistance = value;
      },
      get rolloffFactor() {
        return pannerNode.rolloffFactor;
      },
      set rolloffFactor(value) {
        if (value < 0) {
          throw new RangeError();
        }
        pannerNode.rolloffFactor = value;
      },
      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {
      nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;
    }
    if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {
      nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;
    }
    if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {
      nativePannerNodeFaker.coneOuterGain = coneOuterGain;
    }
    if (distanceModel !== nativePannerNodeFaker.distanceModel) {
      nativePannerNodeFaker.distanceModel = distanceModel;
    }
    if (maxDistance !== nativePannerNodeFaker.maxDistance) {
      nativePannerNodeFaker.maxDistance = maxDistance;
    }
    if (orientationX !== nativePannerNodeFaker.orientationX.value) {
      nativePannerNodeFaker.orientationX.value = orientationX;
    }
    if (orientationY !== nativePannerNodeFaker.orientationY.value) {
      nativePannerNodeFaker.orientationY.value = orientationY;
    }
    if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {
      nativePannerNodeFaker.orientationZ.value = orientationZ;
    }
    if (panningModel !== nativePannerNodeFaker.panningModel) {
      nativePannerNodeFaker.panningModel = panningModel;
    }
    if (positionX !== nativePannerNodeFaker.positionX.value) {
      nativePannerNodeFaker.positionX.value = positionX;
    }
    if (positionY !== nativePannerNodeFaker.positionY.value) {
      nativePannerNodeFaker.positionY.value = positionY;
    }
    if (positionZ !== nativePannerNodeFaker.positionZ.value) {
      nativePannerNodeFaker.positionZ.value = positionZ;
    }
    if (refDistance !== nativePannerNodeFaker.refDistance) {
      nativePannerNodeFaker.refDistance = refDistance;
    }
    if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {
      nativePannerNodeFaker.rolloffFactor = rolloffFactor;
    }
    if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {
      pannerNode.setOrientation(...lastOrientation);
    }
    if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {
      pannerNode.setPosition(...lastPosition);
    }
    const whenConnected = () => {
      inputGainNode.connect(pannerNode);
      connectNativeAudioNodeToNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
      waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);
      waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);
      waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);
      waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);
      waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);
      waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);
      channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);
    };
    const whenDisconnected = () => {
      inputGainNode.disconnect(pannerNode);
      disconnectNativeAudioNodeFromNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
      waveShaperNode.disconnect(orientationXGainNode);
      orientationXGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(orientationYGainNode);
      orientationYGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(orientationZGainNode);
      orientationZGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionXGainNode);
      positionXGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionYGainNode);
      positionYGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionZGainNode);
      positionZGainNode.disconnect(channelMergerNode);
      channelMergerNode.disconnect(scriptProcessorNode);
      scriptProcessorNode.disconnect(nativeContext.destination);
    };
    return monitorConnections2(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);
  };
};
const createNativePeriodicWaveFactory = (createIndexSizeError2) => {
  return (nativeContext, { disableNormalization, imag, real }) => {
    const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);
    const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);
    const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });
    if (Array.from(imag).length < 2) {
      throw createIndexSizeError2();
    }
    return nativePeriodicWave;
  };
};
const createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {
  return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
};
const createNativeStereoPannerNodeFactory = (createNativeStereoPannerNodeFaker, createNotSupportedError2) => {
  return (nativeContext, options2) => {
    const channelCountMode = options2.channelCountMode;
    if (channelCountMode === "clamped-max") {
      throw createNotSupportedError2();
    }
    if (nativeContext.createStereoPanner === void 0) {
      return createNativeStereoPannerNodeFaker(nativeContext, options2);
    }
    const nativeStereoPannerNode = nativeContext.createStereoPanner();
    assignNativeAudioNodeOptions(nativeStereoPannerNode, options2);
    assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options2, "pan");
    Object.defineProperty(nativeStereoPannerNode, "channelCountMode", {
      get: () => channelCountMode,
      set: (value) => {
        if (value !== channelCountMode) {
          throw createNotSupportedError2();
        }
      }
    });
    return nativeStereoPannerNode;
  };
};
const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeGainNode2, createNativeWaveShaperNode2, createNotSupportedError2, monitorConnections2) => {
  const CURVE_SIZE = 16385;
  const DC_CURVE = new Float32Array([1, 1]);
  const HALF_PI2 = Math.PI / 2;
  const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" };
  const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: "none" };
  const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
    const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);
    for (let i = 0; i < CURVE_SIZE; i += 1) {
      const x = i / (CURVE_SIZE - 1) * HALF_PI2;
      leftWaveShaperCurve[i] = Math.cos(x);
      rightWaveShaperCurve[i] = Math.sin(x);
    }
    const leftGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const leftWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve });
    const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });
    const rightGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const rightWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve });
    return {
      connectGraph() {
        inputGainNode.connect(leftGainNode);
        inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        inputGainNode.connect(rightGainNode);
        panWaveShaperNode.connect(panGainNode);
        panGainNode.connect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
        panGainNode.connect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
        leftWaveShaperNode.connect(leftGainNode.gain);
        rightWaveShaperNode.connect(rightGainNode.gain);
        leftGainNode.connect(channelMergerNode, 0, 0);
        rightGainNode.connect(channelMergerNode, 0, 1);
      },
      disconnectGraph() {
        inputGainNode.disconnect(leftGainNode);
        inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        inputGainNode.disconnect(rightGainNode);
        panWaveShaperNode.disconnect(panGainNode);
        panGainNode.disconnect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
        leftWaveShaperNode.disconnect(leftGainNode.gain);
        rightWaveShaperNode.disconnect(rightGainNode.gain);
        leftGainNode.disconnect(channelMergerNode, 0, 0);
        rightGainNode.disconnect(channelMergerNode, 0, 1);
      }
    };
  };
  const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
    const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const centerIndex = Math.floor(CURVE_SIZE / 2);
    for (let i = 0; i < CURVE_SIZE; i += 1) {
      if (i > centerIndex) {
        const x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI2;
        leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);
        leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);
        rightInputForLeftOutputWaveShaperCurve[i] = 0;
        rightInputForRightOutputWaveShaperCurve[i] = 1;
      } else {
        const x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI2;
        leftInputForLeftOutputWaveShaperCurve[i] = 1;
        leftInputForRightOutputWaveShaperCurve[i] = 0;
        rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);
        rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);
      }
    }
    const channelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
      channelCount: 2,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: 2
    });
    const leftInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: leftInputForLeftOutputWaveShaperCurve
    });
    const leftInputForRightOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: leftInputForRightOutputWaveShaperCurve
    });
    const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });
    const rightInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: rightInputForLeftOutputWaveShaperCurve
    });
    const rightInputForRightOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
    const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
      ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: rightInputForRightOutputWaveShaperCurve
    });
    return {
      connectGraph() {
        inputGainNode.connect(channelSplitterNode);
        inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);
        channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);
        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);
        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);
        panWaveShaperNode.connect(panGainNode);
        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);
        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);
        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);
        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);
        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
      },
      disconnectGraph() {
        inputGainNode.disconnect(channelSplitterNode);
        inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);
        channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);
        channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);
        channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);
        panWaveShaperNode.disconnect(panGainNode);
        panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
        leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);
        leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);
        rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);
        rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);
        leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
        rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
        leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
        rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
      }
    };
  };
  const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {
    if (channelCount === 1) {
      return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);
    }
    if (channelCount === 2) {
      return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);
    }
    throw createNotSupportedError2();
  };
  return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {
    if (channelCountMode === "max") {
      throw createNotSupportedError2();
    }
    const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
      ...audioNodeOptions,
      channelCount: 1,
      channelCountMode,
      numberOfInputs: 2
    });
    const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });
    const panGainNode = createNativeGainNode2(nativeContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: pan
    });
    let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);
    Object.defineProperty(panGainNode.gain, "defaultValue", { get: () => 0 });
    Object.defineProperty(panGainNode.gain, "maxValue", { get: () => 1 });
    Object.defineProperty(panGainNode.gain, "minValue", { get: () => -1 });
    const nativeStereoPannerNodeFakerFactory2 = {
      get bufferSize() {
        return void 0;
      },
      get channelCount() {
        return inputGainNode.channelCount;
      },
      set channelCount(value) {
        if (inputGainNode.channelCount !== value) {
          if (isConnected) {
            disconnectGraph();
          }
          ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));
          if (isConnected) {
            connectGraph();
          }
        }
        inputGainNode.channelCount = value;
      },
      get channelCountMode() {
        return inputGainNode.channelCountMode;
      },
      set channelCountMode(value) {
        if (value === "clamped-max" || value === "max") {
          throw createNotSupportedError2();
        }
        inputGainNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return inputGainNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
      },
      get context() {
        return inputGainNode.context;
      },
      get inputs() {
        return [inputGainNode];
      },
      get numberOfInputs() {
        return inputGainNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return inputGainNode.numberOfOutputs;
      },
      get pan() {
        return panGainNode.gain;
      },
      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    let isConnected = false;
    const whenConnected = () => {
      connectGraph();
      isConnected = true;
    };
    const whenDisconnected = () => {
      disconnectGraph();
      isConnected = false;
    };
    return monitorConnections2(interceptConnections(nativeStereoPannerNodeFakerFactory2, channelMergerNode), whenConnected, whenDisconnected);
  };
};
const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError2, createNativeWaveShaperNodeFaker2, isDCCurve2, monitorConnections2, nativeAudioContextConstructor2, overwriteAccessors2) => {
  return (nativeContext, options2) => {
    const nativeWaveShaperNode = nativeContext.createWaveShaper();
    if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext" && nativeContext.createGain().gain.automationRate === void 0) {
      return createNativeWaveShaperNodeFaker2(nativeContext, options2);
    }
    assignNativeAudioNodeOptions(nativeWaveShaperNode, options2);
    const curve = options2.curve === null || options2.curve instanceof Float32Array ? options2.curve : new Float32Array(options2.curve);
    if (curve !== null && curve.length < 2) {
      throw createInvalidStateError2();
    }
    assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, "curve");
    assignNativeAudioNodeOption(nativeWaveShaperNode, options2, "oversample");
    let disconnectNativeAudioBufferSourceNode = null;
    let isConnected = false;
    overwriteAccessors2(nativeWaveShaperNode, "curve", (get2) => () => get2.call(nativeWaveShaperNode), (set2) => (value) => {
      set2.call(nativeWaveShaperNode, value);
      if (isConnected) {
        if (isDCCurve2(value) && disconnectNativeAudioBufferSourceNode === null) {
          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
        } else if (!isDCCurve2(value) && disconnectNativeAudioBufferSourceNode !== null) {
          disconnectNativeAudioBufferSourceNode();
          disconnectNativeAudioBufferSourceNode = null;
        }
      }
      return value;
    });
    const whenConnected = () => {
      isConnected = true;
      if (isDCCurve2(nativeWaveShaperNode.curve)) {
        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
      }
    };
    const whenDisconnected = () => {
      isConnected = false;
      if (disconnectNativeAudioBufferSourceNode !== null) {
        disconnectNativeAudioBufferSourceNode();
        disconnectNativeAudioBufferSourceNode = null;
      }
    };
    return monitorConnections2(nativeWaveShaperNode, whenConnected, whenDisconnected);
  };
};
const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError2, createNativeGainNode2, isDCCurve2, monitorConnections2) => {
  return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {
    const negativeWaveShaperNode = nativeContext.createWaveShaper();
    const positiveWaveShaperNode = nativeContext.createWaveShaper();
    assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);
    assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);
    const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
    const invertGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: -1 });
    const outputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
    const revertGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: -1 });
    let disconnectNativeAudioBufferSourceNode = null;
    let isConnected = false;
    let unmodifiedCurve = null;
    const nativeWaveShaperNodeFaker = {
      get bufferSize() {
        return void 0;
      },
      get channelCount() {
        return negativeWaveShaperNode.channelCount;
      },
      set channelCount(value) {
        inputGainNode.channelCount = value;
        invertGainNode.channelCount = value;
        negativeWaveShaperNode.channelCount = value;
        outputGainNode.channelCount = value;
        positiveWaveShaperNode.channelCount = value;
        revertGainNode.channelCount = value;
      },
      get channelCountMode() {
        return negativeWaveShaperNode.channelCountMode;
      },
      set channelCountMode(value) {
        inputGainNode.channelCountMode = value;
        invertGainNode.channelCountMode = value;
        negativeWaveShaperNode.channelCountMode = value;
        outputGainNode.channelCountMode = value;
        positiveWaveShaperNode.channelCountMode = value;
        revertGainNode.channelCountMode = value;
      },
      get channelInterpretation() {
        return negativeWaveShaperNode.channelInterpretation;
      },
      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
        invertGainNode.channelInterpretation = value;
        negativeWaveShaperNode.channelInterpretation = value;
        outputGainNode.channelInterpretation = value;
        positiveWaveShaperNode.channelInterpretation = value;
        revertGainNode.channelInterpretation = value;
      },
      get context() {
        return negativeWaveShaperNode.context;
      },
      get curve() {
        return unmodifiedCurve;
      },
      set curve(value) {
        if (value !== null && value.length < 2) {
          throw createInvalidStateError2();
        }
        if (value === null) {
          negativeWaveShaperNode.curve = value;
          positiveWaveShaperNode.curve = value;
        } else {
          const curveLength = value.length;
          const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);
          const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);
          negativeCurve[0] = value[0];
          positiveCurve[0] = -value[curveLength - 1];
          const length = Math.ceil((curveLength + 1) / 2);
          const centerIndex = (curveLength + 1) / 2 - 1;
          for (let i = 1; i < length; i += 1) {
            const theoreticIndex = i / length * centerIndex;
            const lowerIndex = Math.floor(theoreticIndex);
            const upperIndex = Math.ceil(theoreticIndex);
            negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];
            positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];
          }
          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;
          negativeWaveShaperNode.curve = negativeCurve;
          positiveWaveShaperNode.curve = positiveCurve;
        }
        unmodifiedCurve = value;
        if (isConnected) {
          if (isDCCurve2(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {
            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
          } else if (disconnectNativeAudioBufferSourceNode !== null) {
            disconnectNativeAudioBufferSourceNode();
            disconnectNativeAudioBufferSourceNode = null;
          }
        }
      },
      get inputs() {
        return [inputGainNode];
      },
      get numberOfInputs() {
        return negativeWaveShaperNode.numberOfInputs;
      },
      get numberOfOutputs() {
        return negativeWaveShaperNode.numberOfOutputs;
      },
      get oversample() {
        return negativeWaveShaperNode.oversample;
      },
      set oversample(value) {
        negativeWaveShaperNode.oversample = value;
        positiveWaveShaperNode.oversample = value;
      },
      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },
      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },
      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }
    };
    if (curve !== null) {
      nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);
    }
    if (oversample !== nativeWaveShaperNodeFaker.oversample) {
      nativeWaveShaperNodeFaker.oversample = oversample;
    }
    const whenConnected = () => {
      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);
      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);
      isConnected = true;
      if (isDCCurve2(unmodifiedCurve)) {
        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
      }
    };
    const whenDisconnected = () => {
      inputGainNode.disconnect(negativeWaveShaperNode);
      negativeWaveShaperNode.disconnect(outputGainNode);
      inputGainNode.disconnect(invertGainNode);
      invertGainNode.disconnect(positiveWaveShaperNode);
      positiveWaveShaperNode.disconnect(revertGainNode);
      revertGainNode.disconnect(outputGainNode);
      isConnected = false;
      if (disconnectNativeAudioBufferSourceNode !== null) {
        disconnectNativeAudioBufferSourceNode();
        disconnectNativeAudioBufferSourceNode = null;
      }
    };
    return monitorConnections2(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);
  };
};
const createNotSupportedError = () => new DOMException("", "NotSupportedError");
const DEFAULT_OPTIONS$5 = {
  numberOfChannels: 1
};
const createOfflineAudioContextConstructor = (baseAudioContextConstructor2, cacheTestResult2, createInvalidStateError2, createNativeOfflineAudioContext2, startRendering2) => {
  return class OfflineAudioContext extends baseAudioContextConstructor2 {
    constructor(a, b2, c) {
      let options2;
      if (typeof a === "number" && b2 !== void 0 && c !== void 0) {
        options2 = { length: b2, numberOfChannels: a, sampleRate: c };
      } else if (typeof a === "object") {
        options2 = a;
      } else {
        throw new Error("The given parameters are not valid.");
      }
      const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS$5, ...options2 };
      const nativeOfflineAudioContext = createNativeOfflineAudioContext2(numberOfChannels, length, sampleRate);
      if (!cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
        nativeOfflineAudioContext.addEventListener("statechange", /* @__PURE__ */ (() => {
          let i = 0;
          const delayStateChangeEvent = (event) => {
            if (this._state === "running") {
              if (i > 0) {
                nativeOfflineAudioContext.removeEventListener("statechange", delayStateChangeEvent);
                event.stopImmediatePropagation();
                this._waitForThePromiseToSettle(event);
              } else {
                i += 1;
              }
            }
          };
          return delayStateChangeEvent;
        })());
      }
      super(nativeOfflineAudioContext, numberOfChannels);
      this._length = length;
      this._nativeOfflineAudioContext = nativeOfflineAudioContext;
      this._state = null;
    }
    get length() {
      if (this._nativeOfflineAudioContext.length === void 0) {
        return this._length;
      }
      return this._nativeOfflineAudioContext.length;
    }
    get state() {
      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
    }
    startRendering() {
      if (this._state === "running") {
        return Promise.reject(createInvalidStateError2());
      }
      this._state = "running";
      return startRendering2(this.destination, this._nativeOfflineAudioContext).finally(() => {
        this._state = null;
        deactivateAudioGraph(this);
      });
    }
    _waitForThePromiseToSettle(event) {
      if (this._state === null) {
        this._nativeOfflineAudioContext.dispatchEvent(event);
      } else {
        setTimeout(() => this._waitForThePromiseToSettle(event));
      }
    }
  };
};
const DEFAULT_OPTIONS$4 = {
  channelCount: 2,
  channelCountMode: "max",
  // This attribute has no effect for nodes with no inputs.
  channelInterpretation: "speakers",
  // This attribute has no effect for nodes with no inputs.
  detune: 0,
  frequency: 440,
  periodicWave: void 0,
  type: "sine"
};
const createOscillatorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeOscillatorNode2, createOscillatorNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {
  return class OscillatorNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$4, ...options2 };
      const nativeOscillatorNode = createNativeOscillatorNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer2() : null;
      const nyquist = context2.sampleRate / 2;
      super(context2, false, nativeOscillatorNode, oscillatorNodeRenderer);
      this._detune = createAudioParam2(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);
      this._frequency = createAudioParam2(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);
      this._nativeOscillatorNode = nativeOscillatorNode;
      this._onended = null;
      this._oscillatorNodeRenderer = oscillatorNodeRenderer;
      if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== void 0) {
        this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;
      }
    }
    get detune() {
      return this._detune;
    }
    get frequency() {
      return this._frequency;
    }
    get onended() {
      return this._onended;
    }
    set onended(value) {
      const wrappedListener = typeof value === "function" ? wrapEventListener2(this, value) : null;
      this._nativeOscillatorNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeOscillatorNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }
    get type() {
      return this._nativeOscillatorNode.type;
    }
    set type(value) {
      this._nativeOscillatorNode.type = value;
      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.periodicWave = null;
      }
    }
    setPeriodicWave(periodicWave) {
      this._nativeOscillatorNode.setPeriodicWave(periodicWave);
      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.periodicWave = periodicWave;
      }
    }
    start(when = 0) {
      this._nativeOscillatorNode.start(when);
      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.start = when;
      }
      if (this.context.state !== "closed") {
        setInternalStateToActive(this);
        const resetInternalStateToPassive = () => {
          this._nativeOscillatorNode.removeEventListener("ended", resetInternalStateToPassive);
          if (isActiveAudioNode(this)) {
            setInternalStateToPassive(this);
          }
        };
        this._nativeOscillatorNode.addEventListener("ended", resetInternalStateToPassive);
      }
    }
    stop(when = 0) {
      this._nativeOscillatorNode.stop(when);
      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.stop = when;
      }
    }
  };
};
const createOscillatorNodeRendererFactory = (connectAudioParam2, createNativeOscillatorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeOscillatorNodes = /* @__PURE__ */ new WeakMap();
    let periodicWave = null;
    let start2 = null;
    let stop = null;
    const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeOscillatorNode = getNativeAudioNode2(proxy);
      const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);
      if (!nativeOscillatorNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeOscillatorNode.channelCount,
          channelCountMode: nativeOscillatorNode.channelCountMode,
          channelInterpretation: nativeOscillatorNode.channelInterpretation,
          detune: nativeOscillatorNode.detune.value,
          frequency: nativeOscillatorNode.frequency.value,
          periodicWave: periodicWave === null ? void 0 : periodicWave,
          type: nativeOscillatorNode.type
        };
        nativeOscillatorNode = createNativeOscillatorNode2(nativeOfflineAudioContext, options2);
        if (start2 !== null) {
          nativeOscillatorNode.start(start2);
        }
        if (stop !== null) {
          nativeOscillatorNode.stop(stop);
        }
      }
      renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);
      if (!nativeOscillatorNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
        await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
      }
      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeOscillatorNode);
      return nativeOscillatorNode;
    };
    return {
      set periodicWave(value) {
        periodicWave = value;
      },
      set start(value) {
        start2 = value;
      },
      set stop(value) {
        stop = value;
      },
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);
        if (renderedNativeOscillatorNode !== void 0) {
          return Promise.resolve(renderedNativeOscillatorNode);
        }
        return createOscillatorNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const DEFAULT_OPTIONS$3 = {
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0,
  distanceModel: "inverse",
  maxDistance: 1e4,
  orientationX: 1,
  orientationY: 0,
  orientationZ: 0,
  panningModel: "equalpower",
  positionX: 0,
  positionY: 0,
  positionZ: 0,
  refDistance: 1,
  rolloffFactor: 1
};
const createPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativePannerNode2, createPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class PannerNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$3, ...options2 };
      const nativePannerNode = createNativePannerNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const pannerNodeRenderer = isOffline ? createPannerNodeRenderer2() : null;
      super(context2, false, nativePannerNode, pannerNodeRenderer);
      this._nativePannerNode = nativePannerNode;
      this._orientationX = createAudioParam2(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._orientationY = createAudioParam2(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._orientationZ = createAudioParam2(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionX = createAudioParam2(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionY = createAudioParam2(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionZ = createAudioParam2(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
      setAudioNodeTailTime2(this, 1);
    }
    get coneInnerAngle() {
      return this._nativePannerNode.coneInnerAngle;
    }
    set coneInnerAngle(value) {
      this._nativePannerNode.coneInnerAngle = value;
    }
    get coneOuterAngle() {
      return this._nativePannerNode.coneOuterAngle;
    }
    set coneOuterAngle(value) {
      this._nativePannerNode.coneOuterAngle = value;
    }
    get coneOuterGain() {
      return this._nativePannerNode.coneOuterGain;
    }
    set coneOuterGain(value) {
      this._nativePannerNode.coneOuterGain = value;
    }
    get distanceModel() {
      return this._nativePannerNode.distanceModel;
    }
    set distanceModel(value) {
      this._nativePannerNode.distanceModel = value;
    }
    get maxDistance() {
      return this._nativePannerNode.maxDistance;
    }
    set maxDistance(value) {
      this._nativePannerNode.maxDistance = value;
    }
    get orientationX() {
      return this._orientationX;
    }
    get orientationY() {
      return this._orientationY;
    }
    get orientationZ() {
      return this._orientationZ;
    }
    get panningModel() {
      return this._nativePannerNode.panningModel;
    }
    set panningModel(value) {
      this._nativePannerNode.panningModel = value;
    }
    get positionX() {
      return this._positionX;
    }
    get positionY() {
      return this._positionY;
    }
    get positionZ() {
      return this._positionZ;
    }
    get refDistance() {
      return this._nativePannerNode.refDistance;
    }
    set refDistance(value) {
      this._nativePannerNode.refDistance = value;
    }
    get rolloffFactor() {
      return this._nativePannerNode.rolloffFactor;
    }
    set rolloffFactor(value) {
      this._nativePannerNode.rolloffFactor = value;
    }
  };
};
const createPannerNodeRendererFactory = (connectAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativePannerNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
  return () => {
    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
    let renderedBufferPromise = null;
    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeGainNode = null;
      let nativePannerNode = getNativeAudioNode2(proxy);
      const commonAudioNodeOptions = {
        channelCount: nativePannerNode.channelCount,
        channelCountMode: nativePannerNode.channelCountMode,
        channelInterpretation: nativePannerNode.channelInterpretation
      };
      const commonNativePannerNodeOptions = {
        ...commonAudioNodeOptions,
        coneInnerAngle: nativePannerNode.coneInnerAngle,
        coneOuterAngle: nativePannerNode.coneOuterAngle,
        coneOuterGain: nativePannerNode.coneOuterGain,
        distanceModel: nativePannerNode.distanceModel,
        maxDistance: nativePannerNode.maxDistance,
        panningModel: nativePannerNode.panningModel,
        refDistance: nativePannerNode.refDistance,
        rolloffFactor: nativePannerNode.rolloffFactor
      };
      const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);
      if ("bufferSize" in nativePannerNode) {
        nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
      } else if (!nativePannerNodeIsOwnedByContext) {
        const options2 = {
          ...commonNativePannerNodeOptions,
          orientationX: nativePannerNode.orientationX.value,
          orientationY: nativePannerNode.orientationY.value,
          orientationZ: nativePannerNode.orientationZ.value,
          positionX: nativePannerNode.positionX.value,
          positionY: nativePannerNode.positionY.value,
          positionZ: nativePannerNode.positionZ.value
        };
        nativePannerNode = createNativePannerNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);
      if (nativeGainNode !== null) {
        if (renderedBufferPromise === null) {
          if (nativeOfflineAudioContextConstructor2 === null) {
            throw new Error("Missing the native OfflineAudioContext constructor.");
          }
          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(
            6,
            // Bug #17: Safari does not yet expose the length.
            proxy.context.length,
            nativeOfflineAudioContext.sampleRate
          );
          const nativeChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: 6
          });
          nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);
          renderedBufferPromise = (async () => {
            const nativeConstantSourceNodes = await Promise.all([
              proxy.orientationX,
              proxy.orientationY,
              proxy.orientationZ,
              proxy.positionX,
              proxy.positionY,
              proxy.positionZ
            ].map(async (audioParam, index) => {
              const nativeConstantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                offset: index === 0 ? 1 : 0
              });
              await renderAutomation2(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);
              return nativeConstantSourceNode;
            }));
            for (let i = 0; i < 6; i += 1) {
              nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);
              nativeConstantSourceNodes[i].start(0);
            }
            return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
          })();
        }
        const renderedBuffer = await renderedBufferPromise;
        const inputGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, inputGainNode);
        const channelDatas = [];
        for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {
          channelDatas.push(renderedBuffer.getChannelData(i));
        }
        let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];
        let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];
        let gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
        let partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, {
          ...commonNativePannerNodeOptions,
          orientationX: lastOrientation[0],
          orientationY: lastOrientation[1],
          orientationZ: lastOrientation[2],
          positionX: lastPosition[0],
          positionY: lastPosition[1],
          positionZ: lastPosition[2]
        });
        inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
        partialPannerNode.connect(nativeGainNode);
        for (let i = 128; i < renderedBuffer.length; i += 128) {
          const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];
          const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];
          if (orientation.some((value, index) => value !== lastOrientation[index]) || positon.some((value, index) => value !== lastPosition[index])) {
            lastOrientation = orientation;
            lastPosition = positon;
            const currentTime = i / nativeOfflineAudioContext.sampleRate;
            gateGainNode.gain.setValueAtTime(0, currentTime);
            gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });
            partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, {
              ...commonNativePannerNodeOptions,
              orientationX: lastOrientation[0],
              orientationY: lastOrientation[1],
              orientationZ: lastOrientation[2],
              positionX: lastPosition[0],
              positionY: lastPosition[1],
              positionZ: lastPosition[2]
            });
            gateGainNode.gain.setValueAtTime(1, currentTime);
            inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
            partialPannerNode.connect(nativeGainNode);
          }
        }
        return nativeGainNode;
      }
      if (!nativePannerNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
        await renderAutomation2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
        await renderAutomation2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
        await renderAutomation2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
        await renderAutomation2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
        await renderAutomation2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
        await connectAudioParam2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
      }
      if (isNativeAudioNodeFaker(nativePannerNode)) {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode);
      }
      return nativePannerNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
        if (renderedNativeGainNodeOrNativePannerNode !== void 0) {
          return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);
        }
        return createAudioNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const DEFAULT_OPTIONS$2 = {
  disableNormalization: false
};
const createPeriodicWaveConstructor = (createNativePeriodicWave2, getNativeContext2, periodicWaveStore, sanitizePeriodicWaveOptions2) => {
  return class PeriodicWave {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = sanitizePeriodicWaveOptions2({ ...DEFAULT_OPTIONS$2, ...options2 });
      const periodicWave = createNativePeriodicWave2(nativeContext, mergedOptions);
      periodicWaveStore.add(periodicWave);
      return periodicWave;
    }
    static [Symbol.hasInstance](instance) {
      return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);
    }
  };
};
const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam2) => {
  return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
    const audioParamRenderer = getAudioParamRenderer(audioParam);
    audioParamRenderer.replay(nativeAudioParam);
    return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
  };
};
const createRenderInputsOfAudioNode = (getAudioNodeConnections2, getAudioNodeRenderer2, isPartOfACycle2) => {
  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {
    const audioNodeConnections = getAudioNodeConnections2(audioNode);
    await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).map(async ([source, output2]) => {
      const audioNodeRenderer = getAudioNodeRenderer2(source);
      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
      const destination = audioNode.context.destination;
      if (!isPartOfACycle2(source) && (audioNode !== destination || !isPartOfACycle2(audioNode))) {
        renderedNativeAudioNode.connect(nativeAudioNode, output2, input);
      }
    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));
  };
};
const createRenderInputsOfAudioParam = (getAudioNodeRenderer2, getAudioParamConnections2, isPartOfACycle2) => {
  return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {
    const audioParamConnections = getAudioParamConnections2(audioParam);
    await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output2]) => {
      const audioNodeRenderer = getAudioNodeRenderer2(source);
      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
      if (!isPartOfACycle2(source)) {
        renderedNativeAudioNode.connect(nativeAudioParam, output2);
      }
    }));
  };
};
const createRenderNativeOfflineAudioContext = (cacheTestResult2, createNativeGainNode2, createNativeScriptProcessorNode2, testOfflineAudioContextCurrentTimeSupport) => {
  return (nativeOfflineAudioContext) => {
    if (cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
      return Promise.resolve(cacheTestResult2(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {
        if (!isOfflineAudioContextCurrentTimeSupported) {
          const scriptProcessorNode = createNativeScriptProcessorNode2(nativeOfflineAudioContext, 512, 0, 1);
          nativeOfflineAudioContext.oncomplete = () => {
            scriptProcessorNode.onaudioprocess = null;
            scriptProcessorNode.disconnect();
          };
          scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime;
          scriptProcessorNode.connect(nativeOfflineAudioContext.destination);
        }
        return nativeOfflineAudioContext.startRendering();
      });
    }
    return new Promise((resolve) => {
      const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        gain: 0
      });
      nativeOfflineAudioContext.oncomplete = (event) => {
        gainNode.disconnect();
        resolve(event.renderedBuffer);
      };
      gainNode.connect(nativeOfflineAudioContext.destination);
      nativeOfflineAudioContext.startRendering();
    });
  };
};
const createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2) => {
  return (nativeAudioWorkletNode, activeInputs) => {
    activeAudioWorkletNodeInputsStore2.set(nativeAudioWorkletNode, activeInputs);
  };
};
const createSetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
  return (audioNode, tailTime) => audioNodeTailTimeStore2.set(audioNode, tailTime);
};
const createStartRendering = (audioBufferStore2, cacheTestResult2, getAudioNodeRenderer2, getUnrenderedAudioWorkletNodes2, renderNativeOfflineAudioContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
  return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer2(destination).render(destination, nativeOfflineAudioContext).then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes2(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer2(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)))).then(() => renderNativeOfflineAudioContext2(nativeOfflineAudioContext)).then((audioBuffer) => {
    if (typeof audioBuffer.copyFromChannel !== "function") {
      wrapAudioBufferCopyChannelMethods2(audioBuffer);
      wrapAudioBufferGetChannelDataMethod(audioBuffer);
    } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
      wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
    }
    audioBufferStore2.add(audioBuffer);
    return audioBuffer;
  });
};
const DEFAULT_OPTIONS$1 = {
  channelCount: 2,
  /*
   * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent
   * behavior.
   */
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  pan: 0
};
const createStereoPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeStereoPannerNode2, createStereoPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2) => {
  return class StereoPannerNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS$1, ...options2 };
      const nativeStereoPannerNode = createNativeStereoPannerNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer2() : null;
      super(context2, false, nativeStereoPannerNode, stereoPannerNodeRenderer);
      this._pan = createAudioParam2(this, isOffline, nativeStereoPannerNode.pan);
    }
    get pan() {
      return this._pan;
    }
  };
};
const createStereoPannerNodeRendererFactory = (connectAudioParam2, createNativeStereoPannerNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeStereoPannerNodes = /* @__PURE__ */ new WeakMap();
    const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeStereoPannerNode = getNativeAudioNode2(proxy);
      const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);
      if (!nativeStereoPannerNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeStereoPannerNode.channelCount,
          channelCountMode: nativeStereoPannerNode.channelCountMode,
          channelInterpretation: nativeStereoPannerNode.channelInterpretation,
          pan: nativeStereoPannerNode.pan.value
        };
        nativeStereoPannerNode = createNativeStereoPannerNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);
      if (!nativeStereoPannerNodeIsOwnedByContext) {
        await renderAutomation2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
      } else {
        await connectAudioParam2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
      }
      if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);
      }
      return nativeStereoPannerNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);
        if (renderedNativeStereoPannerNode !== void 0) {
          return Promise.resolve(renderedNativeStereoPannerNode);
        }
        return createStereoPannerNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor2) => {
  return () => {
    if (nativeAudioBufferConstructor2 === null) {
      return false;
    }
    try {
      new nativeAudioBufferConstructor2({ length: 1, sampleRate: 44100 });
    } catch {
      return false;
    }
    return true;
  };
};
const createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2) => {
  return async () => {
    if (nativeAudioWorkletNodeConstructor2 === null) {
      return true;
    }
    if (nativeOfflineAudioContextConstructor2 === null) {
      return false;
    }
    const blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
      type: "application/javascript; charset=utf-8"
    });
    const offlineAudioContext = new nativeOfflineAudioContextConstructor2(1, 128, 44100);
    const url = URL.createObjectURL(blob);
    let isEmittingMessageEvents = false;
    let isEmittingProcessorErrorEvents = false;
    try {
      await offlineAudioContext.audioWorklet.addModule(url);
      const audioWorkletNode = new nativeAudioWorkletNodeConstructor2(offlineAudioContext, "a", { numberOfOutputs: 0 });
      const oscillator = offlineAudioContext.createOscillator();
      audioWorkletNode.port.onmessage = () => isEmittingMessageEvents = true;
      audioWorkletNode.onprocessorerror = () => isEmittingProcessorErrorEvents = true;
      oscillator.connect(audioWorkletNode);
      oscillator.start(0);
      await offlineAudioContext.startRendering();
      await new Promise((resolve) => setTimeout(resolve));
    } catch {
    } finally {
      URL.revokeObjectURL(url);
    }
    return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;
  };
};
const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode2, nativeOfflineAudioContextConstructor2) => {
  return () => {
    if (nativeOfflineAudioContextConstructor2 === null) {
      return Promise.resolve(false);
    }
    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
    const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: 0
    });
    return new Promise((resolve) => {
      nativeOfflineAudioContext.oncomplete = () => {
        gainNode.disconnect();
        resolve(nativeOfflineAudioContext.currentTime !== 0);
      };
      nativeOfflineAudioContext.startRendering();
    });
  };
};
const createUnknownError = () => new DOMException("", "UnknownError");
const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  curve: null,
  oversample: "none"
};
const createWaveShaperNodeConstructor = (audioNodeConstructor2, createInvalidStateError2, createNativeWaveShaperNode2, createWaveShaperNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
  return class WaveShaperNode extends audioNodeConstructor2 {
    constructor(context2, options2) {
      const nativeContext = getNativeContext2(context2);
      const mergedOptions = { ...DEFAULT_OPTIONS, ...options2 };
      const nativeWaveShaperNode = createNativeWaveShaperNode2(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext2(nativeContext);
      const waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer2() : null;
      super(context2, true, nativeWaveShaperNode, waveShaperNodeRenderer);
      this._isCurveNullified = false;
      this._nativeWaveShaperNode = nativeWaveShaperNode;
      setAudioNodeTailTime2(this, 1);
    }
    get curve() {
      if (this._isCurveNullified) {
        return null;
      }
      return this._nativeWaveShaperNode.curve;
    }
    set curve(value) {
      if (value === null) {
        this._isCurveNullified = true;
        this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
      } else {
        if (value.length < 2) {
          throw createInvalidStateError2();
        }
        this._isCurveNullified = false;
        this._nativeWaveShaperNode.curve = value;
      }
    }
    get oversample() {
      return this._nativeWaveShaperNode.oversample;
    }
    set oversample(value) {
      this._nativeWaveShaperNode.oversample = value;
    }
  };
};
const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
  return () => {
    const renderedNativeWaveShaperNodes = /* @__PURE__ */ new WeakMap();
    const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeWaveShaperNode = getNativeAudioNode2(proxy);
      const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);
      if (!nativeWaveShaperNodeIsOwnedByContext) {
        const options2 = {
          channelCount: nativeWaveShaperNode.channelCount,
          channelCountMode: nativeWaveShaperNode.channelCountMode,
          channelInterpretation: nativeWaveShaperNode.channelInterpretation,
          curve: nativeWaveShaperNode.curve,
          oversample: nativeWaveShaperNode.oversample
        };
        nativeWaveShaperNode = createNativeWaveShaperNode2(nativeOfflineAudioContext, options2);
      }
      renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);
      if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);
      }
      return nativeWaveShaperNode;
    };
    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);
        if (renderedNativeWaveShaperNode !== void 0) {
          return Promise.resolve(renderedNativeWaveShaperNode);
        }
        return createWaveShaperNode(proxy, nativeOfflineAudioContext);
      }
    };
  };
};
const createWindow = () => typeof window === "undefined" ? null : window;
const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong2, createIndexSizeError2) => {
  return (audioBuffer) => {
    audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
      const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
      const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
      if (channelNumber >= audioBuffer.numberOfChannels) {
        throw createIndexSizeError2();
      }
      const audioBufferLength = audioBuffer.length;
      const channelData = audioBuffer.getChannelData(channelNumber);
      const destinationLength = destination.length;
      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {
        destination[i] = channelData[i + bufferOffset];
      }
    };
    audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
      const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
      const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
      if (channelNumber >= audioBuffer.numberOfChannels) {
        throw createIndexSizeError2();
      }
      const audioBufferLength = audioBuffer.length;
      const channelData = audioBuffer.getChannelData(channelNumber);
      const sourceLength = source.length;
      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {
        channelData[i + bufferOffset] = source[i];
      }
    };
  };
};
const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong2) => {
  return (audioBuffer) => {
    audioBuffer.copyFromChannel = /* @__PURE__ */ ((copyFromChannel2) => {
      return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
        if (bufferOffset < audioBuffer.length) {
          return copyFromChannel2.call(audioBuffer, destination, channelNumber, bufferOffset);
        }
      };
    })(audioBuffer.copyFromChannel);
    audioBuffer.copyToChannel = /* @__PURE__ */ ((copyToChannel2) => {
      return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
        if (bufferOffset < audioBuffer.length) {
          return copyToChannel2.call(audioBuffer, source, channelNumber, bufferOffset);
        }
      };
    })(audioBuffer.copyToChannel);
  };
};
const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors2) => {
  return (nativeAudioBufferSourceNode, nativeContext) => {
    const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);
    if (nativeAudioBufferSourceNode.buffer === null) {
      nativeAudioBufferSourceNode.buffer = nullifiedBuffer;
    }
    overwriteAccessors2(nativeAudioBufferSourceNode, "buffer", (get2) => () => {
      const value = get2.call(nativeAudioBufferSourceNode);
      return value === nullifiedBuffer ? null : value;
    }, (set2) => (value) => {
      return set2.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);
    });
  };
};
const createWrapChannelMergerNode = (createInvalidStateError2, monitorConnections2) => {
  return (nativeContext, channelMergerNode) => {
    channelMergerNode.channelCount = 1;
    channelMergerNode.channelCountMode = "explicit";
    Object.defineProperty(channelMergerNode, "channelCount", {
      get: () => 1,
      set: () => {
        throw createInvalidStateError2();
      }
    });
    Object.defineProperty(channelMergerNode, "channelCountMode", {
      get: () => "explicit",
      set: () => {
        throw createInvalidStateError2();
      }
    });
    const audioBufferSourceNode = nativeContext.createBufferSource();
    const whenConnected = () => {
      const length = channelMergerNode.numberOfInputs;
      for (let i = 0; i < length; i += 1) {
        audioBufferSourceNode.connect(channelMergerNode, 0, i);
      }
    };
    const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);
    monitorConnections2(channelMergerNode, whenConnected, whenDisconnected);
  };
};
const getFirstSample = (audioBuffer, buffer, channelNumber) => {
  if (audioBuffer.copyFromChannel === void 0) {
    return audioBuffer.getChannelData(channelNumber)[0];
  }
  audioBuffer.copyFromChannel(buffer, channelNumber);
  return buffer[0];
};
const isDCCurve = (curve) => {
  if (curve === null) {
    return false;
  }
  const length = curve.length;
  if (length % 2 !== 0) {
    return curve[Math.floor(length / 2)] !== 0;
  }
  return curve[length / 2 - 1] + curve[length / 2] !== 0;
};
const overwriteAccessors = (object2, property, createGetter, createSetter) => {
  let prototype = object2;
  while (!prototype.hasOwnProperty(property)) {
    prototype = Object.getPrototypeOf(prototype);
  }
  const { get: get2, set: set2 } = Object.getOwnPropertyDescriptor(prototype, property);
  Object.defineProperty(object2, property, { get: createGetter(get2), set: createSetter(set2) });
};
const sanitizeAudioWorkletNodeOptions = (options2) => {
  return {
    ...options2,
    outputChannelCount: options2.outputChannelCount !== void 0 ? options2.outputChannelCount : options2.numberOfInputs === 1 && options2.numberOfOutputs === 1 ? (
      /*
       * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why
       * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That
       * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.
       */
      [options2.channelCount]
    ) : Array.from({ length: options2.numberOfOutputs }, () => 1)
  };
};
const sanitizeChannelSplitterOptions = (options2) => {
  return { ...options2, channelCount: options2.numberOfOutputs };
};
const sanitizePeriodicWaveOptions = (options2) => {
  const { imag, real } = options2;
  if (imag === void 0) {
    if (real === void 0) {
      return { ...options2, imag: [0, 0], real: [0, 0] };
    }
    return { ...options2, imag: Array.from(real, () => 0), real };
  }
  if (real === void 0) {
    return { ...options2, imag, real: Array.from(imag, () => 0) };
  }
  return { ...options2, imag, real };
};
const setValueAtTimeUntilPossible = (audioParam, value, startTime) => {
  try {
    audioParam.setValueAtTime(value, startTime);
  } catch (err) {
    if (err.code !== 9) {
      throw err;
    }
    setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);
  }
};
const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.start();
  try {
    nativeAudioBufferSourceNode.start();
  } catch {
    return true;
  }
  return false;
};
const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
  nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
  try {
    nativeAudioBufferSourceNode.start(0, 1);
  } catch {
    return false;
  }
  return true;
};
const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.start();
  try {
    nativeAudioBufferSourceNode.stop();
  } catch {
    return false;
  }
  return true;
};
const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createOscillator();
  try {
    nativeAudioBufferSourceNode.start(-1);
  } catch (err) {
    return err instanceof RangeError;
  }
  return false;
};
const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {
  const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
  nativeAudioBufferSourceNode.start();
  nativeAudioBufferSourceNode.stop();
  try {
    nativeAudioBufferSourceNode.stop();
    return true;
  } catch {
    return false;
  }
};
const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {
  const nativeAudioBufferSourceNode = nativeContext.createOscillator();
  try {
    nativeAudioBufferSourceNode.stop(-1);
  } catch (err) {
    return err instanceof RangeError;
  }
  return false;
};
const testAudioWorkletNodeOptionsClonability = (audioWorkletNodeOptions) => {
  const { port1, port2 } = new MessageChannel();
  try {
    port1.postMessage(audioWorkletNodeOptions);
  } finally {
    port1.close();
    port2.close();
  }
};
const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {
  nativeAudioBufferSourceNode.start = /* @__PURE__ */ ((start2) => {
    return (when = 0, offset2 = 0, duration2) => {
      const buffer = nativeAudioBufferSourceNode.buffer;
      const clampedOffset = buffer === null ? offset2 : Math.min(buffer.duration, offset2);
      if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {
        start2.call(nativeAudioBufferSourceNode, when, 0, 0);
      } else {
        start2.call(nativeAudioBufferSourceNode, when, clampedOffset, duration2);
      }
    };
  })(nativeAudioBufferSourceNode.start);
};
const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {
  const nativeGainNode = nativeContext.createGain();
  nativeAudioScheduledSourceNode.connect(nativeGainNode);
  const disconnectGainNode = /* @__PURE__ */ ((disconnect2) => {
    return () => {
      disconnect2.call(nativeAudioScheduledSourceNode, nativeGainNode);
      nativeAudioScheduledSourceNode.removeEventListener("ended", disconnectGainNode);
    };
  })(nativeAudioScheduledSourceNode.disconnect);
  nativeAudioScheduledSourceNode.addEventListener("ended", disconnectGainNode);
  interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);
  nativeAudioScheduledSourceNode.stop = /* @__PURE__ */ ((stop) => {
    let isStopped = false;
    return (when = 0) => {
      if (isStopped) {
        try {
          stop.call(nativeAudioScheduledSourceNode, when);
        } catch {
          nativeGainNode.gain.setValueAtTime(0, when);
        }
      } else {
        stop.call(nativeAudioScheduledSourceNode, when);
        isStopped = true;
      }
    };
  })(nativeAudioScheduledSourceNode.stop);
};
const wrapEventListener = (target, eventListener) => {
  return (event) => {
    const descriptor = { value: target };
    Object.defineProperties(event, {
      currentTarget: descriptor,
      target: descriptor
    });
    if (typeof eventListener === "function") {
      return eventListener.call(target, event);
    }
    return eventListener.handleEvent.call(target, event);
  };
};
const addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);
const addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);
const deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);
const audioNodeTailTimeStore = /* @__PURE__ */ new WeakMap();
const getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);
const cacheTestResult = createCacheTestResult(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap());
const window$1 = createWindow();
const createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);
const getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);
const renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);
const createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);
const getNativeContext = createGetNativeContext(CONTEXT_STORE);
const nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window$1);
const isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);
const audioParamAudioNodeStore = /* @__PURE__ */ new WeakMap();
const eventTargetConstructor = createEventTargetConstructor(wrapEventListener);
const nativeAudioContextConstructor = createNativeAudioContextConstructor(window$1);
const isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);
const isNativeAudioNode = createIsNativeAudioNode(window$1);
const isNativeAudioParam = createIsNativeAudioParam(window$1);
const nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window$1);
const audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);
const analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);
const audioBufferStore = /* @__PURE__ */ new WeakSet();
const nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window$1);
const convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));
const wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);
const wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);
const audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
const addSilentConnection = createAddSilentConnection(createNativeGainNode);
const renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);
const connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);
const createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
const renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);
const createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);
const audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
const audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);
const createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);
const biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
const monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);
const wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);
const createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);
const createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);
const channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);
const createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);
const channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);
const createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);
const createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);
const createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
const createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);
const createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);
const convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
const createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
const createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);
const createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
const createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);
const createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);
const renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));
const createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
const createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);
const iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
const createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);
const unrenderedAudioWorkletNodeStore = /* @__PURE__ */ new WeakMap();
const minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);
const createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
const createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
const createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);
const createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);
const createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);
const createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);
const createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);
const createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
const pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
const createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);
const periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, /* @__PURE__ */ new WeakSet(), sanitizePeriodicWaveOptions);
const nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);
const createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);
const createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);
const createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);
const waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
const isSecureContext = createIsSecureContext(window$1);
const exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window$1);
const backupOfflineAudioContextStore = /* @__PURE__ */ new WeakMap();
const getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);
const addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(
  cacheTestResult,
  createNotSupportedError,
  createEvaluateSource(window$1),
  exposeCurrentFrameAndCurrentTime,
  createFetchSource(createAbortError),
  getNativeContext,
  getOrCreateBackupOfflineAudioContext,
  isNativeOfflineAudioContext,
  nativeAudioWorkletNodeConstructor,
  /* @__PURE__ */ new WeakMap(),
  /* @__PURE__ */ new WeakMap(),
  createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),
  // @todo window is guaranteed to be defined because isSecureContext checks that as well.
  window$1
) : void 0;
const isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);
const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, /* @__PURE__ */ new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
const baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);
const mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
const mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);
const mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
const createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);
const mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);
const audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);
const getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);
const addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
const connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);
const deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
const disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);
const activeAudioWorkletNodeInputsStore = /* @__PURE__ */ new WeakMap();
const getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);
const createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);
const createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);
const createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
const getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);
const setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);
const audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) : void 0;
const createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);
const startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
const offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);
const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);
const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);
const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);
const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);
function isUndef(arg) {
  return arg === void 0;
}
function isDefined(arg) {
  return arg !== void 0;
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isObject(arg) {
  return Object.prototype.toString.call(arg) === "[object Object]" && arg.constructor === Object;
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isArray(arg) {
  return Array.isArray(arg);
}
function isString(arg) {
  return typeof arg === "string";
}
function isNote(arg) {
  return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
}
function assert(statement, error2) {
  if (!statement) {
    throw new Error(error2);
  }
}
function assertRange(value, gte, lte = Infinity) {
  if (!(gte <= value && value <= lte)) {
    throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);
  }
}
function assertContextRunning(context2) {
  if (!context2.isOffline && context2.state !== "running") {
    warn3('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
  }
}
let isInsideScheduledCallback = false;
let printedScheduledWarning = false;
function enterScheduledCallback(insideCallback) {
  isInsideScheduledCallback = insideCallback;
}
function assertUsedScheduleTime(time2) {
  if (isUndef(time2) && isInsideScheduledCallback && !printedScheduledWarning) {
    printedScheduledWarning = true;
    warn3("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing");
  }
}
let defaultLogger = console;
function log2(...args) {
  defaultLogger.log(...args);
}
function warn3(...args) {
  defaultLogger.warn(...args);
}
function createAudioContext(options2) {
  return new audioContextConstructor(options2);
}
function createOfflineAudioContext(channels, length, sampleRate) {
  return new offlineAudioContextConstructor(channels, length, sampleRate);
}
const theWindow = typeof self === "object" ? self : null;
const hasAudioContext = theWindow && (theWindow.hasOwnProperty("AudioContext") || theWindow.hasOwnProperty("webkitAudioContext"));
function createAudioWorkletNode(context2, name, options2) {
  assert(isDefined(audioWorkletNodeConstructor), "AudioWorkletNode only works in a secure context (https or localhost)");
  return new (context2 instanceof (theWindow === null || theWindow === void 0 ? void 0 : theWindow.BaseAudioContext) ? theWindow === null || theWindow === void 0 ? void 0 : theWindow.AudioWorkletNode : audioWorkletNodeConstructor)(context2, name, options2);
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
class Ticker {
  constructor(callback, type2, updateInterval, contextSampleRate) {
    this._callback = callback;
    this._type = type2;
    this._minimumUpdateInterval = Math.max(128 / (contextSampleRate || 44100), 1e-3);
    this.updateInterval = updateInterval;
    this._createClock();
  }
  /**
   * Generate a web worker
   */
  _createWorker() {
    const blob = new Blob([
      /* javascript */
      `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
    ], { type: "text/javascript" });
    const blobUrl = URL.createObjectURL(blob);
    const worker = new Worker(blobUrl);
    worker.onmessage = this._callback.bind(this);
    this._worker = worker;
  }
  /**
   * Create a timeout loop
   */
  _createTimeout() {
    this._timeout = setTimeout(() => {
      this._createTimeout();
      this._callback();
    }, this._updateInterval * 1e3);
  }
  /**
   * Create the clock source.
   */
  _createClock() {
    if (this._type === "worker") {
      try {
        this._createWorker();
      } catch (e2) {
        this._type = "timeout";
        this._createClock();
      }
    } else if (this._type === "timeout") {
      this._createTimeout();
    }
  }
  /**
   * Clean up the current clock source
   */
  _disposeClock() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._worker) {
      this._worker.terminate();
      this._worker.onmessage = null;
    }
  }
  /**
   * The rate in seconds the ticker will update
   */
  get updateInterval() {
    return this._updateInterval;
  }
  set updateInterval(interval) {
    var _a;
    this._updateInterval = Math.max(interval, this._minimumUpdateInterval);
    if (this._type === "worker") {
      (_a = this._worker) === null || _a === void 0 ? void 0 : _a.postMessage(this._updateInterval * 1e3);
    }
  }
  /**
   * The type of the ticker, either a worker or a timeout
   */
  get type() {
    return this._type;
  }
  set type(type2) {
    this._disposeClock();
    this._type = type2;
    this._createClock();
  }
  /**
   * Clean up
   */
  dispose() {
    this._disposeClock();
  }
}
function isAudioParam(arg) {
  return isAnyAudioParam(arg);
}
function isAudioNode(arg) {
  return isAnyAudioNode(arg);
}
function isOfflineAudioContext(arg) {
  return isAnyOfflineAudioContext(arg);
}
function isAudioContext(arg) {
  return isAnyAudioContext(arg);
}
function isAudioBuffer(arg) {
  return arg instanceof audioBufferConstructor;
}
function noCopy(key, arg) {
  return key === "value" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);
}
function deepMerge(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (noCopy(key, source[key])) {
        target[key] = source[key];
      } else if (isObject(source[key])) {
        if (!target[key]) {
          Object.assign(target, { [key]: {} });
        }
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return deepMerge(target, ...sources);
}
function deepEquals(arrayA, arrayB) {
  return arrayA.length === arrayB.length && arrayA.every((element2, index) => arrayB[index] === element2);
}
function optionsFromArguments(defaults2, argsArray, keys = [], objKey) {
  const opts = {};
  const args = Array.from(argsArray);
  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {
    const partOfDefaults = Object.keys(args[0]).some((key) => Reflect.has(defaults2, key));
    if (!partOfDefaults) {
      deepMerge(opts, { [objKey]: args[0] });
      keys.splice(keys.indexOf(objKey), 1);
      args.shift();
    }
  }
  if (args.length === 1 && isObject(args[0])) {
    deepMerge(opts, args[0]);
  } else {
    for (let i = 0; i < keys.length; i++) {
      if (isDefined(args[i])) {
        opts[keys[i]] = args[i];
      }
    }
  }
  return deepMerge(defaults2, opts);
}
function getDefaultsFromInstance(instance) {
  return instance.constructor.getDefaults();
}
function defaultArg(given, fallback) {
  if (isUndef(given)) {
    return fallback;
  } else {
    return given;
  }
}
function omitFromObject(obj, omit2) {
  omit2.forEach((prop) => {
    if (Reflect.has(obj, prop)) {
      delete obj[prop];
    }
  });
  return obj;
}
class Tone {
  constructor() {
    this.debug = false;
    this._wasDisposed = false;
  }
  /**
   * Returns all of the default options belonging to the class.
   */
  static getDefaults() {
    return {};
  }
  /**
   * Prints the outputs to the console log for debugging purposes.
   * Prints the contents only if either the object has a property
   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
   * is set to the name of the class.
   * @example
   * const osc = new Tone.Oscillator();
   * // prints all logs originating from this oscillator
   * osc.debug = true;
   * // calls to start/stop will print in the console
   * osc.start();
   */
  log(...args) {
    if (this.debug || theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS) {
      log2(this, ...args);
    }
  }
  /**
   * disconnect and dispose.
   */
  dispose() {
    this._wasDisposed = true;
    return this;
  }
  /**
   * Indicates if the instance was disposed. 'Disposing' an
   * instance means that all of the Web Audio nodes that were
   * created for the instance are disconnected and freed for garbage collection.
   */
  get disposed() {
    return this._wasDisposed;
  }
  /**
   * Convert the class to a string
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.toString());
   */
  toString() {
    return this.name;
  }
}
Tone.version = version;
const EPSILON = 1e-6;
function GT(a, b2) {
  return a > b2 + EPSILON;
}
function GTE(a, b2) {
  return GT(a, b2) || EQ(a, b2);
}
function LT(a, b2) {
  return a + EPSILON < b2;
}
function EQ(a, b2) {
  return Math.abs(a - b2) < EPSILON;
}
function clamp(value, min, max) {
  return Math.max(Math.min(value, max), min);
}
class Timeline extends Tone {
  constructor() {
    super();
    this.name = "Timeline";
    this._timeline = [];
    const options2 = optionsFromArguments(Timeline.getDefaults(), arguments, ["memory"]);
    this.memory = options2.memory;
    this.increasing = options2.increasing;
  }
  static getDefaults() {
    return {
      memory: Infinity,
      increasing: false
    };
  }
  /**
   * The number of items in the timeline.
   */
  get length() {
    return this._timeline.length;
  }
  /**
   * Insert an event object onto the timeline. Events must have a "time" attribute.
   * @param event  The event object to insert into the timeline.
   */
  add(event) {
    assert(Reflect.has(event, "time"), "Timeline: events must have a time attribute");
    event.time = event.time.valueOf();
    if (this.increasing && this.length) {
      const lastValue = this._timeline[this.length - 1];
      assert(GTE(event.time, lastValue.time), "The time must be greater than or equal to the last scheduled time");
      this._timeline.push(event);
    } else {
      const index = this._search(event.time);
      this._timeline.splice(index + 1, 0, event);
    }
    if (this.length > this.memory) {
      const diff = this.length - this.memory;
      this._timeline.splice(0, diff);
    }
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  {Object}  event  The event object to remove from the list.
   * @returns {Timeline} this
   */
  remove(event) {
    const index = this._timeline.indexOf(event);
    if (index !== -1) {
      this._timeline.splice(index, 1);
    }
    return this;
  }
  /**
   * Get the nearest event whose time is less than or equal to the given time.
   * @param  time  The time to query.
   */
  get(time2, param = "time") {
    const index = this._search(time2, param);
    if (index !== -1) {
      return this._timeline[index];
    } else {
      return null;
    }
  }
  /**
   * Return the first event in the timeline without removing it
   * @returns {Object} The first event object
   * @deprecated
   */
  peek() {
    return this._timeline[0];
  }
  /**
   * Return the first event in the timeline and remove it
   * @deprecated
   */
  shift() {
    return this._timeline.shift();
  }
  /**
   * Get the event which is scheduled after the given time.
   * @param  time  The time to query.
   */
  getAfter(time2, param = "time") {
    const index = this._search(time2, param);
    if (index + 1 < this._timeline.length) {
      return this._timeline[index + 1];
    } else {
      return null;
    }
  }
  /**
   * Get the event before the event at the given time.
   * @param  time  The time to query.
   */
  getBefore(time2) {
    const len = this._timeline.length;
    if (len > 0 && this._timeline[len - 1].time < time2) {
      return this._timeline[len - 1];
    }
    const index = this._search(time2);
    if (index - 1 >= 0) {
      return this._timeline[index - 1];
    } else {
      return null;
    }
  }
  /**
   * Cancel events at and after the given time
   * @param  after  The time to query.
   */
  cancel(after) {
    if (this._timeline.length > 1) {
      let index = this._search(after);
      if (index >= 0) {
        if (EQ(this._timeline[index].time, after)) {
          for (let i = index; i >= 0; i--) {
            if (EQ(this._timeline[i].time, after)) {
              index = i;
            } else {
              break;
            }
          }
          this._timeline = this._timeline.slice(0, index);
        } else {
          this._timeline = this._timeline.slice(0, index + 1);
        }
      } else {
        this._timeline = [];
      }
    } else if (this._timeline.length === 1) {
      if (GTE(this._timeline[0].time, after)) {
        this._timeline = [];
      }
    }
    return this;
  }
  /**
   * Cancel events before or equal to the given time.
   * @param  time  The time to cancel before.
   */
  cancelBefore(time2) {
    const index = this._search(time2);
    if (index >= 0) {
      this._timeline = this._timeline.slice(index + 1);
    }
    return this;
  }
  /**
   * Returns the previous event if there is one. null otherwise
   * @param  event The event to find the previous one of
   * @return The event right before the given event
   */
  previousEvent(event) {
    const index = this._timeline.indexOf(event);
    if (index > 0) {
      return this._timeline[index - 1];
    } else {
      return null;
    }
  }
  /**
   * Does a binary search on the timeline array and returns the
   * nearest event index whose time is after or equal to the given time.
   * If a time is searched before the first index in the timeline, -1 is returned.
   * If the time is after the end, the index of the last item is returned.
   */
  _search(time2, param = "time") {
    if (this._timeline.length === 0) {
      return -1;
    }
    let beginning = 0;
    const len = this._timeline.length;
    let end = len;
    if (len > 0 && this._timeline[len - 1][param] <= time2) {
      return len - 1;
    }
    while (beginning < end) {
      let midPoint = Math.floor(beginning + (end - beginning) / 2);
      const event = this._timeline[midPoint];
      const nextEvent = this._timeline[midPoint + 1];
      if (EQ(event[param], time2)) {
        for (let i = midPoint; i < this._timeline.length; i++) {
          const testEvent = this._timeline[i];
          if (EQ(testEvent[param], time2)) {
            midPoint = i;
          } else {
            break;
          }
        }
        return midPoint;
      } else if (LT(event[param], time2) && GT(nextEvent[param], time2)) {
        return midPoint;
      } else if (GT(event[param], time2)) {
        end = midPoint;
      } else {
        beginning = midPoint + 1;
      }
    }
    return -1;
  }
  /**
   * Internal iterator. Applies extra safety checks for
   * removing items from the array.
   */
  _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {
    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);
  }
  /**
   * Iterate over everything in the array
   * @param  callback The callback to invoke with every item
   */
  forEach(callback) {
    this._iterate(callback);
    return this;
  }
  /**
   * Iterate over everything in the array at or before the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachBefore(time2, callback) {
    const upperBound = this._search(time2);
    if (upperBound !== -1) {
      this._iterate(callback, 0, upperBound);
    }
    return this;
  }
  /**
   * Iterate over everything in the array after the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAfter(time2, callback) {
    const lowerBound = this._search(time2);
    this._iterate(callback, lowerBound + 1);
    return this;
  }
  /**
   * Iterate over everything in the array between the startTime and endTime.
   * The timerange is inclusive of the startTime, but exclusive of the endTime.
   * range = [startTime, endTime).
   * @param  startTime The time to check if items are before
   * @param  endTime The end of the test interval.
   * @param  callback The callback to invoke with every item
   */
  forEachBetween(startTime, endTime, callback) {
    let lowerBound = this._search(startTime);
    let upperBound = this._search(endTime);
    if (lowerBound !== -1 && upperBound !== -1) {
      if (this._timeline[lowerBound].time !== startTime) {
        lowerBound += 1;
      }
      if (this._timeline[upperBound].time === endTime) {
        upperBound -= 1;
      }
      this._iterate(callback, lowerBound, upperBound);
    } else if (lowerBound === -1) {
      this._iterate(callback, 0, upperBound);
    }
    return this;
  }
  /**
   * Iterate over everything in the array at or after the given time. Similar to
   * forEachAfter, but includes the item(s) at the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(time2, callback) {
    let lowerBound = this._search(time2);
    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time2) {
      lowerBound--;
    }
    this._iterate(callback, lowerBound + 1);
    return this;
  }
  /**
   * Iterate over everything in the array at the given time
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(time2, callback) {
    const upperBound = this._search(time2);
    if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time2)) {
      let lowerBound = upperBound;
      for (let i = upperBound; i >= 0; i--) {
        if (EQ(this._timeline[i].time, time2)) {
          lowerBound = i;
        } else {
          break;
        }
      }
      this._iterate((event) => {
        callback(event);
      }, lowerBound, upperBound);
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._timeline = [];
    return this;
  }
}
const notifyNewContext = [];
function onContextInit(cb) {
  notifyNewContext.push(cb);
}
function initializeContext(ctx) {
  notifyNewContext.forEach((cb) => cb(ctx));
}
const notifyCloseContext = [];
function onContextClose(cb) {
  notifyCloseContext.push(cb);
}
function closeContext(ctx) {
  notifyCloseContext.forEach((cb) => cb(ctx));
}
class Emitter extends Tone {
  constructor() {
    super(...arguments);
    this.name = "Emitter";
  }
  /**
   * Bind a callback to a specific event.
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  on(event, callback) {
    const events2 = event.split(/\W+/);
    events2.forEach((eventName) => {
      if (isUndef(this._events)) {
        this._events = {};
      }
      if (!this._events.hasOwnProperty(eventName)) {
        this._events[eventName] = [];
      }
      this._events[eventName].push(callback);
    });
    return this;
  }
  /**
   * Bind a callback which is only invoked once
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  once(event, callback) {
    const boundCallback = (...args) => {
      callback(...args);
      this.off(event, boundCallback);
    };
    this.on(event, boundCallback);
    return this;
  }
  /**
   * Remove the event listener.
   * @param  event     The event to stop listening to.
   * @param  callback  The callback which was bound to the event with Emitter.on.
   *                   If no callback is given, all callbacks events are removed.
   */
  off(event, callback) {
    const events2 = event.split(/\W+/);
    events2.forEach((eventName) => {
      if (isUndef(this._events)) {
        this._events = {};
      }
      if (this._events.hasOwnProperty(eventName)) {
        if (isUndef(callback)) {
          this._events[eventName] = [];
        } else {
          const eventList = this._events[eventName];
          for (let i = eventList.length - 1; i >= 0; i--) {
            if (eventList[i] === callback) {
              eventList.splice(i, 1);
            }
          }
        }
      }
    });
    return this;
  }
  /**
   * Invoke all of the callbacks bound to the event
   * with any arguments passed in.
   * @param  event  The name of the event.
   * @param args The arguments to pass to the functions listening.
   */
  emit(event, ...args) {
    if (this._events) {
      if (this._events.hasOwnProperty(event)) {
        const eventList = this._events[event].slice(0);
        for (let i = 0, len = eventList.length; i < len; i++) {
          eventList[i].apply(this, args);
        }
      }
    }
    return this;
  }
  /**
   * Add Emitter functions (on/off/emit) to the object
   */
  static mixin(constr) {
    ["on", "once", "off", "emit"].forEach((name) => {
      const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);
      Object.defineProperty(constr.prototype, name, property);
    });
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._events = void 0;
    return this;
  }
}
class BaseContext extends Emitter {
  constructor() {
    super(...arguments);
    this.isOffline = false;
  }
  /*
   * This is a placeholder so that JSON.stringify does not throw an error
   * This matches what JSON.stringify(audioContext) returns on a native
   * audioContext instance.
   */
  toJSON() {
    return {};
  }
}
class Context extends BaseContext {
  constructor() {
    var _a, _b;
    super();
    this.name = "Context";
    this._constants = /* @__PURE__ */ new Map();
    this._timeouts = new Timeline();
    this._timeoutIds = 0;
    this._initialized = false;
    this._closeStarted = false;
    this.isOffline = false;
    this._workletPromise = null;
    const options2 = optionsFromArguments(Context.getDefaults(), arguments, [
      "context"
    ]);
    if (options2.context) {
      this._context = options2.context;
      this._latencyHint = ((_a = arguments[0]) === null || _a === void 0 ? void 0 : _a.latencyHint) || "";
    } else {
      this._context = createAudioContext({
        latencyHint: options2.latencyHint
      });
      this._latencyHint = options2.latencyHint;
    }
    this._ticker = new Ticker(this.emit.bind(this, "tick"), options2.clockSource, options2.updateInterval, this._context.sampleRate);
    this.on("tick", this._timeoutLoop.bind(this));
    this._context.onstatechange = () => {
      this.emit("statechange", this.state);
    };
    this[((_b = arguments[0]) === null || _b === void 0 ? void 0 : _b.hasOwnProperty("updateInterval")) ? "_lookAhead" : "lookAhead"] = options2.lookAhead;
  }
  static getDefaults() {
    return {
      clockSource: "worker",
      latencyHint: "interactive",
      lookAhead: 0.1,
      updateInterval: 0.05
    };
  }
  /**
   * Finish setting up the context. **You usually do not need to do this manually.**
   */
  initialize() {
    if (!this._initialized) {
      initializeContext(this);
      this._initialized = true;
    }
    return this;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return this._context.createAnalyser();
  }
  createOscillator() {
    return this._context.createOscillator();
  }
  createBufferSource() {
    return this._context.createBufferSource();
  }
  createBiquadFilter() {
    return this._context.createBiquadFilter();
  }
  createBuffer(numberOfChannels, length, sampleRate) {
    return this._context.createBuffer(numberOfChannels, length, sampleRate);
  }
  createChannelMerger(numberOfInputs) {
    return this._context.createChannelMerger(numberOfInputs);
  }
  createChannelSplitter(numberOfOutputs) {
    return this._context.createChannelSplitter(numberOfOutputs);
  }
  createConstantSource() {
    return this._context.createConstantSource();
  }
  createConvolver() {
    return this._context.createConvolver();
  }
  createDelay(maxDelayTime) {
    return this._context.createDelay(maxDelayTime);
  }
  createDynamicsCompressor() {
    return this._context.createDynamicsCompressor();
  }
  createGain() {
    return this._context.createGain();
  }
  createIIRFilter(feedForward, feedback) {
    return this._context.createIIRFilter(feedForward, feedback);
  }
  createPanner() {
    return this._context.createPanner();
  }
  createPeriodicWave(real, imag, constraints) {
    return this._context.createPeriodicWave(real, imag, constraints);
  }
  createStereoPanner() {
    return this._context.createStereoPanner();
  }
  createWaveShaper() {
    return this._context.createWaveShaper();
  }
  createMediaStreamSource(stream) {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaStreamSource(stream);
  }
  createMediaElementSource(element2) {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaElementSource(element2);
  }
  createMediaStreamDestination() {
    assert(isAudioContext(this._context), "Not available if OfflineAudioContext");
    const context2 = this._context;
    return context2.createMediaStreamDestination();
  }
  decodeAudioData(audioData) {
    return this._context.decodeAudioData(audioData);
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get currentTime() {
    return this._context.currentTime;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get state() {
    return this._context.state;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get sampleRate() {
    return this._context.sampleRate;
  }
  /**
   * The listener
   */
  get listener() {
    this.initialize();
    return this._listener;
  }
  set listener(l) {
    assert(!this._initialized, "The listener cannot be set after initialization.");
    this._listener = l;
  }
  /**
   * There is only one Transport per Context. It is created on initialization.
   */
  get transport() {
    this.initialize();
    return this._transport;
  }
  set transport(t) {
    assert(!this._initialized, "The transport cannot be set after initialization.");
    this._transport = t;
  }
  /**
   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.
   */
  get draw() {
    this.initialize();
    return this._draw;
  }
  set draw(d2) {
    assert(!this._initialized, "Draw cannot be set after initialization.");
    this._draw = d2;
  }
  /**
   * A reference to the Context's destination node.
   */
  get destination() {
    this.initialize();
    return this._destination;
  }
  set destination(d2) {
    assert(!this._initialized, "The destination cannot be set after initialization.");
    this._destination = d2;
  }
  /**
   * Create an audio worklet node from a name and options. The module
   * must first be loaded using {@link addAudioWorkletModule}.
   */
  createAudioWorkletNode(name, options2) {
    return createAudioWorkletNode(this.rawContext, name, options2);
  }
  /**
   * Add an AudioWorkletProcessor module
   * @param url The url of the module
   */
  addAudioWorkletModule(url) {
    return __awaiter(this, void 0, void 0, function* () {
      assert(isDefined(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)");
      if (!this._workletPromise) {
        this._workletPromise = this.rawContext.audioWorklet.addModule(url);
      }
      yield this._workletPromise;
    });
  }
  /**
   * Returns a promise which resolves when all of the worklets have been loaded on this context
   */
  workletsAreReady() {
    return __awaiter(this, void 0, void 0, function* () {
      (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
    });
  }
  //---------------------------
  // TICKER
  //---------------------------
  /**
   * How often the interval callback is invoked.
   * This number corresponds to how responsive the scheduling
   * can be. Setting to 0 will result in the lowest practial interval
   * based on context properties. context.updateInterval + context.lookAhead
   * gives you the total latency between scheduling an event and hearing it.
   */
  get updateInterval() {
    return this._ticker.updateInterval;
  }
  set updateInterval(interval) {
    this._ticker.updateInterval = interval;
  }
  /**
   * What the source of the clock is, either "worker" (default),
   * "timeout", or "offline" (none).
   */
  get clockSource() {
    return this._ticker.type;
  }
  set clockSource(type2) {
    this._ticker.type = type2;
  }
  /**
   * The amount of time into the future events are scheduled. Giving Web Audio
   * a short amount of time into the future to schedule events can reduce clicks and
   * improve performance. This value can be set to 0 to get the lowest latency.
   * Adjusting this value also affects the {@link updateInterval}.
   */
  get lookAhead() {
    return this._lookAhead;
  }
  set lookAhead(time2) {
    this._lookAhead = time2;
    this.updateInterval = time2 ? time2 / 2 : 0.01;
  }
  /**
   * The type of playback, which affects tradeoffs between audio
   * output latency and responsiveness.
   * In addition to setting the value in seconds, the latencyHint also
   * accepts the strings "interactive" (prioritizes low latency),
   * "playback" (prioritizes sustained playback), "balanced" (balances
   * latency and performance).
   * @example
   * // prioritize sustained playback
   * const context = new Tone.Context({ latencyHint: "playback" });
   * // set this context as the global Context
   * Tone.setContext(context);
   * // the global context is gettable with Tone.getContext()
   * console.log(Tone.getContext().latencyHint);
   */
  get latencyHint() {
    return this._latencyHint;
  }
  /**
   * The unwrapped AudioContext or OfflineAudioContext
   */
  get rawContext() {
    return this._context;
  }
  /**
   * The current audio context time plus a short {@link lookAhead}.
   * @example
   * setInterval(() => {
   * 	console.log("now", Tone.now());
   * }, 100);
   */
  now() {
    return this._context.currentTime + this._lookAhead;
  }
  /**
   * The current audio context time without the {@link lookAhead}.
   * In most cases it is better to use {@link now} instead of {@link immediate} since
   * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,
   * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}
   * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.
   */
  immediate() {
    return this._context.currentTime;
  }
  /**
   * Starts the audio context from a suspended state. This is required
   * to initially start the AudioContext.
   * @see {@link start}
   */
  resume() {
    if (isAudioContext(this._context)) {
      return this._context.resume();
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Close the context. Once closed, the context can no longer be used and
   * any AudioNodes created from the context will be silent.
   */
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      if (isAudioContext(this._context) && this.state !== "closed" && !this._closeStarted) {
        this._closeStarted = true;
        yield this._context.close();
      }
      if (this._initialized) {
        closeContext(this);
      }
    });
  }
  /**
   * **Internal** Generate a looped buffer at some constant value.
   */
  getConstant(val) {
    if (this._constants.has(val)) {
      return this._constants.get(val);
    } else {
      const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);
      const arr2 = buffer.getChannelData(0);
      for (let i = 0; i < arr2.length; i++) {
        arr2[i] = val;
      }
      const constant = this._context.createBufferSource();
      constant.channelCount = 1;
      constant.channelCountMode = "explicit";
      constant.buffer = buffer;
      constant.loop = true;
      constant.start(0);
      this._constants.set(val, constant);
      return constant;
    }
  }
  /**
   * Clean up. Also closes the audio context.
   */
  dispose() {
    super.dispose();
    this._ticker.dispose();
    this._timeouts.dispose();
    Object.keys(this._constants).map((val) => this._constants[val].disconnect());
    this.close();
    return this;
  }
  //---------------------------
  // TIMEOUTS
  //---------------------------
  /**
   * The private loop which keeps track of the context scheduled timeouts
   * Is invoked from the clock source
   */
  _timeoutLoop() {
    const now = this.now();
    this._timeouts.forEachBefore(now, (event) => {
      event.callback();
      this._timeouts.remove(event);
    });
  }
  /**
   * A setTimeout which is guaranteed by the clock source.
   * Also runs in the offline context.
   * @param  fn       The callback to invoke
   * @param  timeout  The timeout in seconds
   * @returns ID to use when invoking Context.clearTimeout
   */
  setTimeout(fn2, timeout) {
    this._timeoutIds++;
    const now = this.now();
    this._timeouts.add({
      callback: fn2,
      id: this._timeoutIds,
      time: now + timeout
    });
    return this._timeoutIds;
  }
  /**
   * Clears a previously scheduled timeout with Tone.context.setTimeout
   * @param  id  The ID returned from setTimeout
   */
  clearTimeout(id) {
    this._timeouts.forEach((event) => {
      if (event.id === id) {
        this._timeouts.remove(event);
      }
    });
    return this;
  }
  /**
   * Clear the function scheduled by {@link setInterval}
   */
  clearInterval(id) {
    return this.clearTimeout(id);
  }
  /**
   * Adds a repeating event to the context's callback clock
   */
  setInterval(fn2, interval) {
    const id = ++this._timeoutIds;
    const intervalFn = () => {
      const now = this.now();
      this._timeouts.add({
        callback: () => {
          fn2();
          intervalFn();
        },
        id,
        time: now + interval
      });
    };
    intervalFn();
    return id;
  }
}
class DummyContext extends BaseContext {
  constructor() {
    super(...arguments);
    this.lookAhead = 0;
    this.latencyHint = 0;
    this.isOffline = false;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return {};
  }
  createOscillator() {
    return {};
  }
  createBufferSource() {
    return {};
  }
  createBiquadFilter() {
    return {};
  }
  createBuffer(_numberOfChannels, _length2, _sampleRate) {
    return {};
  }
  createChannelMerger(_numberOfInputs) {
    return {};
  }
  createChannelSplitter(_numberOfOutputs) {
    return {};
  }
  createConstantSource() {
    return {};
  }
  createConvolver() {
    return {};
  }
  createDelay(_maxDelayTime) {
    return {};
  }
  createDynamicsCompressor() {
    return {};
  }
  createGain() {
    return {};
  }
  createIIRFilter(_feedForward, _feedback) {
    return {};
  }
  createPanner() {
    return {};
  }
  createPeriodicWave(_real, _imag, _constraints) {
    return {};
  }
  createStereoPanner() {
    return {};
  }
  createWaveShaper() {
    return {};
  }
  createMediaStreamSource(_stream) {
    return {};
  }
  createMediaElementSource(_element) {
    return {};
  }
  createMediaStreamDestination() {
    return {};
  }
  decodeAudioData(_audioData) {
    return Promise.resolve({});
  }
  //---------------------------
  // TONE AUDIO CONTEXT METHODS
  //---------------------------
  createAudioWorkletNode(_name, _options) {
    return {};
  }
  get rawContext() {
    return {};
  }
  addAudioWorkletModule(_url2) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  resume() {
    return Promise.resolve();
  }
  setTimeout(_fn, _timeout) {
    return 0;
  }
  clearTimeout(_id) {
    return this;
  }
  setInterval(_fn, _interval) {
    return 0;
  }
  clearInterval(_id) {
    return this;
  }
  getConstant(_val) {
    return {};
  }
  get currentTime() {
    return 0;
  }
  get state() {
    return {};
  }
  get sampleRate() {
    return 0;
  }
  get listener() {
    return {};
  }
  get transport() {
    return {};
  }
  get draw() {
    return {};
  }
  set draw(_d) {
  }
  get destination() {
    return {};
  }
  set destination(_d) {
  }
  now() {
    return 0;
  }
  immediate() {
    return 0;
  }
}
function readOnly(target, property) {
  if (isArray(property)) {
    property.forEach((str) => readOnly(target, str));
  } else {
    Object.defineProperty(target, property, {
      enumerable: true,
      writable: false
    });
  }
}
function writable(target, property) {
  if (isArray(property)) {
    property.forEach((str) => writable(target, str));
  } else {
    Object.defineProperty(target, property, {
      writable: true
    });
  }
}
const noOp = () => {
};
class ToneAudioBuffer extends Tone {
  constructor() {
    super();
    this.name = "ToneAudioBuffer";
    this.onload = noOp;
    const options2 = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, ["url", "onload", "onerror"]);
    this.reverse = options2.reverse;
    this.onload = options2.onload;
    if (isString(options2.url)) {
      this.load(options2.url).catch(options2.onerror);
    } else if (options2.url) {
      this.set(options2.url);
    }
  }
  static getDefaults() {
    return {
      onerror: noOp,
      onload: noOp,
      reverse: false
    };
  }
  /**
   * The sample rate of the AudioBuffer
   */
  get sampleRate() {
    if (this._buffer) {
      return this._buffer.sampleRate;
    } else {
      return getContext().sampleRate;
    }
  }
  /**
   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
   */
  set(buffer) {
    if (buffer instanceof ToneAudioBuffer) {
      if (buffer.loaded) {
        this._buffer = buffer.get();
      } else {
        buffer.onload = () => {
          this.set(buffer);
          this.onload(this);
        };
      }
    } else {
      this._buffer = buffer;
    }
    if (this._reversed) {
      this._reverse();
    }
    return this;
  }
  /**
   * The audio buffer stored in the object.
   */
  get() {
    return this._buffer;
  }
  /**
   * Makes an fetch request for the selected url then decodes the file as an audio buffer.
   * Invokes the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   * @returns A Promise which resolves with this ToneAudioBuffer
   */
  load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const doneLoading = ToneAudioBuffer.load(url).then((audioBuffer) => {
        this.set(audioBuffer);
        this.onload(this);
      });
      ToneAudioBuffer.downloads.push(doneLoading);
      try {
        yield doneLoading;
      } finally {
        const index = ToneAudioBuffer.downloads.indexOf(doneLoading);
        ToneAudioBuffer.downloads.splice(index, 1);
      }
      return this;
    });
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this._buffer = void 0;
    return this;
  }
  /**
   * Set the audio buffer from the array.
   * To create a multichannel AudioBuffer, pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   */
  fromArray(array2) {
    const isMultidimensional = isArray(array2) && array2[0].length > 0;
    const channels = isMultidimensional ? array2.length : 1;
    const len = isMultidimensional ? array2[0].length : array2.length;
    const context2 = getContext();
    const buffer = context2.createBuffer(channels, len, context2.sampleRate);
    const multiChannelArray = !isMultidimensional && channels === 1 ? [array2] : array2;
    for (let c = 0; c < channels; c++) {
      buffer.copyToChannel(multiChannelArray[c], c);
    }
    this._buffer = buffer;
    return this;
  }
  /**
   * Sums multiple channels into 1 channel
   * @param chanNum Optionally only copy a single channel from the array.
   */
  toMono(chanNum) {
    if (isNumber(chanNum)) {
      this.fromArray(this.toArray(chanNum));
    } else {
      let outputArray = new Float32Array(this.length);
      const numChannels = this.numberOfChannels;
      for (let channel = 0; channel < numChannels; channel++) {
        const channelArray = this.toArray(channel);
        for (let i = 0; i < channelArray.length; i++) {
          outputArray[i] += channelArray[i];
        }
      }
      outputArray = outputArray.map((sample) => sample / numChannels);
      this.fromArray(outputArray);
    }
    return this;
  }
  /**
   * Get the buffer as an array. Single channel buffers will return a 1-dimensional
   * Float32Array, and multichannel buffers will return multidimensional arrays.
   * @param channel Optionally only copy a single channel from the array.
   */
  toArray(channel) {
    if (isNumber(channel)) {
      return this.getChannelData(channel);
    } else if (this.numberOfChannels === 1) {
      return this.toArray(0);
    } else {
      const ret = [];
      for (let c = 0; c < this.numberOfChannels; c++) {
        ret[c] = this.getChannelData(c);
      }
      return ret;
    }
  }
  /**
   * Returns the Float32Array representing the PCM audio data for the specific channel.
   * @param  channel  The channel number to return
   * @return The audio as a TypedArray
   */
  getChannelData(channel) {
    if (this._buffer) {
      return this._buffer.getChannelData(channel);
    } else {
      return new Float32Array(0);
    }
  }
  /**
   * Cut a subsection of the array and return a buffer of the
   * subsection. Does not modify the original buffer
   * @param start The time to start the slice
   * @param end The end time to slice. If none is given will default to the end of the buffer
   */
  slice(start2, end = this.duration) {
    assert(this.loaded, "Buffer is not loaded");
    const startSamples = Math.floor(start2 * this.sampleRate);
    const endSamples = Math.floor(end * this.sampleRate);
    assert(startSamples < endSamples, "The start time must be less than the end time");
    const length = endSamples - startSamples;
    const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);
    for (let channel = 0; channel < this.numberOfChannels; channel++) {
      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);
    }
    return new ToneAudioBuffer(retBuffer);
  }
  /**
   * Reverse the buffer.
   */
  _reverse() {
    if (this.loaded) {
      for (let i = 0; i < this.numberOfChannels; i++) {
        this.getChannelData(i).reverse();
      }
    }
    return this;
  }
  /**
   * If the buffer is loaded or not
   */
  get loaded() {
    return this.length > 0;
  }
  /**
   * The duration of the buffer in seconds.
   */
  get duration() {
    if (this._buffer) {
      return this._buffer.duration;
    } else {
      return 0;
    }
  }
  /**
   * The length of the buffer in samples
   */
  get length() {
    if (this._buffer) {
      return this._buffer.length;
    } else {
      return 0;
    }
  }
  /**
   * The number of discrete audio channels. Returns 0 if no buffer is loaded.
   */
  get numberOfChannels() {
    if (this._buffer) {
      return this._buffer.numberOfChannels;
    } else {
      return 0;
    }
  }
  /**
   * Reverse the buffer.
   */
  get reverse() {
    return this._reversed;
  }
  set reverse(rev) {
    if (this._reversed !== rev) {
      this._reversed = rev;
      this._reverse();
    }
  }
  /**
   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
   * pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   * @return A ToneAudioBuffer created from the array
   */
  static fromArray(array2) {
    return new ToneAudioBuffer().fromArray(array2);
  }
  /**
   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
   * @param  url The url to load.
   * @return A promise which resolves to a ToneAudioBuffer
   */
  static fromUrl(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const buffer = new ToneAudioBuffer();
      return yield buffer.load(url);
    });
  }
  /**
   * Loads a url using fetch and returns the AudioBuffer.
   */
  static load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      const baseUrl = ToneAudioBuffer.baseUrl === "" || ToneAudioBuffer.baseUrl.endsWith("/") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + "/";
      const response = yield fetch(baseUrl + url);
      if (!response.ok) {
        throw new Error(`could not load url: ${url}`);
      }
      const arrayBuffer = yield response.arrayBuffer();
      const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);
      return audioBuffer;
    });
  }
  /**
   * Checks a url's extension to see if the current browser can play that file type.
   * @param url The url/extension to test
   * @return If the file extension can be played
   * @static
   * @example
   * Tone.ToneAudioBuffer.supportsType("wav"); // returns true
   * Tone.ToneAudioBuffer.supportsType("path/to/file.wav"); // returns true
   */
  static supportsType(url) {
    const extensions = url.split(".");
    const extension = extensions[extensions.length - 1];
    const response = document.createElement("audio").canPlayType("audio/" + extension);
    return response !== "";
  }
  /**
   * Returns a Promise which resolves when all of the buffers have loaded
   */
  static loaded() {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.resolve();
      while (ToneAudioBuffer.downloads.length) {
        yield ToneAudioBuffer.downloads[0];
      }
    });
  }
}
ToneAudioBuffer.baseUrl = "";
ToneAudioBuffer.downloads = [];
class OfflineContext extends Context {
  constructor() {
    super({
      clockSource: "offline",
      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),
      lookAhead: 0,
      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
    });
    this.name = "OfflineContext";
    this._currentTime = 0;
    this.isOffline = true;
    this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
  }
  /**
   * Override the now method to point to the internal clock time
   */
  now() {
    return this._currentTime;
  }
  /**
   * Same as this.now()
   */
  get currentTime() {
    return this._currentTime;
  }
  /**
   * Render just the clock portion of the audio context.
   */
  _renderClock(asynchronous) {
    return __awaiter(this, void 0, void 0, function* () {
      let index = 0;
      while (this._duration - this._currentTime >= 0) {
        this.emit("tick");
        this._currentTime += 128 / this.sampleRate;
        index++;
        const yieldEvery = Math.floor(this.sampleRate / 128);
        if (asynchronous && index % yieldEvery === 0) {
          yield new Promise((done) => setTimeout(done, 1));
        }
      }
    });
  }
  /**
   * Render the output of the OfflineContext
   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
   */
  render() {
    return __awaiter(this, arguments, void 0, function* (asynchronous = true) {
      yield this.workletsAreReady();
      yield this._renderClock(asynchronous);
      const buffer = yield this._context.startRendering();
      return new ToneAudioBuffer(buffer);
    });
  }
  /**
   * Close the context
   */
  close() {
    return Promise.resolve();
  }
}
const dummyContext = new DummyContext();
let globalContext = dummyContext;
function getContext() {
  if (globalContext === dummyContext && hasAudioContext) {
    setContext(new Context());
  }
  return globalContext;
}
function setContext(context2, disposeOld = false) {
  if (disposeOld) {
    globalContext.dispose();
  }
  if (isAudioContext(context2)) {
    globalContext = new Context(context2);
  } else if (isOfflineAudioContext(context2)) {
    globalContext = new OfflineContext(context2);
  } else {
    globalContext = context2;
  }
}
function start() {
  return globalContext.resume();
}
if (theWindow && !theWindow.TONE_SILENCE_LOGGING) {
  let prefix = "v";
  const printString = ` * Tone.js ${prefix}${version} * `;
  console.log(`%c${printString}`, "background: #000; color: #fff");
}
function dbToGain(db) {
  return Math.pow(10, db / 20);
}
function gainToDb(gain) {
  return 20 * (Math.log(gain) / Math.LN10);
}
function intervalToFrequencyRatio(interval) {
  return Math.pow(2, interval / 12);
}
let A4 = 440;
function getA4() {
  return A4;
}
function setA4(freq) {
  A4 = freq;
}
function ftom(frequency) {
  return Math.round(ftomf(frequency));
}
function ftomf(frequency) {
  return 69 + 12 * Math.log2(frequency / A4);
}
function mtof(midi) {
  return A4 * Math.pow(2, (midi - 69) / 12);
}
class TimeBaseClass extends Tone {
  /**
   * @param context The context associated with the time value. Used to compute
   * Transport and context-relative timing.
   * @param  value  The time value as a number, string or object
   * @param  units  Unit values
   */
  constructor(context2, value, units) {
    super();
    this.defaultUnits = "s";
    this._val = value;
    this._units = units;
    this.context = context2;
    this._expressions = this._getExpressions();
  }
  /**
   * All of the time encoding expressions
   */
  _getExpressions() {
    return {
      hz: {
        method: (value) => {
          return this._frequencyToUnits(parseFloat(value));
        },
        regexp: /^(\d+(?:\.\d+)?)hz$/i
      },
      i: {
        method: (value) => {
          return this._ticksToUnits(parseInt(value, 10));
        },
        regexp: /^(\d+)i$/i
      },
      m: {
        method: (value) => {
          return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());
        },
        regexp: /^(\d+)m$/i
      },
      n: {
        method: (value, dot) => {
          const numericValue = parseInt(value, 10);
          const scalar = dot === "." ? 1.5 : 1;
          if (numericValue === 1) {
            return this._beatsToUnits(this._getTimeSignature()) * scalar;
          } else {
            return this._beatsToUnits(4 / numericValue) * scalar;
          }
        },
        regexp: /^(\d+)n(\.?)$/i
      },
      number: {
        method: (value) => {
          return this._expressions[this.defaultUnits].method.call(this, value);
        },
        regexp: /^(\d+(?:\.\d+)?)$/
      },
      s: {
        method: (value) => {
          return this._secondsToUnits(parseFloat(value));
        },
        regexp: /^(\d+(?:\.\d+)?)s$/
      },
      samples: {
        method: (value) => {
          return parseInt(value, 10) / this.context.sampleRate;
        },
        regexp: /^(\d+)samples$/
      },
      t: {
        method: (value) => {
          const numericValue = parseInt(value, 10);
          return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));
        },
        regexp: /^(\d+)t$/i
      },
      tr: {
        method: (m, q, s) => {
          let total = 0;
          if (m && m !== "0") {
            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
          }
          if (q && q !== "0") {
            total += this._beatsToUnits(parseFloat(q));
          }
          if (s && s !== "0") {
            total += this._beatsToUnits(parseFloat(s) / 4);
          }
          return total;
        },
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
      }
    };
  }
  //-------------------------------------
  // 	VALUE OF
  //-------------------------------------
  /**
   * Evaluate the time value. Returns the time in seconds.
   */
  valueOf() {
    if (this._val instanceof TimeBaseClass) {
      this.fromType(this._val);
    }
    if (isUndef(this._val)) {
      return this._noArg();
    } else if (isString(this._val) && isUndef(this._units)) {
      for (const units in this._expressions) {
        if (this._expressions[units].regexp.test(this._val.trim())) {
          this._units = units;
          break;
        }
      }
    } else if (isObject(this._val)) {
      let total = 0;
      for (const typeName in this._val) {
        if (isDefined(this._val[typeName])) {
          const quantity = this._val[typeName];
          const time2 = (
            // @ts-ignore
            new this.constructor(this.context, typeName).valueOf() * quantity
          );
          total += time2;
        }
      }
      return total;
    }
    if (isDefined(this._units)) {
      const expr = this._expressions[this._units];
      const matching = this._val.toString().trim().match(expr.regexp);
      if (matching) {
        return expr.method.apply(this, matching.slice(1));
      } else {
        return expr.method.call(this, this._val);
      }
    } else if (isString(this._val)) {
      return parseFloat(this._val);
    } else {
      return this._val;
    }
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(freq) {
    return 1 / freq;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(beats) {
    return 60 / this._getBpm() * beats;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(seconds) {
    return seconds;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(ticks) {
    return ticks * this._beatsToUnits(1) / this._getPPQ();
  }
  /**
   * With no arguments, return 'now'
   */
  _noArg() {
    return this._now();
  }
  //-------------------------------------
  // 	TEMPO CONVERSIONS
  //-------------------------------------
  /**
   * Return the bpm
   */
  _getBpm() {
    return this.context.transport.bpm.value;
  }
  /**
   * Return the timeSignature
   */
  _getTimeSignature() {
    return this.context.transport.timeSignature;
  }
  /**
   * Return the PPQ or 192 if Transport is not available
   */
  _getPPQ() {
    return this.context.transport.PPQ;
  }
  //-------------------------------------
  // 	CONVERSION INTERFACE
  //-------------------------------------
  /**
   * Coerce a time type into this units type.
   * @param type Any time type units
   */
  fromType(type2) {
    this._units = void 0;
    switch (this.defaultUnits) {
      case "s":
        this._val = type2.toSeconds();
        break;
      case "i":
        this._val = type2.toTicks();
        break;
      case "hz":
        this._val = type2.toFrequency();
        break;
      case "midi":
        this._val = type2.toMidi();
        break;
    }
    return this;
  }
  /**
   * Return the value in hertz
   */
  toFrequency() {
    return 1 / this.toSeconds();
  }
  /**
   * Return the time in samples
   */
  toSamples() {
    return this.toSeconds() * this.context.sampleRate;
  }
  /**
   * Return the time in milliseconds.
   */
  toMilliseconds() {
    return this.toSeconds() * 1e3;
  }
}
class TimeClass extends TimeBaseClass {
  constructor() {
    super(...arguments);
    this.name = "TimeClass";
  }
  _getExpressions() {
    return Object.assign(super._getExpressions(), {
      now: {
        method: (capture) => {
          return this._now() + new this.constructor(this.context, capture).valueOf();
        },
        regexp: /^\+(.+)/
      },
      quantize: {
        method: (capture) => {
          const quantTo = new TimeClass(this.context, capture).valueOf();
          return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));
        },
        regexp: /^@(.+)/
      }
    });
  }
  /**
   * Quantize the time by the given subdivision. Optionally add a
   * percentage which will move the time value towards the ideal
   * quantized value by that percentage.
   * @param  subdiv    The subdivision to quantize to
   * @param  percent  Move the time value towards the quantized value by a percentage.
   * @example
   * Tone.Time(21).quantize(2); // returns 22
   * Tone.Time(0.6).quantize("4n", 0.5); // returns 0.55
   */
  quantize(subdiv, percent = 1) {
    const subdivision = new this.constructor(this.context, subdiv).valueOf();
    const value = this.valueOf();
    const multiple = Math.round(value / subdivision);
    const ideal = multiple * subdivision;
    const diff = ideal - value;
    return value + diff * percent;
  }
  //-------------------------------------
  // CONVERSIONS
  //-------------------------------------
  /**
   * Convert a Time to Notation. The notation values are will be the
   * closest representation between 1m to 128th note.
   * @return {Notation}
   * @example
   * // if the Transport is at 120bpm:
   * Tone.Time(2).toNotation(); // returns "1m"
   */
  toNotation() {
    const time2 = this.toSeconds();
    const testNotations = ["1m"];
    for (let power = 1; power < 9; power++) {
      const subdiv = Math.pow(2, power);
      testNotations.push(subdiv + "n.");
      testNotations.push(subdiv + "n");
      testNotations.push(subdiv + "t");
    }
    testNotations.push("0");
    let closest = testNotations[0];
    let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();
    testNotations.forEach((notation) => {
      const notationSeconds = new TimeClass(this.context, notation).toSeconds();
      if (Math.abs(notationSeconds - time2) < Math.abs(closestSeconds - time2)) {
        closest = notation;
        closestSeconds = notationSeconds;
      }
    });
    return closest;
  }
  /**
   * Return the time encoded as Bars:Beats:Sixteenths.
   */
  toBarsBeatsSixteenths() {
    const quarterTime = this._beatsToUnits(1);
    let quarters = this.valueOf() / quarterTime;
    quarters = parseFloat(quarters.toFixed(4));
    const measures = Math.floor(quarters / this._getTimeSignature());
    let sixteenths = quarters % 1 * 4;
    quarters = Math.floor(quarters) % this._getTimeSignature();
    const sixteenthString = sixteenths.toString();
    if (sixteenthString.length > 3) {
      sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));
    }
    const progress = [measures, quarters, sixteenths];
    return progress.join(":");
  }
  /**
   * Return the time in ticks.
   */
  toTicks() {
    const quarterTime = this._beatsToUnits(1);
    const quarters = this.valueOf() / quarterTime;
    return quarters * this._getPPQ();
  }
  /**
   * Return the time in seconds.
   */
  toSeconds() {
    return this.valueOf();
  }
  /**
   * Return the value as a midi note.
   */
  toMidi() {
    return ftom(this.toFrequency());
  }
  _now() {
    return this.context.now();
  }
}
class FrequencyClass extends TimeClass {
  constructor() {
    super(...arguments);
    this.name = "Frequency";
    this.defaultUnits = "hz";
  }
  /**
   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
   * to generate all the other pitch values from notes. A4's values in Hertz.
   */
  static get A4() {
    return getA4();
  }
  static set A4(freq) {
    setA4(freq);
  }
  //-------------------------------------
  // 	AUGMENT BASE EXPRESSIONS
  //-------------------------------------
  _getExpressions() {
    return Object.assign({}, super._getExpressions(), {
      midi: {
        regexp: /^(\d+(?:\.\d+)?midi)/,
        method(value) {
          if (this.defaultUnits === "midi") {
            return value;
          } else {
            return FrequencyClass.mtof(value);
          }
        }
      },
      note: {
        regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
        method(pitch, octave) {
          const index = noteToScaleIndex[pitch.toLowerCase()];
          const noteNumber = index + (parseInt(octave, 10) + 1) * 12;
          if (this.defaultUnits === "midi") {
            return noteNumber;
          } else {
            return FrequencyClass.mtof(noteNumber);
          }
        }
      },
      tr: {
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
        method(m, q, s) {
          let total = 1;
          if (m && m !== "0") {
            total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
          }
          if (q && q !== "0") {
            total *= this._beatsToUnits(parseFloat(q));
          }
          if (s && s !== "0") {
            total *= this._beatsToUnits(parseFloat(s) / 4);
          }
          return total;
        }
      }
    });
  }
  //-------------------------------------
  // 	EXPRESSIONS
  //-------------------------------------
  /**
   * Transposes the frequency by the given number of semitones.
   * @return  A new transposed frequency
   * @example
   * Tone.Frequency("A4").transpose(3); // "C5"
   */
  transpose(interval) {
    return new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));
  }
  /**
   * Takes an array of semitone intervals and returns
   * an array of frequencies transposed by those intervals.
   * @return  Returns an array of Frequencies
   * @example
   * Tone.Frequency("A4").harmonize([0, 3, 7]); // ["A4", "C5", "E5"]
   */
  harmonize(intervals) {
    return intervals.map((interval) => {
      return this.transpose(interval);
    });
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Frequency("C4").toMidi(); // 60
   */
  toMidi() {
    return ftom(this.valueOf());
  }
  /**
   * Return the value of the frequency in Scientific Pitch Notation
   * @example
   * Tone.Frequency(69, "midi").toNote(); // "A4"
   */
  toNote() {
    const freq = this.toFrequency();
    const log3 = Math.log2(freq / FrequencyClass.A4);
    let noteNumber = Math.round(12 * log3) + 57;
    const octave = Math.floor(noteNumber / 12);
    if (octave < 0) {
      noteNumber += -12 * octave;
    }
    const noteName = scaleIndexToNote[noteNumber % 12];
    return noteName + octave.toString();
  }
  /**
   * Return the duration of one cycle in seconds.
   */
  toSeconds() {
    return 1 / super.toSeconds();
  }
  /**
   * Return the duration of one cycle in ticks
   */
  toTicks() {
    const quarterTime = this._beatsToUnits(1);
    const quarters = this.valueOf() / quarterTime;
    return Math.floor(quarters * this._getPPQ());
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS HELPERS
  //-------------------------------------
  /**
   * With no arguments, return 0
   */
  _noArg() {
    return 0;
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(freq) {
    return freq;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(ticks) {
    return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(beats) {
    return 1 / super._beatsToUnits(beats);
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(seconds) {
    return 1 / seconds;
  }
  /**
   * Convert a MIDI note to frequency value.
   * @param  midi The midi number to convert.
   * @return The corresponding frequency value
   */
  static mtof(midi) {
    return mtof(midi);
  }
  /**
   * Convert a frequency value to a MIDI note.
   * @param frequency The value to frequency value to convert.
   */
  static ftom(frequency) {
    return ftom(frequency);
  }
}
const noteToScaleIndex = {
  cbbb: -3,
  cbb: -2,
  cb: -1,
  c: 0,
  "c#": 1,
  cx: 2,
  "c##": 2,
  "c###": 3,
  "cx#": 3,
  "c#x": 3,
  dbbb: -1,
  dbb: 0,
  db: 1,
  d: 2,
  "d#": 3,
  dx: 4,
  "d##": 4,
  "d###": 5,
  "dx#": 5,
  "d#x": 5,
  ebbb: 1,
  ebb: 2,
  eb: 3,
  e: 4,
  "e#": 5,
  ex: 6,
  "e##": 6,
  "e###": 7,
  "ex#": 7,
  "e#x": 7,
  fbbb: 2,
  fbb: 3,
  fb: 4,
  f: 5,
  "f#": 6,
  fx: 7,
  "f##": 7,
  "f###": 8,
  "fx#": 8,
  "f#x": 8,
  gbbb: 4,
  gbb: 5,
  gb: 6,
  g: 7,
  "g#": 8,
  gx: 9,
  "g##": 9,
  "g###": 10,
  "gx#": 10,
  "g#x": 10,
  abbb: 6,
  abb: 7,
  ab: 8,
  a: 9,
  "a#": 10,
  ax: 11,
  "a##": 11,
  "a###": 12,
  "ax#": 12,
  "a#x": 12,
  bbbb: 8,
  bbb: 9,
  bb: 10,
  b: 11,
  "b#": 12,
  bx: 13,
  "b##": 13,
  "b###": 14,
  "bx#": 14,
  "b#x": 14
};
const scaleIndexToNote = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];
class TransportTimeClass extends TimeClass {
  constructor() {
    super(...arguments);
    this.name = "TransportTime";
  }
  /**
   * Return the current time in whichever context is relevant
   */
  _now() {
    return this.context.transport.seconds;
  }
}
class ToneWithContext extends Tone {
  constructor() {
    super();
    const options2 = optionsFromArguments(ToneWithContext.getDefaults(), arguments, ["context"]);
    if (this.defaultContext) {
      this.context = this.defaultContext;
    } else {
      this.context = options2.context;
    }
  }
  static getDefaults() {
    return {
      context: getContext()
    };
  }
  /**
   * Return the current time of the Context clock plus the lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.now());
   * }, 100);
   */
  now() {
    return this.context.currentTime + this.context.lookAhead;
  }
  /**
   * Return the current time of the Context clock without any lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.immediate());
   * }, 100);
   */
  immediate() {
    return this.context.currentTime;
  }
  /**
   * The duration in seconds of one sample.
   */
  get sampleTime() {
    return 1 / this.context.sampleRate;
  }
  /**
   * The number of seconds of 1 processing block (128 samples)
   * @example
   * console.log(Tone.Destination.blockTime);
   */
  get blockTime() {
    return 128 / this.context.sampleRate;
  }
  /**
   * Convert the incoming time to seconds.
   * This is calculated against the current {@link TransportClass} bpm
   * @example
   * const gain = new Tone.Gain();
   * setInterval(() => console.log(gain.toSeconds("4n")), 100);
   * // ramp the tempo to 60 bpm over 30 seconds
   * Tone.getTransport().bpm.rampTo(60, 30);
   */
  toSeconds(time2) {
    assertUsedScheduleTime(time2);
    return new TimeClass(this.context, time2).toSeconds();
  }
  /**
   * Convert the input to a frequency number
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toFrequency("4n"));
   */
  toFrequency(freq) {
    return new FrequencyClass(this.context, freq).toFrequency();
  }
  /**
   * Convert the input time into ticks
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toTicks("4n"));
   */
  toTicks(time2) {
    return new TransportTimeClass(this.context, time2).toTicks();
  }
  //-------------------------------------
  // 	GET/SET
  //-------------------------------------
  /**
   * Get a subset of the properties which are in the partial props
   */
  _getPartialProperties(props) {
    const options2 = this.get();
    Object.keys(options2).forEach((name) => {
      if (isUndef(props[name])) {
        delete options2[name];
      }
    });
    return options2;
  }
  /**
   * Get the object's attributes.
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.get());
   */
  get() {
    const defaults2 = getDefaultsFromInstance(this);
    Object.keys(defaults2).forEach((attribute) => {
      if (Reflect.has(this, attribute)) {
        const member = this[attribute];
        if (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {
          defaults2[attribute] = member.value;
        } else if (member instanceof ToneWithContext) {
          defaults2[attribute] = member._getPartialProperties(defaults2[attribute]);
        } else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {
          defaults2[attribute] = member;
        } else {
          delete defaults2[attribute];
        }
      }
    });
    return defaults2;
  }
  /**
   * Set multiple properties at once with an object.
   * @example
   * const filter = new Tone.Filter().toDestination();
   * // set values using an object
   * filter.set({
   * 	frequency: "C6",
   * 	type: "highpass"
   * });
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3").connect(filter);
   * player.autostart = true;
   */
  set(props) {
    Object.keys(props).forEach((attribute) => {
      if (Reflect.has(this, attribute) && isDefined(this[attribute])) {
        if (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {
          if (this[attribute].value !== props[attribute]) {
            this[attribute].value = props[attribute];
          }
        } else if (this[attribute] instanceof ToneWithContext) {
          this[attribute].set(props[attribute]);
        } else {
          this[attribute] = props[attribute];
        }
      }
    });
    return this;
  }
}
class StateTimeline extends Timeline {
  constructor(initial = "stopped") {
    super();
    this.name = "StateTimeline";
    this._initial = initial;
    this.setStateAtTime(this._initial, 0);
  }
  /**
   * Returns the scheduled state scheduled before or at
   * the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   */
  getValueAtTime(time2) {
    const event = this.get(time2);
    if (event !== null) {
      return event.state;
    } else {
      return this._initial;
    }
  }
  /**
   * Add a state to the timeline.
   * @param  state The name of the state to set.
   * @param  time  The time to query.
   * @param options Any additional options that are needed in the timeline.
   */
  setStateAtTime(state, time2, options2) {
    assertRange(time2, 0);
    this.add(Object.assign({}, options2, {
      state,
      time: time2
    }));
    return this;
  }
  /**
   * Return the event before the time with the given state
   * @param  state The state to look for
   * @param  time  When to check before
   * @return  The event with the given state before the time
   */
  getLastState(state, time2) {
    const index = this._search(time2);
    for (let i = index; i >= 0; i--) {
      const event = this._timeline[i];
      if (event.state === state) {
        return event;
      }
    }
  }
  /**
   * Return the event after the time with the given state
   * @param  state The state to look for
   * @param  time  When to check from
   * @return  The event with the given state after the time
   */
  getNextState(state, time2) {
    const index = this._search(time2);
    if (index !== -1) {
      for (let i = index; i < this._timeline.length; i++) {
        const event = this._timeline[i];
        if (event.state === state) {
          return event;
        }
      }
    }
  }
}
class Param extends ToneWithContext {
  constructor() {
    const options2 = optionsFromArguments(Param.getDefaults(), arguments, [
      "param",
      "units",
      "convert"
    ]);
    super(options2);
    this.name = "Param";
    this.overridden = false;
    this._minOutput = 1e-7;
    assert(isDefined(options2.param) && (isAudioParam(options2.param) || options2.param instanceof Param), "param must be an AudioParam");
    while (!isAudioParam(options2.param)) {
      options2.param = options2.param._param;
    }
    this._swappable = isDefined(options2.swappable) ? options2.swappable : false;
    if (this._swappable) {
      this.input = this.context.createGain();
      this._param = options2.param;
      this.input.connect(this._param);
    } else {
      this._param = this.input = options2.param;
    }
    this._events = new Timeline(1e3);
    this._initialValue = this._param.defaultValue;
    this.units = options2.units;
    this.convert = options2.convert;
    this._minValue = options2.minValue;
    this._maxValue = options2.maxValue;
    if (isDefined(options2.value) && options2.value !== this._toType(this._initialValue)) {
      this.setValueAtTime(options2.value, 0);
    }
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      convert: true,
      units: "number"
    });
  }
  get value() {
    const now = this.now();
    return this.getValueAtTime(now);
  }
  set value(value) {
    this.cancelScheduledValues(this.now());
    this.setValueAtTime(value, this.now());
  }
  get minValue() {
    if (isDefined(this._minValue)) {
      return this._minValue;
    } else if (this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples") {
      return 0;
    } else if (this.units === "audioRange") {
      return -1;
    } else if (this.units === "decibels") {
      return -Infinity;
    } else {
      return this._param.minValue;
    }
  }
  get maxValue() {
    if (isDefined(this._maxValue)) {
      return this._maxValue;
    } else if (this.units === "normalRange" || this.units === "audioRange") {
      return 1;
    } else {
      return this._param.maxValue;
    }
  }
  /**
   * Type guard based on the unit name
   */
  _is(arg, type2) {
    return this.units === type2;
  }
  /**
   * Make sure the value is always in the defined range
   */
  _assertRange(value) {
    if (isDefined(this.maxValue) && isDefined(this.minValue)) {
      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));
    }
    return value;
  }
  /**
   * Convert the given value from the type specified by Param.units
   * into the destination value (such as Gain or Frequency).
   */
  _fromType(val) {
    if (this.convert && !this.overridden) {
      if (this._is(val, "time")) {
        return this.toSeconds(val);
      } else if (this._is(val, "decibels")) {
        return dbToGain(val);
      } else if (this._is(val, "frequency")) {
        return this.toFrequency(val);
      } else {
        return val;
      }
    } else if (this.overridden) {
      return 0;
    } else {
      return val;
    }
  }
  /**
   * Convert the parameters value into the units specified by Param.units.
   */
  _toType(val) {
    if (this.convert && this.units === "decibels") {
      return gainToDb(val);
    } else {
      return val;
    }
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // all docs are generated from ParamInterface.ts
  //-------------------------------------
  setValueAtTime(value, time2) {
    const computedTime = this.toSeconds(time2);
    const numericValue = this._fromType(value);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time2)}`);
    this._assertRange(numericValue);
    this.log(this.units, "setValueAtTime", value, computedTime);
    this._events.add({
      time: computedTime,
      type: "setValueAtTime",
      value: numericValue
    });
    this._param.setValueAtTime(numericValue, computedTime);
    return this;
  }
  getValueAtTime(time2) {
    const computedTime = Math.max(this.toSeconds(time2), 0);
    const after = this._events.getAfter(computedTime);
    const before = this._events.get(computedTime);
    let value = this._initialValue;
    if (before === null) {
      value = this._initialValue;
    } else if (before.type === "setTargetAtTime" && (after === null || after.type === "setValueAtTime")) {
      const previous = this._events.getBefore(before.time);
      let previousVal;
      if (previous === null) {
        previousVal = this._initialValue;
      } else {
        previousVal = previous.value;
      }
      if (before.type === "setTargetAtTime") {
        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);
      }
    } else if (after === null) {
      value = before.value;
    } else if (after.type === "linearRampToValueAtTime" || after.type === "exponentialRampToValueAtTime") {
      let beforeValue = before.value;
      if (before.type === "setTargetAtTime") {
        const previous = this._events.getBefore(before.time);
        if (previous === null) {
          beforeValue = this._initialValue;
        } else {
          beforeValue = previous.value;
        }
      }
      if (after.type === "linearRampToValueAtTime") {
        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
      } else {
        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
      }
    } else {
      value = before.value;
    }
    return this._toType(value);
  }
  setRampPoint(time2) {
    time2 = this.toSeconds(time2);
    let currentVal = this.getValueAtTime(time2);
    this.cancelAndHoldAtTime(time2);
    if (this._fromType(currentVal) === 0) {
      currentVal = this._toType(this._minOutput);
    }
    this.setValueAtTime(currentVal, time2);
    return this;
  }
  linearRampToValueAtTime(value, endTime) {
    const numericValue = this._fromType(value);
    const computedTime = this.toSeconds(endTime);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
    this._assertRange(numericValue);
    this._events.add({
      time: computedTime,
      type: "linearRampToValueAtTime",
      value: numericValue
    });
    this.log(this.units, "linearRampToValueAtTime", value, computedTime);
    this._param.linearRampToValueAtTime(numericValue, computedTime);
    return this;
  }
  exponentialRampToValueAtTime(value, endTime) {
    let numericValue = this._fromType(value);
    numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;
    this._assertRange(numericValue);
    const computedTime = this.toSeconds(endTime);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);
    this._events.add({
      time: computedTime,
      type: "exponentialRampToValueAtTime",
      value: numericValue
    });
    this.log(this.units, "exponentialRampToValueAtTime", value, computedTime);
    this._param.exponentialRampToValueAtTime(numericValue, computedTime);
    return this;
  }
  exponentialRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
    return this;
  }
  linearRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
    return this;
  }
  targetRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.exponentialApproachValueAtTime(value, startTime, rampTime);
    return this;
  }
  exponentialApproachValueAtTime(value, time2, rampTime) {
    time2 = this.toSeconds(time2);
    rampTime = this.toSeconds(rampTime);
    const timeConstant = Math.log(rampTime + 1) / Math.log(200);
    this.setTargetAtTime(value, time2, timeConstant);
    this.cancelAndHoldAtTime(time2 + rampTime * 0.9);
    this.linearRampToValueAtTime(value, time2 + rampTime);
    return this;
  }
  setTargetAtTime(value, startTime, timeConstant) {
    const numericValue = this._fromType(value);
    assert(isFinite(timeConstant) && timeConstant > 0, "timeConstant must be a number greater than 0");
    const computedTime = this.toSeconds(startTime);
    this._assertRange(numericValue);
    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);
    this._events.add({
      constant: timeConstant,
      time: computedTime,
      type: "setTargetAtTime",
      value: numericValue
    });
    this.log(this.units, "setTargetAtTime", value, computedTime, timeConstant);
    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration2, scaling = 1) {
    duration2 = this.toSeconds(duration2);
    startTime = this.toSeconds(startTime);
    const startingValue = this._fromType(values[0]) * scaling;
    this.setValueAtTime(this._toType(startingValue), startTime);
    const segTime = duration2 / (values.length - 1);
    for (let i = 1; i < values.length; i++) {
      const numericValue = this._fromType(values[i]) * scaling;
      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);
    }
    return this;
  }
  cancelScheduledValues(time2) {
    const computedTime = this.toSeconds(time2);
    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time2)}`);
    this._events.cancel(computedTime);
    this._param.cancelScheduledValues(computedTime);
    this.log(this.units, "cancelScheduledValues", computedTime);
    return this;
  }
  cancelAndHoldAtTime(time2) {
    const computedTime = this.toSeconds(time2);
    const valueAtTime = this._fromType(this.getValueAtTime(computedTime));
    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time2)}`);
    this.log(this.units, "cancelAndHoldAtTime", computedTime, "value=" + valueAtTime);
    const before = this._events.get(computedTime);
    const after = this._events.getAfter(computedTime);
    if (before && EQ(before.time, computedTime)) {
      if (after) {
        this._param.cancelScheduledValues(after.time);
        this._events.cancel(after.time);
      } else {
        this._param.cancelAndHoldAtTime(computedTime);
        this._events.cancel(computedTime + this.sampleTime);
      }
    } else if (after) {
      this._param.cancelScheduledValues(after.time);
      this._events.cancel(after.time);
      if (after.type === "linearRampToValueAtTime") {
        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);
      } else if (after.type === "exponentialRampToValueAtTime") {
        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);
      }
    }
    this._events.add({
      time: computedTime,
      type: "setValueAtTime",
      value: valueAtTime
    });
    this._param.setValueAtTime(valueAtTime, computedTime);
    return this;
  }
  rampTo(value, rampTime = 0.1, startTime) {
    if (this.units === "frequency" || this.units === "bpm" || this.units === "decibels") {
      this.exponentialRampTo(value, rampTime, startTime);
    } else {
      this.linearRampTo(value, rampTime, startTime);
    }
    return this;
  }
  /**
   * Apply all of the previously scheduled events to the passed in Param or AudioParam.
   * The applied values will start at the context's current time and schedule
   * all of the events which are scheduled on this Param onto the passed in param.
   */
  apply(param) {
    const now = this.context.currentTime;
    param.setValueAtTime(this.getValueAtTime(now), now);
    const previousEvent = this._events.get(now);
    if (previousEvent && previousEvent.type === "setTargetAtTime") {
      const nextEvent = this._events.getAfter(previousEvent.time);
      const endTime = nextEvent ? nextEvent.time : now + 2;
      const subdivisions = (endTime - now) / 10;
      for (let i = now; i < endTime; i += subdivisions) {
        param.linearRampToValueAtTime(this.getValueAtTime(i), i);
      }
    }
    this._events.forEachAfter(this.context.currentTime, (event) => {
      if (event.type === "cancelScheduledValues") {
        param.cancelScheduledValues(event.time);
      } else if (event.type === "setTargetAtTime") {
        param.setTargetAtTime(event.value, event.time, event.constant);
      } else {
        param[event.type](event.value, event.time);
      }
    });
    return this;
  }
  /**
   * Replace the Param's internal AudioParam. Will apply scheduled curves
   * onto the parameter and replace the connections.
   */
  setParam(param) {
    assert(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
    const input = this.input;
    input.disconnect(this._param);
    this.apply(param);
    this._param = param;
    input.connect(this._param);
    return this;
  }
  dispose() {
    super.dispose();
    this._events.dispose();
    return this;
  }
  get defaultValue() {
    return this._toType(this._param.defaultValue);
  }
  //-------------------------------------
  // 	AUTOMATION CURVE CALCULATIONS
  // 	MIT License, copyright (c) 2014 Jordan Santell
  //-------------------------------------
  // Calculates the the value along the curve produced by setTargetAtTime
  _exponentialApproach(t0, v0, v1, timeConstant, t) {
    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
  }
  // Calculates the the value along the curve produced by linearRampToValueAtTime
  _linearInterpolate(t0, v0, t1, v1, t) {
    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
  }
  // Calculates the the value along the curve produced by exponentialRampToValueAtTime
  _exponentialInterpolate(t0, v0, t1, v1, t) {
    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
  }
}
class ToneAudioNode extends ToneWithContext {
  constructor() {
    super(...arguments);
    this._internalChannels = [];
  }
  /**
   * The number of inputs feeding into the AudioNode.
   * For source nodes, this will be 0.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfInputs);
   */
  get numberOfInputs() {
    if (isDefined(this.input)) {
      if (isAudioParam(this.input) || this.input instanceof Param) {
        return 1;
      } else {
        return this.input.numberOfInputs;
      }
    } else {
      return 0;
    }
  }
  /**
   * The number of outputs of the AudioNode.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfOutputs);
   */
  get numberOfOutputs() {
    if (isDefined(this.output)) {
      return this.output.numberOfOutputs;
    } else {
      return 0;
    }
  }
  //-------------------------------------
  // AUDIO PROPERTIES
  //-------------------------------------
  /**
   * Used to decide which nodes to get/set properties on
   */
  _isAudioNode(node) {
    return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));
  }
  /**
   * Get all of the audio nodes (either internal or input/output) which together
   * make up how the class node responds to channel input/output
   */
  _getInternalNodes() {
    const nodeList = this._internalChannels.slice(0);
    if (this._isAudioNode(this.input)) {
      nodeList.push(this.input);
    }
    if (this._isAudioNode(this.output)) {
      if (this.input !== this.output) {
        nodeList.push(this.output);
      }
    }
    return nodeList;
  }
  /**
   * Set the audio options for this node such as channelInterpretation
   * channelCount, etc.
   * @param options
   */
  _setChannelProperties(options2) {
    const nodeList = this._getInternalNodes();
    nodeList.forEach((node) => {
      node.channelCount = options2.channelCount;
      node.channelCountMode = options2.channelCountMode;
      node.channelInterpretation = options2.channelInterpretation;
    });
  }
  /**
   * Get the current audio options for this node such as channelInterpretation
   * channelCount, etc.
   */
  _getChannelProperties() {
    const nodeList = this._getInternalNodes();
    assert(nodeList.length > 0, "ToneAudioNode does not have any internal nodes");
    const node = nodeList[0];
    return {
      channelCount: node.channelCount,
      channelCountMode: node.channelCountMode,
      channelInterpretation: node.channelInterpretation
    };
  }
  /**
   * channelCount is the number of channels used when up-mixing and down-mixing
   * connections to any inputs to the node. The default value is 2 except for
   * specific nodes where its value is specially determined.
   */
  get channelCount() {
    return this._getChannelProperties().channelCount;
  }
  set channelCount(channelCount) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelCount }));
  }
  /**
   * channelCountMode determines how channels will be counted when up-mixing and
   * down-mixing connections to any inputs to the node.
   * The default value is "max". This attribute has no effect for nodes with no inputs.
   * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
   * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
   * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
   */
  get channelCountMode() {
    return this._getChannelProperties().channelCountMode;
  }
  set channelCountMode(channelCountMode) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelCountMode }));
  }
  /**
   * channelInterpretation determines how individual channels will be treated
   * when up-mixing and down-mixing connections to any inputs to the node.
   * The default value is "speakers".
   */
  get channelInterpretation() {
    return this._getChannelProperties().channelInterpretation;
  }
  set channelInterpretation(channelInterpretation) {
    const props = this._getChannelProperties();
    this._setChannelProperties(Object.assign(props, { channelInterpretation }));
  }
  //-------------------------------------
  // CONNECTIONS
  //-------------------------------------
  /**
   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
   * @param destination The output to connect to
   * @param outputNum The output to connect from
   * @param inputNum The input to connect to
   */
  connect(destination, outputNum = 0, inputNum = 0) {
    connect(this, destination, outputNum, inputNum);
    return this;
  }
  /**
   * Connect the output to the context's destination node.
   * @example
   * const osc = new Tone.Oscillator("C2").start();
   * osc.toDestination();
   */
  toDestination() {
    this.connect(this.context.destination);
    return this;
  }
  /**
   * Connect the output to the context's destination node.
   * @see {@link toDestination}
   * @deprecated
   */
  toMaster() {
    warn3("toMaster() has been renamed toDestination()");
    return this.toDestination();
  }
  /**
   * disconnect the output
   */
  disconnect(destination, outputNum = 0, inputNum = 0) {
    disconnect(this, destination, outputNum, inputNum);
    return this;
  }
  /**
   * Connect the output of this node to the rest of the nodes in series.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3");
   * player.autostart = true;
   * const filter = new Tone.AutoFilter(4).start();
   * const distortion = new Tone.Distortion(0.5);
   * // connect the player to the filter, distortion and then to the master output
   * player.chain(filter, distortion, Tone.Destination);
   */
  chain(...nodes) {
    connectSeries(this, ...nodes);
    return this;
  }
  /**
   * connect the output of this node to the rest of the nodes in parallel.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3");
   * player.autostart = true;
   * const pitchShift = new Tone.PitchShift(4).toDestination();
   * const filter = new Tone.Filter("G5").toDestination();
   * // connect a node to the pitch shift and filter in parallel
   * player.fan(pitchShift, filter);
   */
  fan(...nodes) {
    nodes.forEach((node) => this.connect(node));
    return this;
  }
  /**
   * Dispose and disconnect
   */
  dispose() {
    super.dispose();
    if (isDefined(this.input)) {
      if (this.input instanceof ToneAudioNode) {
        this.input.dispose();
      } else if (isAudioNode(this.input)) {
        this.input.disconnect();
      }
    }
    if (isDefined(this.output)) {
      if (this.output instanceof ToneAudioNode) {
        this.output.dispose();
      } else if (isAudioNode(this.output)) {
        this.output.disconnect();
      }
    }
    this._internalChannels = [];
    return this;
  }
}
function connectSeries(...nodes) {
  const first = nodes.shift();
  nodes.reduce((prev, current2) => {
    if (prev instanceof ToneAudioNode) {
      prev.connect(current2);
    } else if (isAudioNode(prev)) {
      connect(prev, current2);
    }
    return current2;
  }, first);
}
function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
  assert(isDefined(srcNode), "Cannot connect from undefined node");
  assert(isDefined(dstNode), "Cannot connect to undefined node");
  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {
    assert(dstNode.numberOfInputs > 0, "Cannot connect to node with no inputs");
  }
  assert(srcNode.numberOfOutputs > 0, "Cannot connect from node with no outputs");
  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {
    if (isDefined(dstNode.input)) {
      dstNode = dstNode.input;
    }
  }
  while (srcNode instanceof ToneAudioNode) {
    if (isDefined(srcNode.output)) {
      srcNode = srcNode.output;
    }
  }
  if (isAudioParam(dstNode)) {
    srcNode.connect(dstNode, outputNumber);
  } else {
    srcNode.connect(dstNode, outputNumber, inputNumber);
  }
}
function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
  if (isDefined(dstNode)) {
    while (dstNode instanceof ToneAudioNode) {
      dstNode = dstNode.input;
    }
  }
  while (!isAudioNode(srcNode)) {
    if (isDefined(srcNode.output)) {
      srcNode = srcNode.output;
    }
  }
  if (isAudioParam(dstNode)) {
    srcNode.disconnect(dstNode, outputNumber);
  } else if (isAudioNode(dstNode)) {
    srcNode.disconnect(dstNode, outputNumber, inputNumber);
  } else {
    srcNode.disconnect();
  }
}
class Gain extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Gain.getDefaults(), arguments, [
      "gain",
      "units"
    ]);
    super(options2);
    this.name = "Gain";
    this._gainNode = this.context.createGain();
    this.input = this._gainNode;
    this.output = this._gainNode;
    this.gain = new Param({
      context: this.context,
      convert: options2.convert,
      param: this._gainNode.gain,
      units: options2.units,
      value: options2.gain,
      minValue: options2.minValue,
      maxValue: options2.maxValue
    });
    readOnly(this, "gain");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      convert: true,
      gain: 1,
      units: "gain"
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._gainNode.disconnect();
    this.gain.dispose();
    return this;
  }
}
class OneShotSource extends ToneAudioNode {
  constructor(options2) {
    super(options2);
    this.onended = noOp;
    this._startTime = -1;
    this._stopTime = -1;
    this._timeout = -1;
    this.output = new Gain({
      context: this.context,
      gain: 0
    });
    this._gainNode = this.output;
    this.getStateAtTime = function(time2) {
      const computedTime = this.toSeconds(time2);
      if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {
        return "started";
      } else {
        return "stopped";
      }
    };
    this._fadeIn = options2.fadeIn;
    this._fadeOut = options2.fadeOut;
    this._curve = options2.curve;
    this.onended = options2.onended;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      curve: "linear",
      fadeIn: 0,
      fadeOut: 0,
      onended: noOp
    });
  }
  /**
   * Start the source at the given time
   * @param  time When to start the source
   */
  _startGain(time2, gain = 1) {
    assert(this._startTime === -1, "Source cannot be started more than once");
    const fadeInTime = this.toSeconds(this._fadeIn);
    this._startTime = time2 + fadeInTime;
    this._startTime = Math.max(this._startTime, this.context.currentTime);
    if (fadeInTime > 0) {
      this._gainNode.gain.setValueAtTime(0, time2);
      if (this._curve === "linear") {
        this._gainNode.gain.linearRampToValueAtTime(gain, time2 + fadeInTime);
      } else {
        this._gainNode.gain.exponentialApproachValueAtTime(gain, time2, fadeInTime);
      }
    } else {
      this._gainNode.gain.setValueAtTime(gain, time2);
    }
    return this;
  }
  /**
   * Stop the source node at the given time.
   * @param time When to stop the source
   */
  stop(time2) {
    this.log("stop", time2);
    this._stopGain(this.toSeconds(time2));
    return this;
  }
  /**
   * Stop the source at the given time
   * @param  time When to stop the source
   */
  _stopGain(time2) {
    assert(this._startTime !== -1, "'start' must be called before 'stop'");
    this.cancelStop();
    const fadeOutTime = this.toSeconds(this._fadeOut);
    this._stopTime = this.toSeconds(time2) + fadeOutTime;
    this._stopTime = Math.max(this._stopTime, this.now());
    if (fadeOutTime > 0) {
      if (this._curve === "linear") {
        this._gainNode.gain.linearRampTo(0, fadeOutTime, time2);
      } else {
        this._gainNode.gain.targetRampTo(0, fadeOutTime, time2);
      }
    } else {
      this._gainNode.gain.cancelAndHoldAtTime(time2);
      this._gainNode.gain.setValueAtTime(0, time2);
    }
    this.context.clearTimeout(this._timeout);
    this._timeout = this.context.setTimeout(() => {
      const additionalTail = this._curve === "exponential" ? fadeOutTime * 2 : 0;
      this._stopSource(this.now() + additionalTail);
      this._onended();
    }, this._stopTime - this.context.currentTime);
    return this;
  }
  /**
   * Invoke the onended callback
   */
  _onended() {
    if (this.onended === noOp) {
      return;
    }
    this.onended(this);
    this.onended = noOp;
    if (!this.context.isOffline) {
      const disposeCallback = () => this.dispose();
      if (typeof requestIdleCallback !== "undefined") {
        requestIdleCallback(disposeCallback);
      } else {
        setTimeout(disposeCallback, 10);
      }
    }
  }
  /**
   * Get the playback state at the current time
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Cancel a scheduled stop event
   */
  cancelStop() {
    this.log("cancelStop");
    assert(this._startTime !== -1, "Source is not started");
    this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);
    this.context.clearTimeout(this._timeout);
    this._stopTime = -1;
    return this;
  }
  dispose() {
    super.dispose();
    this._gainNode.dispose();
    this.onended = noOp;
    return this;
  }
}
class ToneConstantSource extends OneShotSource {
  constructor() {
    const options2 = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, ["offset"]);
    super(options2);
    this.name = "ToneConstantSource";
    this._source = this.context.createConstantSource();
    connect(this._source, this._gainNode);
    this.offset = new Param({
      context: this.context,
      convert: options2.convert,
      param: this._source.offset,
      units: options2.units,
      value: options2.offset,
      minValue: options2.minValue,
      maxValue: options2.maxValue
    });
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      convert: true,
      offset: 1,
      units: "number"
    });
  }
  /**
   * Start the source node at the given time
   * @param  time When to start the source
   */
  start(time2) {
    const computedTime = this.toSeconds(time2);
    this.log("start", computedTime);
    this._startGain(computedTime);
    this._source.start(computedTime);
    return this;
  }
  _stopSource(time2) {
    this._source.stop(time2);
  }
  dispose() {
    super.dispose();
    if (this.state === "started") {
      this.stop();
    }
    this._source.disconnect();
    this.offset.dispose();
    return this;
  }
}
class Signal extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Signal.getDefaults(), arguments, [
      "value",
      "units"
    ]);
    super(options2);
    this.name = "Signal";
    this.override = true;
    this.output = this._constantSource = new ToneConstantSource({
      context: this.context,
      convert: options2.convert,
      offset: options2.value,
      units: options2.units,
      minValue: options2.minValue,
      maxValue: options2.maxValue
    });
    this._constantSource.start(0);
    this.input = this._param = this._constantSource.offset;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      convert: true,
      units: "number",
      value: 0
    });
  }
  connect(destination, outputNum = 0, inputNum = 0) {
    connectSignal(this, destination, outputNum, inputNum);
    return this;
  }
  dispose() {
    super.dispose();
    this._param.dispose();
    this._constantSource.dispose();
    return this;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // just a proxy for the ConstantSourceNode's offset AudioParam
  // all docs are generated from AbstractParam.ts
  //-------------------------------------
  setValueAtTime(value, time2) {
    this._param.setValueAtTime(value, time2);
    return this;
  }
  getValueAtTime(time2) {
    return this._param.getValueAtTime(time2);
  }
  setRampPoint(time2) {
    this._param.setRampPoint(time2);
    return this;
  }
  linearRampToValueAtTime(value, time2) {
    this._param.linearRampToValueAtTime(value, time2);
    return this;
  }
  exponentialRampToValueAtTime(value, time2) {
    this._param.exponentialRampToValueAtTime(value, time2);
    return this;
  }
  exponentialRampTo(value, rampTime, startTime) {
    this._param.exponentialRampTo(value, rampTime, startTime);
    return this;
  }
  linearRampTo(value, rampTime, startTime) {
    this._param.linearRampTo(value, rampTime, startTime);
    return this;
  }
  targetRampTo(value, rampTime, startTime) {
    this._param.targetRampTo(value, rampTime, startTime);
    return this;
  }
  exponentialApproachValueAtTime(value, time2, rampTime) {
    this._param.exponentialApproachValueAtTime(value, time2, rampTime);
    return this;
  }
  setTargetAtTime(value, startTime, timeConstant) {
    this._param.setTargetAtTime(value, startTime, timeConstant);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration2, scaling) {
    this._param.setValueCurveAtTime(values, startTime, duration2, scaling);
    return this;
  }
  cancelScheduledValues(time2) {
    this._param.cancelScheduledValues(time2);
    return this;
  }
  cancelAndHoldAtTime(time2) {
    this._param.cancelAndHoldAtTime(time2);
    return this;
  }
  rampTo(value, rampTime, startTime) {
    this._param.rampTo(value, rampTime, startTime);
    return this;
  }
  get value() {
    return this._param.value;
  }
  set value(value) {
    this._param.value = value;
  }
  get convert() {
    return this._param.convert;
  }
  set convert(convert) {
    this._param.convert = convert;
  }
  get units() {
    return this._param.units;
  }
  get overridden() {
    return this._param.overridden;
  }
  set overridden(overridden) {
    this._param.overridden = overridden;
  }
  get maxValue() {
    return this._param.maxValue;
  }
  get minValue() {
    return this._param.minValue;
  }
  /**
   * @see {@link Param.apply}.
   */
  apply(param) {
    this._param.apply(param);
    return this;
  }
}
function connectSignal(signal, destination, outputNum, inputNum) {
  if (destination instanceof Param || isAudioParam(destination) || destination instanceof Signal && destination.override) {
    destination.cancelScheduledValues(0);
    destination.setValueAtTime(0, 0);
    if (destination instanceof Signal) {
      destination.overridden = true;
    }
  }
  connect(signal, destination, outputNum, inputNum);
}
class TickParam extends Param {
  constructor() {
    const options2 = optionsFromArguments(TickParam.getDefaults(), arguments, ["value"]);
    super(options2);
    this.name = "TickParam";
    this._events = new Timeline(Infinity);
    this._multiplier = 1;
    this._multiplier = options2.multiplier;
    this._events.cancel(0);
    this._events.add({
      ticks: 0,
      time: 0,
      type: "setValueAtTime",
      value: this._fromType(options2.value)
    });
    this.setValueAtTime(options2.value, 0);
  }
  static getDefaults() {
    return Object.assign(Param.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  setTargetAtTime(value, time2, constant) {
    time2 = this.toSeconds(time2);
    this.setRampPoint(time2);
    const computedValue = this._fromType(value);
    const prevEvent = this._events.get(time2);
    const segments = Math.round(Math.max(1 / constant, 1));
    for (let i = 0; i <= segments; i++) {
      const segTime = constant * i + time2;
      const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);
      this.linearRampToValueAtTime(this._toType(rampVal), segTime);
    }
    return this;
  }
  setValueAtTime(value, time2) {
    const computedTime = this.toSeconds(time2);
    super.setValueAtTime(value, time2);
    const event = this._events.get(computedTime);
    const previousEvent = this._events.previousEvent(event);
    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
    event.ticks = Math.max(ticksUntilTime, 0);
    return this;
  }
  linearRampToValueAtTime(value, time2) {
    const computedTime = this.toSeconds(time2);
    super.linearRampToValueAtTime(value, time2);
    const event = this._events.get(computedTime);
    const previousEvent = this._events.previousEvent(event);
    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);
    event.ticks = Math.max(ticksUntilTime, 0);
    return this;
  }
  exponentialRampToValueAtTime(value, time2) {
    time2 = this.toSeconds(time2);
    const computedVal = this._fromType(value);
    const prevEvent = this._events.get(time2);
    const segments = Math.round(Math.max((time2 - prevEvent.time) * 10, 1));
    const segmentDur = (time2 - prevEvent.time) / segments;
    for (let i = 0; i <= segments; i++) {
      const segTime = segmentDur * i + prevEvent.time;
      const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time2, computedVal, segTime);
      this.linearRampToValueAtTime(this._toType(rampVal), segTime);
    }
    return this;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  event The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  _getTicksUntilEvent(event, time2) {
    if (event === null) {
      event = {
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: 0
      };
    } else if (isUndef(event.ticks)) {
      const previousEvent = this._events.previousEvent(event);
      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);
    }
    const val0 = this._fromType(this.getValueAtTime(event.time));
    let val1 = this._fromType(this.getValueAtTime(time2));
    const onTheLineEvent = this._events.get(time2);
    if (onTheLineEvent && onTheLineEvent.time === time2 && onTheLineEvent.type === "setValueAtTime") {
      val1 = this._fromType(this.getValueAtTime(time2 - this.sampleTime));
    }
    return 0.5 * (time2 - event.time) * (val0 + val1) + event.ticks;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  time The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  getTicksAtTime(time2) {
    const computedTime = this.toSeconds(time2);
    const event = this._events.get(computedTime);
    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);
  }
  /**
   * Return the elapsed time of the number of ticks from the given time
   * @param ticks The number of ticks to calculate
   * @param  time The time to get the next tick from
   * @return The duration of the number of ticks from the given time in seconds
   */
  getDurationOfTicks(ticks, time2) {
    const computedTime = this.toSeconds(time2);
    const currentTick = this.getTicksAtTime(time2);
    return this.getTimeOfTick(currentTick + ticks) - computedTime;
  }
  /**
   * Given a tick, returns the time that tick occurs at.
   * @return The time that the tick occurs.
   */
  getTimeOfTick(tick) {
    const before = this._events.get(tick, "ticks");
    const after = this._events.getAfter(tick, "ticks");
    if (before && before.ticks === tick) {
      return before.time;
    } else if (before && after && after.type === "linearRampToValueAtTime" && before.value !== after.value) {
      const val0 = this._fromType(this.getValueAtTime(before.time));
      const val1 = this._fromType(this.getValueAtTime(after.time));
      const delta = (val1 - val0) / (after.time - before.time);
      const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
      const sol1 = (-val0 + k) / delta;
      const sol2 = (-val0 - k) / delta;
      return (sol1 > 0 ? sol1 : sol2) + before.time;
    } else if (before) {
      if (before.value === 0) {
        return Infinity;
      } else {
        return before.time + (tick - before.ticks) / before.value;
      }
    } else {
      return tick / this._initialValue;
    }
  }
  /**
   * Convert some number of ticks their the duration in seconds accounting
   * for any automation curves starting at the given time.
   * @param  ticks The number of ticks to convert to seconds.
   * @param  when  When along the automation timeline to convert the ticks.
   * @return The duration in seconds of the ticks.
   */
  ticksToTime(ticks, when) {
    return this.getDurationOfTicks(ticks, when);
  }
  /**
   * The inverse of {@link ticksToTime}. Convert a duration in
   * seconds to the corresponding number of ticks accounting for any
   * automation curves starting at the given time.
   * @param  duration The time interval to convert to ticks.
   * @param  when When along the automation timeline to convert the ticks.
   * @return The duration in ticks.
   */
  timeToTicks(duration2, when) {
    const computedTime = this.toSeconds(when);
    const computedDuration = this.toSeconds(duration2);
    const startTicks = this.getTicksAtTime(computedTime);
    const endTicks = this.getTicksAtTime(computedTime + computedDuration);
    return endTicks - startTicks;
  }
  /**
   * Convert from the type when the unit value is BPM
   */
  _fromType(val) {
    if (this.units === "bpm" && this.multiplier) {
      return 1 / (60 / val / this.multiplier);
    } else {
      return super._fromType(val);
    }
  }
  /**
   * Special case of type conversion where the units === "bpm"
   */
  _toType(val) {
    if (this.units === "bpm" && this.multiplier) {
      return val / this.multiplier * 60;
    } else {
      return super._toType(val);
    }
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._multiplier;
  }
  set multiplier(m) {
    const currentVal = this.value;
    this._multiplier = m;
    this.cancelScheduledValues(0);
    this.setValueAtTime(currentVal, 0);
  }
}
class TickSignal extends Signal {
  constructor() {
    const options2 = optionsFromArguments(TickSignal.getDefaults(), arguments, ["value"]);
    super(options2);
    this.name = "TickSignal";
    this.input = this._param = new TickParam({
      context: this.context,
      convert: options2.convert,
      multiplier: options2.multiplier,
      param: this._constantSource.offset,
      units: options2.units,
      value: options2.value
    });
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  ticksToTime(ticks, when) {
    return this._param.ticksToTime(ticks, when);
  }
  timeToTicks(duration2, when) {
    return this._param.timeToTicks(duration2, when);
  }
  getTimeOfTick(tick) {
    return this._param.getTimeOfTick(tick);
  }
  getDurationOfTicks(ticks, time2) {
    return this._param.getDurationOfTicks(ticks, time2);
  }
  getTicksAtTime(time2) {
    return this._param.getTicksAtTime(time2);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._param.multiplier;
  }
  set multiplier(m) {
    this._param.multiplier = m;
  }
  dispose() {
    super.dispose();
    this._param.dispose();
    return this;
  }
}
class TickSource extends ToneWithContext {
  constructor() {
    const options2 = optionsFromArguments(TickSource.getDefaults(), arguments, ["frequency"]);
    super(options2);
    this.name = "TickSource";
    this._state = new StateTimeline();
    this._tickOffset = new Timeline();
    this._ticksAtTime = new Timeline();
    this._secondsAtTime = new Timeline();
    this.frequency = new TickSignal({
      context: this.context,
      units: options2.units,
      value: options2.frequency
    });
    readOnly(this, "frequency");
    this._state.setStateAtTime("stopped", 0);
    this.setTicksAtTime(0, 0);
  }
  static getDefaults() {
    return Object.assign({
      frequency: 1,
      units: "hertz"
    }, ToneWithContext.getDefaults());
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset The number of ticks to start the source at
   */
  start(time2, offset2) {
    const computedTime = this.toSeconds(time2);
    if (this._state.getValueAtTime(computedTime) !== "started") {
      this._state.setStateAtTime("started", computedTime);
      if (isDefined(offset2)) {
        this.setTicksAtTime(offset2, computedTime);
      }
      this._ticksAtTime.cancel(computedTime);
      this._secondsAtTime.cancel(computedTime);
    }
    return this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   */
  stop(time2) {
    const computedTime = this.toSeconds(time2);
    if (this._state.getValueAtTime(computedTime) === "stopped") {
      const event = this._state.get(computedTime);
      if (event && event.time > 0) {
        this._tickOffset.cancel(event.time);
        this._state.cancel(event.time);
      }
    }
    this._state.cancel(computedTime);
    this._state.setStateAtTime("stopped", computedTime);
    this.setTicksAtTime(0, computedTime);
    this._ticksAtTime.cancel(computedTime);
    this._secondsAtTime.cancel(computedTime);
    return this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(time2) {
    const computedTime = this.toSeconds(time2);
    if (this._state.getValueAtTime(computedTime) === "started") {
      this._state.setStateAtTime("paused", computedTime);
      this._ticksAtTime.cancel(computedTime);
      this._secondsAtTime.cancel(computedTime);
    }
    return this;
  }
  /**
   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.
   * @param time When to clear the events after
   */
  cancel(time2) {
    time2 = this.toSeconds(time2);
    this._state.cancel(time2);
    this._tickOffset.cancel(time2);
    this._ticksAtTime.cancel(time2);
    this._secondsAtTime.cancel(time2);
    return this;
  }
  /**
   * Get the elapsed ticks at the given time
   * @param  time  When to get the tick value
   * @return The number of ticks
   */
  getTicksAtTime(time2) {
    const computedTime = this.toSeconds(time2);
    const stopEvent = this._state.getLastState("stopped", computedTime);
    const memoizedEvent = this._ticksAtTime.get(computedTime);
    const tmpEvent = {
      state: "paused",
      time: computedTime
    };
    this._state.add(tmpEvent);
    let lastState = memoizedEvent ? memoizedEvent : stopEvent;
    let elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;
    let eventToMemoize = null;
    this._state.forEachBetween(lastState.time, computedTime + this.sampleTime, (e2) => {
      let periodStartTime = lastState.time;
      const offsetEvent = this._tickOffset.get(e2.time);
      if (offsetEvent && offsetEvent.time >= lastState.time) {
        elapsedTicks = offsetEvent.ticks;
        periodStartTime = offsetEvent.time;
      }
      if (lastState.state === "started" && e2.state !== "started") {
        elapsedTicks += this.frequency.getTicksAtTime(e2.time) - this.frequency.getTicksAtTime(periodStartTime);
        if (e2.time !== tmpEvent.time) {
          eventToMemoize = {
            state: e2.state,
            time: e2.time,
            ticks: elapsedTicks
          };
        }
      }
      lastState = e2;
    });
    this._state.remove(tmpEvent);
    if (eventToMemoize) {
      this._ticksAtTime.add(eventToMemoize);
    }
    return elapsedTicks;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked. Returns -1 when stopped.
   */
  get ticks() {
    return this.getTicksAtTime(this.now());
  }
  set ticks(t) {
    this.setTicksAtTime(t, this.now());
  }
  /**
   * The time since ticks=0 that the TickSource has been running. Accounts
   * for tempo curves
   */
  get seconds() {
    return this.getSecondsAtTime(this.now());
  }
  set seconds(s) {
    const now = this.now();
    const ticks = this.frequency.timeToTicks(s, now);
    this.setTicksAtTime(ticks, now);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(time2) {
    time2 = this.toSeconds(time2);
    const stopEvent = this._state.getLastState("stopped", time2);
    const tmpEvent = { state: "paused", time: time2 };
    this._state.add(tmpEvent);
    const memoizedEvent = this._secondsAtTime.get(time2);
    let lastState = memoizedEvent ? memoizedEvent : stopEvent;
    let elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;
    let eventToMemoize = null;
    this._state.forEachBetween(lastState.time, time2 + this.sampleTime, (e2) => {
      let periodStartTime = lastState.time;
      const offsetEvent = this._tickOffset.get(e2.time);
      if (offsetEvent && offsetEvent.time >= lastState.time) {
        elapsedSeconds = offsetEvent.seconds;
        periodStartTime = offsetEvent.time;
      }
      if (lastState.state === "started" && e2.state !== "started") {
        elapsedSeconds += e2.time - periodStartTime;
        if (e2.time !== tmpEvent.time) {
          eventToMemoize = {
            state: e2.state,
            time: e2.time,
            seconds: elapsedSeconds
          };
        }
      }
      lastState = e2;
    });
    this._state.remove(tmpEvent);
    if (eventToMemoize) {
      this._secondsAtTime.add(eventToMemoize);
    }
    return elapsedSeconds;
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(ticks, time2) {
    time2 = this.toSeconds(time2);
    this._tickOffset.cancel(time2);
    this._tickOffset.add({
      seconds: this.frequency.getDurationOfTicks(ticks, time2),
      ticks,
      time: time2
    });
    this._ticksAtTime.cancel(time2);
    this._secondsAtTime.cancel(time2);
    return this;
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   */
  getStateAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this._state.getValueAtTime(time2);
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(tick, before = this.now()) {
    const offset2 = this._tickOffset.get(before);
    const event = this._state.get(before);
    const startTime = Math.max(offset2.time, event.time);
    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset2.ticks;
    return this.frequency.getTimeOfTick(absoluteTicks);
  }
  /**
   * Invoke the callback event at all scheduled ticks between the
   * start time and the end time
   * @param  startTime  The beginning of the search range
   * @param  endTime    The end of the search range
   * @param  callback   The callback to invoke with each tick
   */
  forEachTickBetween(startTime, endTime, callback) {
    let lastStateEvent = this._state.get(startTime);
    this._state.forEachBetween(startTime, endTime, (event) => {
      if (lastStateEvent && lastStateEvent.state === "started" && event.state !== "started") {
        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);
      }
      lastStateEvent = event;
    });
    let error2 = null;
    if (lastStateEvent && lastStateEvent.state === "started") {
      const maxStartTime = Math.max(lastStateEvent.time, startTime);
      const startTicks = this.frequency.getTicksAtTime(maxStartTime);
      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);
      const diff = startTicks - ticksAtStart;
      let offset2 = Math.ceil(diff) - diff;
      offset2 = EQ(offset2, 1) ? 0 : offset2;
      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset2);
      while (nextTickTime < endTime) {
        try {
          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));
        } catch (e2) {
          error2 = e2;
          break;
        }
        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);
      }
    }
    if (error2) {
      throw error2;
    }
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._state.dispose();
    this._tickOffset.dispose();
    this._ticksAtTime.dispose();
    this._secondsAtTime.dispose();
    this.frequency.dispose();
    return this;
  }
}
class Clock extends ToneWithContext {
  constructor() {
    const options2 = optionsFromArguments(Clock.getDefaults(), arguments, [
      "callback",
      "frequency"
    ]);
    super(options2);
    this.name = "Clock";
    this.callback = noOp;
    this._lastUpdate = 0;
    this._state = new StateTimeline("stopped");
    this._boundLoop = this._loop.bind(this);
    this.callback = options2.callback;
    this._tickSource = new TickSource({
      context: this.context,
      frequency: options2.frequency,
      units: options2.units
    });
    this._lastUpdate = 0;
    this.frequency = this._tickSource.frequency;
    readOnly(this, "frequency");
    this._state.setStateAtTime("stopped", 0);
    this.context.on("tick", this._boundLoop);
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      callback: noOp,
      frequency: 1,
      units: "hertz"
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this._state.getValueAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset  Where the tick counter starts counting from.
   */
  start(time2, offset2) {
    assertContextRunning(this.context);
    const computedTime = this.toSeconds(time2);
    this.log("start", computedTime);
    if (this._state.getValueAtTime(computedTime) !== "started") {
      this._state.setStateAtTime("started", computedTime);
      this._tickSource.start(computedTime, offset2);
      if (computedTime < this._lastUpdate) {
        this.emit("start", computedTime, offset2);
      }
    }
    return this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   * @example
   * const clock = new Tone.Clock(time => {
   * 	console.log(time);
   * }, 1);
   * clock.start();
   * // stop the clock after 10 seconds
   * clock.stop("+10");
   */
  stop(time2) {
    const computedTime = this.toSeconds(time2);
    this.log("stop", computedTime);
    this._state.cancel(computedTime);
    this._state.setStateAtTime("stopped", computedTime);
    this._tickSource.stop(computedTime);
    if (computedTime < this._lastUpdate) {
      this.emit("stop", computedTime);
    }
    return this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(time2) {
    const computedTime = this.toSeconds(time2);
    if (this._state.getValueAtTime(computedTime) === "started") {
      this._state.setStateAtTime("paused", computedTime);
      this._tickSource.pause(computedTime);
      if (computedTime < this._lastUpdate) {
        this.emit("pause", computedTime);
      }
    }
    return this;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked.
   */
  get ticks() {
    return Math.ceil(this.getTicksAtTime(this.now()));
  }
  set ticks(t) {
    this._tickSource.ticks = t;
  }
  /**
   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
   */
  get seconds() {
    return this._tickSource.seconds;
  }
  set seconds(s) {
    this._tickSource.seconds = s;
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(time2) {
    return this._tickSource.getSecondsAtTime(time2);
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(ticks, time2) {
    this._tickSource.setTicksAtTime(ticks, time2);
    return this;
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(tick, before = this.now()) {
    return this._tickSource.getTimeOfTick(tick, before);
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(time2) {
    return this._tickSource.getTicksAtTime(time2);
  }
  /**
   * Get the time of the next tick
   * @param  offset The tick number.
   */
  nextTickTime(offset2, when) {
    const computedTime = this.toSeconds(when);
    const currentTick = this.getTicksAtTime(computedTime);
    return this._tickSource.getTimeOfTick(currentTick + offset2, computedTime);
  }
  /**
   * The scheduling loop.
   */
  _loop() {
    const startTime = this._lastUpdate;
    const endTime = this.now();
    this._lastUpdate = endTime;
    this.log("loop", startTime, endTime);
    if (startTime !== endTime) {
      this._state.forEachBetween(startTime, endTime, (e2) => {
        switch (e2.state) {
          case "started":
            const offset2 = this._tickSource.getTicksAtTime(e2.time);
            this.emit("start", e2.time, offset2);
            break;
          case "stopped":
            if (e2.time !== 0) {
              this.emit("stop", e2.time);
            }
            break;
          case "paused":
            this.emit("pause", e2.time);
            break;
        }
      });
      this._tickSource.forEachTickBetween(startTime, endTime, (time2, ticks) => {
        this.callback(time2, ticks);
      });
    }
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   * @example
   * const clock = new Tone.Clock();
   * clock.start("+0.1");
   * clock.getStateAtTime("+0.1"); // returns "started"
   */
  getStateAtTime(time2) {
    const computedTime = this.toSeconds(time2);
    return this._state.getValueAtTime(computedTime);
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this.context.off("tick", this._boundLoop);
    this._tickSource.dispose();
    this._state.dispose();
    return this;
  }
}
Emitter.mixin(Clock);
class Delay extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Delay.getDefaults(), arguments, [
      "delayTime",
      "maxDelay"
    ]);
    super(options2);
    this.name = "Delay";
    const maxDelayInSeconds = this.toSeconds(options2.maxDelay);
    this._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options2.delayTime));
    this._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);
    this.delayTime = new Param({
      context: this.context,
      param: this._delayNode.delayTime,
      units: "time",
      value: options2.delayTime,
      minValue: 0,
      maxValue: this.maxDelay
    });
    readOnly(this, "delayTime");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      delayTime: 0,
      maxDelay: 1
    });
  }
  /**
   * The maximum delay time. This cannot be changed after
   * the value is passed into the constructor.
   */
  get maxDelay() {
    return this._maxDelay;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._delayNode.disconnect();
    this.delayTime.dispose();
    return this;
  }
}
class Volume extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Volume.getDefaults(), arguments, [
      "volume"
    ]);
    super(options2);
    this.name = "Volume";
    this.input = this.output = new Gain({
      context: this.context,
      gain: options2.volume,
      units: "decibels"
    });
    this.volume = this.output.gain;
    readOnly(this, "volume");
    this._unmutedVolume = options2.volume;
    this.mute = options2.mute;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const vol = new Tone.Volume(-12).toDestination();
   * const osc = new Tone.Oscillator().connect(vol).start();
   * // mute the output
   * vol.mute = true;
   */
  get mute() {
    return this.volume.value === -Infinity;
  }
  set mute(mute) {
    if (!this.mute && mute) {
      this._unmutedVolume = this.volume.value;
      this.volume.value = -Infinity;
    } else if (this.mute && !mute) {
      this.volume.value = this._unmutedVolume;
    }
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this.input.dispose();
    this.volume.dispose();
    return this;
  }
}
class DestinationClass extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(DestinationClass.getDefaults(), arguments);
    super(options2);
    this.name = "Destination";
    this.input = new Volume({ context: this.context });
    this.output = new Gain({ context: this.context });
    this.volume = this.input.volume;
    connectSeries(this.input, this.output, this.context.rawContext.destination);
    this.mute = options2.mute;
    this._internalChannels = [
      this.input,
      this.context.rawContext.destination,
      this.output
    ];
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const oscillator = new Tone.Oscillator().start().toDestination();
   * setTimeout(() => {
   * 	// mute the output
   * 	Tone.Destination.mute = true;
   * }, 1000);
   */
  get mute() {
    return this.input.mute;
  }
  set mute(mute) {
    this.input.mute = mute;
  }
  /**
   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
   * chained in the master effects chain.
   * @param args All arguments will be connected in a row and the Master will be routed through it.
   * @example
   * // route all audio through a filter and compressor
   * const lowpass = new Tone.Filter(800, "lowpass");
   * const compressor = new Tone.Compressor(-18);
   * Tone.Destination.chain(lowpass, compressor);
   */
  chain(...args) {
    this.input.disconnect();
    args.unshift(this.input);
    args.push(this.output);
    connectSeries(...args);
    return this;
  }
  /**
   * The maximum number of channels the system can output
   * @example
   * console.log(Tone.Destination.maxChannelCount);
   */
  get maxChannelCount() {
    return this.context.rawContext.destination.maxChannelCount;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this.volume.dispose();
    return this;
  }
}
onContextInit((context2) => {
  context2.destination = new DestinationClass({ context: context2 });
});
onContextClose((context2) => {
  context2.destination.dispose();
});
class ListenerClass extends ToneAudioNode {
  constructor() {
    super(...arguments);
    this.name = "Listener";
    this.positionX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionX
    });
    this.positionY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionY
    });
    this.positionZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.positionZ
    });
    this.forwardX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardX
    });
    this.forwardY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardY
    });
    this.forwardZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardZ
    });
    this.upX = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upX
    });
    this.upY = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upY
    });
    this.upZ = new Param({
      context: this.context,
      param: this.context.rawContext.listener.upZ
    });
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      forwardX: 0,
      forwardY: 0,
      forwardZ: -1,
      upX: 0,
      upY: 1,
      upZ: 0
    });
  }
  dispose() {
    super.dispose();
    this.positionX.dispose();
    this.positionY.dispose();
    this.positionZ.dispose();
    this.forwardX.dispose();
    this.forwardY.dispose();
    this.forwardZ.dispose();
    this.upX.dispose();
    this.upY.dispose();
    this.upZ.dispose();
    return this;
  }
}
onContextInit((context2) => {
  context2.listener = new ListenerClass({ context: context2 });
});
onContextClose((context2) => {
  context2.listener.dispose();
});
class ToneAudioBuffers extends Tone {
  constructor() {
    super();
    this.name = "ToneAudioBuffers";
    this._buffers = /* @__PURE__ */ new Map();
    this._loadingCount = 0;
    const options2 = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    this.baseUrl = options2.baseUrl;
    Object.keys(options2.urls).forEach((name) => {
      this._loadingCount++;
      const url = options2.urls[name];
      this.add(name, url, this._bufferLoaded.bind(this, options2.onload), options2.onerror);
    });
  }
  static getDefaults() {
    return {
      baseUrl: "",
      onerror: noOp,
      onload: noOp,
      urls: {}
    };
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param  name  The key or index of the buffer.
   */
  has(name) {
    return this._buffers.has(name.toString());
  }
  /**
   * Get a buffer by name. If an array was loaded,
   * then use the array index.
   * @param  name  The key or index of the buffer.
   */
  get(name) {
    assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);
    return this._buffers.get(name.toString());
  }
  /**
   * A buffer was loaded. decrement the counter.
   */
  _bufferLoaded(callback) {
    this._loadingCount--;
    if (this._loadingCount === 0 && callback) {
      callback();
    }
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return Array.from(this._buffers).every(([_23, buffer]) => buffer.loaded);
  }
  /**
   * Add a buffer by name and url to the Buffers
   * @param  name      A unique name to give the buffer
   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   * @param  onerror  Invoked if the buffer can't be loaded
   */
  add(name, url, callback = noOp, onerror = noOp) {
    if (isString(url)) {
      if (this.baseUrl && url.trim().substring(0, 11).toLowerCase() === "data:audio/") {
        this.baseUrl = "";
      }
      this._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));
    } else {
      this._buffers.set(name.toString(), new ToneAudioBuffer(url, callback, onerror));
    }
    return this;
  }
  dispose() {
    super.dispose();
    this._buffers.forEach((buffer) => buffer.dispose());
    this._buffers.clear();
    return this;
  }
}
class MidiClass extends FrequencyClass {
  constructor() {
    super(...arguments);
    this.name = "MidiClass";
    this.defaultUnits = "midi";
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(freq) {
    return ftom(super._frequencyToUnits(freq));
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(ticks) {
    return ftom(super._ticksToUnits(ticks));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(beats) {
    return ftom(super._beatsToUnits(beats));
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(seconds) {
    return ftom(super._secondsToUnits(seconds));
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toMidi(); // 60
   */
  toMidi() {
    return this.valueOf();
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toFrequency(); // 261.6255653005986
   */
  toFrequency() {
    return mtof(this.toMidi());
  }
  /**
   * Transposes the frequency by the given number of semitones.
   * @return A new transposed MidiClass
   * @example
   * Tone.Midi("A4").transpose(3); // "C5"
   */
  transpose(interval) {
    return new MidiClass(this.context, this.toMidi() + interval);
  }
}
class TicksClass extends TransportTimeClass {
  constructor() {
    super(...arguments);
    this.name = "Ticks";
    this.defaultUnits = "i";
  }
  /**
   * Get the current time in the given units
   */
  _now() {
    return this.context.transport.ticks;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(beats) {
    return this._getPPQ() * beats;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(seconds) {
    return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(ticks) {
    return ticks;
  }
  /**
   * Return the time in ticks
   */
  toTicks() {
    return this.valueOf();
  }
  /**
   * Return the time in seconds
   */
  toSeconds() {
    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
  }
}
class DrawClass extends ToneWithContext {
  constructor() {
    super(...arguments);
    this.name = "Draw";
    this.expiration = 0.25;
    this.anticipation = 8e-3;
    this._events = new Timeline();
    this._boundDrawLoop = this._drawLoop.bind(this);
    this._animationFrame = -1;
  }
  /**
   * Schedule a function at the given time to be invoked
   * on the nearest animation frame.
   * @param  callback  Callback is invoked at the given time.
   * @param  time      The time relative to the AudioContext time to invoke the callback.
   * @example
   * Tone.Transport.scheduleRepeat(time => {
   * 	Tone.Draw.schedule(() => console.log(time), time);
   * }, 1);
   * Tone.Transport.start();
   */
  schedule(callback, time2) {
    this._events.add({
      callback,
      time: this.toSeconds(time2)
    });
    if (this._events.length === 1) {
      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
    }
    return this;
  }
  /**
   * Cancel events scheduled after the given time
   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
   */
  cancel(after) {
    this._events.cancel(this.toSeconds(after));
    return this;
  }
  /**
   * The draw loop
   */
  _drawLoop() {
    const now = this.context.currentTime;
    this._events.forEachBefore(now + this.anticipation, (event) => {
      if (now - event.time <= this.expiration) {
        event.callback();
      }
      this._events.remove(event);
    });
    if (this._events.length > 0) {
      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
    }
  }
  dispose() {
    super.dispose();
    this._events.dispose();
    cancelAnimationFrame(this._animationFrame);
    return this;
  }
}
onContextInit((context2) => {
  context2.draw = new DrawClass({ context: context2 });
});
onContextClose((context2) => {
  context2.draw.dispose();
});
class IntervalTimeline extends Tone {
  constructor() {
    super(...arguments);
    this.name = "IntervalTimeline";
    this._root = null;
    this._length = 0;
  }
  /**
   * The event to add to the timeline. All events must
   * have a time and duration value
   * @param  event  The event to add to the timeline
   */
  add(event) {
    assert(isDefined(event.time), "Events must have a time property");
    assert(isDefined(event.duration), "Events must have a duration parameter");
    event.time = event.time.valueOf();
    let node = new IntervalNode(event.time, event.time + event.duration, event);
    if (this._root === null) {
      this._root = node;
    } else {
      this._root.insert(node);
    }
    this._length++;
    while (node !== null) {
      node.updateHeight();
      node.updateMax();
      this._rebalance(node);
      node = node.parent;
    }
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  event  The event to remove from the timeline
   */
  remove(event) {
    if (this._root !== null) {
      const results = [];
      this._root.search(event.time, results);
      for (const node of results) {
        if (node.event === event) {
          this._removeNode(node);
          this._length--;
          break;
        }
      }
    }
    return this;
  }
  /**
   * The number of items in the timeline.
   * @readOnly
   */
  get length() {
    return this._length;
  }
  /**
   * Remove events whose time time is after the given time
   * @param  after  The time to query.
   */
  cancel(after) {
    this.forEachFrom(after, (event) => this.remove(event));
    return this;
  }
  /**
   * Set the root node as the given node
   */
  _setRoot(node) {
    this._root = node;
    if (this._root !== null) {
      this._root.parent = null;
    }
  }
  /**
   * Replace the references to the node in the node's parent
   * with the replacement node.
   */
  _replaceNodeInParent(node, replacement) {
    if (node.parent !== null) {
      if (node.isLeftChild()) {
        node.parent.left = replacement;
      } else {
        node.parent.right = replacement;
      }
      this._rebalance(node.parent);
    } else {
      this._setRoot(replacement);
    }
  }
  /**
   * Remove the node from the tree and replace it with
   * a successor which follows the schema.
   */
  _removeNode(node) {
    if (node.left === null && node.right === null) {
      this._replaceNodeInParent(node, null);
    } else if (node.right === null) {
      this._replaceNodeInParent(node, node.left);
    } else if (node.left === null) {
      this._replaceNodeInParent(node, node.right);
    } else {
      const balance = node.getBalance();
      let replacement;
      let temp = null;
      if (balance > 0) {
        if (node.left.right === null) {
          replacement = node.left;
          replacement.right = node.right;
          temp = replacement;
        } else {
          replacement = node.left.right;
          while (replacement.right !== null) {
            replacement = replacement.right;
          }
          if (replacement.parent) {
            replacement.parent.right = replacement.left;
            temp = replacement.parent;
            replacement.left = node.left;
            replacement.right = node.right;
          }
        }
      } else if (node.right.left === null) {
        replacement = node.right;
        replacement.left = node.left;
        temp = replacement;
      } else {
        replacement = node.right.left;
        while (replacement.left !== null) {
          replacement = replacement.left;
        }
        if (replacement.parent) {
          replacement.parent.left = replacement.right;
          temp = replacement.parent;
          replacement.left = node.left;
          replacement.right = node.right;
        }
      }
      if (node.parent !== null) {
        if (node.isLeftChild()) {
          node.parent.left = replacement;
        } else {
          node.parent.right = replacement;
        }
      } else {
        this._setRoot(replacement);
      }
      if (temp) {
        this._rebalance(temp);
      }
    }
    node.dispose();
  }
  /**
   * Rotate the tree to the left
   */
  _rotateLeft(node) {
    const parent = node.parent;
    const isLeftChild = node.isLeftChild();
    const pivotNode = node.right;
    if (pivotNode) {
      node.right = pivotNode.left;
      pivotNode.left = node;
    }
    if (parent !== null) {
      if (isLeftChild) {
        parent.left = pivotNode;
      } else {
        parent.right = pivotNode;
      }
    } else {
      this._setRoot(pivotNode);
    }
  }
  /**
   * Rotate the tree to the right
   */
  _rotateRight(node) {
    const parent = node.parent;
    const isLeftChild = node.isLeftChild();
    const pivotNode = node.left;
    if (pivotNode) {
      node.left = pivotNode.right;
      pivotNode.right = node;
    }
    if (parent !== null) {
      if (isLeftChild) {
        parent.left = pivotNode;
      } else {
        parent.right = pivotNode;
      }
    } else {
      this._setRoot(pivotNode);
    }
  }
  /**
   * Balance the BST
   */
  _rebalance(node) {
    const balance = node.getBalance();
    if (balance > 1 && node.left) {
      if (node.left.getBalance() < 0) {
        this._rotateLeft(node.left);
      } else {
        this._rotateRight(node);
      }
    } else if (balance < -1 && node.right) {
      if (node.right.getBalance() > 0) {
        this._rotateRight(node.right);
      } else {
        this._rotateLeft(node);
      }
    }
  }
  /**
   * Get an event whose time and duration span the give time. Will
   * return the match whose "time" value is closest to the given time.
   * @return  The event which spans the desired time
   */
  get(time2) {
    if (this._root !== null) {
      const results = [];
      this._root.search(time2, results);
      if (results.length > 0) {
        let max = results[0];
        for (let i = 1; i < results.length; i++) {
          if (results[i].low > max.low) {
            max = results[i];
          }
        }
        return max.event;
      }
    }
    return null;
  }
  /**
   * Iterate over everything in the timeline.
   * @param  callback The callback to invoke with every item
   */
  forEach(callback) {
    if (this._root !== null) {
      const allNodes = [];
      this._root.traverse((node) => allNodes.push(node));
      allNodes.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the given time
   * overlaps with the time and duration time of the event.
   * @param  time The time to check if items are overlapping
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(time2, callback) {
    if (this._root !== null) {
      const results = [];
      this._root.search(time2, results);
      results.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the time is greater
   * than or equal to the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(time2, callback) {
    if (this._root !== null) {
      const results = [];
      this._root.searchAfter(time2, results);
      results.forEach((node) => {
        if (node.event) {
          callback(node.event);
        }
      });
    }
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    if (this._root !== null) {
      this._root.traverse((node) => node.dispose());
    }
    this._root = null;
    return this;
  }
}
class IntervalNode {
  constructor(low, high, event) {
    this._left = null;
    this._right = null;
    this.parent = null;
    this.height = 0;
    this.event = event;
    this.low = low;
    this.high = high;
    this.max = this.high;
  }
  /**
   * Insert a node into the correct spot in the tree
   */
  insert(node) {
    if (node.low <= this.low) {
      if (this.left === null) {
        this.left = node;
      } else {
        this.left.insert(node);
      }
    } else if (this.right === null) {
      this.right = node;
    } else {
      this.right.insert(node);
    }
  }
  /**
   * Search the tree for nodes which overlap
   * with the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  search(point, results) {
    if (point > this.max) {
      return;
    }
    if (this.left !== null) {
      this.left.search(point, results);
    }
    if (this.low <= point && this.high > point) {
      results.push(this);
    }
    if (this.low > point) {
      return;
    }
    if (this.right !== null) {
      this.right.search(point, results);
    }
  }
  /**
   * Search the tree for nodes which are less
   * than the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  searchAfter(point, results) {
    if (this.low >= point) {
      results.push(this);
      if (this.left !== null) {
        this.left.searchAfter(point, results);
      }
    }
    if (this.right !== null) {
      this.right.searchAfter(point, results);
    }
  }
  /**
   * Invoke the callback on this element and both it's branches
   * @param  {Function}  callback
   */
  traverse(callback) {
    callback(this);
    if (this.left !== null) {
      this.left.traverse(callback);
    }
    if (this.right !== null) {
      this.right.traverse(callback);
    }
  }
  /**
   * Update the height of the node
   */
  updateHeight() {
    if (this.left !== null && this.right !== null) {
      this.height = Math.max(this.left.height, this.right.height) + 1;
    } else if (this.right !== null) {
      this.height = this.right.height + 1;
    } else if (this.left !== null) {
      this.height = this.left.height + 1;
    } else {
      this.height = 0;
    }
  }
  /**
   * Update the height of the node
   */
  updateMax() {
    this.max = this.high;
    if (this.left !== null) {
      this.max = Math.max(this.max, this.left.max);
    }
    if (this.right !== null) {
      this.max = Math.max(this.max, this.right.max);
    }
  }
  /**
   * The balance is how the leafs are distributed on the node
   * @return  Negative numbers are balanced to the right
   */
  getBalance() {
    let balance = 0;
    if (this.left !== null && this.right !== null) {
      balance = this.left.height - this.right.height;
    } else if (this.left !== null) {
      balance = this.left.height + 1;
    } else if (this.right !== null) {
      balance = -(this.right.height + 1);
    }
    return balance;
  }
  /**
   * @returns true if this node is the left child of its parent
   */
  isLeftChild() {
    return this.parent !== null && this.parent.left === this;
  }
  /**
   * get/set the left node
   */
  get left() {
    return this._left;
  }
  set left(node) {
    this._left = node;
    if (node !== null) {
      node.parent = this;
    }
    this.updateHeight();
    this.updateMax();
  }
  /**
   * get/set the right node
   */
  get right() {
    return this._right;
  }
  set right(node) {
    this._right = node;
    if (node !== null) {
      node.parent = this;
    }
    this.updateHeight();
    this.updateMax();
  }
  /**
   * null out references.
   */
  dispose() {
    this.parent = null;
    this._left = null;
    this._right = null;
    this.event = null;
  }
}
class TimelineValue extends Tone {
  /**
   * @param initialValue The value to return if there is no scheduled values
   */
  constructor(initialValue) {
    super();
    this.name = "TimelineValue";
    this._timeline = new Timeline({
      memory: 10
    });
    this._initialValue = initialValue;
  }
  /**
   * Set the value at the given time
   */
  set(value, time2) {
    this._timeline.add({
      value,
      time: time2
    });
    return this;
  }
  /**
   * Get the value at the given time
   */
  get(time2) {
    const event = this._timeline.get(time2);
    if (event) {
      return event.value;
    } else {
      return this._initialValue;
    }
  }
}
class SignalOperator extends ToneAudioNode {
  constructor() {
    super(optionsFromArguments(SignalOperator.getDefaults(), arguments, [
      "context"
    ]));
  }
  connect(destination, outputNum = 0, inputNum = 0) {
    connectSignal(this, destination, outputNum, inputNum);
    return this;
  }
}
class WaveShaper extends SignalOperator {
  constructor() {
    const options2 = optionsFromArguments(WaveShaper.getDefaults(), arguments, ["mapping", "length"]);
    super(options2);
    this.name = "WaveShaper";
    this._shaper = this.context.createWaveShaper();
    this.input = this._shaper;
    this.output = this._shaper;
    if (isArray(options2.mapping) || options2.mapping instanceof Float32Array) {
      this.curve = Float32Array.from(options2.mapping);
    } else if (isFunction(options2.mapping)) {
      this.setMap(options2.mapping, options2.length);
    }
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      length: 1024
    });
  }
  /**
   * Uses a mapping function to set the value of the curve.
   * @param mapping The function used to define the values.
   *                The mapping function take two arguments:
   *                the first is the value at the current position
   *                which goes from -1 to 1 over the number of elements
   *                in the curve array. The second argument is the array position.
   * @example
   * const shaper = new Tone.WaveShaper();
   * // map the input signal from [-1, 1] to [0, 10]
   * shaper.setMap((val, index) => (val + 1) * 5);
   */
  setMap(mapping, length = 1024) {
    const array2 = new Float32Array(length);
    for (let i = 0, len = length; i < len; i++) {
      const normalized = i / (len - 1) * 2 - 1;
      array2[i] = mapping(normalized, i);
    }
    this.curve = array2;
    return this;
  }
  /**
   * The array to set as the waveshaper curve. For linear curves
   * array length does not make much difference, but for complex curves
   * longer arrays will provide smoother interpolation.
   */
  get curve() {
    return this._shaper.curve;
  }
  set curve(mapping) {
    this._shaper.curve = mapping;
  }
  /**
   * Specifies what type of oversampling (if any) should be used when
   * applying the shaping curve. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(oversampling) {
    const isOverSampleType = ["none", "2x", "4x"].some((str) => str.includes(oversampling));
    assert(isOverSampleType, "oversampling must be either 'none', '2x', or '4x'");
    this._shaper.oversample = oversampling;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._shaper.disconnect();
    return this;
  }
}
class Pow extends SignalOperator {
  constructor() {
    const options2 = optionsFromArguments(Pow.getDefaults(), arguments, [
      "value"
    ]);
    super(options2);
    this.name = "Pow";
    this._exponentScaler = this.input = this.output = new WaveShaper({
      context: this.context,
      mapping: this._expFunc(options2.value),
      length: 8192
    });
    this._exponent = options2.value;
  }
  static getDefaults() {
    return Object.assign(SignalOperator.getDefaults(), {
      value: 1
    });
  }
  /**
   * the function which maps the waveshaper
   * @param exponent exponent value
   */
  _expFunc(exponent) {
    return (val) => {
      return Math.pow(Math.abs(val), exponent);
    };
  }
  /**
   * The value of the exponent.
   */
  get value() {
    return this._exponent;
  }
  set value(exponent) {
    this._exponent = exponent;
    this._exponentScaler.setMap(this._expFunc(this._exponent));
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._exponentScaler.dispose();
    return this;
  }
}
class TransportEvent {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(transport, opts) {
    this.id = TransportEvent._eventId++;
    this._remainderTime = 0;
    const options2 = Object.assign(TransportEvent.getDefaults(), opts);
    this.transport = transport;
    this.callback = options2.callback;
    this._once = options2.once;
    this.time = Math.floor(options2.time);
    this._remainderTime = options2.time - this.time;
  }
  static getDefaults() {
    return {
      callback: noOp,
      once: false,
      time: 0
    };
  }
  /**
   * Get the time and remainder time.
   */
  get floatTime() {
    return this.time + this._remainderTime;
  }
  /**
   * Invoke the event callback.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(time2) {
    if (this.callback) {
      const tickDuration = this.transport.bpm.getDurationOfTicks(1, time2);
      this.callback(time2 + this._remainderTime * tickDuration);
      if (this._once) {
        this.transport.clear(this.id);
      }
    }
  }
  /**
   * Clean up
   */
  dispose() {
    this.callback = void 0;
    return this;
  }
}
TransportEvent._eventId = 0;
class TransportRepeatEvent extends TransportEvent {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(transport, opts) {
    super(transport, opts);
    this._currentId = -1;
    this._nextId = -1;
    this._nextTick = this.time;
    this._boundRestart = this._restart.bind(this);
    const options2 = Object.assign(TransportRepeatEvent.getDefaults(), opts);
    this.duration = options2.duration;
    this._interval = options2.interval;
    this._nextTick = options2.time;
    this.transport.on("start", this._boundRestart);
    this.transport.on("loopStart", this._boundRestart);
    this.transport.on("ticks", this._boundRestart);
    this.context = this.transport.context;
    this._restart();
  }
  static getDefaults() {
    return Object.assign({}, TransportEvent.getDefaults(), {
      duration: Infinity,
      interval: 1,
      once: false
    });
  }
  /**
   * Invoke the callback. Returns the tick time which
   * the next event should be scheduled at.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(time2) {
    this._createEvents(time2);
    super.invoke(time2);
  }
  /**
   * Create an event on the transport on the nextTick
   */
  _createEvent() {
    if (LT(this._nextTick, this.floatTime + this.duration)) {
      return this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
    }
    return -1;
  }
  /**
   * Push more events onto the timeline to keep up with the position of the timeline
   */
  _createEvents(time2) {
    if (LT(this._nextTick + this._interval, this.floatTime + this.duration)) {
      this._nextTick += this._interval;
      this._currentId = this._nextId;
      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());
    }
  }
  /**
   * Re-compute the events when the transport time has changed from a start/ticks/loopStart event
   */
  _restart(time2) {
    this.transport.clear(this._currentId);
    this.transport.clear(this._nextId);
    this._nextTick = this.floatTime;
    const ticks = this.transport.getTicksAtTime(time2);
    if (GT(ticks, this.time)) {
      this._nextTick = this.floatTime + Math.ceil((ticks - this.floatTime) / this._interval) * this._interval;
    }
    this._currentId = this._createEvent();
    this._nextTick += this._interval;
    this._nextId = this._createEvent();
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this.transport.clear(this._currentId);
    this.transport.clear(this._nextId);
    this.transport.off("start", this._boundRestart);
    this.transport.off("loopStart", this._boundRestart);
    this.transport.off("ticks", this._boundRestart);
    return this;
  }
}
class TransportClass extends ToneWithContext {
  constructor() {
    const options2 = optionsFromArguments(TransportClass.getDefaults(), arguments);
    super(options2);
    this.name = "Transport";
    this._loop = new TimelineValue(false);
    this._loopStart = 0;
    this._loopEnd = 0;
    this._scheduledEvents = {};
    this._timeline = new Timeline();
    this._repeatedEvents = new IntervalTimeline();
    this._syncedSignals = [];
    this._swingAmount = 0;
    this._ppq = options2.ppq;
    this._clock = new Clock({
      callback: this._processTick.bind(this),
      context: this.context,
      frequency: 0,
      units: "bpm"
    });
    this._bindClockEvents();
    this.bpm = this._clock.frequency;
    this._clock.frequency.multiplier = options2.ppq;
    this.bpm.setValueAtTime(options2.bpm, 0);
    readOnly(this, "bpm");
    this._timeSignature = options2.timeSignature;
    this._swingTicks = options2.ppq / 2;
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      bpm: 120,
      loopEnd: "4m",
      loopStart: 0,
      ppq: 192,
      swing: 0,
      swingSubdivision: "8n",
      timeSignature: 4
    });
  }
  //-------------------------------------
  // 	TICKS
  //-------------------------------------
  /**
   * called on every tick
   * @param  tickTime clock relative tick time
   */
  _processTick(tickTime, ticks) {
    if (this._loop.get(tickTime)) {
      if (ticks >= this._loopEnd) {
        this.emit("loopEnd", tickTime);
        this._clock.setTicksAtTime(this._loopStart, tickTime);
        ticks = this._loopStart;
        this.emit("loopStart", tickTime, this._clock.getSecondsAtTime(tickTime));
        this.emit("loop", tickTime);
      }
    }
    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat
    ticks % (this._swingTicks * 2) !== 0) {
      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
      const amount = Math.sin(progress * Math.PI) * this._swingAmount;
      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;
    }
    enterScheduledCallback(true);
    this._timeline.forEachAtTime(ticks, (event) => event.invoke(tickTime));
    enterScheduledCallback(false);
  }
  //-------------------------------------
  // 	SCHEDULABLE EVENTS
  //-------------------------------------
  /**
   * Schedule an event along the timeline.
   * @param callback The callback to be invoked at the time.
   * @param time The time to invoke the callback at.
   * @return The id of the event which can be used for canceling the event.
   * @example
   * // schedule an event on the 16th measure
   * Tone.getTransport().schedule((time) => {
   * 	// invoked on measure 16
   * 	console.log("measure 16!");
   * }, "16:0:0");
   */
  schedule(callback, time2) {
    const event = new TransportEvent(this, {
      callback,
      time: new TransportTimeClass(this.context, time2).toTicks()
    });
    return this._addEvent(event, this._timeline);
  }
  /**
   * Schedule a repeated event along the timeline. The event will fire
   * at the `interval` starting at the `startTime` and for the specified
   * `duration`.
   * @param  callback   The callback to invoke.
   * @param  interval   The duration between successive callbacks. Must be a positive number.
   * @param  startTime  When along the timeline the events should start being invoked.
   * @param  duration How long the event should repeat.
   * @return  The ID of the scheduled event. Use this to cancel the event.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // a callback invoked every eighth note after the first measure
   * Tone.getTransport().scheduleRepeat((time) => {
   * 	osc.start(time).stop(time + 0.1);
   * }, "8n", "1m");
   */
  scheduleRepeat(callback, interval, startTime, duration2 = Infinity) {
    const event = new TransportRepeatEvent(this, {
      callback,
      duration: new TimeClass(this.context, duration2).toTicks(),
      interval: new TimeClass(this.context, interval).toTicks(),
      time: new TransportTimeClass(this.context, startTime).toTicks()
    });
    return this._addEvent(event, this._repeatedEvents);
  }
  /**
   * Schedule an event that will be removed after it is invoked.
   * @param callback The callback to invoke once.
   * @param time The time the callback should be invoked.
   * @returns The ID of the scheduled event.
   */
  scheduleOnce(callback, time2) {
    const event = new TransportEvent(this, {
      callback,
      once: true,
      time: new TransportTimeClass(this.context, time2).toTicks()
    });
    return this._addEvent(event, this._timeline);
  }
  /**
   * Clear the passed in event id from the timeline
   * @param eventId The id of the event.
   */
  clear(eventId) {
    if (this._scheduledEvents.hasOwnProperty(eventId)) {
      const item = this._scheduledEvents[eventId.toString()];
      item.timeline.remove(item.event);
      item.event.dispose();
      delete this._scheduledEvents[eventId.toString()];
    }
    return this;
  }
  /**
   * Add an event to the correct timeline. Keep track of the
   * timeline it was added to.
   * @returns the event id which was just added
   */
  _addEvent(event, timeline) {
    this._scheduledEvents[event.id.toString()] = {
      event,
      timeline
    };
    timeline.add(event);
    return event.id;
  }
  /**
   * Remove scheduled events from the timeline after
   * the given time. Repeated events will be removed
   * if their startTime is after the given time
   * @param after Clear all events after this time.
   */
  cancel(after = 0) {
    const computedAfter = this.toTicks(after);
    this._timeline.forEachFrom(computedAfter, (event) => this.clear(event.id));
    this._repeatedEvents.forEachFrom(computedAfter, (event) => this.clear(event.id));
    return this;
  }
  //-------------------------------------
  // 	START/STOP/PAUSE
  //-------------------------------------
  /**
   * Bind start/stop/pause events from the clock and emit them.
   */
  _bindClockEvents() {
    this._clock.on("start", (time2, offset2) => {
      offset2 = new TicksClass(this.context, offset2).toSeconds();
      this.emit("start", time2, offset2);
    });
    this._clock.on("stop", (time2) => {
      this.emit("stop", time2);
    });
    this._clock.on("pause", (time2) => {
      this.emit("pause", time2);
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped", or "paused"
   */
  get state() {
    return this._clock.getStateAtTime(this.now());
  }
  /**
   * Start the transport and all sources synced to the transport.
   * @param  time The time when the transport should start.
   * @param  offset The timeline offset to start the transport.
   * @example
   * // start the transport in one second starting at beginning of the 5th measure.
   * Tone.getTransport().start("+1", "4:0:0");
   */
  start(time2, offset2) {
    this.context.resume();
    let offsetTicks;
    if (isDefined(offset2)) {
      offsetTicks = this.toTicks(offset2);
    }
    this._clock.start(time2, offsetTicks);
    return this;
  }
  /**
   * Stop the transport and all sources synced to the transport.
   * @param time The time when the transport should stop.
   * @example
   * Tone.getTransport().stop();
   */
  stop(time2) {
    this._clock.stop(time2);
    return this;
  }
  /**
   * Pause the transport and all sources synced to the transport.
   */
  pause(time2) {
    this._clock.pause(time2);
    return this;
  }
  /**
   * Toggle the current state of the transport. If it is
   * started, it will stop it, otherwise it will start the Transport.
   * @param  time The time of the event
   */
  toggle(time2) {
    time2 = this.toSeconds(time2);
    if (this._clock.getStateAtTime(time2) !== "started") {
      this.start(time2);
    } else {
      this.stop(time2);
    }
    return this;
  }
  //-------------------------------------
  // 	SETTERS/GETTERS
  //-------------------------------------
  /**
   * The time signature as just the numerator over 4.
   * For example 4/4 would be just 4 and 6/8 would be 3.
   * @example
   * // common time
   * Tone.getTransport().timeSignature = 4;
   * // 7/8
   * Tone.getTransport().timeSignature = [7, 8];
   * // this will be reduced to a single number
   * Tone.getTransport().timeSignature; // returns 3.5
   */
  get timeSignature() {
    return this._timeSignature;
  }
  set timeSignature(timeSig) {
    if (isArray(timeSig)) {
      timeSig = timeSig[0] / timeSig[1] * 4;
    }
    this._timeSignature = timeSig;
  }
  /**
   * When the Transport.loop = true, this is the starting position of the loop.
   */
  get loopStart() {
    return new TimeClass(this.context, this._loopStart, "i").toSeconds();
  }
  set loopStart(startPosition) {
    this._loopStart = this.toTicks(startPosition);
  }
  /**
   * When the Transport.loop = true, this is the ending position of the loop.
   */
  get loopEnd() {
    return new TimeClass(this.context, this._loopEnd, "i").toSeconds();
  }
  set loopEnd(endPosition) {
    this._loopEnd = this.toTicks(endPosition);
  }
  /**
   * If the transport loops or not.
   */
  get loop() {
    return this._loop.get(this.now());
  }
  set loop(loop) {
    this._loop.set(loop, this.now());
  }
  /**
   * Set the loop start and stop at the same time.
   * @example
   * // loop over the first measure
   * Tone.getTransport().setLoopPoints(0, "1m");
   * Tone.getTransport().loop = true;
   */
  setLoopPoints(startPosition, endPosition) {
    this.loopStart = startPosition;
    this.loopEnd = endPosition;
    return this;
  }
  /**
   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
   */
  get swing() {
    return this._swingAmount;
  }
  set swing(amount) {
    this._swingAmount = amount;
  }
  /**
   * Set the subdivision which the swing will be applied to.
   * The default value is an 8th note. Value must be less
   * than a quarter note.
   */
  get swingSubdivision() {
    return new TicksClass(this.context, this._swingTicks).toNotation();
  }
  set swingSubdivision(subdivision) {
    this._swingTicks = this.toTicks(subdivision);
  }
  /**
   * The Transport's position in Bars:Beats:Sixteenths.
   * Setting the value will jump to that position right away.
   */
  get position() {
    const now = this.now();
    const ticks = this._clock.getTicksAtTime(now);
    return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();
  }
  set position(progress) {
    const ticks = this.toTicks(progress);
    this.ticks = ticks;
  }
  /**
   * The Transport's position in seconds.
   * Setting the value will jump to that position right away.
   */
  get seconds() {
    return this._clock.seconds;
  }
  set seconds(s) {
    const now = this.now();
    const ticks = this._clock.frequency.timeToTicks(s, now);
    this.ticks = ticks;
  }
  /**
   * The Transport's loop position as a normalized value. Always
   * returns 0 if the Transport.loop = false.
   */
  get progress() {
    if (this.loop) {
      const now = this.now();
      const ticks = this._clock.getTicksAtTime(now);
      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);
    } else {
      return 0;
    }
  }
  /**
   * The Transport's current tick position.
   */
  get ticks() {
    return this._clock.ticks;
  }
  set ticks(t) {
    if (this._clock.ticks !== t) {
      const now = this.now();
      if (this.state === "started") {
        const ticks = this._clock.getTicksAtTime(now);
        const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);
        const time2 = now + remainingTick;
        this.emit("stop", time2);
        this._clock.setTicksAtTime(t, time2);
        this.emit("start", time2, this._clock.getSecondsAtTime(time2));
      } else {
        this.emit("ticks", now);
        this._clock.setTicksAtTime(t, now);
      }
    }
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(time2) {
    return this._clock.getTicksAtTime(time2);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(time2) {
    return this._clock.getSecondsAtTime(time2);
  }
  /**
   * Pulses Per Quarter note. This is the smallest resolution
   * the Transport timing supports. This should be set once
   * on initialization and not set again. Changing this value
   * after other objects have been created can cause problems.
   */
  get PPQ() {
    return this._clock.frequency.multiplier;
  }
  set PPQ(ppq) {
    this._clock.frequency.multiplier = ppq;
  }
  //-------------------------------------
  // 	SYNCING
  //-------------------------------------
  /**
   * Returns the time aligned to the next subdivision
   * of the Transport. If the Transport is not started,
   * it will return 0.
   * Note: this will not work precisely during tempo ramps.
   * @param  subdivision  The subdivision to quantize to
   * @return  The context time of the next subdivision.
   * @example
   * // the transport must be started, otherwise returns 0
   * Tone.getTransport().start();
   * Tone.getTransport().nextSubdivision("4n");
   */
  nextSubdivision(subdivision) {
    subdivision = this.toTicks(subdivision);
    if (this.state !== "started") {
      return 0;
    } else {
      const now = this.now();
      const transportPos = this.getTicksAtTime(now);
      const remainingTicks = subdivision - transportPos % subdivision;
      return this._clock.nextTickTime(remainingTicks, now);
    }
  }
  /**
   * Attaches the signal to the tempo control signal so that
   * any changes in the tempo will change the signal in the same
   * ratio.
   *
   * @param signal
   * @param ratio Optionally pass in the ratio between the two signals.
   * 			Otherwise it will be computed based on their current values.
   */
  syncSignal(signal, ratio) {
    const now = this.now();
    let source = this.bpm;
    let sourceValue = 1 / (60 / source.getValueAtTime(now) / this.PPQ);
    let nodes = [];
    if (signal.units === "time") {
      const scaleFactor = 1 / 64 / sourceValue;
      const scaleBefore = new Gain(scaleFactor);
      const reciprocal = new Pow(-1);
      const scaleAfter = new Gain(scaleFactor);
      source.chain(scaleBefore, reciprocal, scaleAfter);
      source = scaleAfter;
      sourceValue = 1 / sourceValue;
      nodes = [scaleBefore, reciprocal, scaleAfter];
    }
    if (!ratio) {
      if (signal.getValueAtTime(now) !== 0) {
        ratio = signal.getValueAtTime(now) / sourceValue;
      } else {
        ratio = 0;
      }
    }
    const ratioSignal = new Gain(ratio);
    source.connect(ratioSignal);
    ratioSignal.connect(signal._param);
    nodes.push(ratioSignal);
    this._syncedSignals.push({
      initial: signal.value,
      nodes,
      signal
    });
    signal.value = 0;
    return this;
  }
  /**
   * Unsyncs a previously synced signal from the transport's control.
   * @see {@link syncSignal}.
   */
  unsyncSignal(signal) {
    for (let i = this._syncedSignals.length - 1; i >= 0; i--) {
      const syncedSignal = this._syncedSignals[i];
      if (syncedSignal.signal === signal) {
        syncedSignal.nodes.forEach((node) => node.dispose());
        syncedSignal.signal.value = syncedSignal.initial;
        this._syncedSignals.splice(i, 1);
      }
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._clock.dispose();
    writable(this, "bpm");
    this._timeline.dispose();
    this._repeatedEvents.dispose();
    return this;
  }
}
Emitter.mixin(TransportClass);
onContextInit((context2) => {
  context2.transport = new TransportClass({ context: context2 });
});
onContextClose((context2) => {
  context2.transport.dispose();
});
class Source extends ToneAudioNode {
  constructor(options2) {
    super(options2);
    this.input = void 0;
    this._state = new StateTimeline("stopped");
    this._synced = false;
    this._scheduled = [];
    this._syncedStart = noOp;
    this._syncedStop = noOp;
    this._state.memory = 100;
    this._state.increasing = true;
    this._volume = this.output = new Volume({
      context: this.context,
      mute: options2.mute,
      volume: options2.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
    this.onstop = options2.onstop;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      onstop: noOp,
      volume: 0
    });
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/ahntone_c3.mp3", () => {
   * 	player.start();
   * 	console.log(player.state);
   * }).toDestination();
   */
  get state() {
    if (this._synced) {
      if (this.context.transport.state === "started") {
        return this._state.getValueAtTime(this.context.transport.seconds);
      } else {
        return "stopped";
      }
    } else {
      return this._state.getValueAtTime(this.now());
    }
  }
  /**
   * Mute the output.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // mute the output
   * osc.mute = true;
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  /**
   * Ensure that the scheduled time is not before the current time.
   * Should only be used when scheduled unsynced.
   */
  _clampToCurrentTime(time2) {
    if (this._synced) {
      return time2;
    } else {
      return Math.max(time2, this.context.currentTime);
    }
  }
  /**
   * Start the source at the specified time. If no time is given,
   * start the source now.
   * @param  time When the source should be started.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start("+0.5"); // starts the source 0.5 seconds from now
   */
  start(time2, offset2, duration2) {
    let computedTime = isUndef(time2) && this._synced ? this.context.transport.seconds : this.toSeconds(time2);
    computedTime = this._clampToCurrentTime(computedTime);
    if (!this._synced && this._state.getValueAtTime(computedTime) === "started") {
      assert(GT(computedTime, this._state.get(computedTime).time), "Start time must be strictly greater than previous start time");
      this._state.cancel(computedTime);
      this._state.setStateAtTime("started", computedTime);
      this.log("restart", computedTime);
      this.restart(computedTime, offset2, duration2);
    } else {
      this.log("start", computedTime);
      this._state.setStateAtTime("started", computedTime);
      if (this._synced) {
        const event = this._state.get(computedTime);
        if (event) {
          event.offset = this.toSeconds(defaultArg(offset2, 0));
          event.duration = duration2 ? this.toSeconds(duration2) : void 0;
        }
        const sched = this.context.transport.schedule((t) => {
          this._start(t, offset2, duration2);
        }, computedTime);
        this._scheduled.push(sched);
        if (this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {
          this._syncedStart(this.now(), this.context.transport.seconds);
        }
      } else {
        assertContextRunning(this.context);
        this._start(computedTime, offset2, duration2);
      }
    }
    return this;
  }
  /**
   * Stop the source at the specified time. If no time is given,
   * stop the source now.
   * @param  time When the source should be stopped.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start();
   * source.stop("+0.5"); // stops the source 0.5 seconds from now
   */
  stop(time2) {
    let computedTime = isUndef(time2) && this._synced ? this.context.transport.seconds : this.toSeconds(time2);
    computedTime = this._clampToCurrentTime(computedTime);
    if (this._state.getValueAtTime(computedTime) === "started" || isDefined(this._state.getNextState("started", computedTime))) {
      this.log("stop", computedTime);
      if (!this._synced) {
        this._stop(computedTime);
      } else {
        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);
        this._scheduled.push(sched);
      }
      this._state.cancel(computedTime);
      this._state.setStateAtTime("stopped", computedTime);
    }
    return this;
  }
  /**
   * Restart the source.
   */
  restart(time2, offset2, duration2) {
    time2 = this.toSeconds(time2);
    if (this._state.getValueAtTime(time2) === "started") {
      this._state.cancel(time2);
      this._restart(time2, offset2, duration2);
    }
    return this;
  }
  /**
   * Sync the source to the Transport so that all subsequent
   * calls to `start` and `stop` are synced to the TransportTime
   * instead of the AudioContext time.
   *
   * @example
   * const osc = new Tone.Oscillator().toDestination();
   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline
   * osc.sync().start(0).stop(0.3);
   * // start the transport.
   * Tone.Transport.start();
   * // set it to loop once a second
   * Tone.Transport.loop = true;
   * Tone.Transport.loopEnd = 1;
   */
  sync() {
    if (!this._synced) {
      this._synced = true;
      this._syncedStart = (time2, offset2) => {
        if (GT(offset2, 0)) {
          const stateEvent = this._state.get(offset2);
          if (stateEvent && stateEvent.state === "started" && stateEvent.time !== offset2) {
            const startOffset = offset2 - this.toSeconds(stateEvent.time);
            let duration2;
            if (stateEvent.duration) {
              duration2 = this.toSeconds(stateEvent.duration) - startOffset;
            }
            this._start(time2, this.toSeconds(stateEvent.offset) + startOffset, duration2);
          }
        }
      };
      this._syncedStop = (time2) => {
        const seconds = this.context.transport.getSecondsAtTime(Math.max(time2 - this.sampleTime, 0));
        if (this._state.getValueAtTime(seconds) === "started") {
          this._stop(time2);
        }
      };
      this.context.transport.on("start", this._syncedStart);
      this.context.transport.on("loopStart", this._syncedStart);
      this.context.transport.on("stop", this._syncedStop);
      this.context.transport.on("pause", this._syncedStop);
      this.context.transport.on("loopEnd", this._syncedStop);
    }
    return this;
  }
  /**
   * Unsync the source to the Transport.
   * @see {@link sync}
   */
  unsync() {
    if (this._synced) {
      this.context.transport.off("stop", this._syncedStop);
      this.context.transport.off("pause", this._syncedStop);
      this.context.transport.off("loopEnd", this._syncedStop);
      this.context.transport.off("start", this._syncedStart);
      this.context.transport.off("loopStart", this._syncedStart);
    }
    this._synced = false;
    this._scheduled.forEach((id) => this.context.transport.clear(id));
    this._scheduled = [];
    this._state.cancel(0);
    this._stop(0);
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this.onstop = noOp;
    this.unsync();
    this._volume.dispose();
    this._state.dispose();
    return this;
  }
}
class ToneBufferSource extends OneShotSource {
  constructor() {
    const options2 = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]);
    super(options2);
    this.name = "ToneBufferSource";
    this._source = this.context.createBufferSource();
    this._internalChannels = [this._source];
    this._sourceStarted = false;
    this._sourceStopped = false;
    connect(this._source, this._gainNode);
    this._source.onended = () => this._stopSource();
    this.playbackRate = new Param({
      context: this.context,
      param: this._source.playbackRate,
      units: "positive",
      value: options2.playbackRate
    });
    this.loop = options2.loop;
    this.loopStart = options2.loopStart;
    this.loopEnd = options2.loopEnd;
    this._buffer = new ToneAudioBuffer(options2.url, options2.onload, options2.onerror);
    this._internalChannels.push(this._source);
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      url: new ToneAudioBuffer(),
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      onload: noOp,
      onerror: noOp,
      playbackRate: 1
    });
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(t) {
    this._fadeIn = t;
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(t) {
    this._fadeOut = t;
  }
  /**
   * The curve applied to the fades, either "linear" or "exponential"
   */
  get curve() {
    return this._curve;
  }
  set curve(t) {
    this._curve = t;
  }
  /**
   * Start the buffer
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   * @param  gain  The gain to play the buffer back at.
   */
  start(time2, offset2, duration2, gain = 1) {
    assert(this.buffer.loaded, "buffer is either not set or not loaded");
    const computedTime = this.toSeconds(time2);
    this._startGain(computedTime, gain);
    if (this.loop) {
      offset2 = defaultArg(offset2, this.loopStart);
    } else {
      offset2 = defaultArg(offset2, 0);
    }
    let computedOffset = Math.max(this.toSeconds(offset2), 0);
    if (this.loop) {
      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
      const loopStart = this.toSeconds(this.loopStart);
      const loopDuration = loopEnd - loopStart;
      if (GTE(computedOffset, loopEnd)) {
        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;
      }
      if (EQ(computedOffset, this.buffer.duration)) {
        computedOffset = 0;
      }
    }
    this._source.buffer = this.buffer.get();
    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
    if (LT(computedOffset, this.buffer.duration)) {
      this._sourceStarted = true;
      this._source.start(computedTime, computedOffset);
    }
    if (isDefined(duration2)) {
      let computedDur = this.toSeconds(duration2);
      computedDur = Math.max(computedDur, 0);
      this.stop(computedTime + computedDur);
    }
    return this;
  }
  _stopSource(time2) {
    if (!this._sourceStopped && this._sourceStarted) {
      this._sourceStopped = true;
      this._source.stop(this.toSeconds(time2));
      this._onended();
    }
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._source.loopStart;
  }
  set loopStart(loopStart) {
    this._source.loopStart = this.toSeconds(loopStart);
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._source.loopEnd;
  }
  set loopEnd(loopEnd) {
    this._source.loopEnd = this.toSeconds(loopEnd);
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(buffer) {
    this._buffer.set(buffer);
  }
  /**
   * If the buffer should loop once it's over.
   */
  get loop() {
    return this._source.loop;
  }
  set loop(loop) {
    this._source.loop = loop;
    if (this._sourceStarted) {
      this.cancelStop();
    }
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._source.onended = null;
    this._source.disconnect();
    this._buffer.dispose();
    this.playbackRate.dispose();
    return this;
  }
}
class Noise extends Source {
  constructor() {
    const options2 = optionsFromArguments(Noise.getDefaults(), arguments, [
      "type"
    ]);
    super(options2);
    this.name = "Noise";
    this._source = null;
    this._playbackRate = options2.playbackRate;
    this.type = options2.type;
    this._fadeIn = options2.fadeIn;
    this._fadeOut = options2.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      fadeIn: 0,
      fadeOut: 0,
      playbackRate: 1,
      type: "white"
    });
  }
  /**
   * The type of the noise. Can be "white", "brown", or "pink".
   * @example
   * const noise = new Tone.Noise().toDestination().start();
   * noise.type = "brown";
   */
  get type() {
    return this._type;
  }
  set type(type2) {
    assert(type2 in _noiseBuffers, "Noise: invalid type: " + type2);
    if (this._type !== type2) {
      this._type = type2;
      if (this.state === "started") {
        const now = this.now();
        this._stop(now);
        this._start(now);
      }
    }
  }
  /**
   * The playback rate of the noise. Affects
   * the "frequency" of the noise.
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    if (this._source) {
      this._source.playbackRate.value = rate;
    }
  }
  /**
   * internal start method
   */
  _start(time2) {
    const buffer = _noiseBuffers[this._type];
    this._source = new ToneBufferSource({
      url: buffer,
      context: this.context,
      fadeIn: this._fadeIn,
      fadeOut: this._fadeOut,
      loop: true,
      onended: () => this.onstop(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    this._source.start(this.toSeconds(time2), Math.random() * (buffer.duration - 1e-3));
  }
  /**
   * internal stop method
   */
  _stop(time2) {
    if (this._source) {
      this._source.stop(this.toSeconds(time2));
      this._source = null;
    }
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(time2) {
    this._fadeIn = time2;
    if (this._source) {
      this._source.fadeIn = this._fadeIn;
    }
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(time2) {
    this._fadeOut = time2;
    if (this._source) {
      this._source.fadeOut = this._fadeOut;
    }
  }
  _restart(time2) {
    this._stop(time2);
    this._start(time2);
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    if (this._source) {
      this._source.disconnect();
    }
    return this;
  }
}
const BUFFER_LENGTH = 44100 * 5;
const NUM_CHANNELS = 2;
const _noiseCache = {
  brown: null,
  pink: null,
  white: null
};
const _noiseBuffers = {
  get brown() {
    if (!_noiseCache.brown) {
      const buffer = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;
        let lastOut = 0;
        for (let i = 0; i < BUFFER_LENGTH; i++) {
          const white2 = Math.random() * 2 - 1;
          channel[i] = (lastOut + 0.02 * white2) / 1.02;
          lastOut = channel[i];
          channel[i] *= 3.5;
        }
      }
      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);
    }
    return _noiseCache.brown;
  },
  get pink() {
    if (!_noiseCache.pink) {
      const buffer = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
        for (let i = 0; i < BUFFER_LENGTH; i++) {
          const white2 = Math.random() * 2 - 1;
          b0 = 0.99886 * b0 + white2 * 0.0555179;
          b1 = 0.99332 * b1 + white2 * 0.0750759;
          b2 = 0.969 * b2 + white2 * 0.153852;
          b3 = 0.8665 * b3 + white2 * 0.3104856;
          b4 = 0.55 * b4 + white2 * 0.5329522;
          b5 = -0.7616 * b5 - white2 * 0.016898;
          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white2 * 0.5362;
          channel[i] *= 0.11;
          b6 = white2 * 0.115926;
        }
      }
      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);
    }
    return _noiseCache.pink;
  },
  get white() {
    if (!_noiseCache.white) {
      const buffer = [];
      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;
        for (let i = 0; i < BUFFER_LENGTH; i++) {
          channel[i] = Math.random() * 2 - 1;
        }
      }
      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);
    }
    return _noiseCache.white;
  }
};
function generateWaveform(instance, length) {
  return __awaiter(this, void 0, void 0, function* () {
    const duration2 = length / instance.context.sampleRate;
    const context2 = new OfflineContext(1, duration2, instance.context.sampleRate);
    const clone2 = new instance.constructor(Object.assign(instance.get(), {
      // should do 2 iterations
      frequency: 2 / duration2,
      // zero out the detune
      detune: 0,
      context: context2
    })).toDestination();
    clone2.start(0);
    const buffer = yield context2.render();
    return buffer.getChannelData(0);
  });
}
class ToneOscillatorNode extends OneShotSource {
  constructor() {
    const options2 = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]);
    super(options2);
    this.name = "ToneOscillatorNode";
    this._oscillator = this.context.createOscillator();
    this._internalChannels = [this._oscillator];
    connect(this._oscillator, this._gainNode);
    this.type = options2.type;
    this.frequency = new Param({
      context: this.context,
      param: this._oscillator.frequency,
      units: "frequency",
      value: options2.frequency
    });
    this.detune = new Param({
      context: this.context,
      param: this._oscillator.detune,
      units: "cents",
      value: options2.detune
    });
    readOnly(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(OneShotSource.getDefaults(), {
      detune: 0,
      frequency: 440,
      type: "sine"
    });
  }
  /**
   * Start the oscillator node at the given time
   * @param  time When to start the oscillator
   */
  start(time2) {
    const computedTime = this.toSeconds(time2);
    this.log("start", computedTime);
    this._startGain(computedTime);
    this._oscillator.start(computedTime);
    return this;
  }
  _stopSource(time2) {
    this._oscillator.stop(time2);
  }
  /**
   * Sets an arbitrary custom periodic waveform given a PeriodicWave.
   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave
   */
  setPeriodicWave(periodicWave) {
    this._oscillator.setPeriodicWave(periodicWave);
    return this;
  }
  /**
   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'
   */
  get type() {
    return this._oscillator.type;
  }
  set type(type2) {
    this._oscillator.type = type2;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    if (this.state === "started") {
      this.stop();
    }
    this._oscillator.disconnect();
    this.frequency.dispose();
    this.detune.dispose();
    return this;
  }
}
class Oscillator extends Source {
  constructor() {
    const options2 = optionsFromArguments(Oscillator.getDefaults(), arguments, ["frequency", "type"]);
    super(options2);
    this.name = "Oscillator";
    this._oscillator = null;
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    readOnly(this, "frequency");
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    readOnly(this, "detune");
    this._partials = options2.partials;
    this._partialCount = options2.partialCount;
    this._type = options2.type;
    if (options2.partialCount && options2.type !== "custom") {
      this._type = this.baseType + options2.partialCount.toString();
    }
    this.phase = options2.phase;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      partialCount: 0,
      partials: [],
      phase: 0,
      type: "sine"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    const computedTime = this.toSeconds(time2);
    const oscillator = new ToneOscillatorNode({
      context: this.context,
      onended: () => this.onstop(this)
    });
    this._oscillator = oscillator;
    if (this._wave) {
      this._oscillator.setPeriodicWave(this._wave);
    } else {
      this._oscillator.type = this._type;
    }
    this._oscillator.connect(this.output);
    this.frequency.connect(this._oscillator.frequency);
    this.detune.connect(this._oscillator.detune);
    this._oscillator.start(computedTime);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    const computedTime = this.toSeconds(time2);
    if (this._oscillator) {
      this._oscillator.stop(computedTime);
    }
  }
  /**
   * Restart the oscillator. Does not stop the oscillator, but instead
   * just cancels any scheduled 'stop' from being invoked.
   */
  _restart(time2) {
    const computedTime = this.toSeconds(time2);
    this.log("restart", computedTime);
    if (this._oscillator) {
      this._oscillator.cancelStop();
    }
    this._state.cancel(computedTime);
    return this;
  }
  /**
   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,
   * will also affect the oscillators frequency.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * osc.frequency.value = 440;
   * // the ratio between the bpm and the frequency will be maintained
   * osc.syncFrequency();
   * // double the tempo
   * Tone.Transport.bpm.value *= 2;
   * // the frequency of the oscillator is doubled to 880
   */
  syncFrequency() {
    this.context.transport.syncSignal(this.frequency);
    return this;
  }
  /**
   * Unsync the oscillator's frequency from the Transport.
   * @see {@link syncFrequency}
   */
  unsyncFrequency() {
    this.context.transport.unsyncSignal(this.frequency);
    return this;
  }
  /**
   * Get a cached periodic wave. Avoids having to recompute
   * the oscillator values when they have already been computed
   * with the same values.
   */
  _getCachedPeriodicWave() {
    if (this._type === "custom") {
      const oscProps = Oscillator._periodicWaveCache.find((description) => {
        return description.phase === this._phase && deepEquals(description.partials, this._partials);
      });
      return oscProps;
    } else {
      const oscProps = Oscillator._periodicWaveCache.find((description) => {
        return description.type === this._type && description.phase === this._phase;
      });
      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;
      return oscProps;
    }
  }
  get type() {
    return this._type;
  }
  set type(type2) {
    this._type = type2;
    const isBasicType = ["sine", "square", "sawtooth", "triangle"].indexOf(type2) !== -1;
    if (this._phase === 0 && isBasicType) {
      this._wave = void 0;
      this._partialCount = 0;
      if (this._oscillator !== null) {
        this._oscillator.type = type2;
      }
    } else {
      const cache = this._getCachedPeriodicWave();
      if (isDefined(cache)) {
        const { partials, wave } = cache;
        this._wave = wave;
        this._partials = partials;
        if (this._oscillator !== null) {
          this._oscillator.setPeriodicWave(this._wave);
        }
      } else {
        const [real, imag] = this._getRealImaginary(type2, this._phase);
        const periodicWave = this.context.createPeriodicWave(real, imag);
        this._wave = periodicWave;
        if (this._oscillator !== null) {
          this._oscillator.setPeriodicWave(this._wave);
        }
        Oscillator._periodicWaveCache.push({
          imag,
          partialCount: this._partialCount,
          partials: this._partials,
          phase: this._phase,
          real,
          type: this._type,
          wave: this._wave
        });
        if (Oscillator._periodicWaveCache.length > 100) {
          Oscillator._periodicWaveCache.shift();
        }
      }
    }
  }
  get baseType() {
    return this._type.replace(this.partialCount.toString(), "");
  }
  set baseType(baseType) {
    if (this.partialCount && this._type !== "custom" && baseType !== "custom") {
      this.type = baseType + this.partialCount;
    } else {
      this.type = baseType;
    }
  }
  get partialCount() {
    return this._partialCount;
  }
  set partialCount(p2) {
    assertRange(p2, 0);
    let type2 = this._type;
    const partial2 = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
    if (partial2) {
      type2 = partial2[1];
    }
    if (this._type !== "custom") {
      if (p2 === 0) {
        this.type = type2;
      } else {
        this.type = type2 + p2.toString();
      }
    } else {
      const fullPartials = new Float32Array(p2);
      this._partials.forEach((v, i) => fullPartials[i] = v);
      this._partials = Array.from(fullPartials);
      this.type = this._type;
    }
  }
  /**
   * Returns the real and imaginary components based
   * on the oscillator type.
   * @returns [real: Float32Array, imaginary: Float32Array]
   */
  _getRealImaginary(type2, phase) {
    const fftSize = 4096;
    let periodicWaveSize = fftSize / 2;
    const real = new Float32Array(periodicWaveSize);
    const imag = new Float32Array(periodicWaveSize);
    let partialCount = 1;
    if (type2 === "custom") {
      partialCount = this._partials.length + 1;
      this._partialCount = this._partials.length;
      periodicWaveSize = partialCount;
      if (this._partials.length === 0) {
        return [real, imag];
      }
    } else {
      const partial2 = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type2);
      if (partial2) {
        partialCount = parseInt(partial2[2], 10) + 1;
        this._partialCount = parseInt(partial2[2], 10);
        type2 = partial2[1];
        partialCount = Math.max(partialCount, 2);
        periodicWaveSize = partialCount;
      } else {
        this._partialCount = 0;
      }
      this._partials = [];
    }
    for (let n2 = 1; n2 < periodicWaveSize; ++n2) {
      const piFactor = 2 / (n2 * Math.PI);
      let b2;
      switch (type2) {
        case "sine":
          b2 = n2 <= partialCount ? 1 : 0;
          this._partials[n2 - 1] = b2;
          break;
        case "square":
          b2 = n2 & 1 ? 2 * piFactor : 0;
          this._partials[n2 - 1] = b2;
          break;
        case "sawtooth":
          b2 = piFactor * (n2 & 1 ? 1 : -1);
          this._partials[n2 - 1] = b2;
          break;
        case "triangle":
          if (n2 & 1) {
            b2 = 2 * (piFactor * piFactor) * (n2 - 1 >> 1 & 1 ? -1 : 1);
          } else {
            b2 = 0;
          }
          this._partials[n2 - 1] = b2;
          break;
        case "custom":
          b2 = this._partials[n2 - 1];
          break;
        default:
          throw new TypeError("Oscillator: invalid type: " + type2);
      }
      if (b2 !== 0) {
        real[n2] = -b2 * Math.sin(phase * n2);
        imag[n2] = b2 * Math.cos(phase * n2);
      } else {
        real[n2] = 0;
        imag[n2] = 0;
      }
    }
    return [real, imag];
  }
  /**
   * Compute the inverse FFT for a given phase.
   */
  _inverseFFT(real, imag, phase) {
    let sum = 0;
    const len = real.length;
    for (let i = 0; i < len; i++) {
      sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);
    }
    return sum;
  }
  /**
   * Returns the initial value of the oscillator when stopped.
   * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
   */
  getInitialValue() {
    const [real, imag] = this._getRealImaginary(this._type, 0);
    let maxValue = 0;
    const twoPi = Math.PI * 2;
    const testPositions = 32;
    for (let i = 0; i < testPositions; i++) {
      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);
    }
    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);
  }
  get partials() {
    return this._partials.slice(0, this.partialCount);
  }
  set partials(partials) {
    this._partials = partials;
    this._partialCount = this._partials.length;
    if (partials.length) {
      this.type = "custom";
    }
  }
  get phase() {
    return this._phase * (180 / Math.PI);
  }
  set phase(phase) {
    this._phase = phase * Math.PI / 180;
    this.type = this._type;
  }
  asArray() {
    return __awaiter(this, arguments, void 0, function* (length = 1024) {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    if (this._oscillator !== null) {
      this._oscillator.dispose();
    }
    this._wave = void 0;
    this.frequency.dispose();
    this.detune.dispose();
    return this;
  }
}
Oscillator._periodicWaveCache = [];
class AudioToGain extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "AudioToGain";
    this._norm = new WaveShaper({
      context: this.context,
      mapping: (x) => (x + 1) / 2
    });
    this.input = this._norm;
    this.output = this._norm;
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this._norm.dispose();
    return this;
  }
}
class Multiply extends Signal {
  constructor() {
    const options2 = optionsFromArguments(Multiply.getDefaults(), arguments, ["value"]);
    super(options2);
    this.name = "Multiply";
    this.override = false;
    this._mult = this.input = this.output = new Gain({
      context: this.context,
      minValue: options2.minValue,
      maxValue: options2.maxValue
    });
    this.factor = this._param = this._mult.gain;
    this.factor.setValueAtTime(options2.value, 0);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._mult.dispose();
    return this;
  }
}
class AMOscillator extends Source {
  constructor() {
    const options2 = optionsFromArguments(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    super(options2);
    this.name = "AMOscillator";
    this._modulationScale = new AudioToGain({ context: this.context });
    this._modulationNode = new Gain({
      context: this.context
    });
    this._carrier = new Oscillator({
      context: this.context,
      detune: options2.detune,
      frequency: options2.frequency,
      onstop: () => this.onstop(this),
      phase: options2.phase,
      type: options2.type
    });
    this.frequency = this._carrier.frequency, this.detune = this._carrier.detune;
    this._modulator = new Oscillator({
      context: this.context,
      phase: options2.phase,
      type: options2.modulationType
    });
    this.harmonicity = new Multiply({
      context: this.context,
      units: "positive",
      value: options2.harmonicity
    });
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this._modulator.chain(this._modulationScale, this._modulationNode.gain);
    this._carrier.chain(this._modulationNode, this.output);
    readOnly(this, ["frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      harmonicity: 1,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    this._modulator.start(time2);
    this._carrier.start(time2);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    this._modulator.stop(time2);
    this._carrier.stop(time2);
  }
  _restart(time2) {
    this._modulator.restart(time2);
    this._carrier.restart(time2);
  }
  /**
   * The type of the carrier oscillator
   */
  get type() {
    return this._carrier.type;
  }
  set type(type2) {
    this._carrier.type = type2;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(baseType) {
    this._carrier.baseType = baseType;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(partialCount) {
    this._carrier.partialCount = partialCount;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(type2) {
    this._modulator.type = type2;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(phase) {
    this._carrier.phase = phase;
    this._modulator.phase = phase;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(partials) {
    this._carrier.partials = partials;
  }
  asArray() {
    return __awaiter(this, arguments, void 0, function* (length = 1024) {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this.harmonicity.dispose();
    this._carrier.dispose();
    this._modulator.dispose();
    this._modulationNode.dispose();
    this._modulationScale.dispose();
    return this;
  }
}
class FMOscillator extends Source {
  constructor() {
    const options2 = optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    super(options2);
    this.name = "FMOscillator";
    this._modulationNode = new Gain({
      context: this.context,
      gain: 0
    });
    this._carrier = new Oscillator({
      context: this.context,
      detune: options2.detune,
      frequency: 0,
      onstop: () => this.onstop(this),
      phase: options2.phase,
      type: options2.type
    });
    this.detune = this._carrier.detune;
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    this._modulator = new Oscillator({
      context: this.context,
      phase: options2.phase,
      type: options2.modulationType
    });
    this.harmonicity = new Multiply({
      context: this.context,
      units: "positive",
      value: options2.harmonicity
    });
    this.modulationIndex = new Multiply({
      context: this.context,
      units: "positive",
      value: options2.modulationIndex
    });
    this.frequency.connect(this._carrier.frequency);
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this.frequency.chain(this.modulationIndex, this._modulationNode);
    this._modulator.connect(this._modulationNode.gain);
    this._modulationNode.connect(this._carrier.frequency);
    this._carrier.connect(this.output);
    this.detune.connect(this._modulator.detune);
    readOnly(this, [
      "modulationIndex",
      "frequency",
      "detune",
      "harmonicity"
    ]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      harmonicity: 1,
      modulationIndex: 2,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    this._modulator.start(time2);
    this._carrier.start(time2);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    this._modulator.stop(time2);
    this._carrier.stop(time2);
  }
  _restart(time2) {
    this._modulator.restart(time2);
    this._carrier.restart(time2);
    return this;
  }
  get type() {
    return this._carrier.type;
  }
  set type(type2) {
    this._carrier.type = type2;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(baseType) {
    this._carrier.baseType = baseType;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(partialCount) {
    this._carrier.partialCount = partialCount;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(type2) {
    this._modulator.type = type2;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(phase) {
    this._carrier.phase = phase;
    this._modulator.phase = phase;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(partials) {
    this._carrier.partials = partials;
  }
  asArray() {
    return __awaiter(this, arguments, void 0, function* (length = 1024) {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.harmonicity.dispose();
    this._carrier.dispose();
    this._modulator.dispose();
    this._modulationNode.dispose();
    this.modulationIndex.dispose();
    return this;
  }
}
class PulseOscillator extends Source {
  constructor() {
    const options2 = optionsFromArguments(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]);
    super(options2);
    this.name = "PulseOscillator";
    this._widthGate = new Gain({
      context: this.context,
      gain: 0
    });
    this._thresh = new WaveShaper({
      context: this.context,
      mapping: (val) => val <= 0 ? -1 : 1
    });
    this.width = new Signal({
      context: this.context,
      units: "audioRange",
      value: options2.width
    });
    this._triangle = new Oscillator({
      context: this.context,
      detune: options2.detune,
      frequency: options2.frequency,
      onstop: () => this.onstop(this),
      phase: options2.phase,
      type: "triangle"
    });
    this.frequency = this._triangle.frequency;
    this.detune = this._triangle.detune;
    this._triangle.chain(this._thresh, this.output);
    this.width.chain(this._widthGate, this._thresh);
    readOnly(this, ["width", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      phase: 0,
      type: "pulse",
      width: 0.2
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    time2 = this.toSeconds(time2);
    this._triangle.start(time2);
    this._widthGate.gain.setValueAtTime(1, time2);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    time2 = this.toSeconds(time2);
    this._triangle.stop(time2);
    this._widthGate.gain.cancelScheduledValues(time2);
    this._widthGate.gain.setValueAtTime(0, time2);
  }
  _restart(time2) {
    this._triangle.restart(time2);
    this._widthGate.gain.cancelScheduledValues(time2);
    this._widthGate.gain.setValueAtTime(1, time2);
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._triangle.phase;
  }
  set phase(phase) {
    this._triangle.phase = phase;
  }
  /**
   * The type of the oscillator. Always returns "pulse".
   */
  get type() {
    return "pulse";
  }
  /**
   * The baseType of the oscillator. Always returns "pulse".
   */
  get baseType() {
    return "pulse";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * *Internal use* The carrier oscillator type is fed through the
   * waveshaper node to create the pulse. Using different carrier oscillators
   * changes oscillator's behavior.
   */
  set carrierType(type2) {
    this._triangle.type = type2;
  }
  asArray() {
    return __awaiter(this, arguments, void 0, function* (length = 1024) {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up method.
   */
  dispose() {
    super.dispose();
    this._triangle.dispose();
    this.width.dispose();
    this._widthGate.dispose();
    this._thresh.dispose();
    return this;
  }
}
class FatOscillator extends Source {
  constructor() {
    const options2 = optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]);
    super(options2);
    this.name = "FatOscillator";
    this._oscillators = [];
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    this._spread = options2.spread;
    this._type = options2.type;
    this._phase = options2.phase;
    this._partials = options2.partials;
    this._partialCount = options2.partialCount;
    this.count = options2.count;
    readOnly(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), {
      count: 3,
      spread: 20,
      type: "sawtooth"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    time2 = this.toSeconds(time2);
    this._forEach((osc) => osc.start(time2));
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    time2 = this.toSeconds(time2);
    this._forEach((osc) => osc.stop(time2));
  }
  _restart(time2) {
    this._forEach((osc) => osc.restart(time2));
  }
  /**
   * Iterate over all of the oscillators
   */
  _forEach(iterator) {
    for (let i = 0; i < this._oscillators.length; i++) {
      iterator(this._oscillators[i], i);
    }
  }
  /**
   * The type of the oscillator
   */
  get type() {
    return this._type;
  }
  set type(type2) {
    this._type = type2;
    this._forEach((osc) => osc.type = type2);
  }
  /**
   * The detune spread between the oscillators. If "count" is
   * set to 3 oscillators and the "spread" is set to 40,
   * the three oscillators would be detuned like this: [-20, 0, 20]
   * for a total detune spread of 40 cents.
   * @example
   * const fatOsc = new Tone.FatOscillator().toDestination().start();
   * fatOsc.spread = 70;
   */
  get spread() {
    return this._spread;
  }
  set spread(spread) {
    this._spread = spread;
    if (this._oscillators.length > 1) {
      const start2 = -spread / 2;
      const step = spread / (this._oscillators.length - 1);
      this._forEach((osc, i) => osc.detune.value = start2 + step * i);
    }
  }
  /**
   * The number of detuned oscillators. Must be an integer greater than 1.
   * @example
   * const fatOsc = new Tone.FatOscillator("C#3", "sawtooth").toDestination().start();
   * // use 4 sawtooth oscillators
   * fatOsc.count = 4;
   */
  get count() {
    return this._oscillators.length;
  }
  set count(count) {
    assertRange(count, 1);
    if (this._oscillators.length !== count) {
      this._forEach((osc) => osc.dispose());
      this._oscillators = [];
      for (let i = 0; i < count; i++) {
        const osc = new Oscillator({
          context: this.context,
          volume: -6 - count * 1.1,
          type: this._type,
          phase: this._phase + i / count * 360,
          partialCount: this._partialCount,
          onstop: i === 0 ? () => this.onstop(this) : noOp
        });
        if (this.type === "custom") {
          osc.partials = this._partials;
        }
        this.frequency.connect(osc.frequency);
        this.detune.connect(osc.detune);
        osc.detune.overridden = false;
        osc.connect(this.output);
        this._oscillators[i] = osc;
      }
      this.spread = this._spread;
      if (this.state === "started") {
        this._forEach((osc) => osc.start());
      }
    }
  }
  get phase() {
    return this._phase;
  }
  set phase(phase) {
    this._phase = phase;
    this._forEach((osc, i) => osc.phase = this._phase + i / this.count * 360);
  }
  get baseType() {
    return this._oscillators[0].baseType;
  }
  set baseType(baseType) {
    this._forEach((osc) => osc.baseType = baseType);
    this._type = this._oscillators[0].type;
  }
  get partials() {
    return this._oscillators[0].partials;
  }
  set partials(partials) {
    this._partials = partials;
    this._partialCount = this._partials.length;
    if (partials.length) {
      this._type = "custom";
      this._forEach((osc) => osc.partials = partials);
    }
  }
  get partialCount() {
    return this._oscillators[0].partialCount;
  }
  set partialCount(partialCount) {
    this._partialCount = partialCount;
    this._forEach((osc) => osc.partialCount = partialCount);
    this._type = this._oscillators[0].type;
  }
  asArray() {
    return __awaiter(this, arguments, void 0, function* (length = 1024) {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this._forEach((osc) => osc.dispose());
    return this;
  }
}
class PWMOscillator extends Source {
  constructor() {
    const options2 = optionsFromArguments(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
    super(options2);
    this.name = "PWMOscillator";
    this.sourceType = "pwm";
    this._scale = new Multiply({
      context: this.context,
      value: 2
    });
    this._pulse = new PulseOscillator({
      context: this.context,
      frequency: options2.modulationFrequency
    });
    this._pulse.carrierType = "sine";
    this.modulationFrequency = this._pulse.frequency;
    this._modulator = new Oscillator({
      context: this.context,
      detune: options2.detune,
      frequency: options2.frequency,
      onstop: () => this.onstop(this),
      phase: options2.phase
    });
    this.frequency = this._modulator.frequency;
    this.detune = this._modulator.detune;
    this._modulator.chain(this._scale, this._pulse.width);
    this._pulse.connect(this.output);
    readOnly(this, ["modulationFrequency", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      modulationFrequency: 0.4,
      phase: 0,
      type: "pwm"
    });
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    time2 = this.toSeconds(time2);
    this._modulator.start(time2);
    this._pulse.start(time2);
  }
  /**
   * stop the oscillator
   */
  _stop(time2) {
    time2 = this.toSeconds(time2);
    this._modulator.stop(time2);
    this._pulse.stop(time2);
  }
  /**
   * restart the oscillator
   */
  _restart(time2) {
    this._modulator.restart(time2);
    this._pulse.restart(time2);
  }
  /**
   * The type of the oscillator. Always returns "pwm".
   */
  get type() {
    return "pwm";
  }
  /**
   * The baseType of the oscillator. Always returns "pwm".
   */
  get baseType() {
    return "pwm";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._modulator.phase;
  }
  set phase(phase) {
    this._modulator.phase = phase;
  }
  asArray() {
    return __awaiter(this, arguments, void 0, function* (length = 1024) {
      return generateWaveform(this, length);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._pulse.dispose();
    this._scale.dispose();
    this._modulator.dispose();
    return this;
  }
}
const OmniOscillatorSourceMap = {
  am: AMOscillator,
  fat: FatOscillator,
  fm: FMOscillator,
  oscillator: Oscillator,
  pulse: PulseOscillator,
  pwm: PWMOscillator
};
class OmniOscillator extends Source {
  constructor() {
    const options2 = optionsFromArguments(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]);
    super(options2);
    this.name = "OmniOscillator";
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    readOnly(this, ["frequency", "detune"]);
    this.set(options2);
  }
  static getDefaults() {
    return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());
  }
  /**
   * start the oscillator
   */
  _start(time2) {
    this._oscillator.start(time2);
  }
  /**
   * start the oscillator
   */
  _stop(time2) {
    this._oscillator.stop(time2);
  }
  _restart(time2) {
    this._oscillator.restart(time2);
    return this;
  }
  /**
   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
   * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
   * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
   * oscillator's class are accessible when the oscillator is set to that type, but throws an error
   * when it's not.
   * @example
   * const omniOsc = new Tone.OmniOscillator().toDestination().start();
   * omniOsc.type = "pwm";
   * // modulationFrequency is parameter which is available
   * // only when the type is "pwm".
   * omniOsc.modulationFrequency.value = 0.5;
   */
  get type() {
    let prefix = "";
    if (["am", "fm", "fat"].some((p2) => this._sourceType === p2)) {
      prefix = this._sourceType;
    }
    return prefix + this._oscillator.type;
  }
  set type(type2) {
    if (type2.substr(0, 2) === "fm") {
      this._createNewOscillator("fm");
      this._oscillator = this._oscillator;
      this._oscillator.type = type2.substr(2);
    } else if (type2.substr(0, 2) === "am") {
      this._createNewOscillator("am");
      this._oscillator = this._oscillator;
      this._oscillator.type = type2.substr(2);
    } else if (type2.substr(0, 3) === "fat") {
      this._createNewOscillator("fat");
      this._oscillator = this._oscillator;
      this._oscillator.type = type2.substr(3);
    } else if (type2 === "pwm") {
      this._createNewOscillator("pwm");
      this._oscillator = this._oscillator;
    } else if (type2 === "pulse") {
      this._createNewOscillator("pulse");
    } else {
      this._createNewOscillator("oscillator");
      this._oscillator = this._oscillator;
      this._oscillator.type = type2;
    }
  }
  /**
   * The value is an empty array when the type is not "custom".
   * This is not available on "pwm" and "pulse" oscillator types.
   * @see {@link Oscillator.partials}
   */
  get partials() {
    return this._oscillator.partials;
  }
  set partials(partials) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
      this._oscillator.partials = partials;
    }
  }
  get partialCount() {
    return this._oscillator.partialCount;
  }
  set partialCount(partialCount) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
      this._oscillator.partialCount = partialCount;
    }
  }
  set(props) {
    if (Reflect.has(props, "type") && props.type) {
      this.type = props.type;
    }
    super.set(props);
    return this;
  }
  /**
   * connect the oscillator to the frequency and detune signals
   */
  _createNewOscillator(oscType) {
    if (oscType !== this._sourceType) {
      this._sourceType = oscType;
      const OscConstructor = OmniOscillatorSourceMap[oscType];
      const now = this.now();
      if (this._oscillator) {
        const oldOsc = this._oscillator;
        oldOsc.stop(now);
        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);
      }
      this._oscillator = new OscConstructor({
        context: this.context
      });
      this.frequency.connect(this._oscillator.frequency);
      this.detune.connect(this._oscillator.detune);
      this._oscillator.connect(this.output);
      this._oscillator.onstop = () => this.onstop(this);
      if (this.state === "started") {
        this._oscillator.start(now);
      }
    }
  }
  get phase() {
    return this._oscillator.phase;
  }
  set phase(phase) {
    this._oscillator.phase = phase;
  }
  /**
   * The source type of the oscillator.
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare");
   * console.log(omniOsc.sourceType); // 'fm'
   */
  get sourceType() {
    return this._sourceType;
  }
  set sourceType(sType) {
    let baseType = "sine";
    if (this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse") {
      baseType = this._oscillator.type;
    }
    if (sType === "fm") {
      this.type = "fm" + baseType;
    } else if (sType === "am") {
      this.type = "am" + baseType;
    } else if (sType === "fat") {
      this.type = "fat" + baseType;
    } else if (sType === "oscillator") {
      this.type = baseType;
    } else if (sType === "pulse") {
      this.type = "pulse";
    } else if (sType === "pwm") {
      this.type = "pwm";
    }
  }
  _getOscType(osc, sourceType) {
    return osc instanceof OmniOscillatorSourceMap[sourceType];
  }
  /**
   * The base type of the oscillator.
   * @see {@link Oscillator.baseType}
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare4");
   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);
   */
  get baseType() {
    return this._oscillator.baseType;
  }
  set baseType(baseType) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && baseType !== "pulse" && baseType !== "pwm") {
      this._oscillator.baseType = baseType;
    }
  }
  /**
   * The width of the oscillator when sourceType === "pulse".
   * @see {@link PWMOscillator}
   */
  get width() {
    if (this._getOscType(this._oscillator, "pulse")) {
      return this._oscillator.width;
    } else {
      return void 0;
    }
  }
  /**
   * The number of detuned oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get count() {
    if (this._getOscType(this._oscillator, "fat")) {
      return this._oscillator.count;
    } else {
      return void 0;
    }
  }
  set count(count) {
    if (this._getOscType(this._oscillator, "fat") && isNumber(count)) {
      this._oscillator.count = count;
    }
  }
  /**
   * The detune spread between the oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get spread() {
    if (this._getOscType(this._oscillator, "fat")) {
      return this._oscillator.spread;
    } else {
      return void 0;
    }
  }
  set spread(spread) {
    if (this._getOscType(this._oscillator, "fat") && isNumber(spread)) {
      this._oscillator.spread = spread;
    }
  }
  /**
   * The type of the modulator oscillator. Only if the oscillator is set to "am" or "fm" types.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get modulationType() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
      return this._oscillator.modulationType;
    } else {
      return void 0;
    }
  }
  set modulationType(mType) {
    if ((this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && isString(mType)) {
      this._oscillator.modulationType = mType;
    }
  }
  /**
   * The modulation index when the sourceType === "fm"
   * @see {@link FMOscillator}.
   */
  get modulationIndex() {
    if (this._getOscType(this._oscillator, "fm")) {
      return this._oscillator.modulationIndex;
    } else {
      return void 0;
    }
  }
  /**
   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get harmonicity() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
      return this._oscillator.harmonicity;
    } else {
      return void 0;
    }
  }
  /**
   * The modulationFrequency Signal of the oscillator when sourceType === "pwm"
   * see {@link PWMOscillator}
   * @min 0.1
   * @max 5
   */
  get modulationFrequency() {
    if (this._getOscType(this._oscillator, "pwm")) {
      return this._oscillator.modulationFrequency;
    } else {
      return void 0;
    }
  }
  asArray() {
    return __awaiter(this, arguments, void 0, function* (length = 1024) {
      return generateWaveform(this, length);
    });
  }
  dispose() {
    super.dispose();
    this.detune.dispose();
    this.frequency.dispose();
    this._oscillator.dispose();
    return this;
  }
}
class Add extends Signal {
  constructor() {
    super(optionsFromArguments(Add.getDefaults(), arguments, ["value"]));
    this.override = false;
    this.name = "Add";
    this._sum = new Gain({ context: this.context });
    this.input = this._sum;
    this.output = this._sum;
    this.addend = this._param;
    connectSeries(this._constantSource, this._sum);
  }
  static getDefaults() {
    return Object.assign(Signal.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    super.dispose();
    this._sum.dispose();
    return this;
  }
}
class Scale extends SignalOperator {
  constructor() {
    const options2 = optionsFromArguments(Scale.getDefaults(), arguments, [
      "min",
      "max"
    ]);
    super(options2);
    this.name = "Scale";
    this._mult = this.input = new Multiply({
      context: this.context,
      value: options2.max - options2.min
    });
    this._add = this.output = new Add({
      context: this.context,
      value: options2.min
    });
    this._min = options2.min;
    this._max = options2.max;
    this.input.connect(this.output);
  }
  static getDefaults() {
    return Object.assign(SignalOperator.getDefaults(), {
      max: 1,
      min: 0
    });
  }
  /**
   * The minimum output value. This number is output when the value input value is 0.
   */
  get min() {
    return this._min;
  }
  set min(min) {
    this._min = min;
    this._setRange();
  }
  /**
   * The maximum output value. This number is output when the value input value is 1.
   */
  get max() {
    return this._max;
  }
  set max(max) {
    this._max = max;
    this._setRange();
  }
  /**
   * set the values
   */
  _setRange() {
    this._add.value = this._min;
    this._mult.value = this._max - this._min;
  }
  dispose() {
    super.dispose();
    this._add.dispose();
    this._mult.dispose();
    return this;
  }
}
function range(min, max = Infinity) {
  const valueMap = /* @__PURE__ */ new WeakMap();
  return function(target, propertyKey) {
    Reflect.defineProperty(target, propertyKey, {
      configurable: true,
      enumerable: true,
      get: function() {
        return valueMap.get(this);
      },
      set: function(newValue) {
        assertRange(newValue, min, max);
        valueMap.set(this, newValue);
      }
    });
  };
}
function timeRange(min, max = Infinity) {
  const valueMap = /* @__PURE__ */ new WeakMap();
  return function(target, propertyKey) {
    Reflect.defineProperty(target, propertyKey, {
      configurable: true,
      enumerable: true,
      get: function() {
        return valueMap.get(this);
      },
      set: function(newValue) {
        assertRange(this.toSeconds(newValue), min, max);
        valueMap.set(this, newValue);
      }
    });
  };
}
class Player extends Source {
  constructor() {
    const options2 = optionsFromArguments(Player.getDefaults(), arguments, [
      "url",
      "onload"
    ]);
    super(options2);
    this.name = "Player";
    this._activeSources = /* @__PURE__ */ new Set();
    this._buffer = new ToneAudioBuffer({
      onload: this._onload.bind(this, options2.onload),
      onerror: options2.onerror,
      reverse: options2.reverse,
      url: options2.url
    });
    this.autostart = options2.autostart;
    this._loop = options2.loop;
    this._loopStart = options2.loopStart;
    this._loopEnd = options2.loopEnd;
    this._playbackRate = options2.playbackRate;
    this.fadeIn = options2.fadeIn;
    this.fadeOut = options2.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Source.getDefaults(), {
      autostart: false,
      fadeIn: 0,
      fadeOut: 0,
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      onload: noOp,
      onerror: noOp,
      playbackRate: 1,
      reverse: false
    });
  }
  /**
   * Load the audio file as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * Note: this does not need to be called if a url
   * was passed in to the constructor. Only use this
   * if you want to manually load a new url.
   * @param url The url of the buffer to load. Filetype support depends on the browser.
   */
  load(url) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this._buffer.load(url);
      this._onload();
      return this;
    });
  }
  /**
   * Internal callback when the buffer is loaded.
   */
  _onload(callback = noOp) {
    callback();
    if (this.autostart) {
      this.start();
    }
  }
  /**
   * Internal callback when the buffer is done playing.
   */
  _onSourceEnd(source) {
    this.onstop(this);
    this._activeSources.delete(source);
    if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started") {
      this._state.cancel(this.now());
      this._state.setStateAtTime("stopped", this.now());
    }
  }
  /**
   * Play the buffer at the given startTime. Optionally add an offset
   * and/or duration which will play the buffer from a position
   * within the buffer for the given duration.
   *
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   */
  start(time2, offset2, duration2) {
    super.start(time2, offset2, duration2);
    return this;
  }
  /**
   * Internal start method
   */
  _start(startTime, offset2, duration2) {
    if (this._loop) {
      offset2 = defaultArg(offset2, this._loopStart);
    } else {
      offset2 = defaultArg(offset2, 0);
    }
    const computedOffset = this.toSeconds(offset2);
    const origDuration = duration2;
    duration2 = defaultArg(duration2, Math.max(this._buffer.duration - computedOffset, 0));
    let computedDuration = this.toSeconds(duration2);
    computedDuration = computedDuration / this._playbackRate;
    startTime = this.toSeconds(startTime);
    const source = new ToneBufferSource({
      url: this._buffer,
      context: this.context,
      fadeIn: this.fadeIn,
      fadeOut: this.fadeOut,
      loop: this._loop,
      loopEnd: this._loopEnd,
      loopStart: this._loopStart,
      onended: this._onSourceEnd.bind(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    if (!this._loop && !this._synced) {
      this._state.cancel(startTime + computedDuration);
      this._state.setStateAtTime("stopped", startTime + computedDuration, {
        implicitEnd: true
      });
    }
    this._activeSources.add(source);
    if (this._loop && isUndef(origDuration)) {
      source.start(startTime, computedOffset);
    } else {
      source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));
    }
  }
  /**
   * Stop playback.
   */
  _stop(time2) {
    const computedTime = this.toSeconds(time2);
    this._activeSources.forEach((source) => source.stop(computedTime));
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */
  restart(time2, offset2, duration2) {
    super.restart(time2, offset2, duration2);
    return this;
  }
  _restart(time2, offset2, duration2) {
    var _a;
    (_a = [...this._activeSources].pop()) === null || _a === void 0 ? void 0 : _a.stop(time2);
    this._start(time2, offset2, duration2);
  }
  /**
   * Seek to a specific time in the player's buffer. If the
   * source is no longer playing at that time, it will stop.
   * @param offset The time to seek to.
   * @param when The time for the seek event to occur.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3", () => {
   * 	player.start();
   * 	// seek to the offset in 1 second from now
   * 	player.seek(0.4, "+1");
   * }).toDestination();
   */
  seek(offset2, when) {
    const computedTime = this.toSeconds(when);
    if (this._state.getValueAtTime(computedTime) === "started") {
      const computedOffset = this.toSeconds(offset2);
      this._stop(computedTime);
      this._start(computedTime, computedOffset);
    }
    return this;
  }
  /**
   * Set the loop start and end. Will only loop if loop is set to true.
   * @param loopStart The loop start time
   * @param loopEnd The loop end time
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3").toDestination();
   * // loop between the given points
   * player.setLoopPoints(0.2, 0.3);
   * player.loop = true;
   * player.autostart = true;
   */
  setLoopPoints(loopStart, loopEnd) {
    this.loopStart = loopStart;
    this.loopEnd = loopEnd;
    return this;
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(loopStart) {
    this._loopStart = loopStart;
    if (this.buffer.loaded) {
      assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);
    }
    this._activeSources.forEach((source) => {
      source.loopStart = loopStart;
    });
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(loopEnd) {
    this._loopEnd = loopEnd;
    if (this.buffer.loaded) {
      assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);
    }
    this._activeSources.forEach((source) => {
      source.loopEnd = loopEnd;
    });
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(buffer) {
    this._buffer.set(buffer);
  }
  /**
   * If the buffer should loop once it's over.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/breakbeat.mp3").toDestination();
   * player.loop = true;
   * player.autostart = true;
   */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    if (this._loop === loop) {
      return;
    }
    this._loop = loop;
    this._activeSources.forEach((source) => {
      source.loop = loop;
    });
    if (loop) {
      const stopEvent = this._state.getNextState("stopped", this.now());
      if (stopEvent) {
        this._state.cancel(stopEvent.time);
      }
    }
  }
  /**
   * Normal speed is 1. The pitch will change with the playback rate.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3").toDestination();
   * // play at 1/4 speed
   * player.playbackRate = 0.25;
   * // play as soon as the buffer is loaded
   * player.autostart = true;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    const now = this.now();
    const stopEvent = this._state.getNextState("stopped", now);
    if (stopEvent && stopEvent.implicitEnd) {
      this._state.cancel(stopEvent.time);
      this._activeSources.forEach((source) => source.cancelStop());
    }
    this._activeSources.forEach((source) => {
      source.playbackRate.setValueAtTime(rate, now);
    });
  }
  /**
   * If the buffer should be reversed. Note that this sets the underlying {@link ToneAudioBuffer.reverse}, so
   * if multiple players are pointing at the same ToneAudioBuffer, they will all be reversed.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/chime_1.mp3").toDestination();
   * player.autostart = true;
   * player.reverse = true;
   */
  get reverse() {
    return this._buffer.reverse;
  }
  set reverse(rev) {
    this._buffer.reverse = rev;
  }
  /**
   * If the buffer is loaded
   */
  get loaded() {
    return this._buffer.loaded;
  }
  dispose() {
    super.dispose();
    this._activeSources.forEach((source) => source.dispose());
    this._activeSources.clear();
    this._buffer.dispose();
    return this;
  }
}
__decorate([
  timeRange(0)
], Player.prototype, "fadeIn", void 0);
__decorate([
  timeRange(0)
], Player.prototype, "fadeOut", void 0);
class GainToAudio extends SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "GainToAudio";
    this._norm = new WaveShaper({
      context: this.context,
      mapping: (x) => Math.abs(x) * 2 - 1
    });
    this.input = this._norm;
    this.output = this._norm;
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this._norm.dispose();
    return this;
  }
}
class Envelope extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    super(options2);
    this.name = "Envelope";
    this._sig = new Signal({
      context: this.context,
      value: 0
    });
    this.output = this._sig;
    this.input = void 0;
    this.attack = options2.attack;
    this.decay = options2.decay;
    this.sustain = options2.sustain;
    this.release = options2.release;
    this.attackCurve = options2.attackCurve;
    this.releaseCurve = options2.releaseCurve;
    this.decayCurve = options2.decayCurve;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      attack: 0.01,
      attackCurve: "linear",
      decay: 0.1,
      decayCurve: "exponential",
      release: 1,
      releaseCurve: "exponential",
      sustain: 0.5
    });
  }
  /**
   * Read the current value of the envelope. Useful for
   * synchronizing visual output to the envelope.
   */
  get value() {
    return this.getValueAtTime(this.now());
  }
  /**
   * Get the curve
   * @param  curve
   * @param  direction  In/Out
   * @return The curve name
   */
  _getCurve(curve, direction) {
    if (isString(curve)) {
      return curve;
    } else {
      let curveName;
      for (curveName in EnvelopeCurves) {
        if (EnvelopeCurves[curveName][direction] === curve) {
          return curveName;
        }
      }
      return curve;
    }
  }
  /**
   * Assign a the curve to the given name using the direction
   * @param  name
   * @param  direction In/Out
   * @param  curve
   */
  _setCurve(name, direction, curve) {
    if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {
      const curveDef = EnvelopeCurves[curve];
      if (isObject(curveDef)) {
        if (name !== "_decayCurve") {
          this[name] = curveDef[direction];
        }
      } else {
        this[name] = curveDef;
      }
    } else if (isArray(curve) && name !== "_decayCurve") {
      this[name] = curve;
    } else {
      throw new Error("Envelope: invalid curve: " + curve);
    }
  }
  /**
   * The shape of the attack.
   * Can be any of these strings:
   * * "linear"
   * * "exponential"
   * * "sine"
   * * "cosine"
   * * "bounce"
   * * "ripple"
   * * "step"
   *
   * Can also be an array which describes the curve. Values
   * in the array are evenly subdivided and linearly
   * interpolated over the duration of the attack.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope(0.4).toDestination();
   * 	env.attackCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get attackCurve() {
    return this._getCurve(this._attackCurve, "In");
  }
  set attackCurve(curve) {
    this._setCurve("_attackCurve", "In", curve);
  }
  /**
   * The shape of the release. See the attack curve types.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		release: 0.8
   * 	}).toDestination();
   * 	env.triggerAttack();
   * 	// release curve could also be defined by an array
   * 	env.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];
   * 	env.triggerRelease(0.2);
   * }, 1, 1);
   */
  get releaseCurve() {
    return this._getCurve(this._releaseCurve, "Out");
  }
  set releaseCurve(curve) {
    this._setCurve("_releaseCurve", "Out", curve);
  }
  /**
   * The shape of the decay either "linear" or "exponential"
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		sustain: 0.1,
   * 		decay: 0.5
   * 	}).toDestination();
   * 	env.decayCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get decayCurve() {
    return this._getCurve(this._decayCurve, "Out");
  }
  set decayCurve(curve) {
    this._setCurve("_decayCurve", "Out", curve);
  }
  /**
   * Trigger the attack/decay portion of the ADSR envelope.
   * @param  time When the attack should start.
   * @param velocity The velocity of the envelope scales the vales.
   *                             number between 0-1
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the attack 0.5 seconds from now with a velocity of 0.2
   * env.triggerAttack("+0.5", 0.2);
   */
  triggerAttack(time2, velocity = 1) {
    this.log("triggerAttack", time2, velocity);
    time2 = this.toSeconds(time2);
    const originalAttack = this.toSeconds(this.attack);
    let attack = originalAttack;
    const decay = this.toSeconds(this.decay);
    const currentValue = this.getValueAtTime(time2);
    if (currentValue > 0) {
      const attackRate = 1 / attack;
      const remainingDistance = 1 - currentValue;
      attack = remainingDistance / attackRate;
    }
    if (attack < this.sampleTime) {
      this._sig.cancelScheduledValues(time2);
      this._sig.setValueAtTime(velocity, time2);
    } else if (this._attackCurve === "linear") {
      this._sig.linearRampTo(velocity, attack, time2);
    } else if (this._attackCurve === "exponential") {
      this._sig.targetRampTo(velocity, attack, time2);
    } else {
      this._sig.cancelAndHoldAtTime(time2);
      let curve = this._attackCurve;
      for (let i = 1; i < curve.length; i++) {
        if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {
          curve = this._attackCurve.slice(i);
          curve[0] = currentValue;
          break;
        }
      }
      this._sig.setValueCurveAtTime(curve, time2, attack, velocity);
    }
    if (decay && this.sustain < 1) {
      const decayValue = velocity * this.sustain;
      const decayStart = time2 + attack;
      this.log("decay", decayStart);
      if (this._decayCurve === "linear") {
        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);
      } else {
        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);
      }
    }
    return this;
  }
  /**
   * Triggers the release of the envelope.
   * @param  time When the release portion of the envelope should start.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator({
   * 	type: "sawtooth"
   * }).connect(env).start();
   * env.triggerAttack();
   * // trigger the release half a second after the attack
   * env.triggerRelease("+0.5");
   */
  triggerRelease(time2) {
    this.log("triggerRelease", time2);
    time2 = this.toSeconds(time2);
    const currentValue = this.getValueAtTime(time2);
    if (currentValue > 0) {
      const release = this.toSeconds(this.release);
      if (release < this.sampleTime) {
        this._sig.setValueAtTime(0, time2);
      } else if (this._releaseCurve === "linear") {
        this._sig.linearRampTo(0, release, time2);
      } else if (this._releaseCurve === "exponential") {
        this._sig.targetRampTo(0, release, time2);
      } else {
        assert(isArray(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array");
        this._sig.cancelAndHoldAtTime(time2);
        this._sig.setValueCurveAtTime(this._releaseCurve, time2, release, currentValue);
      }
    }
    return this;
  }
  /**
   * Get the scheduled value at the given time. This will
   * return the unconverted (raw) value.
   * @example
   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);
   * env.triggerAttackRelease(2);
   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);
   */
  getValueAtTime(time2) {
    return this._sig.getValueAtTime(time2);
  }
  /**
   * triggerAttackRelease is shorthand for triggerAttack, then waiting
   * some duration, then triggerRelease.
   * @param duration The duration of the sustain.
   * @param time When the attack should be triggered.
   * @param velocity The velocity of the envelope.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the release 0.5 seconds after the attack
   * env.triggerAttackRelease(0.5);
   */
  triggerAttackRelease(duration2, time2, velocity = 1) {
    time2 = this.toSeconds(time2);
    this.triggerAttack(time2, velocity);
    this.triggerRelease(time2 + this.toSeconds(duration2));
    return this;
  }
  /**
   * Cancels all scheduled envelope changes after the given time.
   */
  cancel(after) {
    this._sig.cancelScheduledValues(this.toSeconds(after));
    return this;
  }
  /**
   * Connect the envelope to a destination node.
   */
  connect(destination, outputNumber = 0, inputNumber = 0) {
    connectSignal(this, destination, outputNumber, inputNumber);
    return this;
  }
  /**
   * Render the envelope curve to an array of the given length.
   * Good for visualizing the envelope curve. Rescales the duration of the
   * envelope to fit the length.
   */
  asArray() {
    return __awaiter(this, arguments, void 0, function* (length = 1024) {
      const duration2 = length / this.context.sampleRate;
      const context2 = new OfflineContext(1, duration2, this.context.sampleRate);
      const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);
      const envelopeDuration = attackPortion + this.toSeconds(this.release);
      const sustainTime = envelopeDuration * 0.1;
      const totalDuration = envelopeDuration + sustainTime;
      const clone2 = new this.constructor(Object.assign(this.get(), {
        attack: duration2 * this.toSeconds(this.attack) / totalDuration,
        decay: duration2 * this.toSeconds(this.decay) / totalDuration,
        release: duration2 * this.toSeconds(this.release) / totalDuration,
        context: context2
      }));
      clone2._sig.toDestination();
      clone2.triggerAttackRelease(duration2 * (attackPortion + sustainTime) / totalDuration, 0);
      const buffer = yield context2.render();
      return buffer.getChannelData(0);
    });
  }
  dispose() {
    super.dispose();
    this._sig.dispose();
    return this;
  }
}
__decorate([
  timeRange(0)
], Envelope.prototype, "attack", void 0);
__decorate([
  timeRange(0)
], Envelope.prototype, "decay", void 0);
__decorate([
  range(0, 1)
], Envelope.prototype, "sustain", void 0);
__decorate([
  timeRange(0)
], Envelope.prototype, "release", void 0);
const EnvelopeCurves = (() => {
  const curveLen = 128;
  let i;
  let k;
  const cosineCurve = [];
  for (i = 0; i < curveLen; i++) {
    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));
  }
  const rippleCurve = [];
  const rippleCurveFreq = 6.4;
  for (i = 0; i < curveLen - 1; i++) {
    k = i / (curveLen - 1);
    const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
    rippleCurve[i] = sineWave / 10 + k * 0.83;
  }
  rippleCurve[curveLen - 1] = 1;
  const stairsCurve = [];
  const steps = 5;
  for (i = 0; i < curveLen; i++) {
    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;
  }
  const sineCurve = [];
  for (i = 0; i < curveLen; i++) {
    k = i / (curveLen - 1);
    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));
  }
  const bounceCurve = [];
  for (i = 0; i < curveLen; i++) {
    k = i / (curveLen - 1);
    const freq = Math.pow(k, 3) * 4 + 0.2;
    const val = Math.cos(freq * Math.PI * 2 * k);
    bounceCurve[i] = Math.abs(val * (1 - k));
  }
  function invertCurve(curve) {
    const out = new Array(curve.length);
    for (let j2 = 0; j2 < curve.length; j2++) {
      out[j2] = 1 - curve[j2];
    }
    return out;
  }
  function reverseCurve(curve) {
    return curve.slice(0).reverse();
  }
  return {
    bounce: {
      In: invertCurve(bounceCurve),
      Out: bounceCurve
    },
    cosine: {
      In: cosineCurve,
      Out: reverseCurve(cosineCurve)
    },
    exponential: "exponential",
    linear: "linear",
    ripple: {
      In: rippleCurve,
      Out: invertCurve(rippleCurve)
    },
    sine: {
      In: sineCurve,
      Out: invertCurve(sineCurve)
    },
    step: {
      In: stairsCurve,
      Out: invertCurve(stairsCurve)
    }
  };
})();
class Instrument extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Instrument.getDefaults(), arguments);
    super(options2);
    this._scheduledEvents = [];
    this._synced = false;
    this._original_triggerAttack = this.triggerAttack;
    this._original_triggerRelease = this.triggerRelease;
    this._syncedRelease = (time2) => this._original_triggerRelease(time2);
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options2.volume
    });
    this.volume = this._volume.volume;
    readOnly(this, "volume");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      volume: 0
    });
  }
  /**
   * Sync the instrument to the Transport. All subsequent calls of
   * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.
   * @example
   * const fmSynth = new Tone.FMSynth().toDestination();
   * fmSynth.volume.value = -6;
   * fmSynth.sync();
   * // schedule 3 notes when the transport first starts
   * fmSynth.triggerAttackRelease("C4", "8n", 0);
   * fmSynth.triggerAttackRelease("E4", "8n", "8n");
   * fmSynth.triggerAttackRelease("G4", "8n", "4n");
   * // start the transport to hear the notes
   * Tone.Transport.start();
   */
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 0);
      this.context.transport.on("stop", this._syncedRelease);
      this.context.transport.on("pause", this._syncedRelease);
      this.context.transport.on("loopEnd", this._syncedRelease);
    }
    return this;
  }
  /**
   * set _sync
   */
  _syncState() {
    let changed = false;
    if (!this._synced) {
      this._synced = true;
      changed = true;
    }
    return changed;
  }
  /**
   * Wrap the given method so that it can be synchronized
   * @param method Which method to wrap and sync
   * @param  timePosition What position the time argument appears in
   */
  _syncMethod(method, timePosition) {
    const originalMethod = this["_original_" + method] = this[method];
    this[method] = (...args) => {
      const time2 = args[timePosition];
      const id = this.context.transport.schedule((t) => {
        args[timePosition] = t;
        originalMethod.apply(this, args);
      }, time2);
      this._scheduledEvents.push(id);
    };
  }
  /**
   * Unsync the instrument from the Transport
   */
  unsync() {
    this._scheduledEvents.forEach((id) => this.context.transport.clear(id));
    this._scheduledEvents = [];
    if (this._synced) {
      this._synced = false;
      this.triggerAttack = this._original_triggerAttack;
      this.triggerRelease = this._original_triggerRelease;
      this.context.transport.off("stop", this._syncedRelease);
      this.context.transport.off("pause", this._syncedRelease);
      this.context.transport.off("loopEnd", this._syncedRelease);
    }
    return this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param  note     The note to trigger.
   * @param  duration How long the note should be held for before
   *                         triggering the release. This value must be greater than 0.
   * @param time  When the note should be triggered.
   * @param  velocity The velocity the note should be triggered at.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger "C4" for the duration of an 8th note
   * synth.triggerAttackRelease("C4", "8n");
   */
  triggerAttackRelease(note, duration2, time2, velocity) {
    const computedTime = this.toSeconds(time2);
    const computedDuration = this.toSeconds(duration2);
    this.triggerAttack(note, computedTime, velocity);
    this.triggerRelease(computedTime + computedDuration);
    return this;
  }
  /**
   * clean up
   * @returns {Instrument} this
   */
  dispose() {
    super.dispose();
    this._volume.dispose();
    this.unsync();
    this._scheduledEvents = [];
    return this;
  }
}
class Monophonic extends Instrument {
  constructor() {
    const options2 = optionsFromArguments(Monophonic.getDefaults(), arguments);
    super(options2);
    this.portamento = options2.portamento;
    this.onsilence = options2.onsilence;
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      detune: 0,
      onsilence: noOp,
      portamento: 0
    });
  }
  /**
   * Trigger the attack of the note optionally with a given velocity.
   * @param  note The note to trigger.
   * @param  time When the note should start.
   * @param  velocity The velocity determines how "loud" the note will be.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger the note a half second from now at half velocity
   * synth.triggerAttack("C4", "+0.5", 0.5);
   */
  triggerAttack(note, time2, velocity = 1) {
    this.log("triggerAttack", note, time2, velocity);
    const seconds = this.toSeconds(time2);
    this._triggerEnvelopeAttack(seconds, velocity);
    this.setNote(note, seconds);
    return this;
  }
  /**
   * Trigger the release portion of the envelope.
   * @param  time If no time is given, the release happens immediately.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // trigger the release a second from now
   * synth.triggerRelease("+1");
   */
  triggerRelease(time2) {
    this.log("triggerRelease", time2);
    const seconds = this.toSeconds(time2);
    this._triggerEnvelopeRelease(seconds);
    return this;
  }
  /**
   * Set the note at the given time. If no time is given, the note
   * will set immediately.
   * @param note The note to change to.
   * @param  time The time when the note should be set.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // change to F#6 in one quarter note from now.
   * synth.setNote("F#6", "+4n");
   */
  setNote(note, time2) {
    const computedTime = this.toSeconds(time2);
    const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;
    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {
      const portTime = this.toSeconds(this.portamento);
      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);
    } else {
      this.frequency.setValueAtTime(computedFrequency, computedTime);
    }
    return this;
  }
}
__decorate([
  timeRange(0)
], Monophonic.prototype, "portamento", void 0);
class AmplitudeEnvelope extends Envelope {
  constructor() {
    super(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [
      "attack",
      "decay",
      "sustain",
      "release"
    ]));
    this.name = "AmplitudeEnvelope";
    this._gainNode = new Gain({
      context: this.context,
      gain: 0
    });
    this.output = this._gainNode;
    this.input = this._gainNode;
    this._sig.connect(this._gainNode.gain);
    this.output = this._gainNode;
    this.input = this._gainNode;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._gainNode.dispose();
    return this;
  }
}
class Synth extends Monophonic {
  constructor() {
    const options2 = optionsFromArguments(Synth.getDefaults(), arguments);
    super(options2);
    this.name = "Synth";
    this.oscillator = new OmniOscillator(Object.assign({
      context: this.context,
      detune: options2.detune,
      onstop: () => this.onsilence(this)
    }, options2.oscillator));
    this.frequency = this.oscillator.frequency;
    this.detune = this.oscillator.detune;
    this.envelope = new AmplitudeEnvelope(Object.assign({
      context: this.context
    }, options2.envelope));
    this.oscillator.chain(this.envelope, this.output);
    readOnly(this, ["oscillator", "frequency", "detune", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(Monophonic.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.3
      }),
      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [
        ...Object.keys(Source.getDefaults()),
        "frequency",
        "detune"
      ]), {
        type: "triangle"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */
  _triggerEnvelopeAttack(time2, velocity) {
    this.envelope.triggerAttack(time2, velocity);
    this.oscillator.start(time2);
    if (this.envelope.sustain === 0) {
      const computedAttack = this.toSeconds(this.envelope.attack);
      const computedDecay = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(time2 + computedAttack + computedDecay);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */
  _triggerEnvelopeRelease(time2) {
    this.envelope.triggerRelease(time2);
    this.oscillator.stop(time2 + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this.envelope.getValueAtTime(time2);
  }
  /**
   * clean up
   */
  dispose() {
    super.dispose();
    this.oscillator.dispose();
    this.envelope.dispose();
    return this;
  }
}
class BiquadFilter extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(BiquadFilter.getDefaults(), arguments, ["frequency", "type"]);
    super(options2);
    this.name = "BiquadFilter";
    this._filter = this.context.createBiquadFilter();
    this.input = this.output = this._filter;
    this.Q = new Param({
      context: this.context,
      units: "number",
      value: options2.Q,
      param: this._filter.Q
    });
    this.frequency = new Param({
      context: this.context,
      units: "frequency",
      value: options2.frequency,
      param: this._filter.frequency
    });
    this.detune = new Param({
      context: this.context,
      units: "cents",
      value: options2.detune,
      param: this._filter.detune
    });
    this.gain = new Param({
      context: this.context,
      units: "decibels",
      convert: false,
      value: options2.gain,
      param: this._filter.gain
    });
    this.type = options2.type;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      Q: 1,
      type: "lowpass",
      frequency: 350,
      detune: 0,
      gain: 0
    });
  }
  /**
   * The type of this BiquadFilterNode. For a complete list of types and their attributes, see the
   * [Web Audio API](https://webaudio.github.io/web-audio-api/#dom-biquadfiltertype-lowpass)
   */
  get type() {
    return this._filter.type;
  }
  set type(type2) {
    const types2 = [
      "lowpass",
      "highpass",
      "bandpass",
      "lowshelf",
      "highshelf",
      "notch",
      "allpass",
      "peaking"
    ];
    assert(types2.indexOf(type2) !== -1, `Invalid filter type: ${type2}`);
    this._filter.type = type2;
  }
  /**
   * Get the frequency response curve. This curve represents how the filter
   * responses to frequencies between 20hz-20khz.
   * @param  len The number of values to return
   * @return The frequency response curve between 20-20kHz
   */
  getFrequencyResponse(len = 128) {
    const freqValues = new Float32Array(len);
    for (let i = 0; i < len; i++) {
      const norm = Math.pow(i / len, 2);
      const freq = norm * (2e4 - 20) + 20;
      freqValues[i] = freq;
    }
    const magValues = new Float32Array(len);
    const phaseValues = new Float32Array(len);
    const filterClone = this.context.createBiquadFilter();
    filterClone.type = this.type;
    filterClone.Q.value = this.Q.value;
    filterClone.frequency.value = this.frequency.value;
    filterClone.gain.value = this.gain.value;
    filterClone.getFrequencyResponse(freqValues, magValues, phaseValues);
    return magValues;
  }
  dispose() {
    super.dispose();
    this._filter.disconnect();
    this.Q.dispose();
    this.frequency.dispose();
    this.gain.dispose();
    this.detune.dispose();
    return this;
  }
}
class Filter extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Filter.getDefaults(), arguments, [
      "frequency",
      "type",
      "rolloff"
    ]);
    super(options2);
    this.name = "Filter";
    this.input = new Gain({ context: this.context });
    this.output = new Gain({ context: this.context });
    this._filters = [];
    this._filters = [];
    this.Q = new Signal({
      context: this.context,
      units: "positive",
      value: options2.Q
    });
    this.frequency = new Signal({
      context: this.context,
      units: "frequency",
      value: options2.frequency
    });
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    this.gain = new Signal({
      context: this.context,
      units: "decibels",
      convert: false,
      value: options2.gain
    });
    this._type = options2.type;
    this.rolloff = options2.rolloff;
    readOnly(this, ["detune", "frequency", "gain", "Q"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      Q: 1,
      detune: 0,
      frequency: 350,
      gain: 0,
      rolloff: -12,
      type: "lowpass"
    });
  }
  /**
   * The type of the filter. Types: "lowpass", "highpass",
   * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking".
   */
  get type() {
    return this._type;
  }
  set type(type2) {
    const types2 = [
      "lowpass",
      "highpass",
      "bandpass",
      "lowshelf",
      "highshelf",
      "notch",
      "allpass",
      "peaking"
    ];
    assert(types2.indexOf(type2) !== -1, `Invalid filter type: ${type2}`);
    this._type = type2;
    this._filters.forEach((filter) => filter.type = type2);
  }
  /**
   * The rolloff of the filter which is the drop in db
   * per octave. Implemented internally by cascading filters.
   * Only accepts the values -12, -24, -48 and -96.
   */
  get rolloff() {
    return this._rolloff;
  }
  set rolloff(rolloff) {
    const rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10);
    const possibilities = [-12, -24, -48, -96];
    let cascadingCount = possibilities.indexOf(rolloffNum);
    assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(", ")}`);
    cascadingCount += 1;
    this._rolloff = rolloffNum;
    this.input.disconnect();
    this._filters.forEach((filter) => filter.disconnect());
    this._filters = new Array(cascadingCount);
    for (let count = 0; count < cascadingCount; count++) {
      const filter = new BiquadFilter({
        context: this.context
      });
      filter.type = this._type;
      this.frequency.connect(filter.frequency);
      this.detune.connect(filter.detune);
      this.Q.connect(filter.Q);
      this.gain.connect(filter.gain);
      this._filters[count] = filter;
    }
    this._internalChannels = this._filters;
    connectSeries(this.input, ...this._internalChannels, this.output);
  }
  /**
   * Get the frequency response curve. This curve represents how the filter
   * responses to frequencies between 20hz-20khz.
   * @param  len The number of values to return
   * @return The frequency response curve between 20-20kHz
   */
  getFrequencyResponse(len = 128) {
    const filterClone = new BiquadFilter({
      context: this.context,
      frequency: this.frequency.value,
      gain: this.gain.value,
      Q: this.Q.value,
      type: this._type,
      detune: this.detune.value
    });
    const totalResponse = new Float32Array(len).map(() => 1);
    this._filters.forEach(() => {
      const response = filterClone.getFrequencyResponse(len);
      response.forEach((val, i) => totalResponse[i] *= val);
    });
    filterClone.dispose();
    return totalResponse;
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._filters.forEach((filter) => {
      filter.dispose();
    });
    writable(this, ["detune", "frequency", "gain", "Q"]);
    this.frequency.dispose();
    this.Q.dispose();
    this.detune.dispose();
    this.gain.dispose();
    return this;
  }
}
const inharmRatios = [1, 1.483, 1.932, 2.546, 2.63, 3.897];
class MetalSynth extends Monophonic {
  constructor() {
    const options2 = optionsFromArguments(MetalSynth.getDefaults(), arguments);
    super(options2);
    this.name = "MetalSynth";
    this._oscillators = [];
    this._freqMultipliers = [];
    this.detune = new Signal({
      context: this.context,
      units: "cents",
      value: options2.detune
    });
    this.frequency = new Signal({
      context: this.context,
      units: "frequency"
    });
    this._amplitude = new Gain({
      context: this.context,
      gain: 0
    }).connect(this.output);
    this._highpass = new Filter({
      // Q: -3.0102999566398125,
      Q: 0,
      context: this.context,
      type: "highpass"
    }).connect(this._amplitude);
    for (let i = 0; i < inharmRatios.length; i++) {
      const osc = new FMOscillator({
        context: this.context,
        harmonicity: options2.harmonicity,
        modulationIndex: options2.modulationIndex,
        modulationType: "square",
        onstop: i === 0 ? () => this.onsilence(this) : noOp,
        type: "square"
      });
      osc.connect(this._highpass);
      this._oscillators[i] = osc;
      const mult = new Multiply({
        context: this.context,
        value: inharmRatios[i]
      });
      this._freqMultipliers[i] = mult;
      this.frequency.chain(mult, osc.frequency);
      this.detune.connect(osc.detune);
    }
    this._filterFreqScaler = new Scale({
      context: this.context,
      max: 7e3,
      min: this.toFrequency(options2.resonance)
    });
    this.envelope = new Envelope({
      attack: options2.envelope.attack,
      attackCurve: "linear",
      context: this.context,
      decay: options2.envelope.decay,
      release: options2.envelope.release,
      sustain: 0
    });
    this.envelope.chain(this._filterFreqScaler, this._highpass.frequency);
    this.envelope.connect(this._amplitude.gain);
    this._octaves = options2.octaves;
    this.octaves = options2.octaves;
  }
  static getDefaults() {
    return deepMerge(Monophonic.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        attack: 1e-3,
        decay: 1.4,
        release: 0.2
      }),
      harmonicity: 5.1,
      modulationIndex: 32,
      octaves: 1.5,
      resonance: 4e3
    });
  }
  /**
   * Trigger the attack.
   * @param time When the attack should be triggered.
   * @param velocity The velocity that the envelope should be triggered at.
   */
  _triggerEnvelopeAttack(time2, velocity = 1) {
    this.envelope.triggerAttack(time2, velocity);
    this._oscillators.forEach((osc) => osc.start(time2));
    if (this.envelope.sustain === 0) {
      this._oscillators.forEach((osc) => {
        osc.stop(time2 + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));
      });
    }
    return this;
  }
  /**
   * Trigger the release of the envelope.
   * @param time When the release should be triggered.
   */
  _triggerEnvelopeRelease(time2) {
    this.envelope.triggerRelease(time2);
    this._oscillators.forEach((osc) => osc.stop(time2 + this.toSeconds(this.envelope.release)));
    return this;
  }
  getLevelAtTime(time2) {
    time2 = this.toSeconds(time2);
    return this.envelope.getValueAtTime(time2);
  }
  /**
   * The modulationIndex of the oscillators which make up the source.
   * see {@link FMOscillator.modulationIndex}
   * @min 1
   * @max 100
   */
  get modulationIndex() {
    return this._oscillators[0].modulationIndex.value;
  }
  set modulationIndex(val) {
    this._oscillators.forEach((osc) => osc.modulationIndex.value = val);
  }
  /**
   * The harmonicity of the oscillators which make up the source.
   * see Tone.FMOscillator.harmonicity
   * @min 0.1
   * @max 10
   */
  get harmonicity() {
    return this._oscillators[0].harmonicity.value;
  }
  set harmonicity(val) {
    this._oscillators.forEach((osc) => osc.harmonicity.value = val);
  }
  /**
   * The lower level of the highpass filter which is attached to the envelope.
   * This value should be between [0, 7000]
   * @min 0
   * @max 7000
   */
  get resonance() {
    return this._filterFreqScaler.min;
  }
  set resonance(val) {
    this._filterFreqScaler.min = this.toFrequency(val);
    this.octaves = this._octaves;
  }
  /**
   * The number of octaves above the "resonance" frequency
   * that the filter ramps during the attack/decay envelope
   * @min 0
   * @max 8
   */
  get octaves() {
    return this._octaves;
  }
  set octaves(val) {
    this._octaves = val;
    this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, val);
  }
  dispose() {
    super.dispose();
    this._oscillators.forEach((osc) => osc.dispose());
    this._freqMultipliers.forEach((freqMult) => freqMult.dispose());
    this.frequency.dispose();
    this.detune.dispose();
    this._filterFreqScaler.dispose();
    this._amplitude.dispose();
    this.envelope.dispose();
    this._highpass.dispose();
    return this;
  }
}
class MembraneSynth extends Synth {
  constructor() {
    const options2 = optionsFromArguments(MembraneSynth.getDefaults(), arguments);
    super(options2);
    this.name = "MembraneSynth";
    this.portamento = 0;
    this.pitchDecay = options2.pitchDecay;
    this.octaves = options2.octaves;
    readOnly(this, ["oscillator", "envelope"]);
  }
  static getDefaults() {
    return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {
      envelope: {
        attack: 1e-3,
        attackCurve: "exponential",
        decay: 0.4,
        release: 1.4,
        sustain: 0.01
      },
      octaves: 10,
      oscillator: {
        type: "sine"
      },
      pitchDecay: 0.05
    });
  }
  setNote(note, time2) {
    const seconds = this.toSeconds(time2);
    const hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);
    const maxNote = hertz * this.octaves;
    this.oscillator.frequency.setValueAtTime(maxNote, seconds);
    this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));
    return this;
  }
  dispose() {
    super.dispose();
    return this;
  }
}
__decorate([
  range(0)
], MembraneSynth.prototype, "octaves", void 0);
__decorate([
  timeRange(0)
], MembraneSynth.prototype, "pitchDecay", void 0);
class NoiseSynth extends Instrument {
  constructor() {
    const options2 = optionsFromArguments(NoiseSynth.getDefaults(), arguments);
    super(options2);
    this.name = "NoiseSynth";
    this.noise = new Noise(Object.assign({
      context: this.context
    }, options2.noise));
    this.envelope = new AmplitudeEnvelope(Object.assign({
      context: this.context
    }, options2.envelope));
    this.noise.chain(this.envelope, this.output);
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {
        decay: 0.1,
        sustain: 0
      }),
      noise: Object.assign(omitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())), {
        type: "white"
      })
    });
  }
  /**
   * Start the attack portion of the envelopes. Unlike other
   * instruments, Tone.NoiseSynth doesn't have a note.
   * @example
   * const noiseSynth = new Tone.NoiseSynth().toDestination();
   * noiseSynth.triggerAttack();
   */
  triggerAttack(time2, velocity = 1) {
    time2 = this.toSeconds(time2);
    this.envelope.triggerAttack(time2, velocity);
    this.noise.start(time2);
    if (this.envelope.sustain === 0) {
      this.noise.stop(time2 + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));
    }
    return this;
  }
  /**
   * Start the release portion of the envelopes.
   */
  triggerRelease(time2) {
    time2 = this.toSeconds(time2);
    this.envelope.triggerRelease(time2);
    this.noise.stop(time2 + this.toSeconds(this.envelope.release));
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 0);
      this._syncMethod("triggerRelease", 0);
    }
    return this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param duration The amount of time to hold the note for
   * @param time The time the note should start
   * @param velocity The volume of the note (0-1)
   * @example
   * const noiseSynth = new Tone.NoiseSynth().toDestination();
   * // hold the note for 0.5 seconds
   * noiseSynth.triggerAttackRelease(0.5);
   */
  triggerAttackRelease(duration2, time2, velocity = 1) {
    time2 = this.toSeconds(time2);
    duration2 = this.toSeconds(duration2);
    this.triggerAttack(time2, velocity);
    this.triggerRelease(time2 + duration2);
    return this;
  }
  dispose() {
    super.dispose();
    this.noise.dispose();
    this.envelope.dispose();
    return this;
  }
}
const workletContext = /* @__PURE__ */ new Set();
function addToWorklet(classOrFunction) {
  workletContext.add(classOrFunction);
}
function registerProcessor(name, classDesc) {
  const processor = (
    /* javascript */
    `registerProcessor("${name}", ${classDesc})`
  );
  workletContext.add(processor);
}
const toneAudioWorkletProcessor = (
  /* javascript */
  `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`
);
addToWorklet(toneAudioWorkletProcessor);
const singleIOProcess = (
  /* javascript */
  `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`
);
addToWorklet(singleIOProcess);
const delayLine = (
  /* javascript */
  `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`
);
addToWorklet(delayLine);
const workletName$1 = "feedback-comb-filter";
const feedbackCombFilter = (
  /* javascript */
  `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`
);
registerProcessor(workletName$1, feedbackCombFilter);
class PolySynth extends Instrument {
  constructor() {
    const options2 = optionsFromArguments(PolySynth.getDefaults(), arguments, ["voice", "options"]);
    super(options2);
    this.name = "PolySynth";
    this._availableVoices = [];
    this._activeVoices = [];
    this._voices = [];
    this._gcTimeout = -1;
    this._averageActiveVoices = 0;
    this._syncedRelease = (time2) => this.releaseAll(time2);
    assert(!isNumber(options2.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
    const defaults2 = options2.voice.getDefaults();
    this.options = Object.assign(defaults2, options2.options);
    this.voice = options2.voice;
    this.maxPolyphony = options2.maxPolyphony;
    this._dummyVoice = this._getNextAvailableVoice();
    const index = this._voices.indexOf(this._dummyVoice);
    this._voices.splice(index, 1);
    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      maxPolyphony: 32,
      options: {},
      voice: Synth
    });
  }
  /**
   * The number of active voices.
   */
  get activeVoices() {
    return this._activeVoices.length;
  }
  /**
   * Invoked when the source is done making sound, so that it can be
   * readded to the pool of available voices
   */
  _makeVoiceAvailable(voice) {
    this._availableVoices.push(voice);
    const activeVoiceIndex = this._activeVoices.findIndex((e2) => e2.voice === voice);
    this._activeVoices.splice(activeVoiceIndex, 1);
  }
  /**
   * Get an available voice from the pool of available voices.
   * If one is not available and the maxPolyphony limit is reached,
   * steal a voice, otherwise return null.
   */
  _getNextAvailableVoice() {
    if (this._availableVoices.length) {
      return this._availableVoices.shift();
    } else if (this._voices.length < this.maxPolyphony) {
      const voice = new this.voice(Object.assign(this.options, {
        context: this.context,
        onsilence: this._makeVoiceAvailable.bind(this)
      }));
      assert(voice instanceof Monophonic, "Voice must extend Monophonic class");
      voice.connect(this.output);
      this._voices.push(voice);
      return voice;
    } else {
      warn3("Max polyphony exceeded. Note dropped.");
    }
  }
  /**
   * Occasionally check if there are any allocated voices which can be cleaned up.
   */
  _collectGarbage() {
    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);
    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
      const firstAvail = this._availableVoices.shift();
      const index = this._voices.indexOf(firstAvail);
      this._voices.splice(index, 1);
      if (!this.context.isOffline) {
        firstAvail.dispose();
      }
    }
  }
  /**
   * Internal method which triggers the attack
   */
  _triggerAttack(notes, time2, velocity) {
    notes.forEach((note) => {
      const midiNote = new MidiClass(this.context, note).toMidi();
      const voice = this._getNextAvailableVoice();
      if (voice) {
        voice.triggerAttack(note, time2, velocity);
        this._activeVoices.push({
          midi: midiNote,
          voice,
          released: false
        });
        this.log("triggerAttack", note, time2);
      }
    });
  }
  /**
   * Internal method which triggers the release
   */
  _triggerRelease(notes, time2) {
    notes.forEach((note) => {
      const midiNote = new MidiClass(this.context, note).toMidi();
      const event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);
      if (event) {
        event.voice.triggerRelease(time2);
        event.released = true;
        this.log("triggerRelease", note, time2);
      }
    });
  }
  /**
   * Schedule the attack/release events. If the time is in the future, then it should set a timeout
   * to wait for just-in-time scheduling
   */
  _scheduleEvent(type2, notes, time2, velocity) {
    assert(!this.disposed, "Synth was already disposed");
    if (time2 <= this.now()) {
      if (type2 === "attack") {
        this._triggerAttack(notes, time2, velocity);
      } else {
        this._triggerRelease(notes, time2);
      }
    } else {
      this.context.setTimeout(() => {
        if (!this.disposed) {
          this._scheduleEvent(type2, notes, time2, velocity);
        }
      }, time2 - this.now());
    }
  }
  /**
   * Trigger the attack portion of the note
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  The start time of the note.
   * @param velocity The velocity of the note.
   * @example
   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();
   * // trigger a chord immediately with a velocity of 0.2
   * synth.triggerAttack(["Ab3", "C4", "F5"], Tone.now(), 0.2);
   */
  triggerAttack(notes, time2, velocity) {
    if (!Array.isArray(notes)) {
      notes = [notes];
    }
    const computedTime = this.toSeconds(time2);
    this._scheduleEvent("attack", notes, computedTime, velocity);
    return this;
  }
  /**
   * Trigger the release of the note. Unlike monophonic instruments,
   * a note (or array of notes) needs to be passed in as the first argument.
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  When the release will be triggered.
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * poly.triggerAttack(["Ab3", "C4", "F5"]);
   * // trigger the release of the given notes.
   * poly.triggerRelease(["Ab3", "C4"], "+1");
   * poly.triggerRelease("F5", "+3");
   */
  triggerRelease(notes, time2) {
    if (!Array.isArray(notes)) {
      notes = [notes];
    }
    const computedTime = this.toSeconds(time2);
    this._scheduleEvent("release", notes, computedTime);
    return this;
  }
  /**
   * Trigger the attack and release after the specified duration
   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.
   * @param  duration the duration of the note
   * @param  time  if no time is given, defaults to now
   * @param  velocity the velocity of the attack (0-1)
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * // can pass in an array of durations as well
   * poly.triggerAttackRelease(["Eb3", "G4", "Bb4", "D5"], [4, 3, 2, 1]);
   */
  triggerAttackRelease(notes, duration2, time2, velocity) {
    const computedTime = this.toSeconds(time2);
    this.triggerAttack(notes, computedTime, velocity);
    if (isArray(duration2)) {
      assert(isArray(notes), "If the duration is an array, the notes must also be an array");
      notes = notes;
      for (let i = 0; i < notes.length; i++) {
        const d2 = duration2[Math.min(i, duration2.length - 1)];
        const durationSeconds = this.toSeconds(d2);
        assert(durationSeconds > 0, "The duration must be greater than 0");
        this.triggerRelease(notes[i], computedTime + durationSeconds);
      }
    } else {
      const durationSeconds = this.toSeconds(duration2);
      assert(durationSeconds > 0, "The duration must be greater than 0");
      this.triggerRelease(notes, computedTime + durationSeconds);
    }
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 1);
      this.context.transport.on("stop", this._syncedRelease);
      this.context.transport.on("pause", this._syncedRelease);
      this.context.transport.on("loopEnd", this._syncedRelease);
    }
    return this;
  }
  /**
   * Set a member/attribute of the voices
   * @example
   * const poly = new Tone.PolySynth().toDestination();
   * // set all of the voices using an options object for the synth type
   * poly.set({
   * 	envelope: {
   * 		attack: 0.25
   * 	}
   * });
   * poly.triggerAttackRelease("Bb3", 0.2);
   */
  set(options2) {
    const sanitizedOptions = omitFromObject(options2, [
      "onsilence",
      "context"
    ]);
    this.options = deepMerge(this.options, sanitizedOptions);
    this._voices.forEach((voice) => voice.set(sanitizedOptions));
    this._dummyVoice.set(sanitizedOptions);
    return this;
  }
  get() {
    return this._dummyVoice.get();
  }
  /**
   * Trigger the release portion of all the currently active voices immediately.
   * Useful for silencing the synth.
   */
  releaseAll(time2) {
    const computedTime = this.toSeconds(time2);
    this._activeVoices.forEach(({ voice }) => {
      voice.triggerRelease(computedTime);
    });
    return this;
  }
  dispose() {
    super.dispose();
    this._dummyVoice.dispose();
    this._voices.forEach((v) => v.dispose());
    this._activeVoices = [];
    this._availableVoices = [];
    this.context.clearInterval(this._gcTimeout);
    return this;
  }
}
class Sampler extends Instrument {
  constructor() {
    const options2 = optionsFromArguments(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    super(options2);
    this.name = "Sampler";
    this._activeSources = /* @__PURE__ */ new Map();
    const urlMap = {};
    Object.keys(options2.urls).forEach((note) => {
      const noteNumber = parseInt(note, 10);
      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);
      if (isNote(note)) {
        const mid = new FrequencyClass(this.context, note).toMidi();
        urlMap[mid] = options2.urls[note];
      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {
        urlMap[noteNumber] = options2.urls[noteNumber];
      }
    });
    this._buffers = new ToneAudioBuffers({
      urls: urlMap,
      onload: options2.onload,
      baseUrl: options2.baseUrl,
      onerror: options2.onerror
    });
    this.attack = options2.attack;
    this.release = options2.release;
    this.curve = options2.curve;
    if (this._buffers.loaded) {
      Promise.resolve().then(options2.onload);
    }
  }
  static getDefaults() {
    return Object.assign(Instrument.getDefaults(), {
      attack: 0,
      baseUrl: "",
      curve: "exponential",
      onload: noOp,
      onerror: noOp,
      release: 0.1,
      urls: {}
    });
  }
  /**
   * Returns the difference in steps between the given midi note at the closets sample.
   */
  _findClosest(midi) {
    const MAX_INTERVAL = 96;
    let interval = 0;
    while (interval < MAX_INTERVAL) {
      if (this._buffers.has(midi + interval)) {
        return -interval;
      } else if (this._buffers.has(midi - interval)) {
        return interval;
      }
      interval++;
    }
    throw new Error(`No available buffers for note: ${midi}`);
  }
  /**
   * @param  notes	The note to play, or an array of notes.
   * @param  time     When to play the note
   * @param  velocity The velocity to play the sample back.
   */
  triggerAttack(notes, time2, velocity = 1) {
    this.log("triggerAttack", notes, time2, velocity);
    if (!Array.isArray(notes)) {
      notes = [notes];
    }
    notes.forEach((note) => {
      const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());
      const midi = Math.round(midiFloat);
      const remainder = midiFloat - midi;
      const difference = this._findClosest(midi);
      const closestNote = midi - difference;
      const buffer = this._buffers.get(closestNote);
      const playbackRate = intervalToFrequencyRatio(difference + remainder);
      const source = new ToneBufferSource({
        url: buffer,
        context: this.context,
        curve: this.curve,
        fadeIn: this.attack,
        fadeOut: this.release,
        playbackRate
      }).connect(this.output);
      source.start(time2, 0, buffer.duration / playbackRate, velocity);
      if (!isArray(this._activeSources.get(midi))) {
        this._activeSources.set(midi, []);
      }
      this._activeSources.get(midi).push(source);
      source.onended = () => {
        if (this._activeSources && this._activeSources.has(midi)) {
          const sources = this._activeSources.get(midi);
          const index = sources.indexOf(source);
          if (index !== -1) {
            sources.splice(index, 1);
          }
        }
      };
    });
    return this;
  }
  /**
   * @param  notes	The note to release, or an array of notes.
   * @param  time     	When to release the note.
   */
  triggerRelease(notes, time2) {
    this.log("triggerRelease", notes, time2);
    if (!Array.isArray(notes)) {
      notes = [notes];
    }
    notes.forEach((note) => {
      const midi = new FrequencyClass(this.context, note).toMidi();
      if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {
        const sources = this._activeSources.get(midi);
        time2 = this.toSeconds(time2);
        sources.forEach((source) => {
          source.stop(time2);
        });
        this._activeSources.set(midi, []);
      }
    });
    return this;
  }
  /**
   * Release all currently active notes.
   * @param  time     	When to release the notes.
   */
  releaseAll(time2) {
    const computedTime = this.toSeconds(time2);
    this._activeSources.forEach((sources) => {
      while (sources.length) {
        const source = sources.shift();
        source.stop(computedTime);
      }
    });
    return this;
  }
  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);
      this._syncMethod("triggerRelease", 1);
    }
    return this;
  }
  /**
   * Invoke the attack phase, then after the duration, invoke the release.
   * @param  notes	The note to play and release, or an array of notes.
   * @param  duration The time the note should be held
   * @param  time     When to start the attack
   * @param  velocity The velocity of the attack
   */
  triggerAttackRelease(notes, duration2, time2, velocity = 1) {
    const computedTime = this.toSeconds(time2);
    this.triggerAttack(notes, computedTime, velocity);
    if (isArray(duration2)) {
      assert(isArray(notes), "notes must be an array when duration is array");
      notes.forEach((note, index) => {
        const d2 = duration2[Math.min(index, duration2.length - 1)];
        this.triggerRelease(note, computedTime + this.toSeconds(d2));
      });
    } else {
      this.triggerRelease(notes, computedTime + this.toSeconds(duration2));
    }
    return this;
  }
  /**
   * Add a note to the sampler.
   * @param  note      The buffer's pitch.
   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   */
  add(note, url, callback) {
    assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);
    if (isNote(note)) {
      const mid = new FrequencyClass(this.context, note).toMidi();
      this._buffers.add(mid, url, callback);
    } else {
      this._buffers.add(note, url, callback);
    }
    return this;
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Clean up
   */
  dispose() {
    super.dispose();
    this._buffers.dispose();
    this._activeSources.forEach((sources) => {
      sources.forEach((source) => source.dispose());
    });
    this._activeSources.clear();
    return this;
  }
}
__decorate([
  timeRange(0)
], Sampler.prototype, "attack", void 0);
__decorate([
  timeRange(0)
], Sampler.prototype, "release", void 0);
class ToneEvent extends ToneWithContext {
  constructor() {
    const options2 = optionsFromArguments(ToneEvent.getDefaults(), arguments, ["callback", "value"]);
    super(options2);
    this.name = "ToneEvent";
    this._state = new StateTimeline("stopped");
    this._startOffset = 0;
    this._loop = options2.loop;
    this.callback = options2.callback;
    this.value = options2.value;
    this._loopStart = this.toTicks(options2.loopStart);
    this._loopEnd = this.toTicks(options2.loopEnd);
    this._playbackRate = options2.playbackRate;
    this._probability = options2.probability;
    this._humanize = options2.humanize;
    this.mute = options2.mute;
    this._playbackRate = options2.playbackRate;
    this._state.increasing = true;
    this._rescheduleEvents();
  }
  static getDefaults() {
    return Object.assign(ToneWithContext.getDefaults(), {
      callback: noOp,
      humanize: false,
      loop: false,
      loopEnd: "1m",
      loopStart: 0,
      mute: false,
      playbackRate: 1,
      probability: 1,
      value: null
    });
  }
  /**
   * Reschedule all of the events along the timeline
   * with the updated values.
   * @param after Only reschedules events after the given time.
   */
  _rescheduleEvents(after = -1) {
    this._state.forEachFrom(after, (event) => {
      let duration2;
      if (event.state === "started") {
        if (event.id !== -1) {
          this.context.transport.clear(event.id);
        }
        const startTick = event.time + Math.round(this.startOffset / this._playbackRate);
        if (this._loop === true || isNumber(this._loop) && this._loop > 1) {
          duration2 = Infinity;
          if (isNumber(this._loop)) {
            duration2 = this._loop * this._getLoopDuration();
          }
          const nextEvent = this._state.getAfter(startTick);
          if (nextEvent !== null) {
            duration2 = Math.min(duration2, nextEvent.time - startTick);
          }
          if (duration2 !== Infinity) {
            duration2 = new TicksClass(this.context, duration2);
          }
          const interval = new TicksClass(this.context, this._getLoopDuration());
          event.id = this.context.transport.scheduleRepeat(this._tick.bind(this), interval, new TicksClass(this.context, startTick), duration2);
        } else {
          event.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));
        }
      }
    });
  }
  /**
   * Returns the playback state of the note, either "started" or "stopped".
   */
  get state() {
    return this._state.getValueAtTime(this.context.transport.ticks);
  }
  /**
   * The start from the scheduled start time.
   */
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(offset2) {
    this._startOffset = offset2;
  }
  /**
   * The probability of the notes being triggered.
   */
  get probability() {
    return this._probability;
  }
  set probability(prob) {
    this._probability = prob;
  }
  /**
   * If set to true, will apply small random variation
   * to the callback time. If the value is given as a time, it will randomize
   * by that amount.
   * @example
   * const event = new Tone.ToneEvent();
   * event.humanize = true;
   */
  get humanize() {
    return this._humanize;
  }
  set humanize(variation) {
    this._humanize = variation;
  }
  /**
   * Start the note at the given time.
   * @param  time  When the event should start.
   */
  start(time2) {
    const ticks = this.toTicks(time2);
    if (this._state.getValueAtTime(ticks) === "stopped") {
      this._state.add({
        id: -1,
        state: "started",
        time: ticks
      });
      this._rescheduleEvents(ticks);
    }
    return this;
  }
  /**
   * Stop the Event at the given time.
   * @param  time  When the event should stop.
   */
  stop(time2) {
    this.cancel(time2);
    const ticks = this.toTicks(time2);
    if (this._state.getValueAtTime(ticks) === "started") {
      this._state.setStateAtTime("stopped", ticks, { id: -1 });
      const previousEvent = this._state.getBefore(ticks);
      let rescheduleTime = ticks;
      if (previousEvent !== null) {
        rescheduleTime = previousEvent.time;
      }
      this._rescheduleEvents(rescheduleTime);
    }
    return this;
  }
  /**
   * Cancel all scheduled events greater than or equal to the given time
   * @param  time  The time after which events will be cancel.
   */
  cancel(time2) {
    time2 = defaultArg(time2, -Infinity);
    const ticks = this.toTicks(time2);
    this._state.forEachFrom(ticks, (event) => {
      this.context.transport.clear(event.id);
    });
    this._state.cancel(ticks);
    return this;
  }
  /**
   * The callback function invoker. Also
   * checks if the Event is done playing
   * @param  time  The time of the event in seconds
   */
  _tick(time2) {
    const ticks = this.context.transport.getTicksAtTime(time2);
    if (!this.mute && this._state.getValueAtTime(ticks) === "started") {
      if (this.probability < 1 && Math.random() > this.probability) {
        return;
      }
      if (this.humanize) {
        let variation = 0.02;
        if (!isBoolean(this.humanize)) {
          variation = this.toSeconds(this.humanize);
        }
        time2 += (Math.random() * 2 - 1) * variation;
      }
      this.callback(time2, this.value);
    }
  }
  /**
   * Get the duration of the loop.
   */
  _getLoopDuration() {
    return (this._loopEnd - this._loopStart) / this._playbackRate;
  }
  /**
   * If the note should loop or not
   * between ToneEvent.loopStart and
   * ToneEvent.loopEnd. If set to true,
   * the event will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this._rescheduleEvents();
  }
  /**
   * The playback rate of the event. Defaults to 1.
   * @example
   * const note = new Tone.ToneEvent();
   * note.loop = true;
   * // repeat the note twice as fast
   * note.playbackRate = 2;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    this._rescheduleEvents();
  }
  /**
   * The loopEnd point is the time the event will loop
   * if ToneEvent.loop is true.
   */
  get loopEnd() {
    return new TicksClass(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(loopEnd) {
    this._loopEnd = this.toTicks(loopEnd);
    if (this._loop) {
      this._rescheduleEvents();
    }
  }
  /**
   * The time when the loop should start.
   */
  get loopStart() {
    return new TicksClass(this.context, this._loopStart).toSeconds();
  }
  set loopStart(loopStart) {
    this._loopStart = this.toTicks(loopStart);
    if (this._loop) {
      this._rescheduleEvents();
    }
  }
  /**
   * The current progress of the loop interval.
   * Returns 0 if the event is not started yet or
   * it is not set to loop.
   */
  get progress() {
    if (this._loop) {
      const ticks = this.context.transport.ticks;
      const lastEvent = this._state.get(ticks);
      if (lastEvent !== null && lastEvent.state === "started") {
        const loopDuration = this._getLoopDuration();
        const progress = (ticks - lastEvent.time) % loopDuration;
        return progress / loopDuration;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }
  dispose() {
    super.dispose();
    this.cancel();
    this._state.dispose();
    return this;
  }
}
class Part extends ToneEvent {
  constructor() {
    const options2 = optionsFromArguments(Part.getDefaults(), arguments, [
      "callback",
      "events"
    ]);
    super(options2);
    this.name = "Part";
    this._state = new StateTimeline("stopped");
    this._events = /* @__PURE__ */ new Set();
    this._state.increasing = true;
    options2.events.forEach((event) => {
      if (isArray(event)) {
        this.add(event[0], event[1]);
      } else {
        this.add(event);
      }
    });
  }
  static getDefaults() {
    return Object.assign(ToneEvent.getDefaults(), {
      events: []
    });
  }
  /**
   * Start the part at the given time.
   * @param  time    When to start the part.
   * @param  offset  The offset from the start of the part to begin playing at.
   */
  start(time2, offset2) {
    const ticks = this.toTicks(time2);
    if (this._state.getValueAtTime(ticks) !== "started") {
      offset2 = defaultArg(offset2, this._loop ? this._loopStart : 0);
      if (this._loop) {
        offset2 = defaultArg(offset2, this._loopStart);
      } else {
        offset2 = defaultArg(offset2, 0);
      }
      const computedOffset = this.toTicks(offset2);
      this._state.add({
        id: -1,
        offset: computedOffset,
        state: "started",
        time: ticks
      });
      this._forEach((event) => {
        this._startNote(event, ticks, computedOffset);
      });
    }
    return this;
  }
  /**
   * Start the event in the given event at the correct time given
   * the ticks and offset and looping.
   * @param  event
   * @param  ticks
   * @param  offset
   */
  _startNote(event, ticks, offset2) {
    ticks -= offset2;
    if (this._loop) {
      if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
        if (event.startOffset < offset2) {
          ticks += this._getLoopDuration();
        }
        event.start(new TicksClass(this.context, ticks));
      } else if (event.startOffset < this._loopStart && event.startOffset >= offset2) {
        event.loop = false;
        event.start(new TicksClass(this.context, ticks));
      }
    } else if (event.startOffset >= offset2) {
      event.start(new TicksClass(this.context, ticks));
    }
  }
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(offset2) {
    this._startOffset = offset2;
    this._forEach((event) => {
      event.startOffset += this._startOffset;
    });
  }
  /**
   * Stop the part at the given time.
   * @param  time  When to stop the part.
   */
  stop(time2) {
    const ticks = this.toTicks(time2);
    this._state.cancel(ticks);
    this._state.setStateAtTime("stopped", ticks);
    this._forEach((event) => {
      event.stop(time2);
    });
    return this;
  }
  /**
   * Get/Set an Event's value at the given time.
   * If a value is passed in and no event exists at
   * the given time, one will be created with that value.
   * If two events are at the same time, the first one will
   * be returned.
   * @example
   * const part = new Tone.Part();
   * part.at("1m"); // returns the part at the first measure
   * part.at("2m", "C2"); // set the value at "2m" to C2.
   * // if an event didn't exist at that time, it will be created.
   * @param time The time of the event to get or set.
   * @param value If a value is passed in, the value of the event at the given time will be set to it.
   */
  at(time2, value) {
    const timeInTicks = new TransportTimeClass(this.context, time2).toTicks();
    const tickTime = new TicksClass(this.context, 1).toSeconds();
    const iterator = this._events.values();
    let result = iterator.next();
    while (!result.done) {
      const event = result.value;
      if (Math.abs(timeInTicks - event.startOffset) < tickTime) {
        if (isDefined(value)) {
          event.value = value;
        }
        return event;
      }
      result = iterator.next();
    }
    if (isDefined(value)) {
      this.add(time2, value);
      return this.at(time2);
    } else {
      return null;
    }
  }
  add(time2, value) {
    if (time2 instanceof Object && Reflect.has(time2, "time")) {
      value = time2;
      time2 = value.time;
    }
    const ticks = this.toTicks(time2);
    let event;
    if (value instanceof ToneEvent) {
      event = value;
      event.callback = this._tick.bind(this);
    } else {
      event = new ToneEvent({
        callback: this._tick.bind(this),
        context: this.context,
        value
      });
    }
    event.startOffset = ticks;
    event.set({
      humanize: this.humanize,
      loop: this.loop,
      loopEnd: this.loopEnd,
      loopStart: this.loopStart,
      playbackRate: this.playbackRate,
      probability: this.probability
    });
    this._events.add(event);
    this._restartEvent(event);
    return this;
  }
  /**
   * Restart the given event
   */
  _restartEvent(event) {
    this._state.forEach((stateEvent) => {
      if (stateEvent.state === "started") {
        this._startNote(event, stateEvent.time, stateEvent.offset);
      } else {
        event.stop(new TicksClass(this.context, stateEvent.time));
      }
    });
  }
  remove(time2, value) {
    if (isObject(time2) && time2.hasOwnProperty("time")) {
      value = time2;
      time2 = value.time;
    }
    time2 = this.toTicks(time2);
    this._events.forEach((event) => {
      if (event.startOffset === time2) {
        if (isUndef(value) || isDefined(value) && event.value === value) {
          this._events.delete(event);
          event.dispose();
        }
      }
    });
    return this;
  }
  /**
   * Remove all of the notes from the group.
   */
  clear() {
    this._forEach((event) => event.dispose());
    this._events.clear();
    return this;
  }
  /**
   * Cancel scheduled state change events: i.e. "start" and "stop".
   * @param after The time after which to cancel the scheduled events.
   */
  cancel(after) {
    this._forEach((event) => event.cancel(after));
    this._state.cancel(this.toTicks(after));
    return this;
  }
  /**
   * Iterate over all of the events
   */
  _forEach(callback) {
    if (this._events) {
      this._events.forEach((event) => {
        if (event instanceof Part) {
          event._forEach(callback);
        } else {
          callback(event);
        }
      });
    }
    return this;
  }
  /**
   * Set the attribute of all of the events
   * @param  attr  the attribute to set
   * @param  value      The value to set it to
   */
  _setAll(attr, value) {
    this._forEach((event) => {
      event[attr] = value;
    });
  }
  /**
   * Internal tick method
   * @param  time  The time of the event in seconds
   */
  _tick(time2, value) {
    if (!this.mute) {
      this.callback(time2, value);
    }
  }
  /**
   * Determine if the event should be currently looping
   * given the loop boundries of this Part.
   * @param  event  The event to test
   */
  _testLoopBoundries(event) {
    if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {
      event.cancel(0);
    } else if (event.state === "stopped") {
      this._restartEvent(event);
    }
  }
  get probability() {
    return this._probability;
  }
  set probability(prob) {
    this._probability = prob;
    this._setAll("probability", prob);
  }
  get humanize() {
    return this._humanize;
  }
  set humanize(variation) {
    this._humanize = variation;
    this._setAll("humanize", variation);
  }
  /**
   * If the part should loop or not
   * between Part.loopStart and
   * Part.loopEnd. If set to true,
   * the part will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   * @example
   * const part = new Tone.Part();
   * // loop the part 8 times
   * part.loop = 8;
   */
  get loop() {
    return this._loop;
  }
  set loop(loop) {
    this._loop = loop;
    this._forEach((event) => {
      event.loopStart = this.loopStart;
      event.loopEnd = this.loopEnd;
      event.loop = loop;
      this._testLoopBoundries(event);
    });
  }
  /**
   * The loopEnd point determines when it will
   * loop if Part.loop is true.
   */
  get loopEnd() {
    return new TicksClass(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(loopEnd) {
    this._loopEnd = this.toTicks(loopEnd);
    if (this._loop) {
      this._forEach((event) => {
        event.loopEnd = loopEnd;
        this._testLoopBoundries(event);
      });
    }
  }
  /**
   * The loopStart point determines when it will
   * loop if Part.loop is true.
   */
  get loopStart() {
    return new TicksClass(this.context, this._loopStart).toSeconds();
  }
  set loopStart(loopStart) {
    this._loopStart = this.toTicks(loopStart);
    if (this._loop) {
      this._forEach((event) => {
        event.loopStart = this.loopStart;
        this._testLoopBoundries(event);
      });
    }
  }
  /**
   * The playback rate of the part
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(rate) {
    this._playbackRate = rate;
    this._setAll("playbackRate", rate);
  }
  /**
   * The number of scheduled notes in the part.
   */
  get length() {
    return this._events.size;
  }
  dispose() {
    super.dispose();
    this.clear();
    return this;
  }
}
class Sequence extends ToneEvent {
  constructor() {
    const options2 = optionsFromArguments(Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]);
    super(options2);
    this.name = "Sequence";
    this._part = new Part({
      callback: this._seqCallback.bind(this),
      context: this.context
    });
    this._events = [];
    this._eventsArray = [];
    this._subdivision = this.toTicks(options2.subdivision);
    this.events = options2.events;
    this.loop = options2.loop;
    this.loopStart = options2.loopStart;
    this.loopEnd = options2.loopEnd;
    this.playbackRate = options2.playbackRate;
    this.probability = options2.probability;
    this.humanize = options2.humanize;
    this.mute = options2.mute;
    this.playbackRate = options2.playbackRate;
  }
  static getDefaults() {
    return Object.assign(omitFromObject(ToneEvent.getDefaults(), ["value"]), {
      events: [],
      loop: true,
      loopEnd: 0,
      loopStart: 0,
      subdivision: "8n"
    });
  }
  /**
   * The internal callback for when an event is invoked
   */
  _seqCallback(time2, value) {
    if (value !== null && !this.mute) {
      this.callback(time2, value);
    }
  }
  /**
   * The sequence
   */
  get events() {
    return this._events;
  }
  set events(s) {
    this.clear();
    this._eventsArray = s;
    this._events = this._createSequence(this._eventsArray);
    this._eventsUpdated();
  }
  /**
   * Start the part at the given time.
   * @param  time    When to start the part.
   * @param  offset  The offset index to start at
   */
  start(time2, offset2) {
    this._part.start(time2, offset2 ? this._indexTime(offset2) : offset2);
    return this;
  }
  /**
   * Stop the part at the given time.
   * @param  time  When to stop the part.
   */
  stop(time2) {
    this._part.stop(time2);
    return this;
  }
  /**
   * The subdivision of the sequence. This can only be
   * set in the constructor. The subdivision is the
   * interval between successive steps.
   */
  get subdivision() {
    return new TicksClass(this.context, this._subdivision).toSeconds();
  }
  /**
   * Create a sequence proxy which can be monitored to create subsequences
   */
  _createSequence(array2) {
    return new Proxy(array2, {
      get: (target, property) => {
        return target[property];
      },
      set: (target, property, value) => {
        if (isString(property) && isFinite(parseInt(property, 10))) {
          if (isArray(value)) {
            target[property] = this._createSequence(value);
          } else {
            target[property] = value;
          }
        } else {
          target[property] = value;
        }
        this._eventsUpdated();
        return true;
      }
    });
  }
  /**
   * When the sequence has changed, all of the events need to be recreated
   */
  _eventsUpdated() {
    this._part.clear();
    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);
    this.loopEnd = this.loopEnd;
  }
  /**
   * reschedule all of the events that need to be rescheduled
   */
  _rescheduleSequence(sequence2, subdivision, startOffset) {
    sequence2.forEach((value, index) => {
      const eventOffset = index * subdivision + startOffset;
      if (isArray(value)) {
        this._rescheduleSequence(value, subdivision / value.length, eventOffset);
      } else {
        const startTime = new TicksClass(this.context, eventOffset, "i").toSeconds();
        this._part.add(startTime, value);
      }
    });
  }
  /**
   * Get the time of the index given the Sequence's subdivision
   * @param  index
   * @return The time of that index
   */
  _indexTime(index) {
    return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();
  }
  /**
   * Clear all of the events
   */
  clear() {
    this._part.clear();
    return this;
  }
  dispose() {
    super.dispose();
    this._part.dispose();
    return this;
  }
  //-------------------------------------
  // PROXY CALLS
  //-------------------------------------
  get loop() {
    return this._part.loop;
  }
  set loop(l) {
    this._part.loop = l;
  }
  /**
   * The index at which the sequence should start looping
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(index) {
    this._loopStart = index;
    this._part.loopStart = this._indexTime(index);
  }
  /**
   * The index at which the sequence should end looping
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(index) {
    this._loopEnd = index;
    if (index === 0) {
      this._part.loopEnd = this._indexTime(this._eventsArray.length);
    } else {
      this._part.loopEnd = this._indexTime(index);
    }
  }
  get startOffset() {
    return this._part.startOffset;
  }
  set startOffset(start2) {
    this._part.startOffset = start2;
  }
  get playbackRate() {
    return this._part.playbackRate;
  }
  set playbackRate(rate) {
    this._part.playbackRate = rate;
  }
  get probability() {
    return this._part.probability;
  }
  set probability(prob) {
    this._part.probability = prob;
  }
  get progress() {
    return this._part.progress;
  }
  get humanize() {
    return this._part.humanize;
  }
  set humanize(variation) {
    this._part.humanize = variation;
  }
  /**
   * The number of scheduled events
   */
  get length() {
    return this._part.length;
  }
}
class CrossFade extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(CrossFade.getDefaults(), arguments, ["fade"]);
    super(options2);
    this.name = "CrossFade";
    this._panner = this.context.createStereoPanner();
    this._split = this.context.createChannelSplitter(2);
    this._g2a = new GainToAudio({ context: this.context });
    this.a = new Gain({
      context: this.context,
      gain: 0
    });
    this.b = new Gain({
      context: this.context,
      gain: 0
    });
    this.output = new Gain({ context: this.context });
    this._internalChannels = [this.a, this.b];
    this.fade = new Signal({
      context: this.context,
      units: "normalRange",
      value: options2.fade
    });
    readOnly(this, "fade");
    this.context.getConstant(1).connect(this._panner);
    this._panner.connect(this._split);
    this._panner.channelCount = 1;
    this._panner.channelCountMode = "explicit";
    connect(this._split, this.a.gain, 0);
    connect(this._split, this.b.gain, 1);
    this.fade.chain(this._g2a, this._panner.pan);
    this.a.connect(this.output);
    this.b.connect(this.output);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      fade: 0.5
    });
  }
  dispose() {
    super.dispose();
    this.a.dispose();
    this.b.dispose();
    this.output.dispose();
    this.fade.dispose();
    this._g2a.dispose();
    this._panner.disconnect();
    this._split.disconnect();
    return this;
  }
}
class Effect extends ToneAudioNode {
  constructor(options2) {
    super(options2);
    this.name = "Effect";
    this._dryWet = new CrossFade({ context: this.context });
    this.wet = this._dryWet.fade;
    this.effectSend = new Gain({ context: this.context });
    this.effectReturn = new Gain({ context: this.context });
    this.input = new Gain({ context: this.context });
    this.output = this._dryWet;
    this.input.fan(this._dryWet.a, this.effectSend);
    this.effectReturn.connect(this._dryWet.b);
    this.wet.setValueAtTime(options2.wet, 0);
    this._internalChannels = [this.effectReturn, this.effectSend];
    readOnly(this, "wet");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      wet: 1
    });
  }
  /**
   * chains the effect in between the effectSend and effectReturn
   */
  connectEffect(effect) {
    this._internalChannels.push(effect);
    this.effectSend.chain(effect, this.effectReturn);
    return this;
  }
  dispose() {
    super.dispose();
    this._dryWet.dispose();
    this.effectSend.dispose();
    this.effectReturn.dispose();
    this.wet.dispose();
    return this;
  }
}
class Panner extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Panner.getDefaults(), arguments, [
      "pan"
    ]);
    super(options2);
    this.name = "Panner";
    this._panner = this.context.createStereoPanner();
    this.input = this._panner;
    this.output = this._panner;
    this.pan = new Param({
      context: this.context,
      param: this._panner.pan,
      value: options2.pan,
      minValue: -1,
      maxValue: 1
    });
    this._panner.channelCount = options2.channelCount;
    this._panner.channelCountMode = "explicit";
    readOnly(this, "pan");
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      pan: 0,
      channelCount: 1
    });
  }
  dispose() {
    super.dispose();
    this._panner.disconnect();
    this.pan.dispose();
    return this;
  }
}
const workletName = "bit-crusher";
const bitCrusherWorklet = (
  /* javascript */
  `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`
);
registerProcessor(workletName, bitCrusherWorklet);
class Split extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Split.getDefaults(), arguments, [
      "channels"
    ]);
    super(options2);
    this.name = "Split";
    this._splitter = this.input = this.output = this.context.createChannelSplitter(options2.channels);
    this._internalChannels = [this._splitter];
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      channels: 2
    });
  }
  dispose() {
    super.dispose();
    this._splitter.disconnect();
    return this;
  }
}
class Merge extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Merge.getDefaults(), arguments, [
      "channels"
    ]);
    super(options2);
    this.name = "Merge";
    this._merger = this.output = this.input = this.context.createChannelMerger(options2.channels);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      channels: 2
    });
  }
  dispose() {
    super.dispose();
    this._merger.disconnect();
    return this;
  }
}
class Distortion extends Effect {
  constructor() {
    const options2 = optionsFromArguments(Distortion.getDefaults(), arguments, ["distortion"]);
    super(options2);
    this.name = "Distortion";
    this._shaper = new WaveShaper({
      context: this.context,
      length: 4096
    });
    this._distortion = options2.distortion;
    this.connectEffect(this._shaper);
    this.distortion = options2.distortion;
    this.oversample = options2.oversample;
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      distortion: 0.4,
      oversample: "none"
    });
  }
  /**
   * The amount of distortion. Nominal range is between 0 and 1.
   */
  get distortion() {
    return this._distortion;
  }
  set distortion(amount) {
    this._distortion = amount;
    const k = amount * 100;
    const deg = Math.PI / 180;
    this._shaper.setMap((x) => {
      if (Math.abs(x) < 1e-3) {
        return 0;
      } else {
        return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
      }
    });
  }
  /**
   * The oversampling of the effect. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(oversampling) {
    this._shaper.oversample = oversampling;
  }
  dispose() {
    super.dispose();
    this._shaper.dispose();
    return this;
  }
}
class FeedbackEffect extends Effect {
  constructor(options2) {
    super(options2);
    this.name = "FeedbackEffect";
    this._feedbackGain = new Gain({
      context: this.context,
      gain: options2.feedback,
      units: "normalRange"
    });
    this.feedback = this._feedbackGain.gain;
    readOnly(this, "feedback");
    this.effectReturn.chain(this._feedbackGain, this.effectSend);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      feedback: 0.125
    });
  }
  dispose() {
    super.dispose();
    this._feedbackGain.dispose();
    this.feedback.dispose();
    return this;
  }
}
class FeedbackDelay extends FeedbackEffect {
  constructor() {
    const options2 = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, ["delayTime", "feedback"]);
    super(options2);
    this.name = "FeedbackDelay";
    this._delayNode = new Delay({
      context: this.context,
      delayTime: options2.delayTime,
      maxDelay: options2.maxDelay
    });
    this.delayTime = this._delayNode.delayTime;
    this.connectEffect(this._delayNode);
    readOnly(this, "delayTime");
  }
  static getDefaults() {
    return Object.assign(FeedbackEffect.getDefaults(), {
      delayTime: 0.25,
      maxDelay: 1
    });
  }
  dispose() {
    super.dispose();
    this._delayNode.dispose();
    this.delayTime.dispose();
    return this;
  }
}
class Reverb extends Effect {
  constructor() {
    const options2 = optionsFromArguments(Reverb.getDefaults(), arguments, [
      "decay"
    ]);
    super(options2);
    this.name = "Reverb";
    this._convolver = this.context.createConvolver();
    this.ready = Promise.resolve();
    const decayTime = this.toSeconds(options2.decay);
    assertRange(decayTime, 1e-3);
    this._decay = decayTime;
    const preDelayTime = this.toSeconds(options2.preDelay);
    assertRange(preDelayTime, 0);
    this._preDelay = preDelayTime;
    this.generate();
    this.connectEffect(this._convolver);
  }
  static getDefaults() {
    return Object.assign(Effect.getDefaults(), {
      decay: 1.5,
      preDelay: 0.01
    });
  }
  /**
   * The duration of the reverb.
   */
  get decay() {
    return this._decay;
  }
  set decay(time2) {
    time2 = this.toSeconds(time2);
    assertRange(time2, 1e-3);
    this._decay = time2;
    this.generate();
  }
  /**
   * The amount of time before the reverb is fully ramped in.
   */
  get preDelay() {
    return this._preDelay;
  }
  set preDelay(time2) {
    time2 = this.toSeconds(time2);
    assertRange(time2, 0);
    this._preDelay = time2;
    this.generate();
  }
  /**
   * Generate the Impulse Response. Returns a promise while the IR is being generated.
   * @return Promise which returns this object.
   */
  generate() {
    return __awaiter(this, void 0, void 0, function* () {
      const previousReady = this.ready;
      const context2 = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);
      const noiseL = new Noise({ context: context2 });
      const noiseR = new Noise({ context: context2 });
      const merge2 = new Merge({ context: context2 });
      noiseL.connect(merge2, 0, 0);
      noiseR.connect(merge2, 0, 1);
      const gainNode = new Gain({ context: context2 }).toDestination();
      merge2.connect(gainNode);
      noiseL.start(0);
      noiseR.start(0);
      gainNode.gain.setValueAtTime(0, 0);
      gainNode.gain.setValueAtTime(1, this._preDelay);
      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);
      const renderPromise = context2.render();
      this.ready = renderPromise.then(noOp);
      yield previousReady;
      this._convolver.buffer = (yield renderPromise).get();
      return this;
    });
  }
  dispose() {
    super.dispose();
    this._convolver.disconnect();
    return this;
  }
}
class Analyser extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Analyser.getDefaults(), arguments, ["type", "size"]);
    super(options2);
    this.name = "Analyser";
    this._analysers = [];
    this._buffers = [];
    this.input = this.output = this._gain = new Gain({ context: this.context });
    this._split = new Split({
      context: this.context,
      channels: options2.channels
    });
    this.input.connect(this._split);
    assertRange(options2.channels, 1);
    for (let channel = 0; channel < options2.channels; channel++) {
      this._analysers[channel] = this.context.createAnalyser();
      this._split.connect(this._analysers[channel], channel, 0);
    }
    this.size = options2.size;
    this.type = options2.type;
    this.smoothing = options2.smoothing;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      size: 1024,
      smoothing: 0.8,
      type: "fft",
      channels: 1
    });
  }
  /**
   * Run the analysis given the current settings. If {@link channels} = 1,
   * it will return a Float32Array. If {@link channels} > 1, it will
   * return an array of Float32Arrays where each index in the array
   * represents the analysis done on a channel.
   */
  getValue() {
    this._analysers.forEach((analyser, index) => {
      const buffer = this._buffers[index];
      if (this._type === "fft") {
        analyser.getFloatFrequencyData(buffer);
      } else if (this._type === "waveform") {
        analyser.getFloatTimeDomainData(buffer);
      }
    });
    if (this.channels === 1) {
      return this._buffers[0];
    } else {
      return this._buffers;
    }
  }
  /**
   * The size of analysis. This must be a power of two in the range 16 to 16384.
   */
  get size() {
    return this._analysers[0].frequencyBinCount;
  }
  set size(size) {
    this._analysers.forEach((analyser, index) => {
      analyser.fftSize = size * 2;
      this._buffers[index] = new Float32Array(size);
    });
  }
  /**
   * The number of channels the analyser does the analysis on. Channel
   * separation is done using {@link Split}
   */
  get channels() {
    return this._analysers.length;
  }
  /**
   * The analysis function returned by analyser.getValue(), either "fft" or "waveform".
   */
  get type() {
    return this._type;
  }
  set type(type2) {
    assert(type2 === "waveform" || type2 === "fft", `Analyser: invalid type: ${type2}`);
    this._type = type2;
  }
  /**
   * 0 represents no time averaging with the last analysis frame.
   */
  get smoothing() {
    return this._analysers[0].smoothingTimeConstant;
  }
  set smoothing(val) {
    this._analysers.forEach((a) => a.smoothingTimeConstant = val);
  }
  /**
   * Clean up.
   */
  dispose() {
    super.dispose();
    this._analysers.forEach((a) => a.disconnect());
    this._split.dispose();
    this._gain.dispose();
    return this;
  }
}
class Solo extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Solo.getDefaults(), arguments, [
      "solo"
    ]);
    super(options2);
    this.name = "Solo";
    this.input = this.output = new Gain({
      context: this.context
    });
    if (!Solo._allSolos.has(this.context)) {
      Solo._allSolos.set(this.context, /* @__PURE__ */ new Set());
    }
    Solo._allSolos.get(this.context).add(this);
    this.solo = options2.solo;
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      solo: false
    });
  }
  /**
   * Isolates this instance and mutes all other instances of Solo.
   * Only one instance can be soloed at a time. A soloed
   * instance will report `solo=false` when another instance is soloed.
   */
  get solo() {
    return this._isSoloed();
  }
  set solo(solo) {
    if (solo) {
      this._addSolo();
    } else {
      this._removeSolo();
    }
    Solo._allSolos.get(this.context).forEach((instance) => instance._updateSolo());
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed
   */
  get muted() {
    return this.input.gain.value === 0;
  }
  /**
   * Add this to the soloed array
   */
  _addSolo() {
    if (!Solo._soloed.has(this.context)) {
      Solo._soloed.set(this.context, /* @__PURE__ */ new Set());
    }
    Solo._soloed.get(this.context).add(this);
  }
  /**
   * Remove this from the soloed array
   */
  _removeSolo() {
    if (Solo._soloed.has(this.context)) {
      Solo._soloed.get(this.context).delete(this);
    }
  }
  /**
   * Is this on the soloed array
   */
  _isSoloed() {
    return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);
  }
  /**
   * Returns true if no one is soloed
   */
  _noSolos() {
    return !Solo._soloed.has(this.context) || // or has a solo set but doesn't include any items
    Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0;
  }
  /**
   * Solo the current instance and unsolo all other instances.
   */
  _updateSolo() {
    if (this._isSoloed()) {
      this.input.gain.value = 1;
    } else if (this._noSolos()) {
      this.input.gain.value = 1;
    } else {
      this.input.gain.value = 0;
    }
  }
  dispose() {
    super.dispose();
    Solo._allSolos.get(this.context).delete(this);
    this._removeSolo();
    return this;
  }
}
Solo._allSolos = /* @__PURE__ */ new Map();
Solo._soloed = /* @__PURE__ */ new Map();
class PanVol extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(PanVol.getDefaults(), arguments, [
      "pan",
      "volume"
    ]);
    super(options2);
    this.name = "PanVol";
    this._panner = this.input = new Panner({
      context: this.context,
      pan: options2.pan,
      channelCount: options2.channelCount
    });
    this.pan = this._panner.pan;
    this._volume = this.output = new Volume({
      context: this.context,
      volume: options2.volume
    });
    this.volume = this._volume.volume;
    this._panner.connect(this._volume);
    this.mute = options2.mute;
    readOnly(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      mute: false,
      pan: 0,
      volume: 0,
      channelCount: 1
    });
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(mute) {
    this._volume.mute = mute;
  }
  dispose() {
    super.dispose();
    this._panner.dispose();
    this.pan.dispose();
    this._volume.dispose();
    this.volume.dispose();
    return this;
  }
}
class Channel extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Channel.getDefaults(), arguments, [
      "volume",
      "pan"
    ]);
    super(options2);
    this.name = "Channel";
    this._solo = this.input = new Solo({
      solo: options2.solo,
      context: this.context
    });
    this._panVol = this.output = new PanVol({
      context: this.context,
      pan: options2.pan,
      volume: options2.volume,
      mute: options2.mute,
      channelCount: options2.channelCount
    });
    this.pan = this._panVol.pan;
    this.volume = this._panVol.volume;
    this._solo.connect(this._panVol);
    readOnly(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      pan: 0,
      volume: 0,
      mute: false,
      solo: false,
      channelCount: 1
    });
  }
  /**
   * Solo/unsolo the channel. Soloing is only relative to other {@link Channel}s and {@link Solo} instances
   */
  get solo() {
    return this._solo.solo;
  }
  set solo(solo) {
    this._solo.solo = solo;
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed,
   * or the channel is muted
   */
  get muted() {
    return this._solo.muted || this.mute;
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._panVol.mute;
  }
  set mute(mute) {
    this._panVol.mute = mute;
  }
  /**
   * Get the gain node belonging to the bus name. Create it if
   * it doesn't exist
   * @param name The bus name
   */
  _getBus(name) {
    if (!Channel.buses.has(name)) {
      Channel.buses.set(name, new Gain({ context: this.context }));
    }
    return Channel.buses.get(name);
  }
  /**
   * Send audio to another channel using a string. `send` is a lot like
   * {@link connect}, except it uses a string instead of an object. This can
   * be useful in large applications to decouple sections since {@link send}
   * and {@link receive} can be invoked separately in order to connect an object
   * @param name The channel name to send the audio
   * @param volume The amount of the signal to send.
   * 	Defaults to 0db, i.e. send the entire signal
   * @returns Returns the gain node of this connection.
   */
  send(name, volume = 0) {
    const bus = this._getBus(name);
    const sendKnob = new Gain({
      context: this.context,
      units: "decibels",
      gain: volume
    });
    this.connect(sendKnob);
    sendKnob.connect(bus);
    return sendKnob;
  }
  /**
   * Receive audio from a channel which was connected with {@link send}.
   * @param name The channel name to receive audio from.
   */
  receive(name) {
    const bus = this._getBus(name);
    bus.connect(this);
    return this;
  }
  dispose() {
    super.dispose();
    this._panVol.dispose();
    this.pan.dispose();
    this.volume.dispose();
    this._solo.dispose();
    return this;
  }
}
Channel.buses = /* @__PURE__ */ new Map();
class Compressor extends ToneAudioNode {
  constructor() {
    const options2 = optionsFromArguments(Compressor.getDefaults(), arguments, ["threshold", "ratio"]);
    super(options2);
    this.name = "Compressor";
    this._compressor = this.context.createDynamicsCompressor();
    this.input = this._compressor;
    this.output = this._compressor;
    this.threshold = new Param({
      minValue: this._compressor.threshold.minValue,
      maxValue: this._compressor.threshold.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.threshold,
      units: "decibels",
      value: options2.threshold
    });
    this.attack = new Param({
      minValue: this._compressor.attack.minValue,
      maxValue: this._compressor.attack.maxValue,
      context: this.context,
      param: this._compressor.attack,
      units: "time",
      value: options2.attack
    });
    this.release = new Param({
      minValue: this._compressor.release.minValue,
      maxValue: this._compressor.release.maxValue,
      context: this.context,
      param: this._compressor.release,
      units: "time",
      value: options2.release
    });
    this.knee = new Param({
      minValue: this._compressor.knee.minValue,
      maxValue: this._compressor.knee.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.knee,
      units: "decibels",
      value: options2.knee
    });
    this.ratio = new Param({
      minValue: this._compressor.ratio.minValue,
      maxValue: this._compressor.ratio.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.ratio,
      units: "positive",
      value: options2.ratio
    });
    readOnly(this, ["knee", "release", "attack", "ratio", "threshold"]);
  }
  static getDefaults() {
    return Object.assign(ToneAudioNode.getDefaults(), {
      attack: 3e-3,
      knee: 30,
      ratio: 12,
      release: 0.25,
      threshold: -24
    });
  }
  /**
   * A read-only decibel value for metering purposes, representing the current amount of gain
   * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).
   */
  get reduction() {
    return this._compressor.reduction;
  }
  dispose() {
    super.dispose();
    this._compressor.disconnect();
    this.attack.dispose();
    this.release.dispose();
    this.threshold.dispose();
    this.ratio.dispose();
    this.knee.dispose();
    return this;
  }
}
getContext().transport;
function getTransport() {
  return getContext().transport;
}
getContext().destination;
getContext().destination;
function getDestination() {
  return getContext().destination;
}
getContext().listener;
getContext().draw;
const context = getContext();
function createSynth(synthConfig) {
  const { type: type2 = "mono", oscillator = {}, envelope = {}, voices = 4 } = synthConfig;
  const synthOptions = {
    oscillator: { type: oscillator.type || "sine" },
    envelope: {
      attack: envelope.attack ?? 0.01,
      decay: envelope.decay ?? 0.2,
      sustain: envelope.sustain ?? 0.5,
      release: envelope.release ?? 1
    }
  };
  switch (type2) {
    case "poly":
      return new PolySynth(Synth, {
        maxPolyphony: voices,
        voice: Synth,
        options: synthOptions
      });
    case "drums":
      return createDrumKit();
    case "mono":
    default:
      return new Synth(synthOptions);
  }
}
function createDrumKit(config2) {
  const kick = new MembraneSynth({
    pitchDecay: 0.05,
    octaves: 6,
    oscillator: { type: "sine" },
    envelope: { attack: 1e-3, decay: 0.4, sustain: 0.01, release: 1.4 }
  });
  const snare = new NoiseSynth({
    noise: { type: "white" },
    envelope: { attack: 5e-3, decay: 0.15, sustain: 0 }
  });
  const hihat = new MetalSynth({
    frequency: 200,
    envelope: { attack: 1e-3, decay: 0.1, release: 0.01 },
    harmonicity: 5.1,
    modulationIndex: 32,
    resonance: 4e3,
    octaves: 1.5
  });
  const kit = {
    kick,
    snare,
    hihat,
    _voices: [kick, snare, hihat],
    connect(destination) {
      this._voices.forEach((v) => v.connect(destination));
      return this;
    },
    toDestination() {
      this._voices.forEach((v) => v.toDestination());
      return this;
    },
    triggerAttackRelease(note, duration2, time2) {
      const n2 = typeof note === "string" ? note.toLowerCase() : note;
      if (n2 === "kick" || n2 === "k" || n2 === "C2") kick.triggerAttackRelease(n2 === "kick" || n2 === "k" ? "C2" : n2, duration2, time2);
      else if (n2 === "snare" || n2 === "s") snare.triggerAttackRelease(duration2, time2);
      else if (n2 === "hihat" || n2 === "h") hihat.triggerAttackRelease(duration2, time2);
    },
    dispose() {
      this._voices.forEach((v) => v.dispose());
    }
  };
  return kit;
}
function createEffectsChain(effectsConfig = {}) {
  const effects = [];
  if (effectsConfig.reverb) {
    effects.push(new Reverb({
      decay: effectsConfig.reverb.decay ?? 2.5,
      wet: effectsConfig.reverb.wet ?? 0.3
    }));
  }
  if (effectsConfig.delay) {
    effects.push(new FeedbackDelay({
      delayTime: effectsConfig.delay.delayTime ?? 0.25,
      feedback: effectsConfig.delay.feedback ?? 0.2,
      wet: effectsConfig.delay.wet ?? 0.3
    }));
  }
  if (effectsConfig.filter) {
    effects.push(new Filter({
      frequency: effectsConfig.filter.frequency ?? 1e3,
      type: effectsConfig.filter.type ?? "lowpass",
      Q: effectsConfig.filter.Q ?? 1
    }));
  }
  if (effectsConfig.distortion) {
    effects.push(new Distortion({
      distortion: effectsConfig.distortion.amount ?? 0.4,
      wet: effectsConfig.distortion.wet ?? 0.5
    }));
  }
  if (effectsConfig.compressor) {
    effects.push(new Compressor({
      threshold: effectsConfig.compressor.threshold ?? -24,
      ratio: effectsConfig.compressor.ratio ?? 4,
      attack: effectsConfig.compressor.attack ?? 3e-3,
      release: effectsConfig.compressor.release ?? 0.25
    }));
  }
  if (effects.length === 0) {
    const passthrough = new Gain(1);
    return {
      chain: passthrough,
      effects: [passthrough],
      dispose() {
        passthrough.dispose();
      }
    };
  }
  for (let i = 0; i < effects.length - 1; i++) {
    effects[i].connect(effects[i + 1]);
  }
  return {
    chain: effects[0],
    // Connect synth to this
    output: effects[effects.length - 1],
    // Connect this to destination
    effects,
    dispose() {
      effects.forEach((fx) => fx.dispose());
    }
  };
}
async function ensureAudioContext() {
  if (context.state !== "running") {
    await start();
  }
  if (typeof window !== "undefined") {
    window.__TONE_CONTEXT__ = context.rawContext || context._context;
    window.__TONE_DESTINATION__ = getDestination();
  }
}
function startTransport(bpm = 120) {
  getTransport().bpm.value = bpm;
  getTransport().start();
}
function stopTransport() {
  getTransport().stop();
  getTransport().cancel();
}
function createSequence(synth2, seqConfig) {
  const { notes = ["C4"], duration: duration2 = "8n", interval = "4n" } = seqConfig;
  const sequence2 = new Sequence((time2, note) => {
    if (note !== null && note !== "rest") {
      synth2.triggerAttackRelease(note, duration2, time2);
    }
  }, notes, interval);
  return sequence2;
}
function createAnalyser(options2 = {}) {
  const {
    fftSize = 1024,
    smoothingTimeConstant = 0.8
  } = options2;
  const analyser = new Analyser("fft", fftSize);
  analyser.smoothing = smoothingTimeConstant;
  return {
    analyser,
    /**
     * Connect an audio source to this analyser.
     * @param {object} source - Tone.js audio node
     */
    connect(source) {
      source.connect(analyser);
      return this;
    },
    /**
     * Get current FFT data as Float32Array (dB values).
     * @returns {Float32Array}
     */
    getRawValue() {
      return analyser.getValue();
    },
    /**
     * Get current FFT data normalized to 0-1 range.
     * Tone.Analyser returns dB values (typically -100 to 0).
     * We map to 0-1 using minDecibels/maxDecibels.
     *
     * @param {number} minDb - Minimum dB value (maps to 0). Default: -100
     * @param {number} maxDb - Maximum dB value (maps to 1). Default: -30
     * @returns {Float32Array} Values in 0-1 range
     */
    getNormalizedValue(minDb = -100, maxDb = -30) {
      const raw = analyser.getValue();
      const range2 = maxDb - minDb;
      const normalized = new Float32Array(raw.length);
      for (let i = 0; i < raw.length; i++) {
        normalized[i] = Math.max(0, Math.min(1, (raw[i] - minDb) / range2));
      }
      return normalized;
    },
    /**
     * Get the FFT size (number of frequency bins = fftSize / 2).
     */
    get binCount() {
      return fftSize / 2;
    },
    dispose() {
      analyser.dispose();
    }
  };
}
function extractBands(spectrum, sampleRate = 48e3, fftSize = 1024) {
  const binWidth = sampleRate / fftSize;
  const binCount = spectrum.length;
  const freqToBin = (freq) => Math.min(Math.round(freq / binWidth), binCount - 1);
  const bands = {
    sub: [20, 60],
    bass: [60, 250],
    lowMid: [250, 500],
    mid: [500, 2e3],
    highMid: [2e3, 4e3],
    treble: [4e3, 8e3]
  };
  const result = {};
  for (const [name, [lowFreq, highFreq]] of Object.entries(bands)) {
    const lowBin = freqToBin(lowFreq);
    const highBin = freqToBin(highFreq);
    if (lowBin >= highBin) {
      result[name] = 0;
      continue;
    }
    let sum = 0;
    let count = 0;
    for (let i = lowBin; i <= highBin && i < binCount; i++) {
      sum += spectrum[i];
      count++;
    }
    result[name] = count > 0 ? sum / count : 0;
  }
  return result;
}
function getSimpleBands(bands) {
  return {
    bass: Math.max(bands.sub || 0, bands.bass || 0),
    mids: ((bands.lowMid || 0) + (bands.mid || 0) + (bands.highMid || 0)) / 3,
    treble: bands.treble || 0
  };
}
class BeatDetector {
  /**
   * @param {object} options
   * @param {number} options.threshold - Flux threshold for beat detection (default: 0.15)
   * @param {number} options.decayRate - How fast the threshold adapts (default: 0.98)
   * @param {number} options.minInterval - Minimum ms between beats (default: 200)
   */
  constructor(options2 = {}) {
    this.threshold = options2.threshold ?? 0.15;
    this.decayRate = options2.decayRate ?? 0.98;
    this.minInterval = options2.minInterval ?? 200;
    this.prevSpectrum = null;
    this.adaptiveThreshold = this.threshold;
    this.lastBeatTime = 0;
    this.beatValue = 0;
    this.beatDecay = 0.9;
  }
  /**
   * Update beat detector with new spectrum data.
   *
   * @param {Float32Array} spectrum - Normalized 0-1 FFT data
   * @returns {boolean} True if a beat was detected this frame
   */
  update(spectrum) {
    this.beatValue *= this.beatDecay;
    if (!this.prevSpectrum) {
      this.prevSpectrum = new Float32Array(spectrum);
      return false;
    }
    let flux = 0;
    for (let i = 0; i < spectrum.length; i++) {
      const diff = spectrum[i] - this.prevSpectrum[i];
      if (diff > 0) flux += diff;
    }
    flux /= spectrum.length;
    this.adaptiveThreshold = Math.max(
      this.threshold,
      this.adaptiveThreshold * this.decayRate
    );
    const now = performance.now();
    const isBeat = flux > this.adaptiveThreshold && now - this.lastBeatTime > this.minInterval;
    if (isBeat) {
      this.lastBeatTime = now;
      this.adaptiveThreshold = flux * 1.1;
      this.beatValue = 1;
    }
    this.prevSpectrum.set(spectrum);
    return isBeat;
  }
  /**
   * Get current beat value (0-1).
   * 1.0 at moment of beat, decays exponentially to 0.
   * Use this for smooth visual reactions to beats.
   */
  getValue() {
    return this.beatValue;
  }
  /**
   * Reset detector state.
   */
  reset() {
    this.prevSpectrum = null;
    this.adaptiveThreshold = this.threshold;
    this.lastBeatTime = 0;
    this.beatValue = 0;
  }
}
class EnvelopeFollower {
  /**
   * @param {object} options
   * @param {number} options.attack - Attack rate (0-1, how fast to rise). Default: 0.1
   * @param {number} options.release - Release rate (0-1, how fast to fall). Default: 0.05
   */
  constructor(options2 = {}) {
    this.attack = options2.attack ?? 0.1;
    this.release = options2.release ?? 0.05;
    this.currentLevel = 0;
    this.peakLevel = 0;
    this.peakDecay = 0.999;
  }
  /**
   * Update envelope with current spectrum.
   *
   * @param {Float32Array} spectrum - Normalized 0-1 FFT data
   * @returns {number} Current envelope level (0-1)
   */
  update(spectrum) {
    let sumSquares = 0;
    for (let i = 0; i < spectrum.length; i++) {
      sumSquares += spectrum[i] * spectrum[i];
    }
    const rms = Math.sqrt(sumSquares / spectrum.length);
    if (rms > this.peakLevel) {
      this.peakLevel = rms;
    } else {
      this.peakLevel *= this.peakDecay;
    }
    const targetLevel = this.peakLevel > 1e-3 ? rms / this.peakLevel : 0;
    if (targetLevel > this.currentLevel) {
      this.currentLevel += (targetLevel - this.currentLevel) * this.attack;
    } else {
      this.currentLevel += (targetLevel - this.currentLevel) * this.release;
    }
    return Math.max(0, Math.min(1, this.currentLevel));
  }
  /**
   * Get current level without updating.
   * @returns {number} Current level (0-1)
   */
  getValue() {
    return this.currentLevel;
  }
  /**
   * Reset follower state.
   */
  reset() {
    this.currentLevel = 0;
    this.peakLevel = 0;
  }
}
function createSmoother(alpha = 0.15) {
  let current2 = null;
  return function smooth(value) {
    if (current2 === null) {
      current2 = value;
      return value;
    }
    current2 += (value - current2) * alpha;
    return current2;
  };
}
function createBatchSmoother(keys, alpha = 0.15) {
  const smoothers = {};
  for (const key of keys) {
    smoothers[key] = createSmoother(alpha);
  }
  return function smoothAll(data2) {
    const result = { ...data2 };
    for (const key of keys) {
      if (key in data2 && smoothers[key]) {
        result[key] = smoothers[key](data2[key]);
      }
    }
    return result;
  };
}
function easeLinear(t) {
  return t;
}
function easeExponentialIn(t) {
  return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
}
function easeExponentialOut(t) {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
}
function easeLogarithmic(t) {
  return t <= 0 ? 0 : Math.log(1 + t * 9) / Math.log(10);
}
function easeSineInOut(t) {
  return -(Math.cos(Math.PI * t) - 1) / 2;
}
function easeCubicOut(t) {
  return 1 - Math.pow(1 - t, 3);
}
function easeQuadraticIn(t) {
  return t * t;
}
function applyMapping(value, mapping = {}) {
  const { min = 0, max = 1, curve = "linear" } = mapping;
  const t = Math.max(0, Math.min(1, value));
  const easingFns = {
    linear: easeLinear,
    exponentialIn: easeExponentialIn,
    exponentialOut: easeExponentialOut,
    logarithmic: easeLogarithmic,
    sineInOut: easeSineInOut,
    cubicOut: easeCubicOut,
    quadraticIn: easeQuadraticIn
  };
  const easeFn = easingFns[curve] || easeLinear;
  const eased = easeFn(t);
  return min + eased * (max - min);
}
class AudioDataProvider {
  /**
   * @param {object} source - Tone.js audio node to analyze
   * @param {object} options - Configuration options
   * @param {number} options.fftSize - FFT size (default: 1024)
   * @param {number} options.smoothing - Analyser smoothing (default: 0.8)
   * @param {number} options.outputSmoothing - Output value smoothing alpha (default: 0.15)
   * @param {number} options.beatThreshold - Beat detection threshold (default: 0.15)
   * @param {number} options.sampleRate - Audio sample rate (default: 48000)
   */
  constructor(source, options2 = {}) {
    const {
      fftSize = 1024,
      smoothing = 0.8,
      outputSmoothing = 0.15,
      beatThreshold = 0.15,
      sampleRate = 48e3
    } = options2;
    this.fftSize = fftSize;
    this.sampleRate = sampleRate;
    this.analyser = createAnalyser({ fftSize, smoothingTimeConstant: smoothing });
    this.analyser.connect(source);
    this.beatDetector = new BeatDetector({ threshold: beatThreshold });
    this.envelopeFollower = new EnvelopeFollower();
    this.smoother = createBatchSmoother(
      ["bass", "lowMid", "mid", "highMid", "treble", "sub", "energy", "envelope"],
      outputSmoothing
    );
    this.data = {
      bass: 0,
      lowMid: 0,
      mid: 0,
      highMid: 0,
      treble: 0,
      sub: 0,
      energy: 0,
      beat: 0,
      envelope: 0,
      // Simple 3-band aliases
      mids: 0,
      // Raw spectrum (unsmoothed, for advanced use)
      spectrum: new Float32Array(fftSize / 2)
    };
  }
  /**
   * Update all analysis and return fresh audio data.
   * Call this once per animation frame.
   *
   * @returns {object} Audio data with all metrics (0-1 normalized)
   */
  update() {
    const spectrum = this.analyser.getNormalizedValue();
    const bands = extractBands(spectrum, this.sampleRate, this.fftSize);
    const simpleBands = getSimpleBands(bands);
    this.beatDetector.update(spectrum);
    this.envelopeFollower.update(spectrum);
    const energy = (bands.sub + bands.bass + bands.lowMid + bands.mid + bands.highMid + bands.treble) / 6;
    const rawData = {
      ...bands,
      energy,
      envelope: this.envelopeFollower.getValue(),
      beat: this.beatDetector.getValue()
    };
    const smoothed = this.smoother(rawData);
    this.data = {
      ...smoothed,
      mids: simpleBands.mids,
      beat: this.beatDetector.getValue(),
      // Beat value not smoothed (already has its own decay)
      spectrum
    };
    return this.data;
  }
  /**
   * Get last computed data without updating.
   * @returns {object}
   */
  getData() {
    return this.data;
  }
  /**
   * Reset all detector states.
   */
  reset() {
    this.beatDetector.reset();
    this.envelopeFollower.reset();
  }
  /**
   * Dispose all resources.
   */
  dispose() {
    this.analyser.dispose();
    this.beatDetector.reset();
    this.envelopeFollower.reset();
  }
}
let synth = null;
let effectsChain = null;
let sequence = null;
let audioDataProvider = null;
let isPlaying = false;
function initAudio(config2) {
  effectsChain = createEffectsChain(config2.effects || {});
  effectsChain.output.toDestination();
  synth = createSynth(config2.synth || {});
  synth.connect(effectsChain.chain);
  audioDataProvider = new AudioDataProvider(effectsChain.output, {
    fftSize: config2.analysis?.fftSize || 1024,
    smoothing: config2.analysis?.smoothing || 0.8,
    outputSmoothing: config2.analysis?.outputSmoothing || 0.15,
    beatThreshold: config2.analysis?.beatThreshold || 0.15
  });
  sequence = createSequence(synth, config2.sequence || {});
}
async function startAudio(bpm = 120) {
  await ensureAudioContext();
  if (!isPlaying) {
    sequence.start(0);
    startTransport(bpm);
    isPlaying = true;
  }
}
function stopAudio() {
  if (isPlaying) {
    sequence.stop();
    stopTransport();
    isPlaying = false;
    if (audioDataProvider) audioDataProvider.reset();
  }
}
function getAudioData() {
  if (!audioDataProvider) {
    return { bass: 0, lowMid: 0, mid: 0, highMid: 0, treble: 0, energy: 0, beat: 0, envelope: 0, mids: 0, spectrum: [] };
  }
  return audioDataProvider.update();
}
const sketch = (p2) => {
  let config2 = {
    // Visual parameters
    bgHue: 240,
    baseSize: 100,
    particleCount: 60,
    rotationSpeed: 0.5,
    // Audio-visual mapping
    bassSizeScale: 200,
    midsHueShift: 120,
    trebleDetail: 8,
    beatFlash: 0.8,
    // Audio config
    synth: {
      type: "mono",
      oscillator: { type: "triangle" },
      envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.8 }
    },
    sequence: {
      notes: ["C4", "E4", "G4", "B4", "C5", null, "G4", "E4"],
      duration: "8n",
      interval: "8n"
    },
    effects: {
      reverb: { decay: 3, wet: 0.4 }
    },
    transport: { bpm: 120 },
    analysis: {
      fftSize: 1024,
      smoothing: 0.8,
      outputSmoothing: 0.15,
      beatThreshold: 0.15
    }
  };
  let gui;
  let time2 = 0;
  p2.setup = () => {
    p2.createCanvas(800, 800);
    p2.colorMode(p2.HSB, 360, 100, 100, 100);
    p2.noStroke();
    loadConfig();
  };
  p2.draw = () => {
    const audio = getAudioData();
    const bgBrightness = 8 + audio.envelope * 5;
    p2.background(config2.bgHue, 20, bgBrightness);
    if (audio.beat > 0.1) {
      p2.fill(0, 0, 100, audio.beat * config2.beatFlash * 100);
      p2.rect(0, 0, p2.width, p2.height);
    }
    p2.push();
    p2.translate(p2.width / 2, p2.height / 2);
    const rotation = time2 * config2.rotationSpeed + audio.treble * Math.PI;
    p2.rotate(rotation);
    const numElements = Math.floor(config2.trebleDetail + audio.highMid * 12);
    const size = applyMapping(audio.bass, {
      min: config2.baseSize * 0.5,
      max: config2.baseSize + config2.bassSizeScale,
      curve: "cubicOut"
    });
    for (let i = 0; i < numElements; i++) {
      const angle = p2.TWO_PI / numElements * i;
      const radius = size + audio.mid * 50;
      const x = p2.cos(angle) * radius;
      const y = p2.sin(angle) * radius;
      const hue = (config2.bgHue + config2.midsHueShift * audio.mids + i * (360 / numElements)) % 360;
      const elementSize = 10 + audio.bass * 30 + p2.sin(time2 + i) * 5;
      const alpha = 60 + audio.energy * 40;
      p2.fill(hue, 70 + audio.treble * 30, 80 + audio.envelope * 20, alpha);
      p2.circle(x, y, elementSize);
    }
    const coreSize = 30 + audio.envelope * 60 + audio.bass * 40;
    const coreHue = (config2.bgHue + 180 + audio.mids * config2.midsHueShift) % 360;
    p2.fill(coreHue, 60, 90, 80);
    p2.circle(0, 0, coreSize);
    p2.pop();
    time2 += 0.02;
  };
  async function loadConfig() {
    try {
      const response = await fetch("./config.json");
      const saved = await response.json();
      config2 = deepMerge2(config2, saved);
    } catch (e2) {
      console.log("No saved config, using defaults");
    }
    initAudio(config2);
    setupGUI();
    setupTransportButtons();
  }
  function setupTransportButtons() {
    const playBtn = document.getElementById("playBtn");
    const stopBtn = document.getElementById("stopBtn");
    if (playBtn) {
      playBtn.addEventListener("click", async () => {
        await startAudio(config2.transport.bpm);
        playBtn.classList.add("active");
      });
    }
    if (stopBtn) {
      stopBtn.addEventListener("click", () => {
        stopAudio();
        if (playBtn) playBtn.classList.remove("active");
      });
    }
  }
  function setupGUI() {
    gui = new GUI({ title: "av1" });
    const visFolder = gui.addFolder("Visual");
    visFolder.add(config2, "bgHue", 0, 360).name("Background Hue");
    visFolder.add(config2, "baseSize", 30, 300).name("Base Size");
    visFolder.add(config2, "particleCount", 10, 100).step(1).name("Particles");
    visFolder.add(config2, "rotationSpeed", 0, 3).name("Rotation");
    const mapFolder = gui.addFolder("Audio Mapping");
    mapFolder.add(config2, "bassSizeScale", 0, 500).name("Bass -> Size");
    mapFolder.add(config2, "midsHueShift", 0, 360).name("Mids -> Hue");
    mapFolder.add(config2, "trebleDetail", 3, 24).step(1).name("Treble -> Detail");
    mapFolder.add(config2, "beatFlash", 0, 1).name("Beat Flash");
    const transportFolder = gui.addFolder("Transport");
    transportFolder.add(config2.transport, "bpm", 40, 200).step(1).name("BPM");
    gui.onChange(() => {
      console.log("Copy to config.json:", JSON.stringify(config2, null, 2));
    });
  }
  function deepMerge2(target, source) {
    const result = { ...target };
    for (const key of Object.keys(source)) {
      if (source[key] && typeof source[key] === "object" && !Array.isArray(source[key])) {
        result[key] = deepMerge2(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    return result;
  }
};
new p5$2(sketch);
