# Blueprint: Codex + MCP для игр (скриншоты/клики vs прямой state)

## Цели
- Позволить Codex управлять игрой через MCP.
- Понять, какой путь проще: "скриншоты+клики" или прямой доступ к состоянию.

## Вывод (коротко)
- Для динамичных игр устойчивее прямой доступ к состоянию игры через API (state/actions).
- Скриншоты+клики подходят для медленных, кликабельных, пошаговых сценариев.

## Варианты архитектуры

### A) Прямой state через MCP (рекомендуется)
- Игра публикует API: get_state() -> JSON, step(action) -> новый state.
- MCP сервер проксирует этот API агенту.
- Codex принимает решения на основе состояния, отправляет action.
- Визуализация может быть отдельно, но агент не опирается на картинку.

Плюсы:
- Быстро и стабильно.
- Работает и для динамичных игр.
- Нет проблем с распознаванием UI.

Минусы:
- Нужно добавить API в игру.

### B) Веб-игра + браузерная автоматизация
- MCP управляет браузером (клики, клавиши, скриншоты).
- Распознавание через визуальные подсказки.

Плюсы:
- Быстро запустить прототип.

Минусы:
- Хрупкость к UI-изменениям.
- Низкая скорость реакции.

### C) Скриншоты + CV для динамики
- Высокая частота захвата кадров.
- Реальное время.

Плюсы:
- Не нужно менять игру.

Минусы:
- Сложно, медленно, нестабильно.
- Плохо подходит для быстрых игр.

## Рекомендация
- Если нужна динамика: делайте API состояния (вариант A).
- Если нужен быстрый прототип: делайте кликабельное или пошаговое (вариант B).

## Минимальный протокол MCP
- get_state():
  - positions, velocities, timers, health, score
- step(action):
  - action: "move_left", "jump", "shoot"
  - dt: фиксированное или шаговое время
- reset()
- render_frame()? (опционально для человека)

## Следующие шаги
1) Уточнить платформу игры (web/desktop/engine).
2) Выбрать архитектуру A или B.
3) Набросать MCP сервер (Python/Node) и протокол.
4) Добавить адаптер в игру (если A).
