---
phase: 05-composition-canvas-offline-support
plan: 02
type: execute
wave: 1
depends_on: ["05-01"]
duration: 3h
autonomous: true
files_modified:
  - portfolio/src/scripts/db.ts
  - portfolio/src/scripts/composition-store.ts
  - portfolio/src/components/AtomPickerSheet.astro
  - portfolio/src/components/CompositionCanvas.astro
  - portfolio/src/pages/mobile/compositions.astro
  - portfolio/src/pages/mobile/compose.astro
  - portfolio/src/pages/mobile/gallery.astro
  - portfolio/src/styles/canvas.css

must_haves:
  truths:
    - "IndexedDB 'compositions' object store exists with keyPath 'id' and indexes on 'name', 'updatedAt', 'synced'"
    - "DB_VERSION is bumped to 2 in db.ts to trigger the upgrade handler for the new store"
    - "CRUD functions exist: saveComposition, getComposition, getAllCompositions, deleteComposition"
    - "FAB '+' button on compose page opens an atom selection bottom sheet"
    - "Bottom sheet shows searchable list of atoms from IndexedDB, tapping one adds it to canvas"
    - "Added atom appears as AtomNode at canvas center with parameters from config.json"
    - "Composition list page at /mobile/compositions shows all saved compositions"
    - "Tapping a composition in the list opens it on the compose canvas"
    - "New composition auto-creates on first atom add if no composition is active"
    - "MAX_ATOMS_PER_COMPOSITION (5) is enforced; FAB disabled when limit reached"
  artifacts:
    - path: "portfolio/src/scripts/composition-store.ts"
      provides: "IndexedDB CRUD for compositions + canvas state management"
      contains: "saveComposition"
    - path: "portfolio/src/components/AtomPickerSheet.astro"
      provides: "Bottom sheet for selecting atoms to add to canvas"
      contains: "atom-picker"
    - path: "portfolio/src/pages/mobile/compositions.astro"
      provides: "Composition list page showing saved compositions"
      contains: "compositions"
  key_links:
    - from: "portfolio/src/scripts/composition-store.ts"
      to: "portfolio/src/scripts/db.ts"
      via: "import { getDB }"
      pattern: "getDB"
    - from: "portfolio/src/scripts/composition-store.ts"
      to: "portfolio/src/scripts/composition-types.ts"
      via: "import { Composition, CompositionAtom }"
      pattern: "Composition"
    - from: "portfolio/src/components/AtomPickerSheet.astro"
      to: "portfolio/src/scripts/db.ts"
      via: "import { getAllAtomsSorted }"
      pattern: "getAllAtomsSorted"
    - from: "portfolio/src/pages/mobile/compositions.astro"
      to: "portfolio/src/scripts/composition-store.ts"
      via: "import { getAllCompositions }"
      pattern: "getAllCompositions"
---

<objective>
Extend IndexedDB with a compositions object store and implement the atom addition workflow: FAB button opens atom picker bottom sheet, user taps an atom, it appears on the canvas as a node. Also create the composition list page (/mobile/compositions) for browsing saved compositions. After this plan, users can create compositions by adding atoms and the data persists in IndexedDB.

Purpose: This plan delivers the core COMP-01 requirement ("User can add atoms to composition canvas") and the persistence layer (MOB-05) for compositions. Without a way to add atoms and save compositions, the canvas from 05-01 is an empty shell.
Output: Working atom addition flow (FAB -> picker -> node on canvas), IndexedDB composition persistence, and composition list page.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-composition-canvas-offline-support/05-RESEARCH.md
@.planning/phases/05-composition-canvas-offline-support/05-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend IndexedDB with compositions object store</name>
  <files>
    portfolio/src/scripts/db.ts
  </files>
  <action>
Bump the database version and add the compositions object store. The existing db.ts has DB_VERSION=1 with stores for atoms, voiceNotes, screenshots, and configOverrides.

**Update portfolio/src/scripts/db.ts:**

1. Change `DB_VERSION` from `1` to `2`

2. Add the compositions store in the upgrade handler. The upgrade handler must handle both fresh installs (no stores exist) and upgrades (v1 stores exist, add v2 store). The existing `if (!db.objectStoreNames.contains(...))` pattern handles this correctly.

Add inside the `upgrade(db)` callback, after the configOverrides block:

```typescript
// Compositions store (Phase 5)
if (!db.objectStoreNames.contains('compositions')) {
  const compositionStore = db.createObjectStore('compositions', { keyPath: 'id' });
  compositionStore.createIndex('name', 'name');
  compositionStore.createIndex('updatedAt', 'updatedAt');
  compositionStore.createIndex('synced', 'synced');  // Phase 6 sync queries
}
```

3. Reset the cached dbInstance when version changes. Add before the `openDB` call:

```typescript
// Reset cached instance (version upgrade invalidates it)
dbInstance = null;
```

Wait -- the `dbInstance` is already null on first call. The upgrade handler runs automatically when version changes. No code change needed for cache invalidation.

Important: The `upgrade` callback in `idb` receives the `db`, `oldVersion`, `newVersion`, and `transaction` parameters. The existing pattern of checking `!db.objectStoreNames.contains(...)` is correct and handles both fresh installs and upgrades.

After the change, existing users who had DB_VERSION=1 will get the upgrade handler called with `oldVersion=1, newVersion=2`, which will skip existing stores (they pass the `contains` check) and create the new compositions store.
  </action>
  <verify>
1. DB_VERSION is 2 in db.ts
2. compositions store creation code exists in upgrade handler
3. compositions store has indexes: name, updatedAt, synced
4. Existing stores (atoms, voiceNotes, screenshots, configOverrides) are unchanged
5. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
IndexedDB schema upgraded to version 2 with new 'compositions' object store. Indexes on name, updatedAt, and synced (Phase 6 sync queries). Existing v1 stores unaffected. Upgrade handler uses contains() guard for safe v1->v2 migration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create composition storage module with CRUD functions</name>
  <files>
    portfolio/src/scripts/composition-store.ts
  </files>
  <action>
Create the composition persistence layer that wraps IndexedDB operations and provides canvas state management utilities.

**Create portfolio/src/scripts/composition-store.ts:**

```typescript
/**
 * Composition storage and state management for Phase 5.
 *
 * Provides:
 * - IndexedDB CRUD for compositions
 * - Canvas state helpers (add atom, build React Flow nodes/edges)
 * - Composition lifecycle (create, load, save, delete)
 *
 * Design decisions:
 * - Save is explicit (called by autosave in 05-04, not on every mutation)
 * - Atom addition checks MAX_ATOMS limit
 * - Missing atoms handled gracefully (placeholder node)
 */
import { getDB } from './db';
import type { AtomMetadata } from './db';
import {
  type Composition,
  type CompositionAtom,
  type ParameterRoute,
  type AtomNodeData,
  generateId,
  createEmptyComposition,
  parseAtomParameters,
  MAX_ATOMS_PER_COMPOSITION,
} from './composition-types';
import type { Node, Edge } from 'reactflow';

// ---- IndexedDB CRUD ----

export async function saveComposition(composition: Composition): Promise<void> {
  const db = await getDB();
  const updated = {
    ...composition,
    updatedAt: new Date().toISOString(),
    synced: false,
  };
  await db.put('compositions', updated);
}

export async function getComposition(id: string): Promise<Composition | undefined> {
  const db = await getDB();
  return db.get('compositions', id);
}

export async function getAllCompositions(): Promise<Composition[]> {
  const db = await getDB();
  const compositions = await db.getAllFromIndex('compositions', 'updatedAt');
  return compositions.reverse(); // Most recent first
}

export async function deleteComposition(id: string): Promise<void> {
  const db = await getDB();
  await db.delete('compositions', id);
}

export async function getUnsyncedCount(): Promise<number> {
  const db = await getDB();
  const unsynced = await db.getAllFromIndex('compositions', 'synced', false);
  return unsynced.length;
}

// ---- Canvas State Helpers ----

/**
 * Add an atom to a composition. Returns updated composition or null if limit reached.
 */
export function addAtomToComposition(
  composition: Composition,
  atomSlug: string,
  atomMetadata: AtomMetadata,
): Composition | null {
  if (composition.atoms.length >= MAX_ATOMS_PER_COMPOSITION) {
    return null; // Limit reached
  }

  const newAtom: CompositionAtom = {
    nodeId: generateId(),
    atomSlug,
    position: calculateNewNodePosition(composition.atoms.length),
    paramOverrides: undefined,
  };

  return {
    ...composition,
    atoms: [...composition.atoms, newAtom],
    updatedAt: new Date().toISOString(),
  };
}

/**
 * Remove an atom (and its routes) from a composition.
 */
export function removeAtomFromComposition(
  composition: Composition,
  nodeId: string,
): Composition {
  return {
    ...composition,
    atoms: composition.atoms.filter(a => a.nodeId !== nodeId),
    routes: composition.routes.filter(
      r => r.sourceNodeId !== nodeId && r.targetNodeId !== nodeId
    ),
    updatedAt: new Date().toISOString(),
  };
}

/**
 * Calculate position for a new node based on existing node count.
 * Arranges in a staggered grid pattern for readability.
 */
function calculateNewNodePosition(existingCount: number): { x: number; y: number } {
  const col = existingCount % 2;
  const row = Math.floor(existingCount / 2);
  return {
    x: 50 + col * 250,   // 250px horizontal spacing
    y: 50 + row * 200,   // 200px vertical spacing
  };
}

/**
 * Build React Flow nodes from composition atoms.
 * Loads atom metadata from IndexedDB to populate node data.
 */
export async function buildNodes(
  composition: Composition,
  atomsMap: Map<string, AtomMetadata>,
): Promise<Node<AtomNodeData>[]> {
  return composition.atoms.map(compAtom => {
    const metadata = atomsMap.get(compAtom.atomSlug);

    if (!metadata) {
      // Atom not found in IndexedDB - show placeholder
      return {
        id: compAtom.nodeId,
        type: 'atomNode',
        position: compAtom.position,
        data: {
          atomSlug: compAtom.atomSlug,
          atomTitle: compAtom.atomSlug,
          atomType: 'visual',
          parameters: [],
          missing: true,
        },
      };
    }

    const parameters = parseAtomParameters(metadata.configJson);

    return {
      id: compAtom.nodeId,
      type: 'atomNode',
      position: compAtom.position,
      data: {
        atomSlug: compAtom.atomSlug,
        atomTitle: metadata.title,
        atomType: metadata.type,
        parameters,
        paramOverrides: compAtom.paramOverrides,
        missing: false,
      },
    };
  });
}

/**
 * Build React Flow edges from composition routes.
 */
export function buildEdges(composition: Composition): Edge[] {
  return composition.routes.map(route => ({
    id: route.id,
    source: route.sourceNodeId,
    target: route.targetNodeId,
    sourceHandle: `${route.sourceParam}-out`,
    targetHandle: `${route.targetParam}-in`,
    type: 'smoothstep',
    animated: true,
    style: { stroke: '#6bb5ff', strokeWidth: 2 },
  }));
}

/**
 * Update node positions in composition from React Flow node changes.
 * Called after drag operations to persist positions.
 */
export function updateNodePositions(
  composition: Composition,
  nodes: Node[],
): Composition {
  const positionMap = new Map(nodes.map(n => [n.id, n.position]));

  return {
    ...composition,
    atoms: composition.atoms.map(atom => {
      const newPos = positionMap.get(atom.nodeId);
      return newPos ? { ...atom, position: newPos } : atom;
    }),
    updatedAt: new Date().toISOString(),
  };
}

/**
 * Load all atom metadata into a lookup map for quick node building.
 */
export async function loadAtomsMap(): Promise<Map<string, AtomMetadata>> {
  const { getAllAtomsSorted } = await import('./db');
  const atoms = await getAllAtomsSorted();
  return new Map(atoms.map(a => [a.slug, a]));
}
```

This module:
- Provides IndexedDB CRUD (save, get, getAll, delete)
- Manages atom addition with limit enforcement
- Converts composition data to React Flow nodes/edges
- Handles missing atoms (placeholder nodes)
- Tracks node position changes for persistence
- Provides atom metadata lookup map for efficient node building
  </action>
  <verify>
1. portfolio/src/scripts/composition-store.ts exists
2. Exports: saveComposition, getComposition, getAllCompositions, deleteComposition
3. Exports: addAtomToComposition, removeAtomFromComposition
4. Exports: buildNodes, buildEdges, updateNodePositions, loadAtomsMap
5. MAX_ATOMS_PER_COMPOSITION enforced in addAtomToComposition
6. Missing atoms handled with placeholder node (missing: true)
7. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Composition storage module created with IndexedDB CRUD, atom addition with limit enforcement, React Flow node/edge building from composition data, missing atom placeholder handling, node position tracking, and atom metadata lookup map. All Phase 5 canvas operations route through this module.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create atom picker bottom sheet</name>
  <files>
    portfolio/src/components/AtomPickerSheet.astro
    portfolio/src/styles/canvas.css
  </files>
  <action>
Create the bottom sheet that slides up when the user taps the FAB "+" button. It shows a searchable list of atoms from IndexedDB. Tapping an atom dispatches a custom event that the canvas listens to.

**Create portfolio/src/components/AtomPickerSheet.astro:**

```astro
---
/**
 * AtomPickerSheet: Bottom sheet for selecting atoms to add to canvas.
 *
 * UI flow:
 * 1. User taps FAB "+" button
 * 2. Sheet slides up (80% viewport height) with atom list
 * 3. User can search by typing in search field
 * 4. Tapping an atom dispatches 'eoe:add-atom' custom event
 * 5. Sheet dismisses automatically after selection
 *
 * Data source: IndexedDB atoms store (populated by gallery on first visit)
 */
---

<div id="atom-picker-backdrop" class="picker-backdrop" style="display: none;">
  <div id="atom-picker-sheet" class="picker-sheet">
    <div class="picker-handle"></div>

    <div class="picker-header">
      <h3 class="picker-title">Add Atom</h3>
      <button id="picker-close-btn" class="picker-close">&times;</button>
    </div>

    <input
      type="search"
      id="picker-search"
      class="search-bar"
      placeholder="Search atoms..."
      autocomplete="off"
      autocapitalize="none"
      spellcheck="false"
    />

    <div id="picker-list" class="picker-list">
      <!-- Populated dynamically from IndexedDB -->
    </div>

    <div id="picker-empty" class="picker-empty" style="display: none;">
      No atoms found. Visit the Gallery first to cache atoms.
    </div>

    <div id="picker-limit" class="picker-limit" style="display: none;">
      Maximum 5 atoms per composition reached.
    </div>
  </div>
</div>

<script>
  import { getAllAtomsSorted, type AtomMetadata } from '../scripts/db';

  let allAtoms: AtomMetadata[] = [];
  let isOpen = false;

  const backdrop = document.getElementById('atom-picker-backdrop')!;
  const sheet = document.getElementById('atom-picker-sheet')!;
  const searchInput = document.getElementById('picker-search') as HTMLInputElement;
  const listEl = document.getElementById('picker-list')!;
  const emptyEl = document.getElementById('picker-empty')!;
  const limitEl = document.getElementById('picker-limit')!;
  const closeBtn = document.getElementById('picker-close-btn')!;

  // Open picker
  window.addEventListener('eoe:open-atom-picker', async (e: CustomEvent) => {
    const atLimit = e.detail?.atLimit || false;

    if (atLimit) {
      limitEl.style.display = 'block';
      emptyEl.style.display = 'none';
    } else {
      limitEl.style.display = 'none';
    }

    // Load atoms from IndexedDB
    allAtoms = await getAllAtomsSorted();
    renderAtomList(allAtoms);

    // Show sheet
    backdrop.style.display = 'block';
    requestAnimationFrame(() => {
      backdrop.classList.add('open');
      sheet.classList.add('open');
    });
    isOpen = true;

    // Focus search after animation
    setTimeout(() => searchInput.focus(), 350);
  });

  // Close picker
  function closePicker() {
    backdrop.classList.remove('open');
    sheet.classList.remove('open');
    setTimeout(() => {
      backdrop.style.display = 'none';
      searchInput.value = '';
      isOpen = false;
    }, 300);
  }

  closeBtn.addEventListener('click', closePicker);
  backdrop.addEventListener('click', (e) => {
    if (e.target === backdrop) closePicker();
  });

  // Search filtering
  searchInput.addEventListener('input', () => {
    const query = searchInput.value.toLowerCase().trim();
    if (!query) {
      renderAtomList(allAtoms);
      return;
    }
    const filtered = allAtoms.filter(a =>
      a.title.toLowerCase().includes(query) ||
      a.slug.toLowerCase().includes(query) ||
      a.type.toLowerCase().includes(query)
    );
    renderAtomList(filtered);
  });

  // Render atom list
  function renderAtomList(atoms: AtomMetadata[]) {
    if (atoms.length === 0) {
      listEl.innerHTML = '';
      emptyEl.style.display = 'block';
      return;
    }
    emptyEl.style.display = 'none';

    const typeColors: Record<string, string> = {
      visual: '#6bb5ff',
      audio: '#ff6b9d',
      'audio-visual': '#b56bff',
      composition: '#6bffb5',
    };

    listEl.innerHTML = atoms.map(atom => {
      const color = typeColors[atom.type] || '#888';
      return `
        <button class="picker-atom-item" data-slug="${atom.slug}">
          <div class="picker-atom-thumb" style="border-color: ${color}">
            <span class="picker-atom-type-icon">${
              atom.type === 'visual' ? 'V' :
              atom.type === 'audio' ? 'A' :
              atom.type === 'audio-visual' ? 'AV' : 'C'
            }</span>
          </div>
          <div class="picker-atom-info">
            <span class="picker-atom-title">${atom.title}</span>
            <span class="picker-atom-meta">
              ${atom.date}
              <span style="color: ${color}; font-weight: 600; text-transform: uppercase; font-size: 0.65rem;">${atom.type}</span>
            </span>
          </div>
        </button>
      `;
    }).join('');

    // Attach click handlers
    listEl.querySelectorAll('.picker-atom-item').forEach(item => {
      item.addEventListener('click', () => {
        const slug = (item as HTMLElement).dataset.slug;
        if (slug) {
          window.dispatchEvent(new CustomEvent('eoe:add-atom', {
            detail: { atomSlug: slug }
          }));
          closePicker();
        }
      });
    });
  }
</script>

<style>
  .picker-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0);
    z-index: 200;
    transition: background 300ms ease;
  }

  .picker-backdrop.open {
    background: rgba(0, 0, 0, 0.5);
  }

  .picker-sheet {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    max-height: 80vh;
    background: #111;
    border-radius: 16px 16px 0 0;
    padding: 0 16px 16px;
    padding-bottom: calc(16px + env(safe-area-inset-bottom, 0));
    transform: translateY(100%);
    transition: transform 300ms ease;
    z-index: 201;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .picker-sheet.open {
    transform: translateY(0);
  }

  .picker-handle {
    width: 32px;
    height: 4px;
    background: #444;
    border-radius: 2px;
    margin: 12px auto 8px;
  }

  .picker-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0 12px;
  }

  .picker-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #fff;
  }

  .picker-close {
    width: 36px;
    height: 36px;
    border: none;
    background: #222;
    color: #888;
    border-radius: 18px;
    font-size: 1.2rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .picker-close:active {
    background: #333;
  }

  .picker-list {
    flex: 1;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    margin-top: 12px;
  }

  .picker-atom-item {
    display: flex;
    align-items: center;
    gap: 12px;
    width: 100%;
    padding: 10px 8px;
    border: none;
    background: none;
    color: inherit;
    text-align: left;
    cursor: pointer;
    border-radius: 8px;
    min-height: 56px;
    font-family: inherit;
  }

  .picker-atom-item:active {
    background: #1a1a1a;
  }

  .picker-atom-thumb {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    background: #1a1a1a;
    border: 2px solid #333;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .picker-atom-type-icon {
    font-size: 0.7rem;
    font-weight: 700;
    color: #888;
  }

  .picker-atom-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
    min-width: 0;
  }

  .picker-atom-title {
    color: #fff;
    font-weight: 600;
    font-size: 0.9rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .picker-atom-meta {
    color: #666;
    font-size: 0.75rem;
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .picker-empty, .picker-limit {
    padding: 24px;
    text-align: center;
    color: #666;
    font-size: 0.85rem;
  }

  .picker-limit {
    color: #ffb56b;
  }
</style>
```

**Update portfolio/src/styles/canvas.css:**

Add the FAB button disabled state:

```css
.compose-fab.disabled {
  background: #444;
  color: #888;
  box-shadow: none;
  pointer-events: none;
}
```
  </action>
  <verify>
1. portfolio/src/components/AtomPickerSheet.astro exists
2. Bottom sheet slides up on 'eoe:open-atom-picker' custom event
3. Atom list populated from IndexedDB (getAllAtomsSorted)
4. Search input filters atoms by name/slug/type
5. Tapping atom dispatches 'eoe:add-atom' custom event with atomSlug
6. Sheet dismisses after selection
7. Backdrop click closes sheet
8. Close button closes sheet
9. Limit message shown when atLimit=true in event detail
10. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Atom picker bottom sheet created with slide-up animation, searchable atom list from IndexedDB, tap-to-add dispatching custom event, backdrop dismissal, limit warning, and mobile-optimized styling. FAB disabled state added to canvas CSS.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate atom addition into composition canvas</name>
  <files>
    portfolio/src/components/CompositionCanvas.astro
    portfolio/src/pages/mobile/compose.astro
  </files>
  <action>
Update the CompositionCanvas and compose page to wire up the FAB button, atom picker, and canvas state management. When the user taps FAB -> picks atom -> atom appears on canvas.

**Update portfolio/src/pages/mobile/compose.astro:**

Replace the existing content with:

```astro
---
import MobileLayout from '../../layouts/MobileLayout.astro';
import CompositionCanvas from '../../components/CompositionCanvas.astro';
import AtomPickerSheet from '../../components/AtomPickerSheet.astro';
---

<MobileLayout title="Compose" showBack={true} backHref="/mobile/compositions">
  <div style="margin: -16px; margin-top: -16px;">
    <CompositionCanvas />
  </div>

  <!-- FAB button to add atoms -->
  <button id="add-atom-fab" class="compose-fab" title="Add atom">+</button>

  <!-- Atom picker bottom sheet -->
  <AtomPickerSheet />
</MobileLayout>

<script>
  import {
    saveComposition,
    getComposition,
    addAtomToComposition,
    buildNodes,
    buildEdges,
    loadAtomsMap,
    updateNodePositions,
  } from '../../scripts/composition-store';
  import {
    createEmptyComposition,
    MAX_ATOMS_PER_COMPOSITION,
  } from '../../scripts/composition-types';
  import { getAtom } from '../../scripts/db';
  import type { Node, Edge } from 'reactflow';

  let currentComposition = createEmptyComposition('Untitled Composition');
  let atomsMap = new Map();

  // Load composition from URL parameter or create new
  async function initComposition() {
    atomsMap = await loadAtomsMap();

    const params = new URLSearchParams(window.location.search);
    const compId = params.get('id');

    if (compId) {
      const loaded = await getComposition(compId);
      if (loaded) {
        currentComposition = loaded;
        await refreshCanvas();
        return;
      }
    }

    // New composition - canvas starts empty
    updateFabState();
  }

  // Refresh React Flow canvas from composition data
  async function refreshCanvas() {
    const nodes = await buildNodes(currentComposition, atomsMap);
    const edges = buildEdges(currentComposition);

    // Update React canvas via global setters (from 05-01 CompositionCanvas)
    if ((window as any).__canvasSetNodes) {
      (window as any).__canvasSetNodes(nodes);
    }
    if ((window as any).__canvasSetEdges) {
      (window as any).__canvasSetEdges(edges);
    }
    updateFabState();
  }

  // FAB button: open atom picker
  const fab = document.getElementById('add-atom-fab')!;
  fab.addEventListener('click', () => {
    const atLimit = currentComposition.atoms.length >= MAX_ATOMS_PER_COMPOSITION;
    window.dispatchEvent(new CustomEvent('eoe:open-atom-picker', {
      detail: { atLimit }
    }));
  });

  // Handle atom selection from picker
  window.addEventListener('eoe:add-atom', async (e: CustomEvent) => {
    const { atomSlug } = e.detail;
    const atomMeta = atomsMap.get(atomSlug);
    if (!atomMeta) {
      console.warn('[compose] Atom not found in cache:', atomSlug);
      return;
    }

    const updated = addAtomToComposition(currentComposition, atomSlug, atomMeta);
    if (!updated) {
      // Limit reached
      showToast('Maximum 5 atoms reached');
      return;
    }

    currentComposition = updated;
    await saveComposition(currentComposition);
    await refreshCanvas();

    showToast(`Added ${atomMeta.title}`);
  });

  // Update FAB state (disable at limit)
  function updateFabState() {
    const atLimit = currentComposition.atoms.length >= MAX_ATOMS_PER_COMPOSITION;
    fab.classList.toggle('disabled', atLimit);
  }

  // Toast notification helper
  function showToast(message: string) {
    const toast = document.getElementById('canvas-toast');
    if (toast) {
      toast.textContent = message;
      toast.classList.add('visible');
      setTimeout(() => toast.classList.remove('visible'), 2000);
    }
  }

  // Listen for node position changes from React Flow
  // The canvas dispatches this when nodes are dragged
  window.addEventListener('eoe:nodes-changed', async (e: CustomEvent) => {
    const nodes = e.detail?.nodes;
    if (nodes && currentComposition) {
      currentComposition = updateNodePositions(currentComposition, nodes);
      // Don't save on every drag - autosave in 05-04 handles this
    }
  });

  // Initialize
  initComposition();
</script>

<style>
  :global(.mobile-main) {
    padding: 0 !important;
    max-width: none !important;
  }
</style>
```

**Update portfolio/src/components/CompositionCanvas.astro:**

Add node drag handling to the React Flow canvas so position changes are dispatched:

In the CanvasApp function, add onNodesChange handling and fitView behavior. The key addition is dispatching position updates when nodes are dragged.

Update the React Flow component creation to include onNodeDragStop:

```typescript
// Inside CanvasApp component, add drag handler:
const onNodeDragStop = React.useCallback((_event: any, _node: any) => {
  // Dispatch updated positions to Astro script
  const currentNodes = (window as any).__canvasGetNodes?.() || [];
  window.dispatchEvent(new CustomEvent('eoe:nodes-changed', {
    detail: { nodes: currentNodes }
  }));
}, []);
```

And pass `onNodeDragStop` to the ReactFlow createElement props.

Also add the `onNodesChange` handler to allow React Flow to update positions during drag:

```typescript
import { ReactFlow, Background, useNodesState, useEdgesState } from 'reactflow';

// Replace useState with useNodesState/useEdgesState:
const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
```

Pass `onNodesChange` and `onEdgesChange` to ReactFlow props.
  </action>
  <verify>
1. FAB "+" button visible on compose page
2. Tapping FAB opens atom picker bottom sheet
3. Picking an atom adds it as a node on the canvas
4. Node shows atom name, type badge, and parameters
5. Canvas updates immediately after atom addition
6. Composition saved to IndexedDB after atom addition
7. FAB shows disabled state at 5-atom limit
8. Toast notification appears after adding atom
9. Node dragging works (finger drag repositions nodes)
10. URL parameter ?id=<uuid> loads existing composition
11. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Atom addition flow wired end-to-end: FAB button opens picker, atom selection creates node on canvas, composition auto-saves to IndexedDB, FAB disables at 5-atom limit. Node dragging dispatches position updates. Composition loaded from URL parameter or created new. Toast notifications for user feedback.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create composition list page</name>
  <files>
    portfolio/src/pages/mobile/compositions.astro
    portfolio/src/pages/mobile/gallery.astro
  </files>
  <action>
Create the composition list page at /mobile/compositions that shows all saved compositions. This is the entry point for the composition workflow.

**Create portfolio/src/pages/mobile/compositions.astro:**

```astro
---
import MobileLayout from '../../layouts/MobileLayout.astro';
---

<MobileLayout title="Compositions">
  <div id="comp-list" class="comp-list">
    <!-- Populated from IndexedDB on client side -->
  </div>

  <div id="comp-empty" class="comp-empty" style="display: none;">
    <div class="comp-empty-title">No Compositions Yet</div>
    <div class="comp-empty-text">Create one by tapping the button below.</div>
  </div>

  <a href="/mobile/compose" class="btn btn-primary" id="new-comp-btn" style="width: 100%; margin-top: 16px;">
    + New Composition
  </a>

  <!-- Bottom nav -->
  <nav class="bottom-nav">
    <a href="/mobile/gallery" class="bottom-nav-item">Gallery</a>
    <a href="/mobile/compositions" class="bottom-nav-item active">Compose</a>
  </nav>

  <script>
    import { getAllCompositions, deleteComposition } from '../../scripts/composition-store';

    async function loadCompositions() {
      const listEl = document.getElementById('comp-list')!;
      const emptyEl = document.getElementById('comp-empty')!;

      const compositions = await getAllCompositions();

      if (compositions.length === 0) {
        listEl.innerHTML = '';
        emptyEl.style.display = 'block';
        return;
      }

      emptyEl.style.display = 'none';

      listEl.innerHTML = compositions.map(comp => {
        const atomCount = comp.atoms.length;
        const routeCount = comp.routes.length;
        const date = new Date(comp.updatedAt).toLocaleDateString('en-US', {
          month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
        });

        return `
          <a href="/mobile/compose?id=${comp.id}" class="comp-item">
            <div class="comp-item-info">
              <span class="comp-item-name">${comp.name}</span>
              <span class="comp-item-meta">
                ${atomCount} atom${atomCount !== 1 ? 's' : ''} &middot;
                ${routeCount} route${routeCount !== 1 ? 's' : ''} &middot;
                ${date}
              </span>
            </div>
            <button class="comp-item-delete" data-id="${comp.id}" title="Delete">&times;</button>
          </a>
        `;
      }).join('');

      // Delete handlers
      listEl.querySelectorAll('.comp-item-delete').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          const id = (btn as HTMLElement).dataset.id;
          if (id && confirm('Delete this composition?')) {
            await deleteComposition(id);
            loadCompositions(); // Refresh list
          }
        });
      });
    }

    loadCompositions();
  </script>

  <style>
    .comp-list {
      margin-bottom: 16px;
    }

    .comp-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      border-bottom: 1px solid #1a1a1a;
      text-decoration: none;
      color: inherit;
      min-height: 64px;
    }

    .comp-item:active {
      background: #1a1a1a;
    }

    .comp-item-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .comp-item-name {
      color: #fff;
      font-weight: 600;
      font-size: 0.95rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .comp-item-meta {
      color: #666;
      font-size: 0.8rem;
    }

    .comp-item-delete {
      width: 36px;
      height: 36px;
      border: none;
      background: #1a1a1a;
      color: #888;
      border-radius: 18px;
      font-size: 1.1rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .comp-item-delete:active {
      background: #ff444440;
      color: #ff4444;
    }

    .comp-empty {
      text-align: center;
      padding: 48px 24px;
    }

    .comp-empty-title {
      color: #888;
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .comp-empty-text {
      color: #555;
      font-size: 0.85rem;
    }

    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      background: #111;
      border-top: 1px solid #222;
      padding-bottom: env(safe-area-inset-bottom, 0);
      z-index: 100;
    }

    .bottom-nav-item {
      flex: 1;
      padding: 12px;
      text-align: center;
      color: #666;
      font-size: 0.85rem;
      font-weight: 600;
      text-decoration: none;
      min-height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .bottom-nav-item.active {
      color: #6bb5ff;
    }

    .bottom-nav-item:active {
      background: #1a1a1a;
    }
  </style>
</MobileLayout>
```

**Update gallery.astro bottom nav** to point "Compose" to /mobile/compositions instead of /mobile/compose:

In portfolio/src/pages/mobile/gallery.astro, update the Compose nav item href:
```html
<a href="/mobile/compositions" class="bottom-nav-item">Compose</a>
```

The navigation flow is now:
- Gallery (/mobile/gallery) -> bottom nav "Compose" -> Compositions list (/mobile/compositions)
- Compositions list -> tap composition -> Canvas with loaded composition (/mobile/compose?id=...)
- Compositions list -> "New Composition" button -> Empty canvas (/mobile/compose)
- Canvas -> back button -> Compositions list (/mobile/compositions)
  </action>
  <verify>
1. portfolio/src/pages/mobile/compositions.astro exists
2. /mobile/compositions page lists saved compositions from IndexedDB
3. Each composition shows name, atom count, route count, and last modified date
4. Tapping a composition navigates to /mobile/compose?id=<uuid>
5. Delete button removes composition from IndexedDB and refreshes list
6. "New Composition" button navigates to /mobile/compose (empty canvas)
7. Empty state message shown when no compositions exist
8. Gallery bottom nav "Compose" links to /mobile/compositions
9. Compose page back button goes to /mobile/compositions
10. Bottom navigation shown on compositions page (Gallery | Compose)
11. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Composition list page created at /mobile/compositions showing saved compositions with name, atom/route counts, and last modified date. Tap opens in canvas, delete button removes from IndexedDB. "New Composition" button starts empty canvas. Navigation flow: Gallery <-> Compositions list -> Canvas. Bottom nav updated across pages.
  </done>
</task>

</tasks>

<verification>
1. IndexedDB "eoe-atoms" database version is 2 with 5 stores (atoms, voiceNotes, screenshots, configOverrides, compositions)
2. compositions store has indexes on name, updatedAt, synced
3. CRUD functions work: save, get, getAll, delete compositions
4. FAB "+" button opens atom picker bottom sheet on compose page
5. Atom picker shows searchable atom list from IndexedDB
6. Tapping atom adds it as a node on the React Flow canvas
7. Node shows atom name, type badge, and parameter handles
8. Composition auto-saves to IndexedDB after adding atoms
9. FAB disabled when 5-atom limit reached
10. /mobile/compositions page lists all saved compositions
11. Tapping a composition opens it in the canvas (loads from IndexedDB)
12. Delete button removes compositions
13. Navigation flow: Gallery <-> Compositions <-> Compose canvas
14. Missing atoms show placeholder node (graceful degradation)
15. Toast notifications for atom addition and errors
</verification>

<success_criteria>
- User can add atoms to composition canvas from gallery picker (COMP-01)
- Compositions persist in IndexedDB across page reloads (MOB-05)
- Composition list provides overview of all saved compositions
- Maximum 5 atoms enforced per composition (performance limit)
- Missing atoms handled gracefully (placeholder node, not crash)
- Navigation flow is logical: Gallery -> Compositions -> Canvas
- All features work offline after first visit (IndexedDB persistence)
</success_criteria>

<output>
After completion, create `.planning/phases/05-composition-canvas-offline-support/05-02-SUMMARY.md`
</output>
