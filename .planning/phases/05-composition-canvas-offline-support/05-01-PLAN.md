---
phase: 05-composition-canvas-offline-support
plan: 01
type: execute
wave: 1
depends_on: []
duration: 3h
autonomous: true
files_modified:
  - portfolio/package.json
  - portfolio/src/pages/mobile/compose.astro
  - portfolio/src/components/CompositionCanvas.astro
  - portfolio/src/scripts/composition-types.ts
  - portfolio/src/scripts/atom-node.tsx
  - portfolio/src/styles/canvas.css
  - portfolio/astro.config.mjs

must_haves:
  truths:
    - "React Flow 11.11+ is installed with tree-shaken named imports (import { ReactFlow } from 'reactflow')"
    - "/mobile/compose page exists and renders a React Flow canvas that fills the viewport below the header"
    - "Custom AtomNode component renders atom name, type badge, and parameter handle dots"
    - "React Flow is configured for mobile: panOnDrag=[1], zoomOnPinch=true, panOnScroll=false"
    - "Canvas renders 0-5 nodes without visible lag (<500ms cold, <200ms warm)"
    - "TypeScript interfaces for Composition, CompositionAtom, and ParameterRoute are defined"
    - "React integration works within Astro via client:only='react' directive"
    - "Total mobile bundle stays under 1.2MB gzipped after React Flow addition"
    - "AtomNode component uses React.memo to prevent unnecessary re-renders"
  artifacts:
    - path: "portfolio/src/scripts/composition-types.ts"
      provides: "TypeScript interfaces for Composition, CompositionAtom, ParameterRoute"
      contains: "Composition"
    - path: "portfolio/src/scripts/atom-node.tsx"
      provides: "Custom React Flow node component for atom representation"
      contains: "AtomNode"
    - path: "portfolio/src/pages/mobile/compose.astro"
      provides: "Composition canvas page at /mobile/compose"
      contains: "CompositionCanvas"
    - path: "portfolio/src/components/CompositionCanvas.astro"
      provides: "Astro wrapper for React Flow canvas with client:only directive"
      contains: "ReactFlow"
    - path: "portfolio/src/styles/canvas.css"
      provides: "Canvas-specific styles: full viewport, dark theme, touch overrides"
      contains: "react-flow"
  key_links:
    - from: "portfolio/src/pages/mobile/compose.astro"
      to: "portfolio/src/components/CompositionCanvas.astro"
      via: "import CompositionCanvas"
      pattern: "CompositionCanvas"
    - from: "portfolio/src/scripts/atom-node.tsx"
      to: "portfolio/src/scripts/composition-types.ts"
      via: "import { CompositionAtom }"
      pattern: "CompositionAtom"
    - from: "portfolio/src/components/CompositionCanvas.astro"
      to: "reactflow"
      via: "import { ReactFlow } from 'reactflow'"
      pattern: "ReactFlow"
---

<objective>
Install React Flow and create the composition canvas foundation at /mobile/compose. After this plan, there is a mobile-optimized React Flow canvas that renders custom atom nodes with parameter handles, configured for touch interaction (single-finger pan, pinch zoom). This is the foundation upon which all composition features (atom addition, parameter routing, persistence) are built.

Purpose: Without the canvas, no composition feature can exist. React Flow integration is the most technically risky piece (bundle size, mobile performance, Astro+React interop), so it must be validated first in isolation. This plan proves React Flow is viable on mobile before investing in composition logic.
Output: Working /mobile/compose page with touch-optimized React Flow canvas, custom AtomNode component, and composition TypeScript types.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-composition-canvas-offline-support/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install React Flow and React dependencies</name>
  <files>
    portfolio/package.json
    portfolio/astro.config.mjs
  </files>
  <action>
Install React Flow and its peer dependencies. The portfolio uses Astro 5.x which supports React via `@astrojs/react`. React Flow 11.11+ requires React 17+ and ReactDOM.

**Install dependencies in portfolio/:**
```bash
cd portfolio && npm install reactflow @astrojs/react react react-dom
```

**Install TypeScript types:**
```bash
cd portfolio && npm install -D @types/react @types/react-dom
```

**Update portfolio/astro.config.mjs:**

Add the React integration alongside the existing PWA integration:

```javascript
import { defineConfig } from 'astro/config';
import AstroPWA from '@vite-pwa/astro';
import react from '@astrojs/react';

export default defineConfig({
  integrations: [
    react(),
    AstroPWA({
      // ... existing PWA config unchanged
    })
  ],
  vite: {
    server: {
      fs: {
        allow: ['..']
      }
    }
  }
});
```

Important: Add `react()` BEFORE `AstroPWA()` in the integrations array. The React integration must process .tsx files before PWA generates the service worker.

**Verify installation:**
```bash
cd portfolio && npm ls reactflow && npm ls react && npm ls @astrojs/react
```

After installation, verify the portfolio still builds:
```bash
cd portfolio && npm run build
```

React Flow must be imported via named imports for tree-shaking:
```typescript
// CORRECT - tree-shaken (~100KB gzipped)
import { ReactFlow, Background, Controls } from 'reactflow';
import type { Node, Edge, NodeProps } from 'reactflow';

// WRONG - imports entire bundle (~600KB)
import ReactFlow from 'reactflow';
```
  </action>
  <verify>
1. `cd portfolio && npm ls reactflow` shows 11.11+ installed
2. `cd portfolio && npm ls react` shows 18+ or 19+ installed
3. `cd portfolio && npm ls @astrojs/react` shows installed version
4. `cd portfolio && npm ls @types/react @types/react-dom` shows dev deps installed
5. portfolio/astro.config.mjs imports react from '@astrojs/react'
6. `cd portfolio && npm run build` completes without errors
7. No existing functionality is broken (gallery, detail pages still build)
  </verify>
  <done>
React Flow 11.11+ and React dependencies installed. Astro React integration added to astro.config.mjs. Tree-shaking via named imports confirmed. Build succeeds with all existing pages intact.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define composition data model TypeScript types</name>
  <files>
    portfolio/src/scripts/composition-types.ts
  </files>
  <action>
Create the TypeScript interfaces that define the composition data model. These types are used by every subsequent Phase 5 plan (canvas, persistence, routing, undo/redo).

**Create portfolio/src/scripts/composition-types.ts:**

```typescript
/**
 * Composition data model for Phase 5.
 *
 * A Composition is a graph of atoms connected by parameter routes.
 * Stored in IndexedDB as a single JSON document per composition.
 *
 * Design decisions (from 05-RESEARCH.md):
 * - UUIDs for all IDs (collision-free for Phase 6 sync)
 * - paramOverrides at composition level (don't mutate atom config.json)
 * - synced flag for Phase 6 cloud backup
 * - viewport state persisted for resume-where-you-left-off
 * - Max 5 atoms per composition in Phase 5 (performance limit)
 */

export const MAX_ATOMS_PER_COMPOSITION = 5;

export interface Composition {
  id: string;                    // UUID
  name: string;                  // User-visible name (e.g., "My First Composition")
  createdAt: string;             // ISO timestamp
  updatedAt: string;             // ISO timestamp
  atoms: CompositionAtom[];      // Atoms on the canvas (max 5 in Phase 5)
  routes: ParameterRoute[];      // Parameter connections between atoms
  viewport: {                    // React Flow viewport state
    x: number;
    y: number;
    zoom: number;
  };
  synced: boolean;               // Phase 6 sync flag
}

export interface CompositionAtom {
  nodeId: string;                // Unique within composition (UUID)
  atomSlug: string;              // Reference to atoms IndexedDB store
  position: { x: number; y: number };  // Canvas position
  paramOverrides?: Record<string, number | string | boolean>;  // Local tweaks
}

export interface ParameterRoute {
  id: string;                    // UUID
  sourceNodeId: string;          // CompositionAtom.nodeId
  sourceParam: string;           // config.json controller key
  targetNodeId: string;          // CompositionAtom.nodeId
  targetParam: string;           // config.json controller key
}

/**
 * Data passed to the custom AtomNode React component.
 * This is the `data` field of a React Flow Node.
 */
export interface AtomNodeData {
  atomSlug: string;
  atomTitle: string;
  atomType: string;              // "visual" | "audio" | "audio-visual"
  parameters: AtomParameter[];   // Parsed from config.json controllers
  paramOverrides?: Record<string, number | string | boolean>;
  missing?: boolean;             // True if atom not found in IndexedDB
}

/**
 * Single parameter definition for display in atom nodes.
 * Derived from config.json controllers object.
 */
export interface AtomParameter {
  name: string;
  type: 'number' | 'string' | 'boolean' | 'object';
  value: number | string | boolean | object;
}

/**
 * Infer parameter type from a config.json controller value.
 * Phase 5: strict type matching only (number->number, etc.)
 */
export function inferParamType(value: unknown): AtomParameter['type'] {
  if (typeof value === 'number') return 'number';
  if (typeof value === 'string') return 'string';
  if (typeof value === 'boolean') return 'boolean';
  return 'object';
}

/**
 * Check if two parameters are compatible for routing.
 * Phase 5: same-type routing only. Phase 6 adds transforms.
 */
export function canRoute(sourceValue: unknown, targetValue: unknown): boolean {
  const sourceType = inferParamType(sourceValue);
  const targetType = inferParamType(targetValue);
  // Phase 5: Only allow same-type routing
  // Object types are not routable in Phase 5
  if (sourceType === 'object' || targetType === 'object') return false;
  return sourceType === targetType;
}

/**
 * Parse config.json controllers into AtomParameter array.
 */
export function parseAtomParameters(configJson: string): AtomParameter[] {
  try {
    const config = JSON.parse(configJson);
    const controllers = config.controllers || {};
    return Object.entries(controllers).map(([name, value]) => ({
      name,
      type: inferParamType(value),
      value: value as number | string | boolean | object,
    }));
  } catch {
    return [];
  }
}

/**
 * Generate a UUID v4. Uses crypto.randomUUID when available,
 * falls back to manual generation for older browsers.
 */
export function generateId(): string {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback for environments without crypto.randomUUID
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/**
 * Create an empty composition with default values.
 */
export function createEmptyComposition(name: string): Composition {
  const now = new Date().toISOString();
  return {
    id: generateId(),
    name,
    createdAt: now,
    updatedAt: now,
    atoms: [],
    routes: [],
    viewport: { x: 0, y: 0, zoom: 1 },
    synced: false,
  };
}
```

This file provides:
- Core data types (Composition, CompositionAtom, ParameterRoute)
- Node display types (AtomNodeData, AtomParameter)
- Type inference and routing compatibility checks
- UUID generation utility
- Factory function for new compositions
- Constant for max atoms limit (5 in Phase 5)
  </action>
  <verify>
1. portfolio/src/scripts/composition-types.ts exists
2. Exports: Composition, CompositionAtom, ParameterRoute, AtomNodeData, AtomParameter interfaces
3. Exports: inferParamType, canRoute, parseAtomParameters, generateId, createEmptyComposition functions
4. MAX_ATOMS_PER_COMPOSITION constant equals 5
5. `cd portfolio && npx tsc --noEmit` passes (or build succeeds)
  </verify>
  <done>
Composition data model defined with TypeScript interfaces for Composition (graph document), CompositionAtom (node), ParameterRoute (edge), AtomNodeData (React Flow node data), and AtomParameter (controller entry). Includes type inference, routing compatibility check, UUID generation, and factory function. All Phase 5 plans import from this module.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create custom AtomNode React component</name>
  <files>
    portfolio/src/scripts/atom-node.tsx
  </files>
  <action>
Create the custom React Flow node component that visually represents an atom on the canvas. Each node shows the atom name, type badge, and parameter handles (dots on the sides that routes connect to).

**Create portfolio/src/scripts/atom-node.tsx:**

```tsx
/**
 * AtomNode: Custom React Flow node for composition canvas.
 *
 * Renders:
 * - Atom title and type badge in header
 * - Parameter list with type-colored dots (handles)
 * - "Missing atom" placeholder when atomSlug not found
 *
 * Performance: React.memo prevents re-renders unless data changes.
 * Touch: All interactive areas >= 48px for mobile touch targets.
 *
 * Handles:
 * - Left side: Input handles (target) for each parameter
 * - Right side: Output handles (source) for each parameter
 */
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import type { NodeProps } from 'reactflow';
import type { AtomNodeData } from './composition-types';

const TYPE_COLORS: Record<string, string> = {
  visual: '#6bb5ff',
  audio: '#ff6b9d',
  'audio-visual': '#b56bff',
  composition: '#6bffb5',
};

const PARAM_TYPE_COLORS: Record<string, string> = {
  number: '#6bb5ff',
  string: '#6bff6b',
  boolean: '#ffb56b',
  object: '#888',
};

function AtomNodeComponent({ data }: NodeProps<AtomNodeData>) {
  const badgeColor = TYPE_COLORS[data.atomType] || '#888';

  if (data.missing) {
    return (
      <div style={{
        background: '#1a1a1a',
        border: '2px dashed #ff4444',
        borderRadius: 8,
        padding: 12,
        minWidth: 160,
        fontFamily: '-apple-system, BlinkMacSystemFont, sans-serif',
      }}>
        <div style={{ color: '#ff4444', fontSize: 13, fontWeight: 600 }}>
          Atom not found
        </div>
        <div style={{ color: '#888', fontSize: 11, marginTop: 4 }}>
          {data.atomSlug}
        </div>
      </div>
    );
  }

  // Routable parameters only (exclude 'object' type in Phase 5)
  const routableParams = data.parameters.filter(p => p.type !== 'object');

  return (
    <div style={{
      background: '#1a1a1a',
      border: `2px solid ${badgeColor}40`,
      borderRadius: 8,
      minWidth: 180,
      fontFamily: '-apple-system, BlinkMacSystemFont, sans-serif',
      boxShadow: '0 2px 8px rgba(0,0,0,0.4)',
    }}>
      {/* Header */}
      <div style={{
        padding: '8px 12px',
        borderBottom: '1px solid #333',
        display: 'flex',
        alignItems: 'center',
        gap: 8,
      }}>
        <span style={{
          fontSize: 13,
          fontWeight: 600,
          color: '#fff',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          whiteSpace: 'nowrap',
          flex: 1,
        }}>
          {data.atomTitle}
        </span>
        <span style={{
          fontSize: 10,
          fontWeight: 700,
          color: badgeColor,
          textTransform: 'uppercase',
          letterSpacing: 0.5,
        }}>
          {data.atomType}
        </span>
      </div>

      {/* Parameters */}
      <div style={{ padding: '6px 0' }}>
        {routableParams.length === 0 && (
          <div style={{ padding: '4px 12px', color: '#555', fontSize: 11 }}>
            No parameters
          </div>
        )}
        {routableParams.map((param, index) => {
          const handleId = param.name;
          const color = PARAM_TYPE_COLORS[param.type] || '#888';
          const displayValue = typeof param.value === 'number'
            ? Math.round(param.value * 100) / 100
            : String(param.value);

          return (
            <div
              key={param.name}
              style={{
                position: 'relative',
                padding: '4px 12px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                minHeight: 28,
                fontSize: 12,
              }}
            >
              {/* Input handle (left) */}
              <Handle
                type="target"
                position={Position.Left}
                id={`${handleId}-in`}
                style={{
                  width: 10,
                  height: 10,
                  background: color,
                  border: '2px solid #0a0a0a',
                  left: -5,
                }}
              />

              <span style={{ color: '#ccc' }}>{param.name}</span>
              <span style={{ color: '#666', fontSize: 11, marginLeft: 8 }}>
                {displayValue}
              </span>

              {/* Output handle (right) */}
              <Handle
                type="source"
                position={Position.Right}
                id={`${handleId}-out`}
                style={{
                  width: 10,
                  height: 10,
                  background: color,
                  border: '2px solid #0a0a0a',
                  right: -5,
                }}
              />
            </div>
          );
        })}
      </div>
    </div>
  );
}

// React.memo with custom comparator for performance
// Only re-render if atom data actually changed
export const AtomNode = memo(AtomNodeComponent, (prev, next) => {
  return (
    prev.data.atomSlug === next.data.atomSlug &&
    prev.data.atomTitle === next.data.atomTitle &&
    prev.data.parameters === next.data.parameters &&
    prev.data.paramOverrides === next.data.paramOverrides &&
    prev.data.missing === next.data.missing
  );
});

// Node type registration object for React Flow
export const nodeTypes = {
  atomNode: AtomNode,
};
```

This component:
- Renders atom name, type badge (color-coded), and parameter list
- Shows input handles (left) and output handles (right) for each routable parameter
- Color-codes parameter handles by type (number=blue, string=green, boolean=orange)
- Displays current parameter values next to names
- Shows "Atom not found" placeholder for missing atoms
- Uses React.memo with custom comparator to prevent re-renders
- Exports nodeTypes object for React Flow registration
  </action>
  <verify>
1. portfolio/src/scripts/atom-node.tsx exists
2. Exports AtomNode (memoized component) and nodeTypes object
3. Uses Handle from 'reactflow' for parameter connections
4. Parameter handles have type-specific colors
5. Missing atom state shows dashed red border placeholder
6. React.memo comparator checks atomSlug, parameters, and overrides
7. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Custom AtomNode React component created with atom header (name + type badge), parameter list with type-colored handles (input left, output right), missing atom placeholder, and React.memo optimization. Exports nodeTypes registration object for React Flow canvas.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create canvas styles and React Flow canvas wrapper</name>
  <files>
    portfolio/src/styles/canvas.css
    portfolio/src/components/CompositionCanvas.astro
  </files>
  <action>
Create canvas-specific CSS and the Astro wrapper component that hosts the React Flow canvas.

**Create portfolio/src/styles/canvas.css:**

```css
/* Composition canvas styles */

/* React Flow container: fill viewport below header */
.canvas-container {
  width: 100%;
  height: calc(100vh - 48px); /* 48px = mobile header height */
  position: relative;
  background: #0a0a0a;
}

/* Override React Flow default styles for dark theme */
.react-flow__background {
  background: #0a0a0a !important;
}

.react-flow__background pattern line {
  stroke: #1a1a1a !important;
}

/* Edge styles */
.react-flow__edge-path {
  stroke: #6bb5ff;
  stroke-width: 2;
}

.react-flow__edge.selected .react-flow__edge-path {
  stroke: #fff;
  stroke-width: 3;
}

/* Connection line (while dragging) */
.react-flow__connection-line {
  stroke: #6bb5ff;
  stroke-width: 2;
  stroke-dasharray: 5 5;
}

/* Minimap (disabled on mobile, but style anyway) */
.react-flow__minimap {
  display: none; /* Hidden on mobile to save screen space */
}

/* Controls panel */
.react-flow__controls {
  display: none; /* Hidden on mobile; use gestures instead */
}

/* Attribution */
.react-flow__attribution {
  display: none; /* Hidden (React Flow Pro not required for open source) */
}

/* iOS Safari: Prevent grey highlight rectangles on touch */
.react-flow,
.react-flow * {
  -webkit-tap-highlight-color: transparent;
}

/* Prevent scroll conflicts on canvas */
.canvas-container {
  touch-action: none;
  overflow: hidden;
}

/* FAB button placeholder (implemented in 05-02) */
.compose-fab {
  position: fixed;
  bottom: calc(24px + env(safe-area-inset-bottom, 0));
  right: 24px;
  width: 56px;
  height: 56px;
  border-radius: 28px;
  background: #6bb5ff;
  color: #0a0a0a;
  border: none;
  font-size: 24px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(107, 181, 255, 0.3);
  cursor: pointer;
  z-index: 50;
  -webkit-tap-highlight-color: transparent;
}

.compose-fab:active {
  transform: scale(0.92);
  opacity: 0.9;
}

/* Empty canvas message */
.canvas-empty {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  color: #555;
  font-size: 0.9rem;
  pointer-events: none;
  z-index: 1;
}

.canvas-empty-title {
  font-size: 1.1rem;
  color: #888;
  margin-bottom: 8px;
}

/* Toast notification for composition actions */
.canvas-toast {
  position: fixed;
  bottom: calc(96px + env(safe-area-inset-bottom, 0));
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: #fff;
  padding: 10px 20px;
  border-radius: 8px;
  font-size: 0.85rem;
  z-index: 100;
  opacity: 0;
  transition: opacity 300ms ease;
  pointer-events: none;
}

.canvas-toast.visible {
  opacity: 1;
}
```

**Create portfolio/src/components/CompositionCanvas.astro:**

This Astro component wraps a React component that renders the React Flow canvas. Astro uses `client:only="react"` to render React components only on the client (no SSR for React Flow -- it requires browser APIs).

```astro
---
/**
 * CompositionCanvas: Astro wrapper for React Flow composition canvas.
 *
 * Uses client:only="react" because React Flow requires browser APIs
 * (DOM measurements, touch events) and cannot be server-rendered.
 *
 * Props:
 * - compositionId: Optional ID of composition to load from IndexedDB
 */
import '../styles/canvas.css';

export interface Props {
  compositionId?: string;
}

const { compositionId } = Astro.props;
---

<div class="canvas-container" id="canvas-root" data-composition-id={compositionId || ''}>
  <!-- React Flow mounts here via client-side React -->
  <div id="react-canvas-mount" style="width: 100%; height: 100%;"></div>

  <!-- Empty state (hidden when nodes exist) -->
  <div class="canvas-empty" id="canvas-empty-state">
    <div class="canvas-empty-title">Empty Canvas</div>
    <div>Tap + to add an atom</div>
  </div>

  <!-- Toast container -->
  <div class="canvas-toast" id="canvas-toast"></div>
</div>

<script>
  import React from 'react';
  import { createRoot } from 'react-dom/client';
  import { ReactFlow, Background } from 'reactflow';
  import type { Node, Edge, Viewport } from 'reactflow';
  import 'reactflow/dist/style.css';
  import { nodeTypes } from '../scripts/atom-node';
  import type { AtomNodeData } from '../scripts/composition-types';

  // Initialize React Flow canvas
  function initCanvas() {
    const mountEl = document.getElementById('react-canvas-mount');
    if (!mountEl) return;

    const root = createRoot(mountEl);

    // Canvas state (managed outside React for Phase 5 simplicity)
    // Plans 05-02 through 05-04 will upgrade this to full state management
    const initialNodes: Node<AtomNodeData>[] = [];
    const initialEdges: Edge[] = [];

    function CanvasApp() {
      const [nodes, setNodes] = React.useState<Node<AtomNodeData>[]>(initialNodes);
      const [edges, setEdges] = React.useState<Edge[]>(initialEdges);

      // Expose setters globally for Astro script interop (temporary pattern)
      // Plans 05-02+ will replace with proper event-based communication
      React.useEffect(() => {
        (window as any).__canvasSetNodes = setNodes;
        (window as any).__canvasSetEdges = setEdges;
        (window as any).__canvasGetNodes = () => nodes;
        (window as any).__canvasGetEdges = () => edges;

        return () => {
          delete (window as any).__canvasSetNodes;
          delete (window as any).__canvasSetEdges;
          delete (window as any).__canvasGetNodes;
          delete (window as any).__canvasGetEdges;
        };
      }, [nodes, edges]);

      // Hide empty state when nodes exist
      React.useEffect(() => {
        const emptyState = document.getElementById('canvas-empty-state');
        if (emptyState) {
          emptyState.style.display = nodes.length === 0 ? 'block' : 'none';
        }
      }, [nodes.length]);

      return React.createElement(
        ReactFlow,
        {
          nodes: nodes,
          edges: edges,
          nodeTypes: nodeTypes,
          // Mobile-optimized settings (from 05-RESEARCH.md)
          panOnDrag: [1],           // Single-finger pan on background
          zoomOnPinch: true,        // Pinch-to-zoom
          panOnScroll: false,       // Disable (conflicts with page scroll)
          zoomOnScroll: false,      // Disable (use pinch only)
          zoomOnDoubleClick: false, // Disable (accidental taps on mobile)
          nodesDraggable: true,     // Drag nodes with finger
          nodesConnectable: false,  // Disable drag-to-connect (use dropdown routing in 05-03)
          minZoom: 0.5,
          maxZoom: 2,
          defaultViewport: { x: 0, y: 0, zoom: 1 },
          fitView: true,
          fitViewOptions: { padding: 0.3 },
          proOptions: { hideAttribution: true },
        },
        // Background dots for spatial reference
        React.createElement(Background, {
          gap: 20,
          size: 1,
          color: '#222',
        })
      );
    }

    root.render(React.createElement(CanvasApp));
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCanvas);
  } else {
    initCanvas();
  }
</script>
```

Key design decisions:
- Uses `React.createElement` instead of JSX in the Astro script block (JSX in Astro script tags requires extra tooling)
- Exposes canvas state setters on window for Astro-to-React interop (temporary pattern, upgraded in 05-02)
- React Flow configured for mobile: single-finger pan, pinch zoom, no scroll zoom, no double-click zoom
- nodesConnectable=false (routing is done via dropdown UI in 05-03, not drag-to-connect)
- Background dots at 20px gap for spatial orientation
- Empty state message shown when no nodes on canvas
  </action>
  <verify>
1. portfolio/src/styles/canvas.css exists with dark theme overrides and touch-action rules
2. portfolio/src/components/CompositionCanvas.astro exists
3. React Flow is initialized with mobile-optimized config (panOnDrag=[1], zoomOnPinch=true)
4. Background component renders dot grid
5. Empty state shows "Tap + to add an atom" when no nodes
6. iOS grey rectangle fix applied (-webkit-tap-highlight-color: transparent)
7. Canvas container uses touch-action: none to prevent scroll conflicts
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Canvas CSS created with dark theme, React Flow overrides, iOS touch fix, FAB styles, toast notification, and empty state. CompositionCanvas Astro wrapper created with client-side React Flow initialization, mobile-optimized config (single-finger pan, pinch zoom, no scroll/double-click zoom), custom node types, and background grid. Empty state shown when canvas has no nodes.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create /mobile/compose page and verify canvas renders</name>
  <files>
    portfolio/src/pages/mobile/compose.astro
  </files>
  <action>
Create the composition canvas page and verify React Flow renders correctly.

**Create portfolio/src/pages/mobile/compose.astro:**

```astro
---
import MobileLayout from '../../layouts/MobileLayout.astro';
import CompositionCanvas from '../../components/CompositionCanvas.astro';
---

<MobileLayout title="Compose" showBack={true} backHref="/mobile/gallery">
  <div style="margin: -16px; margin-top: -16px;">
    <CompositionCanvas />
  </div>
</MobileLayout>

<style>
  /* Override MobileLayout padding for full-bleed canvas */
  :global(.mobile-main) {
    padding: 0 !important;
    max-width: none !important;
  }
</style>
```

The compose page:
- Uses MobileLayout for consistent header and offline indicator
- Negative margin removes MobileLayout padding (canvas needs full viewport width)
- Overrides mobile-main padding and max-width for full-bleed canvas
- Back button navigates to gallery

**Add navigation link from gallery:**

Update portfolio/src/pages/mobile/gallery.astro to include a link to the compose page. Add after the search bar:

In the gallery page, add a "Compose" link in the header area or as a secondary action. The simplest approach: add a link to the gallery that navigates to /mobile/compose. This can be a simple text link or a button. The FAB button for adding atoms TO a composition is different and comes in Plan 05-02.

For now, add a minimal navigation link. This can be a bottom nav bar item or a header link. Add a simple bottom navigation with two items: Gallery (current) and Compose.

```html
<!-- Add before closing MobileLayout tag in gallery.astro -->
<nav class="bottom-nav">
  <a href="/mobile/gallery" class="bottom-nav-item active">Gallery</a>
  <a href="/mobile/compose" class="bottom-nav-item">Compose</a>
</nav>
```

And corresponding styles:
```css
.bottom-nav {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  background: #111;
  border-top: 1px solid #222;
  padding-bottom: env(safe-area-inset-bottom, 0);
  z-index: 100;
}

.bottom-nav-item {
  flex: 1;
  padding: 12px;
  text-align: center;
  color: #666;
  font-size: 0.85rem;
  font-weight: 600;
  text-decoration: none;
  min-height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.bottom-nav-item.active {
  color: #6bb5ff;
}

.bottom-nav-item:active {
  background: #1a1a1a;
}
```

**Verify the page:**

1. Build the project: `cd portfolio && npm run build`
2. Preview: `cd portfolio && npm run preview`
3. Navigate to /mobile/compose
4. Verify:
   - React Flow canvas renders (dark background with dot grid)
   - Empty state message visible: "Empty Canvas / Tap + to add an atom"
   - Pinch-to-zoom works (on touch device or Chrome DevTools touch simulation)
   - Single-finger pan works on canvas background
   - Back button navigates to /mobile/gallery
   - No console errors related to React Flow or React
   - Page loads in reasonable time (<2s on simulated 3G)
5. Check bundle size:
   - In Chrome DevTools Network tab, note total JS transferred
   - Target: <1.2MB gzipped total
   - If over: check that React Flow is tree-shaken (named imports only)
  </action>
  <verify>
1. portfolio/src/pages/mobile/compose.astro exists
2. /mobile/compose page renders React Flow canvas
3. Canvas shows dark background with dot grid
4. Empty state message visible
5. Back button navigates to /mobile/gallery
6. Gallery page has navigation link to /mobile/compose
7. `cd portfolio && npm run build` succeeds
8. No React/React Flow console errors
9. Pinch-to-zoom and single-finger pan work (DevTools touch simulation)
10. Total JS bundle < 1.2MB gzipped
  </verify>
  <done>
Compose page created at /mobile/compose with full-viewport React Flow canvas, dark theme, dot grid background, empty state message, and back navigation to gallery. Gallery page updated with bottom navigation bar (Gallery | Compose). Canvas renders with mobile-optimized touch config. Bundle size verified under 1.2MB target.
  </done>
</task>

</tasks>

<verification>
1. `cd portfolio && npm run build` completes without errors
2. React Flow 11.11+ installed with tree-shaken named imports
3. /mobile/compose page renders React Flow canvas in dark theme
4. Canvas shows dot grid background and empty state message
5. Mobile touch config active: single-finger pan, pinch zoom, no scroll zoom
6. Custom AtomNode component renders atom name, type badge, and parameter handles
7. AtomNode uses React.memo for render optimization
8. TypeScript interfaces for Composition, CompositionAtom, ParameterRoute exist
9. Type inference function correctly identifies number/string/boolean/object
10. Routing compatibility function allows same-type only, blocks object routing
11. Gallery has navigation to compose page
12. Back button from compose returns to gallery
13. Total JS bundle < 1.2MB gzipped
14. No iOS grey rectangle artifacts (CSS fix applied)
15. Canvas container has touch-action: none (no scroll conflicts)
</verification>

<success_criteria>
- React Flow renders on mobile without errors (COMP-01 foundation)
- Canvas is touch-optimized: pan with one finger, zoom with pinch (COMP-01 foundation)
- Custom atom nodes display name, type, and parameter handles (COMP-01 foundation)
- Composition data model types are defined and exported (COMP-01, COMP-02, COMP-03 foundation)
- Bundle size stays under 1.2MB gzipped (mobile performance constraint)
- React integration works within Astro via client-side rendering
- Foundation is ready for Plans 05-02 through 05-05 to build upon
</success_criteria>

<output>
After completion, create `.planning/phases/05-composition-canvas-offline-support/05-01-SUMMARY.md`
</output>
