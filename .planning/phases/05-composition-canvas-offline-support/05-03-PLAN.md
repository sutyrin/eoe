---
phase: 05-composition-canvas-offline-support
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
duration: 3h
autonomous: true
files_modified:
  - portfolio/src/components/NodeDetailSheet.astro
  - portfolio/src/scripts/routing-engine.ts
  - portfolio/src/components/CompositionCanvas.astro
  - portfolio/src/pages/mobile/compose.astro
  - portfolio/src/scripts/composition-store.ts
  - portfolio/src/styles/canvas.css

must_haves:
  truths:
    - "Tapping an atom node on the canvas opens a node detail bottom sheet"
    - "Node detail sheet shows atom name, type, and lists all parameters with current values"
    - "Each output parameter has a '+ Route' button that opens a dropdown of compatible target parameters"
    - "Dropdown shows only parameters from OTHER nodes that match the source parameter type"
    - "Selecting a target from dropdown creates a ParameterRoute and renders an edge on the canvas"
    - "Existing routes are shown in the node detail sheet with a delete button per route"
    - "Tapping delete removes the route and the edge from the canvas"
    - "Routes are stored in composition.routes array and persisted to IndexedDB"
    - "Parameter types are color-coded in the dropdown: number=blue, string=green, boolean=orange"
    - "Toast notification appears on route creation: 'Routed [source.param] -> [target.param]'"
  artifacts:
    - path: "portfolio/src/components/NodeDetailSheet.astro"
      provides: "Bottom sheet showing node parameters and routing controls"
      contains: "node-detail"
    - path: "portfolio/src/scripts/routing-engine.ts"
      provides: "Parameter routing logic: compatible params, create/delete routes"
      contains: "findCompatibleTargets"
  key_links:
    - from: "portfolio/src/scripts/routing-engine.ts"
      to: "portfolio/src/scripts/composition-types.ts"
      via: "import { canRoute, ParameterRoute, AtomParameter }"
      pattern: "canRoute"
    - from: "portfolio/src/components/NodeDetailSheet.astro"
      to: "portfolio/src/scripts/routing-engine.ts"
      via: "import { findCompatibleTargets }"
      pattern: "findCompatibleTargets"
    - from: "portfolio/src/pages/mobile/compose.astro"
      to: "portfolio/src/components/NodeDetailSheet.astro"
      via: "import NodeDetailSheet"
      pattern: "NodeDetailSheet"
---

<objective>
Implement the parameter routing UI: tap a node to see its parameters in a bottom sheet, tap "+ Route" to select a compatible target parameter via dropdown, and create visual edges on the canvas. After this plan, users can route parameters between atoms (COMP-02) and create multi-atom combinations (COMP-03).

Purpose: Parameter routing is the core value proposition of the composition canvas. Without it, atoms on the canvas are isolated and the composition is just a visual arrangement. Routing enables the combinatorial creative possibilities that differentiate EOE from a simple gallery.
Output: Working parameter routing via dropdown UI with edge visualization, route CRUD, and type-filtered compatible parameter discovery.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-composition-canvas-offline-support/05-RESEARCH.md
@.planning/phases/05-composition-canvas-offline-support/05-01-PLAN.md
@.planning/phases/05-composition-canvas-offline-support/05-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create routing engine with compatible parameter discovery</name>
  <files>
    portfolio/src/scripts/routing-engine.ts
  </files>
  <action>
Create the routing logic module that determines which parameters can be connected and manages route creation/deletion.

**Create portfolio/src/scripts/routing-engine.ts:**

```typescript
/**
 * Routing engine for parameter connections between atoms.
 *
 * Phase 5 routing rules (from 05-RESEARCH.md):
 * - Strict type matching: number -> number, string -> string, boolean -> boolean
 * - Object types not routable (defer to Phase 6 nested routing)
 * - No range normalization (values pass through as-is)
 * - Circular routes allowed (trust user, warn in Phase 6 preview)
 * - Chaining allowed (A.x -> B.y -> C.z)
 *
 * Phase 6 additions (prepared but not implemented):
 * - Transform functions (normalize, invert)
 * - Range scaling (source range -> target range)
 * - Cycle detection and warnings
 */
import {
  type Composition,
  type ParameterRoute,
  type AtomParameter,
  type CompositionAtom,
  canRoute,
  parseAtomParameters,
  generateId,
} from './composition-types';
import type { AtomMetadata } from './db';

/**
 * Represents a target parameter that a source can route to.
 */
export interface RoutableTarget {
  nodeId: string;
  atomTitle: string;
  paramName: string;
  paramType: AtomParameter['type'];
  currentValue: number | string | boolean | object;
}

/**
 * Find all compatible target parameters for a given source parameter.
 *
 * Rules:
 * - Must be on a DIFFERENT node (no self-routing)
 * - Must be same type (number -> number, etc.)
 * - Object types excluded
 * - Already-routed targets still shown (allows multiple sources to one target)
 */
export function findCompatibleTargets(
  sourceNodeId: string,
  sourceParam: AtomParameter,
  composition: Composition,
  atomsMap: Map<string, AtomMetadata>,
): RoutableTarget[] {
  const targets: RoutableTarget[] = [];

  for (const atom of composition.atoms) {
    // Skip self
    if (atom.nodeId === sourceNodeId) continue;

    const metadata = atomsMap.get(atom.atomSlug);
    if (!metadata) continue;

    const params = parseAtomParameters(metadata.configJson);

    for (const param of params) {
      if (canRoute(sourceParam.value, param.value)) {
        targets.push({
          nodeId: atom.nodeId,
          atomTitle: metadata.title,
          paramName: param.name,
          paramType: param.type,
          currentValue: param.value,
        });
      }
    }
  }

  return targets;
}

/**
 * Create a parameter route and add it to the composition.
 * Returns updated composition.
 */
export function createRoute(
  composition: Composition,
  sourceNodeId: string,
  sourceParam: string,
  targetNodeId: string,
  targetParam: string,
): Composition {
  const route: ParameterRoute = {
    id: generateId(),
    sourceNodeId,
    sourceParam,
    targetNodeId,
    targetParam,
  };

  return {
    ...composition,
    routes: [...composition.routes, route],
    updatedAt: new Date().toISOString(),
  };
}

/**
 * Delete a parameter route from the composition.
 * Returns updated composition.
 */
export function deleteRoute(
  composition: Composition,
  routeId: string,
): Composition {
  return {
    ...composition,
    routes: composition.routes.filter(r => r.id !== routeId),
    updatedAt: new Date().toISOString(),
  };
}

/**
 * Get all routes originating from a specific node.
 */
export function getOutgoingRoutes(
  composition: Composition,
  nodeId: string,
): ParameterRoute[] {
  return composition.routes.filter(r => r.sourceNodeId === nodeId);
}

/**
 * Get all routes targeting a specific node.
 */
export function getIncomingRoutes(
  composition: Composition,
  nodeId: string,
): ParameterRoute[] {
  return composition.routes.filter(r => r.targetNodeId === nodeId);
}

/**
 * Get a human-readable description of a route.
 */
export function describeRoute(
  route: ParameterRoute,
  composition: Composition,
  atomsMap: Map<string, AtomMetadata>,
): string {
  const sourceAtom = composition.atoms.find(a => a.nodeId === route.sourceNodeId);
  const targetAtom = composition.atoms.find(a => a.nodeId === route.targetNodeId);

  const sourceName = sourceAtom
    ? atomsMap.get(sourceAtom.atomSlug)?.title || sourceAtom.atomSlug
    : '???';
  const targetName = targetAtom
    ? atomsMap.get(targetAtom.atomSlug)?.title || targetAtom.atomSlug
    : '???';

  return `${sourceName}.${route.sourceParam} -> ${targetName}.${route.targetParam}`;
}

/**
 * Color for parameter type (used in UI).
 */
export function getParamTypeColor(type: AtomParameter['type']): string {
  const colors: Record<string, string> = {
    number: '#6bb5ff',
    string: '#6bff6b',
    boolean: '#ffb56b',
    object: '#888',
  };
  return colors[type] || '#888';
}
```

This module:
- Discovers compatible target parameters (same type, different node)
- Creates and deletes routes in the composition
- Queries routes by node (incoming/outgoing)
- Provides route description for UI display
- Color-codes parameter types for dropdown UI
  </action>
  <verify>
1. portfolio/src/scripts/routing-engine.ts exists
2. Exports: findCompatibleTargets, createRoute, deleteRoute, getOutgoingRoutes, getIncomingRoutes
3. findCompatibleTargets excludes self-routing and object types
4. canRoute enforces strict type matching
5. Route creation generates UUID for route.id
6. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Routing engine created with compatible parameter discovery (same-type, different-node), route CRUD (create/delete), route queries (incoming/outgoing per node), route description for UI, and parameter type color coding. Strict type matching enforced. Object types excluded.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create node detail bottom sheet with routing UI</name>
  <files>
    portfolio/src/components/NodeDetailSheet.astro
  </files>
  <action>
Create the bottom sheet that appears when a user taps a node on the canvas. It shows the atom's parameters and provides the routing interface.

**Create portfolio/src/components/NodeDetailSheet.astro:**

```astro
---
/**
 * NodeDetailSheet: Bottom sheet for viewing node parameters and creating routes.
 *
 * UI flow:
 * 1. User taps a node on canvas
 * 2. Sheet slides up showing: atom name, parameters, existing routes
 * 3. Each parameter has a "+ Route" button
 * 4. Tapping "+ Route" shows inline dropdown of compatible targets
 * 5. Selecting target creates route and edge
 * 6. Existing routes shown with delete button
 *
 * Events:
 * - Listens: 'eoe:open-node-detail' (nodeId, composition, atomsMap)
 * - Dispatches: 'eoe:create-route' (sourceNodeId, sourceParam, targetNodeId, targetParam)
 * - Dispatches: 'eoe:delete-route' (routeId)
 * - Dispatches: 'eoe:remove-node' (nodeId)
 */
---

<div id="node-detail-backdrop" class="detail-backdrop" style="display: none;">
  <div id="node-detail-sheet" class="detail-sheet">
    <div class="detail-handle"></div>

    <div class="detail-header">
      <div>
        <h3 class="detail-title" id="detail-title"></h3>
        <span class="detail-type" id="detail-type"></span>
      </div>
      <div class="detail-header-actions">
        <button id="detail-remove-btn" class="detail-remove-btn" title="Remove from canvas">Remove</button>
        <button id="detail-close-btn" class="detail-close-btn">&times;</button>
      </div>
    </div>

    <!-- Parameters section -->
    <div class="detail-section">
      <h4 class="detail-section-title">Parameters</h4>
      <div id="detail-params" class="detail-params">
        <!-- Populated dynamically -->
      </div>
    </div>

    <!-- Existing routes section -->
    <div class="detail-section">
      <h4 class="detail-section-title">Active Routes</h4>
      <div id="detail-routes" class="detail-routes">
        <!-- Populated dynamically -->
      </div>
      <div id="detail-no-routes" class="detail-empty">
        No routes yet. Tap "+ Route" on a parameter above.
      </div>
    </div>
  </div>
</div>

<script>
  import {
    findCompatibleTargets,
    getOutgoingRoutes,
    getIncomingRoutes,
    describeRoute,
    getParamTypeColor,
    type RoutableTarget,
  } from '../scripts/routing-engine';
  import {
    parseAtomParameters,
    type Composition,
    type AtomParameter,
  } from '../scripts/composition-types';
  import type { AtomMetadata } from '../scripts/db';

  const backdrop = document.getElementById('node-detail-backdrop')!;
  const sheet = document.getElementById('node-detail-sheet')!;
  const titleEl = document.getElementById('detail-title')!;
  const typeEl = document.getElementById('detail-type')!;
  const paramsEl = document.getElementById('detail-params')!;
  const routesEl = document.getElementById('detail-routes')!;
  const noRoutesEl = document.getElementById('detail-no-routes')!;
  const closeBtn = document.getElementById('detail-close-btn')!;
  const removeBtn = document.getElementById('detail-remove-btn')!;

  let currentNodeId = '';
  let currentComposition: Composition | null = null;
  let currentAtomsMap: Map<string, AtomMetadata> = new Map();

  // Open node detail
  window.addEventListener('eoe:open-node-detail', (e: CustomEvent) => {
    const { nodeId, composition, atomsMap } = e.detail;
    currentNodeId = nodeId;
    currentComposition = composition;
    currentAtomsMap = atomsMap;

    renderNodeDetail();

    backdrop.style.display = 'block';
    requestAnimationFrame(() => {
      backdrop.classList.add('open');
      sheet.classList.add('open');
    });
  });

  // Close
  function closeSheet() {
    backdrop.classList.remove('open');
    sheet.classList.remove('open');
    setTimeout(() => {
      backdrop.style.display = 'none';
      currentNodeId = '';
    }, 300);
  }

  closeBtn.addEventListener('click', closeSheet);
  backdrop.addEventListener('click', (e) => {
    if (e.target === backdrop) closeSheet();
  });

  // Remove node from canvas
  removeBtn.addEventListener('click', () => {
    if (currentNodeId && confirm('Remove this atom from the composition?')) {
      window.dispatchEvent(new CustomEvent('eoe:remove-node', {
        detail: { nodeId: currentNodeId }
      }));
      closeSheet();
    }
  });

  function renderNodeDetail() {
    if (!currentComposition || !currentNodeId) return;

    const compAtom = currentComposition.atoms.find(a => a.nodeId === currentNodeId);
    if (!compAtom) return;

    const metadata = currentAtomsMap.get(compAtom.atomSlug);
    const atomTitle = metadata?.title || compAtom.atomSlug;
    const atomType = metadata?.type || 'unknown';

    // Header
    titleEl.textContent = atomTitle;
    typeEl.textContent = atomType;
    typeEl.style.color = ({
      visual: '#6bb5ff',
      audio: '#ff6b9d',
      'audio-visual': '#b56bff',
    } as Record<string, string>)[atomType] || '#888';

    // Parameters
    const params = metadata ? parseAtomParameters(metadata.configJson) : [];
    const routableParams = params.filter(p => p.type !== 'object');

    if (routableParams.length === 0) {
      paramsEl.innerHTML = '<div class="detail-empty">No routable parameters</div>';
    } else {
      paramsEl.innerHTML = routableParams.map(param => {
        const color = getParamTypeColor(param.type);
        const displayValue = typeof param.value === 'number'
          ? Math.round(param.value * 100) / 100
          : String(param.value);

        return `
          <div class="param-row" data-param-name="${param.name}">
            <div class="param-info">
              <span class="param-dot" style="background: ${color}"></span>
              <span class="param-name">${param.name}</span>
              <span class="param-value">${displayValue}</span>
              <span class="param-type-label" style="color: ${color}">${param.type}</span>
            </div>
            <button class="param-route-btn" data-param="${param.name}" data-param-type="${param.type}">
              + Route
            </button>
            <div class="param-dropdown" data-param="${param.name}" style="display: none;">
              <!-- Populated when + Route is tapped -->
            </div>
          </div>
        `;
      }).join('');

      // Attach "+ Route" handlers
      paramsEl.querySelectorAll('.param-route-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const paramName = (btn as HTMLElement).dataset.param!;
          const param = routableParams.find(p => p.name === paramName);
          if (!param) return;

          toggleDropdown(paramName, param);
        });
      });
    }

    // Existing routes
    renderRoutes();
  }

  function toggleDropdown(paramName: string, param: AtomParameter) {
    const dropdown = paramsEl.querySelector(`.param-dropdown[data-param="${paramName}"]`) as HTMLElement;
    if (!dropdown || !currentComposition) return;

    // Toggle visibility
    const isVisible = dropdown.style.display !== 'none';
    // Close all dropdowns first
    paramsEl.querySelectorAll('.param-dropdown').forEach((d: HTMLElement) => {
      d.style.display = 'none';
    });

    if (isVisible) return; // Was open, now closed

    // Find compatible targets
    const targets = findCompatibleTargets(
      currentNodeId,
      param,
      currentComposition,
      currentAtomsMap,
    );

    if (targets.length === 0) {
      dropdown.innerHTML = '<div class="dropdown-empty">No compatible targets</div>';
    } else {
      dropdown.innerHTML = targets.map(t => {
        const color = getParamTypeColor(t.paramType);
        const displayValue = typeof t.currentValue === 'number'
          ? Math.round((t.currentValue as number) * 100) / 100
          : String(t.currentValue);

        return `
          <button class="dropdown-item"
            data-target-node="${t.nodeId}"
            data-target-param="${t.paramName}">
            <span class="dropdown-atom-name">${t.atomTitle}</span>
            <span class="dropdown-param-name">
              <span class="param-dot" style="background: ${color}"></span>
              ${t.paramName}
              <span class="dropdown-param-value">(${displayValue})</span>
            </span>
          </button>
        `;
      }).join('');

      // Attach selection handlers
      dropdown.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', () => {
          const targetNodeId = (item as HTMLElement).dataset.targetNode!;
          const targetParam = (item as HTMLElement).dataset.targetParam!;

          window.dispatchEvent(new CustomEvent('eoe:create-route', {
            detail: {
              sourceNodeId: currentNodeId,
              sourceParam: paramName,
              targetNodeId,
              targetParam,
            }
          }));

          dropdown.style.display = 'none';

          // Refresh routes display after a tick (allow composition to update)
          setTimeout(() => {
            // Re-read composition from compose page
            window.dispatchEvent(new CustomEvent('eoe:request-composition-state'));
          }, 100);
        });
      });
    }

    dropdown.style.display = 'block';
  }

  // Listen for composition state updates (after route changes)
  window.addEventListener('eoe:composition-updated', (e: CustomEvent) => {
    if (e.detail?.composition) {
      currentComposition = e.detail.composition;
      renderRoutes();
    }
  });

  function renderRoutes() {
    if (!currentComposition || !currentNodeId) return;

    const outgoing = getOutgoingRoutes(currentComposition, currentNodeId);
    const incoming = getIncomingRoutes(currentComposition, currentNodeId);
    const allRoutes = [...outgoing, ...incoming];

    if (allRoutes.length === 0) {
      routesEl.innerHTML = '';
      noRoutesEl.style.display = 'block';
      return;
    }

    noRoutesEl.style.display = 'none';

    routesEl.innerHTML = allRoutes.map(route => {
      const desc = describeRoute(route, currentComposition!, currentAtomsMap);
      const isOutgoing = route.sourceNodeId === currentNodeId;

      return `
        <div class="route-item">
          <span class="route-direction">${isOutgoing ? 'OUT' : 'IN'}</span>
          <span class="route-desc">${desc}</span>
          <button class="route-delete-btn" data-route-id="${route.id}" title="Delete route">&times;</button>
        </div>
      `;
    }).join('');

    // Delete route handlers
    routesEl.querySelectorAll('.route-delete-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const routeId = (btn as HTMLElement).dataset.routeId!;
        window.dispatchEvent(new CustomEvent('eoe:delete-route', {
          detail: { routeId }
        }));

        // Refresh after deletion
        setTimeout(() => {
          window.dispatchEvent(new CustomEvent('eoe:request-composition-state'));
        }, 100);
      });
    });
  }
</script>

<style>
  .detail-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0);
    z-index: 200;
    transition: background 300ms ease;
  }

  .detail-backdrop.open {
    background: rgba(0, 0, 0, 0.5);
  }

  .detail-sheet {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    max-height: 75vh;
    background: #111;
    border-radius: 16px 16px 0 0;
    padding: 0 16px 16px;
    padding-bottom: calc(16px + env(safe-area-inset-bottom, 0));
    transform: translateY(100%);
    transition: transform 300ms ease;
    z-index: 201;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .detail-sheet.open {
    transform: translateY(0);
  }

  .detail-handle {
    width: 32px;
    height: 4px;
    background: #444;
    border-radius: 2px;
    margin: 12px auto 8px;
    flex-shrink: 0;
  }

  .detail-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 8px 0 16px;
    flex-shrink: 0;
  }

  .detail-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #fff;
    margin-bottom: 4px;
  }

  .detail-type {
    font-size: 0.7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .detail-header-actions {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .detail-remove-btn {
    padding: 6px 12px;
    border: 1px solid #ff444440;
    background: none;
    color: #ff6666;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    min-height: 32px;
  }

  .detail-remove-btn:active {
    background: #ff444420;
  }

  .detail-close-btn {
    width: 36px;
    height: 36px;
    border: none;
    background: #222;
    color: #888;
    border-radius: 18px;
    font-size: 1.2rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .detail-section {
    margin-bottom: 20px;
  }

  .detail-section-title {
    font-size: 0.8rem;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    font-weight: 600;
    margin-bottom: 10px;
    padding-bottom: 6px;
    border-bottom: 1px solid #222;
  }

  .detail-empty {
    color: #555;
    font-size: 0.8rem;
    padding: 8px 0;
  }

  /* Parameter rows */
  .param-row {
    padding: 6px 0;
    border-bottom: 1px solid #1a1a1a;
  }

  .param-info {
    display: flex;
    align-items: center;
    gap: 8px;
    min-height: 36px;
  }

  .param-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .param-name {
    color: #ccc;
    font-size: 0.85rem;
    flex: 1;
  }

  .param-value {
    color: #666;
    font-size: 0.8rem;
    font-family: 'SF Mono', monospace;
  }

  .param-type-label {
    font-size: 0.65rem;
    font-weight: 700;
    text-transform: uppercase;
  }

  .param-route-btn {
    display: block;
    width: 100%;
    padding: 8px 12px;
    margin-top: 4px;
    border: 1px dashed #333;
    background: none;
    color: #6bb5ff;
    border-radius: 6px;
    font-size: 0.8rem;
    font-weight: 600;
    cursor: pointer;
    text-align: left;
    min-height: 36px;
  }

  .param-route-btn:active {
    background: #6bb5ff10;
    border-color: #6bb5ff40;
  }

  /* Dropdown for target selection */
  .param-dropdown {
    margin-top: 4px;
    border: 1px solid #333;
    border-radius: 8px;
    background: #1a1a1a;
    overflow: hidden;
  }

  .dropdown-empty {
    padding: 12px;
    color: #555;
    font-size: 0.8rem;
    text-align: center;
  }

  .dropdown-item {
    display: flex;
    flex-direction: column;
    gap: 2px;
    width: 100%;
    padding: 10px 12px;
    border: none;
    background: none;
    color: inherit;
    text-align: left;
    cursor: pointer;
    border-bottom: 1px solid #222;
    min-height: 48px;
    font-family: inherit;
  }

  .dropdown-item:last-child {
    border-bottom: none;
  }

  .dropdown-item:active {
    background: #222;
  }

  .dropdown-atom-name {
    font-size: 0.8rem;
    font-weight: 600;
    color: #fff;
  }

  .dropdown-param-name {
    font-size: 0.75rem;
    color: #aaa;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .dropdown-param-value {
    color: #666;
    font-size: 0.7rem;
  }

  /* Route items */
  .route-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 0;
    border-bottom: 1px solid #1a1a1a;
    min-height: 40px;
  }

  .route-direction {
    font-size: 0.6rem;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 3px;
    letter-spacing: 0.5px;
    flex-shrink: 0;
  }

  .route-direction:contains('OUT') {
    /* Fallback; use JS for actual coloring */
  }

  .route-desc {
    flex: 1;
    font-size: 0.8rem;
    color: #ccc;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .route-delete-btn {
    width: 28px;
    height: 28px;
    border: none;
    background: #1a1a1a;
    color: #888;
    border-radius: 14px;
    font-size: 1rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .route-delete-btn:active {
    background: #ff444440;
    color: #ff4444;
  }
</style>
```
  </action>
  <verify>
1. portfolio/src/components/NodeDetailSheet.astro exists
2. Sheet opens on 'eoe:open-node-detail' event
3. Shows atom name, type badge, and parameter list
4. Each parameter has "+ Route" button
5. Dropdown shows compatible targets with type colors
6. Selecting target dispatches 'eoe:create-route' event
7. Existing routes shown with incoming/outgoing labels and delete buttons
8. Delete button dispatches 'eoe:delete-route' event
9. "Remove from canvas" button dispatches 'eoe:remove-node' event
10. Sheet dismisses on backdrop click or close button
11. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Node detail bottom sheet created with parameter list (type-colored), "+ Route" button per parameter that opens inline dropdown of compatible targets (filtered by type, different-node only), route creation via dropdown selection, existing routes display with incoming/outgoing labels and delete buttons, and "Remove from canvas" action. All actions dispatched as custom events.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire routing events into composition canvas</name>
  <files>
    portfolio/src/pages/mobile/compose.astro
    portfolio/src/components/CompositionCanvas.astro
  </files>
  <action>
Connect the node detail sheet events to the composition state. When the user creates or deletes a route, update the composition and refresh the canvas edges.

**Update portfolio/src/pages/mobile/compose.astro:**

Add the NodeDetailSheet import and event handlers. In the `<script>` section of compose.astro:

1. Import NodeDetailSheet component in the Astro frontmatter:
```astro
import NodeDetailSheet from '../../components/NodeDetailSheet.astro';
```

2. Add the component in the template (after AtomPickerSheet):
```astro
<NodeDetailSheet />
```

3. Add routing imports to the script block:
```typescript
import { createRoute, deleteRoute } from '../../scripts/routing-engine';
import { removeAtomFromComposition } from '../../scripts/composition-store';
```

4. Add event listeners in the compose page script:

```typescript
// Handle node tap -> open detail sheet
window.addEventListener('eoe:node-tapped', (e: CustomEvent) => {
  const { nodeId } = e.detail;
  window.dispatchEvent(new CustomEvent('eoe:open-node-detail', {
    detail: {
      nodeId,
      composition: currentComposition,
      atomsMap,
    }
  }));
});

// Handle route creation
window.addEventListener('eoe:create-route', async (e: CustomEvent) => {
  const { sourceNodeId, sourceParam, targetNodeId, targetParam } = e.detail;

  currentComposition = createRoute(
    currentComposition,
    sourceNodeId,
    sourceParam,
    targetNodeId,
    targetParam,
  );

  await saveComposition(currentComposition);
  await refreshCanvas();

  // Notify detail sheet of updated composition
  window.dispatchEvent(new CustomEvent('eoe:composition-updated', {
    detail: { composition: currentComposition }
  }));

  // Find target atom name for toast
  const targetAtom = currentComposition.atoms.find(a => a.nodeId === targetNodeId);
  const targetName = targetAtom
    ? atomsMap.get(targetAtom.atomSlug)?.title || targetAtom.atomSlug
    : '???';
  showToast(`Routed ${sourceParam} -> ${targetName}.${targetParam}`);
});

// Handle route deletion
window.addEventListener('eoe:delete-route', async (e: CustomEvent) => {
  const { routeId } = e.detail;

  currentComposition = deleteRoute(currentComposition, routeId);
  await saveComposition(currentComposition);
  await refreshCanvas();

  window.dispatchEvent(new CustomEvent('eoe:composition-updated', {
    detail: { composition: currentComposition }
  }));

  showToast('Route deleted');
});

// Handle node removal
window.addEventListener('eoe:remove-node', async (e: CustomEvent) => {
  const { nodeId } = e.detail;

  currentComposition = removeAtomFromComposition(currentComposition, nodeId);
  await saveComposition(currentComposition);
  await refreshCanvas();

  showToast('Atom removed');
});

// Handle composition state request (from detail sheet after changes)
window.addEventListener('eoe:request-composition-state', () => {
  window.dispatchEvent(new CustomEvent('eoe:composition-updated', {
    detail: { composition: currentComposition }
  }));
});
```

**Update portfolio/src/components/CompositionCanvas.astro:**

Add node click handling to dispatch 'eoe:node-tapped' event. In the CanvasApp React component, add `onNodeClick` callback:

```typescript
const onNodeClick = React.useCallback((_event: any, node: any) => {
  window.dispatchEvent(new CustomEvent('eoe:node-tapped', {
    detail: { nodeId: node.id }
  }));
}, []);
```

Pass `onNodeClick` to the ReactFlow createElement props.

This completes the event flow:
1. User taps node on canvas -> React Flow fires onNodeClick -> dispatches 'eoe:node-tapped'
2. compose.astro catches 'eoe:node-tapped' -> dispatches 'eoe:open-node-detail' with composition data
3. NodeDetailSheet opens with parameter list and routing UI
4. User selects target -> dispatches 'eoe:create-route'
5. compose.astro catches 'eoe:create-route' -> creates route in composition -> saves -> refreshes canvas
6. Edge appears on canvas, toast shows confirmation
  </action>
  <verify>
1. Tapping a node on canvas opens the node detail sheet
2. Node detail sheet shows parameters from the tapped node's config.json
3. Tapping "+ Route" shows dropdown of compatible targets
4. Selecting a target creates a route edge on the canvas
5. Edge rendered as smoothstep animated line in blue
6. Toast notification: "Routed [source.param] -> [target.param]"
7. Existing routes shown in detail sheet with delete buttons
8. Deleting a route removes the edge and shows "Route deleted" toast
9. "Remove from canvas" removes the node and all its routes
10. All changes auto-save to IndexedDB
11. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Routing events wired end-to-end: node tap opens detail sheet with composition data, route creation updates composition and canvas edges, route deletion removes edges, node removal cleans up routes. Toast notifications for all actions. Composition auto-saves to IndexedDB after every routing change. Event flow: React Flow onNodeClick -> compose.astro orchestrator -> NodeDetailSheet UI -> routing-engine logic -> canvas refresh.
  </done>
</task>

<task type="auto">
  <name>Task 4: Verify routing end-to-end</name>
  <files>
    (no new files -- verification task)
  </files>
  <action>
Verify the parameter routing workflow works correctly end-to-end.

**Build and serve:**
```bash
cd portfolio && npm run build && npm run preview
```

**Verification checks:**

1. **Create composition with 2+ atoms:**
   - Navigate to /mobile/compose
   - Tap FAB "+" and add first atom
   - Tap FAB "+" and add second atom
   - Verify both nodes appear on canvas with parameters

2. **Create a route:**
   - Tap first atom node
   - Node detail sheet opens with parameter list
   - Tap "+ Route" on a number parameter (e.g., bgHue)
   - Dropdown shows compatible number parameters from second atom
   - Dropdown does NOT show parameters from the same node (no self-routing)
   - Dropdown does NOT show object-type parameters
   - Parameters are color-coded (blue for number)
   - Tap a target parameter
   - Edge appears on canvas (blue smoothstep, animated)
   - Toast: "Routed bgHue -> [target-atom].[param]"

3. **View existing routes:**
   - Tap the source node again
   - Detail sheet shows the route under "Active Routes"
   - Route has "OUT" label and "source.param -> target.param" description
   - Tap target node -> route shows with "IN" label

4. **Delete a route:**
   - In detail sheet, tap the X button on a route
   - Edge disappears from canvas
   - Toast: "Route deleted"

5. **Remove a node:**
   - Tap "Remove" button in detail sheet header
   - Confirm dialog appears
   - Node and all its routes removed from canvas
   - Composition saves to IndexedDB

6. **Persistence:**
   - Reload the page
   - Navigate back to composition
   - All nodes and edges should reload from IndexedDB
   - Route connections preserved

7. **Edge cases:**
   - Add only 1 atom -> "+ Route" shows "No compatible targets" (no other nodes)
   - Add 2 atoms with no matching parameter types -> "+ Route" shows empty
   - String params can only route to string params (type strictness)

8. **Performance:**
   - Parameter routing UI response: <200ms from tap to dropdown visible
   - Route creation: <300ms from selection to edge visible
   - No lag when opening/closing bottom sheets
  </action>
  <verify>
1. Two atoms on canvas with visible parameter handles
2. "+ Route" shows compatible targets from other nodes only
3. Route creation adds edge to canvas with animation
4. Toast notification confirms routing
5. Existing routes visible in node detail sheet
6. Route deletion removes edge from canvas
7. Node removal clears all associated routes
8. Routes persist across page reload
9. Type matching enforced (number->number only)
10. UI responsive (<200ms for dropdown, <300ms for edge creation)
  </verify>
  <done>
Parameter routing verified end-to-end: route creation via dropdown UI works (COMP-02), edges render on canvas, routes persist in IndexedDB, type matching enforced (COMP-03 type safety), route deletion and node removal clean up properly, routes survive page reload. Performance within targets.
  </done>
</task>

</tasks>

<verification>
1. Tapping a node opens detail sheet with parameter list and type indicators
2. "+ Route" button on each parameter opens dropdown of compatible targets
3. Targets filtered by type (number->number, string->string, boolean->boolean)
4. Object-type parameters excluded from routing
5. Self-routing prevented (same node targets not shown)
6. Route creation adds edge to canvas and saves to IndexedDB
7. Edge rendered as animated smoothstep line
8. Toast notification confirms route creation and deletion
9. Existing routes visible in detail sheet with delete buttons
10. Route deletion removes edge and updates IndexedDB
11. Node removal removes node and all associated routes
12. Routes persist across page reload (IndexedDB)
13. Parameter types color-coded in dropdown (blue/green/orange)
14. Routing UI response time < 200ms
</verification>

<success_criteria>
- User can route parameters between atoms via dropdown UI (COMP-02)
- Only compatible parameters shown (strict type matching, no self-routing)
- Routes visualized as edges on canvas (COMP-03 foundation)
- Routes persist in IndexedDB across reloads (MOB-05)
- Route CRUD works: create via dropdown, view in detail sheet, delete via button
- Parameter types color-coded for discoverability
- UI responsive to touch (<200ms)
- Node removal properly cascades to route deletion
</success_criteria>

<output>
After completion, create `.planning/phases/05-composition-canvas-offline-support/05-03-SUMMARY.md`
</output>
