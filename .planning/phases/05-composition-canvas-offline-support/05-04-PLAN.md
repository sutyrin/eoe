---
phase: 05-composition-canvas-offline-support
plan: 04
type: execute
wave: 2
depends_on: ["05-02", "05-03"]
duration: 2h
autonomous: true
files_modified:
  - portfolio/src/scripts/undo-redo.ts
  - portfolio/src/scripts/composition-autosave.ts
  - portfolio/src/pages/mobile/compose.astro
  - portfolio/src/components/CompositionToolbar.astro
  - portfolio/src/styles/canvas.css

must_haves:
  truths:
    - "Undo/redo system tracks composition state changes in a 20-state circular buffer"
    - "Undo button restores previous composition state and refreshes canvas"
    - "Redo button re-applies undone state and refreshes canvas"
    - "State changes tracked: add/remove node, add/remove route, move node, rename composition"
    - "Composition auto-saves to IndexedDB on every change, debounced at 500ms"
    - "Composition name can be edited via tapping the title in the toolbar"
    - "Delete composition action removes from IndexedDB and navigates to compositions list"
    - "Toolbar shows undo/redo buttons and composition name"
    - "Undo/redo buttons are disabled when history is empty"
  artifacts:
    - path: "portfolio/src/scripts/undo-redo.ts"
      provides: "20-state circular buffer for composition state history"
      contains: "UndoRedoManager"
    - path: "portfolio/src/scripts/composition-autosave.ts"
      provides: "Debounced autosave of composition to IndexedDB"
      contains: "scheduleAutosave"
    - path: "portfolio/src/components/CompositionToolbar.astro"
      provides: "Toolbar with undo/redo buttons, composition name, and actions"
      contains: "undo"
  key_links:
    - from: "portfolio/src/scripts/undo-redo.ts"
      to: "portfolio/src/scripts/composition-types.ts"
      via: "import { Composition }"
      pattern: "Composition"
    - from: "portfolio/src/scripts/composition-autosave.ts"
      to: "portfolio/src/scripts/composition-store.ts"
      via: "import { saveComposition }"
      pattern: "saveComposition"
    - from: "portfolio/src/pages/mobile/compose.astro"
      to: "portfolio/src/scripts/undo-redo.ts"
      via: "import { UndoRedoManager }"
      pattern: "UndoRedoManager"
---

<objective>
Implement undo/redo history and autosave for compositions. After this plan, every composition change is tracked in a circular buffer (undo up to 20 steps), compositions auto-save to IndexedDB on change, and users can rename or delete compositions from a toolbar.

Purpose: Without undo/redo, accidental changes on a touch screen are irreversible (fat-finger node deletions, wrong route connections). Without autosave, closing the browser loses work. This plan makes the composition workflow feel safe and reliable on mobile.
Output: Undo/redo buttons in toolbar, debounced autosave, composition rename/delete, and state history tracking.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-composition-canvas-offline-support/05-RESEARCH.md
@.planning/phases/05-composition-canvas-offline-support/05-02-PLAN.md
@.planning/phases/05-composition-canvas-offline-support/05-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create undo/redo manager with circular buffer</name>
  <files>
    portfolio/src/scripts/undo-redo.ts
  </files>
  <action>
Create the undo/redo system that stores composition state snapshots in a fixed-size circular buffer.

**Create portfolio/src/scripts/undo-redo.ts:**

```typescript
/**
 * Undo/Redo manager for composition state.
 *
 * Uses a circular buffer (20 states max) to track composition changes.
 * Each state is a deep clone of the full Composition object.
 *
 * Memory impact (from 05-RESEARCH.md):
 * - Each composition snapshot: ~5-20KB (5 atoms, 50 routes, metadata)
 * - 20 snapshots: ~100-400KB total (well within mobile limits)
 *
 * Design decisions:
 * - Deep clone via JSON.parse(JSON.stringify()) for simplicity
 *   (Composition has no Blobs, Dates, or circular refs)
 * - Push clears redo stack (standard undo/redo behavior)
 * - Buffer overflow discards oldest state
 */
import type { Composition } from './composition-types';

const MAX_HISTORY = 20;

export class UndoRedoManager {
  private history: string[] = [];  // JSON-serialized Composition snapshots
  private cursor: number = -1;     // Points to current state in history

  /**
   * Push a new state onto the history.
   * Clears any redo states (future states after cursor).
   */
  push(composition: Composition): void {
    const snapshot = JSON.stringify(composition);

    // If we're not at the end of history, truncate redo states
    if (this.cursor < this.history.length - 1) {
      this.history = this.history.slice(0, this.cursor + 1);
    }

    // Add new state
    this.history.push(snapshot);

    // Enforce max buffer size (discard oldest)
    if (this.history.length > MAX_HISTORY) {
      this.history.shift();
    } else {
      this.cursor++;
    }

    // Ensure cursor is at end
    this.cursor = this.history.length - 1;
  }

  /**
   * Undo: move cursor back one step.
   * Returns the previous composition state, or null if at beginning.
   */
  undo(): Composition | null {
    if (!this.canUndo()) return null;

    this.cursor--;
    return JSON.parse(this.history[this.cursor]);
  }

  /**
   * Redo: move cursor forward one step.
   * Returns the next composition state, or null if at end.
   */
  redo(): Composition | null {
    if (!this.canRedo()) return null;

    this.cursor++;
    return JSON.parse(this.history[this.cursor]);
  }

  /**
   * Can we undo? (cursor is past the first state)
   */
  canUndo(): boolean {
    return this.cursor > 0;
  }

  /**
   * Can we redo? (cursor is before the last state)
   */
  canRedo(): boolean {
    return this.cursor < this.history.length - 1;
  }

  /**
   * Get current state (at cursor position).
   */
  current(): Composition | null {
    if (this.cursor < 0 || this.cursor >= this.history.length) return null;
    return JSON.parse(this.history[this.cursor]);
  }

  /**
   * Clear all history (e.g., when loading a different composition).
   */
  clear(): void {
    this.history = [];
    this.cursor = -1;
  }

  /**
   * Get history stats for debugging / UI display.
   */
  stats(): { size: number; cursor: number; canUndo: boolean; canRedo: boolean } {
    return {
      size: this.history.length,
      cursor: this.cursor,
      canUndo: this.canUndo(),
      canRedo: this.canRedo(),
    };
  }
}
```

This provides:
- 20-state circular buffer (discards oldest when full)
- Standard undo/redo behavior (pushing new state clears redo stack)
- Deep clone via JSON serialization (safe for Composition objects)
- Memory-efficient (~400KB max for 20 snapshots of 5-atom compositions)
  </action>
  <verify>
1. portfolio/src/scripts/undo-redo.ts exists
2. UndoRedoManager class exported
3. push() adds state, undo()/redo() navigate, canUndo()/canRedo() check
4. Buffer limited to 20 states (MAX_HISTORY constant)
5. Push after undo truncates redo stack
6. clear() resets history
7. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
UndoRedoManager created with 20-state circular buffer, push/undo/redo/clear operations, JSON deep clone for state snapshots, redo stack truncation on new push, and stats for UI display. ~400KB max memory for 20 composition snapshots.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create autosave module with debouncing</name>
  <files>
    portfolio/src/scripts/composition-autosave.ts
  </files>
  <action>
Create the autosave module that persists compositions to IndexedDB on change, debounced to prevent excessive writes during rapid interaction.

**Create portfolio/src/scripts/composition-autosave.ts:**

```typescript
/**
 * Composition autosave with debouncing.
 *
 * Saves composition to IndexedDB after a 500ms quiet period.
 * This prevents excessive writes during rapid interactions
 * (dragging nodes, adjusting routes).
 *
 * From 05-RESEARCH.md: Instant parameter persistence pattern,
 * adapted with debounce for composition-level saves.
 */
import { saveComposition } from './composition-store';
import type { Composition } from './composition-types';

let saveTimer: ReturnType<typeof setTimeout> | null = null;
let pendingComposition: Composition | null = null;

const DEBOUNCE_MS = 500;

/**
 * Schedule a composition save. Debounced: only the last call
 * within DEBOUNCE_MS window actually saves.
 */
export function scheduleAutosave(composition: Composition): void {
  pendingComposition = composition;

  if (saveTimer) {
    clearTimeout(saveTimer);
  }

  saveTimer = setTimeout(async () => {
    if (pendingComposition) {
      try {
        await saveComposition(pendingComposition);
        console.log('[autosave] Saved composition:', pendingComposition.id);

        // Dispatch save event for UI feedback
        window.dispatchEvent(new CustomEvent('eoe:composition-saved', {
          detail: { compositionId: pendingComposition.id }
        }));
      } catch (err) {
        console.error('[autosave] Failed to save:', err);
        window.dispatchEvent(new CustomEvent('eoe:autosave-error', {
          detail: { error: String(err) }
        }));
      }
      pendingComposition = null;
    }
    saveTimer = null;
  }, DEBOUNCE_MS);
}

/**
 * Force immediate save (e.g., before navigating away).
 */
export async function flushAutosave(): Promise<void> {
  if (saveTimer) {
    clearTimeout(saveTimer);
    saveTimer = null;
  }
  if (pendingComposition) {
    await saveComposition(pendingComposition);
    console.log('[autosave] Flushed composition:', pendingComposition.id);
    pendingComposition = null;
  }
}

/**
 * Cancel any pending autosave (e.g., when loading a different composition).
 */
export function cancelAutosave(): void {
  if (saveTimer) {
    clearTimeout(saveTimer);
    saveTimer = null;
  }
  pendingComposition = null;
}
```

This provides:
- 500ms debounced saves (prevents rapid IndexedDB writes during node dragging)
- Force flush for critical moments (page navigation, app backgrounding)
- Cancel for composition switching
- Events for UI feedback (save confirmation, error notification)
  </action>
  <verify>
1. portfolio/src/scripts/composition-autosave.ts exists
2. scheduleAutosave() debounces saves at 500ms
3. flushAutosave() forces immediate save
4. cancelAutosave() clears pending save
5. Dispatches 'eoe:composition-saved' event on successful save
6. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Composition autosave created with 500ms debounce, force flush for navigation, cancel for composition switching, and custom events for UI feedback (saved/error). Prevents excessive IndexedDB writes during rapid touch interactions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create composition toolbar component</name>
  <files>
    portfolio/src/components/CompositionToolbar.astro
    portfolio/src/styles/canvas.css
  </files>
  <action>
Create the toolbar that sits at the top of the canvas with undo/redo buttons, composition name (editable), and action menu.

**Create portfolio/src/components/CompositionToolbar.astro:**

```astro
---
/**
 * CompositionToolbar: Fixed toolbar on composition canvas.
 *
 * Shows:
 * - Undo/Redo buttons (disabled when history empty)
 * - Composition name (tappable to edit)
 * - Save status indicator
 * - Delete composition action
 */
---

<div class="comp-toolbar" id="comp-toolbar">
  <div class="toolbar-left">
    <button id="undo-btn" class="toolbar-btn" disabled title="Undo">
      <span class="toolbar-btn-icon">&#8630;</span>
    </button>
    <button id="redo-btn" class="toolbar-btn" disabled title="Redo">
      <span class="toolbar-btn-icon">&#8631;</span>
    </button>
  </div>

  <div class="toolbar-center">
    <button id="comp-name-btn" class="comp-name-btn" title="Tap to rename">
      <span id="comp-name-text">Untitled</span>
    </button>
    <span id="save-indicator" class="save-indicator" style="display: none;">Saved</span>
  </div>

  <div class="toolbar-right">
    <button id="comp-delete-btn" class="toolbar-btn toolbar-danger" title="Delete composition">
      <span class="toolbar-btn-icon" style="font-size: 0.85rem;">Del</span>
    </button>
  </div>
</div>

<script>
  import { flushAutosave } from '../scripts/composition-autosave';

  const undoBtn = document.getElementById('undo-btn') as HTMLButtonElement;
  const redoBtn = document.getElementById('redo-btn') as HTMLButtonElement;
  const nameBtn = document.getElementById('comp-name-btn')!;
  const nameText = document.getElementById('comp-name-text')!;
  const saveIndicator = document.getElementById('save-indicator')!;
  const deleteBtn = document.getElementById('comp-delete-btn')!;

  // Undo button
  undoBtn.addEventListener('click', () => {
    window.dispatchEvent(new CustomEvent('eoe:undo'));
  });

  // Redo button
  redoBtn.addEventListener('click', () => {
    window.dispatchEvent(new CustomEvent('eoe:redo'));
  });

  // Rename composition
  nameBtn.addEventListener('click', () => {
    const currentName = nameText.textContent || 'Untitled';
    const newName = prompt('Composition name:', currentName);
    if (newName !== null && newName.trim()) {
      window.dispatchEvent(new CustomEvent('eoe:rename-composition', {
        detail: { name: newName.trim() }
      }));
    }
  });

  // Delete composition
  deleteBtn.addEventListener('click', async () => {
    if (confirm('Delete this composition? This cannot be undone.')) {
      await flushAutosave(); // Save any pending changes first
      window.dispatchEvent(new CustomEvent('eoe:delete-composition'));
    }
  });

  // Update undo/redo button states
  window.addEventListener('eoe:history-changed', (e: CustomEvent) => {
    const { canUndo, canRedo } = e.detail;
    undoBtn.disabled = !canUndo;
    redoBtn.disabled = !canRedo;
  });

  // Update composition name
  window.addEventListener('eoe:composition-name-changed', (e: CustomEvent) => {
    nameText.textContent = e.detail.name;
  });

  // Save indicator
  window.addEventListener('eoe:composition-saved', () => {
    saveIndicator.style.display = 'inline';
    saveIndicator.textContent = 'Saved';
    setTimeout(() => {
      saveIndicator.style.display = 'none';
    }, 1500);
  });

  // Flush autosave on page unload
  window.addEventListener('beforeunload', () => {
    flushAutosave();
  });

  // Flush on visibilitychange (mobile: app backgrounded)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      flushAutosave();
    }
  });
</script>

<style>
  .comp-toolbar {
    position: fixed;
    top: 48px; /* Below mobile header */
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 12px;
    background: rgba(10, 10, 10, 0.9);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border-bottom: 1px solid #1a1a1a;
    z-index: 50;
    min-height: 40px;
  }

  .toolbar-left, .toolbar-right {
    display: flex;
    gap: 4px;
  }

  .toolbar-center {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
    justify-content: center;
    min-width: 0;
  }

  .toolbar-btn {
    width: 36px;
    height: 36px;
    border: 1px solid #333;
    background: #1a1a1a;
    color: #ccc;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
  }

  .toolbar-btn:disabled {
    opacity: 0.3;
    pointer-events: none;
  }

  .toolbar-btn:active:not(:disabled) {
    background: #333;
  }

  .toolbar-danger {
    border-color: #ff444440;
    color: #ff6666;
  }

  .toolbar-danger:active {
    background: #ff444420 !important;
  }

  .toolbar-btn-icon {
    font-size: 1.1rem;
    line-height: 1;
  }

  .comp-name-btn {
    border: none;
    background: none;
    color: #fff;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    max-width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-family: inherit;
  }

  .comp-name-btn:active {
    background: #222;
  }

  .save-indicator {
    font-size: 0.7rem;
    color: #6bff6b;
    font-weight: 600;
  }
</style>
```
  </action>
  <verify>
1. portfolio/src/components/CompositionToolbar.astro exists
2. Toolbar shows undo/redo buttons, composition name, and delete button
3. Undo/redo buttons disabled when history empty
4. Tapping name opens prompt() for renaming
5. Delete button confirms and dispatches 'eoe:delete-composition'
6. Save indicator shows briefly after successful save
7. Flush autosave on beforeunload and visibilitychange
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Composition toolbar created with undo/redo buttons (disabled state tracking), editable composition name (tap to rename via prompt), delete button with confirmation, save status indicator, and autosave flush on page unload/background. Semi-transparent backdrop blur for visual hierarchy.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate undo/redo and autosave into compose page</name>
  <files>
    portfolio/src/pages/mobile/compose.astro
    portfolio/src/styles/canvas.css
  </files>
  <action>
Wire the undo/redo manager, autosave, and toolbar into the compose page. Every composition-mutating action should push to history and schedule autosave.

**Update portfolio/src/pages/mobile/compose.astro:**

1. Import the toolbar component:
```astro
import CompositionToolbar from '../../components/CompositionToolbar.astro';
```

2. Add CompositionToolbar to the template (before the canvas):
```astro
<CompositionToolbar />
```

3. Import undo/redo and autosave in the script block:
```typescript
import { UndoRedoManager } from '../../scripts/undo-redo';
import { scheduleAutosave, cancelAutosave } from '../../scripts/composition-autosave';
```

4. Create the UndoRedoManager instance:
```typescript
const history = new UndoRedoManager();
```

5. Create a helper function that pushes state, schedules autosave, and updates toolbar:
```typescript
function commitChange(composition: Composition) {
  currentComposition = composition;
  history.push(composition);
  scheduleAutosave(composition);
  updateHistoryButtons();
}

function updateHistoryButtons() {
  window.dispatchEvent(new CustomEvent('eoe:history-changed', {
    detail: history.stats(),
  }));
}
```

6. Replace all existing `saveComposition(currentComposition)` calls with `commitChange(currentComposition)`:
   - After addAtomToComposition: `commitChange(updated)`
   - After createRoute: `commitChange(currentComposition)`
   - After deleteRoute: `commitChange(currentComposition)`
   - After removeAtomFromComposition: `commitChange(currentComposition)`
   - After node position updates: `commitChange(currentComposition)` (but debounce position changes -- only commit on dragStop, not during drag)

7. Add undo/redo event handlers:
```typescript
// Undo
window.addEventListener('eoe:undo', async () => {
  const prev = history.undo();
  if (prev) {
    currentComposition = prev;
    scheduleAutosave(prev);
    await refreshCanvas();
    updateHistoryButtons();
    showToast('Undone');
  }
});

// Redo
window.addEventListener('eoe:redo', async () => {
  const next = history.redo();
  if (next) {
    currentComposition = next;
    scheduleAutosave(next);
    await refreshCanvas();
    updateHistoryButtons();
    showToast('Redone');
  }
});
```

8. Add rename handler:
```typescript
window.addEventListener('eoe:rename-composition', async (e: CustomEvent) => {
  currentComposition = {
    ...currentComposition,
    name: e.detail.name,
    updatedAt: new Date().toISOString(),
  };
  commitChange(currentComposition);

  window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
    detail: { name: e.detail.name }
  }));
});
```

9. Add delete handler:
```typescript
window.addEventListener('eoe:delete-composition', async () => {
  const { deleteComposition } = await import('../../scripts/composition-store');
  await deleteComposition(currentComposition.id);
  cancelAutosave();
  window.location.href = '/mobile/compositions';
});
```

10. On composition load (in initComposition), push initial state and set name:
```typescript
// After loading composition:
history.clear();
history.push(currentComposition);
updateHistoryButtons();

window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
  detail: { name: currentComposition.name }
}));
```

**Update portfolio/src/styles/canvas.css:**

Adjust canvas container to account for toolbar height:
```css
.canvas-container {
  width: 100%;
  height: calc(100vh - 48px - 40px); /* header (48px) + toolbar (40px) */
  position: relative;
  background: #0a0a0a;
}
```
  </action>
  <verify>
1. Toolbar visible below header on compose page
2. Undo button works: reverts last change and refreshes canvas
3. Redo button works: re-applies undone change
4. Undo/redo buttons disabled when no history available
5. Adding atom pushes to history
6. Creating route pushes to history
7. Deleting route pushes to history
8. Moving nodes pushes to history (on drag stop)
9. Removing nodes pushes to history
10. All changes auto-save to IndexedDB (debounced 500ms)
11. Renaming composition updates toolbar title and saves
12. Deleting composition removes from IndexedDB and navigates to list
13. Save indicator flashes "Saved" briefly after IndexedDB write
14. Autosave flushes on page unload and app backgrounding
15. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Undo/redo and autosave integrated into compose page. Every composition mutation pushes to 20-state circular buffer and schedules 500ms debounced autosave. Toolbar shows undo/redo buttons with disabled states, editable composition name, save indicator, and delete action. Autosave flushes on page unload and visibilitychange. Canvas height adjusted for toolbar.
  </done>
</task>

</tasks>

<verification>
1. Undo/redo works for all composition changes (add node, remove node, add route, delete route, move node)
2. 20-state circular buffer limits memory usage
3. Undo/redo buttons correctly enable/disable based on history
4. Composition auto-saves to IndexedDB (debounced 500ms)
5. Autosave flushes on page unload and app backgrounding
6. Save indicator shows briefly after successful save
7. Composition name editable via toolbar tap
8. Delete composition removes from IndexedDB and navigates to list
9. Loading existing composition initializes history with loaded state
10. New composition starts with initial state in history
11. Canvas height adjusted for toolbar
</verification>

<success_criteria>
- Undo/redo provides safety net for accidental changes on mobile touch
- Autosave prevents data loss (MOB-05 offline persistence)
- Composition rename and delete provide basic management
- Toolbar is compact (40px height) and touch-friendly
- Memory usage within limits (~400KB for 20 history states)
- Save status visible to user (confidence that work is preserved)
- Autosave flushes before page unload (no data loss on navigation)
</success_criteria>

<output>
After completion, create `.planning/phases/05-composition-canvas-offline-support/05-04-SUMMARY.md`
</output>
