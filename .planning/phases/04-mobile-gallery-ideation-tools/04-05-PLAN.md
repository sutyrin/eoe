---
phase: 04-mobile-gallery-ideation-tools
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - portfolio/src/components/AnnotationCanvas.astro
  - portfolio/src/scripts/annotation-engine.ts
  - portfolio/src/pages/mobile/annotate.astro
  - portfolio/src/pages/mobile/[slug].astro
autonomous: true

must_haves:
  truths:
    - "User can upload or take a photo/screenshot on their phone to annotate"
    - "Canvas drawing surface fills the screen width and scales the image proportionally"
    - "User can draw freehand with pen tool using touch gestures"
    - "Pen has a single dark color (black/dark gray) and adjustable stroke width"
    - "User can add text annotations by tapping a location and typing"
    - "Full undo/redo stack: user can undo/redo up to 20 steps"
    - "Undo and redo are accessible via dedicated buttons (not keyboard shortcuts)"
    - "Annotated image saved as WebP to IndexedDB screenshots store"
    - "Screenshot is associated with a specific atom (atomSlug)"
    - "Touch drawing does not interfere with page scroll (touch-action: none on canvas)"
    - "Drawing strokes use quadratic Bezier smoothing (no jagged lines on fast strokes)"
    - "Canvas undo uses ImageData (not base64 toDataURL) to conserve memory"
  artifacts:
    - path: "portfolio/src/components/AnnotationCanvas.astro"
      provides: "Canvas drawing surface with toolbar (pen, text, undo, redo, save)"
      contains: "canvas"
    - path: "portfolio/src/scripts/annotation-engine.ts"
      provides: "Canvas drawing engine with touch handling, stroke smoothing, undo/redo, text tool"
      contains: "AnnotationEngine"
    - path: "portfolio/src/pages/mobile/annotate.astro"
      provides: "Standalone annotation page with image upload and canvas"
      contains: "annotate"
  key_links:
    - from: "portfolio/src/components/AnnotationCanvas.astro"
      to: "portfolio/src/scripts/annotation-engine.ts"
      via: "import { AnnotationEngine }"
      pattern: "AnnotationEngine"
    - from: "portfolio/src/components/AnnotationCanvas.astro"
      to: "portfolio/src/scripts/db.ts"
      via: "import { saveScreenshot }"
      pattern: "saveScreenshot"
    - from: "portfolio/src/pages/mobile/[slug].astro"
      to: "portfolio/src/pages/mobile/annotate.astro"
      via: "link to /mobile/annotate?atom=<slug>"
      pattern: "annotate"
---

<objective>
Create the screenshot annotation tool that lets users upload images on their phone, draw freehand markup and add text labels, then save annotated images to IndexedDB associated with specific atoms. After this plan, users can capture screenshots of inspiration, mark them up with pen drawings and text notes, and store them as part of their atom's creative documentation.

Purpose: Screenshot annotation (IDEA-03) captures visual inspiration on mobile. Users see something interesting, screenshot it, annotate what caught their eye, and associate it with an atom they're working on. Without annotation, screenshots are just raw images without context. The pen and text tools add the "why" to the "what."
Output: AnnotationCanvas component with pen drawing, text placement, undo/redo stack, and WebP export. Standalone annotation page at /mobile/annotate. Integration into atom detail view.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mobile-gallery-ideation-tools/04-CONTEXT.md
@.planning/phases/04-mobile-gallery-ideation-tools/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create annotation engine with drawing, text, and undo/redo</name>
  <files>
    portfolio/src/scripts/annotation-engine.ts
  </files>
  <action>
Create the TypeScript engine that manages all canvas operations: freehand pen drawing with Bezier smoothing, text placement, undo/redo history, stroke width control, and image export.

**Create portfolio/src/scripts/annotation-engine.ts:**

```typescript
/**
 * Annotation engine for screenshot markup.
 *
 * Features:
 * - Freehand pen drawing with quadratic Bezier curve smoothing
 * - Text annotation placement (tap location + typed text)
 * - Undo/redo stack (20 states max, using ImageData not base64)
 * - Adjustable stroke width
 * - Touch and mouse event support
 * - WebP export for storage
 *
 * Architecture:
 * - Canvas is the single drawing surface
 * - Image is drawn first as the background
 * - All markup (strokes, text) is drawn on top
 * - History stores full canvas snapshots (ImageData) for undo/redo
 * - Memory limit: 20 states × ~4MB per 1080p canvas = ~80MB max
 *
 * Anti-patterns avoided:
 * - No base64 toDataURL for history (memory bloat)
 * - No Fabric.js/tldraw (overkill for pen + text)
 * - No touchmove preventDefault unless actively drawing (preserves page scroll)
 */

export type Tool = 'pen' | 'text';

export interface AnnotationOptions {
  canvas: HTMLCanvasElement;
  strokeColor?: string;
  strokeWidth?: number;
  textColor?: string;
  textSize?: number;
}

export interface AnnotationState {
  canUndo: boolean;
  canRedo: boolean;
  tool: Tool;
  strokeWidth: number;
  hasImage: boolean;
}

export type StateCallback = (state: AnnotationState) => void;

export class AnnotationEngine {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;

  // Drawing state
  private isDrawing = false;
  private lastX = 0;
  private lastY = 0;
  private prevX = 0; // For Bezier smoothing (point before last)
  private prevY = 0;
  private strokeCount = 0; // Points in current stroke

  // Tool settings
  private currentTool: Tool = 'pen';
  private strokeColor: string;
  private strokeWidth: number;
  private textColor: string;
  private textSize: number;

  // History
  private history: ImageData[] = [];
  private historyIndex = -1;
  private readonly MAX_HISTORY = 20;

  // State callback
  private onStateChange: StateCallback | null = null;

  // Image loaded flag
  private imageLoaded = false;

  constructor(options: AnnotationOptions) {
    this.canvas = options.canvas;
    this.ctx = this.canvas.getContext('2d', { willReadFrequently: true })!;
    this.strokeColor = options.strokeColor || '#222222';
    this.strokeWidth = options.strokeWidth || 3;
    this.textColor = options.textColor || '#222222';
    this.textSize = options.textSize || 20;

    // Configure canvas for high-DPI screens
    this.canvas.style.touchAction = 'none'; // Prevent scroll while drawing

    this.setupEventListeners();
  }

  // ---- Public API ----

  /**
   * Load an image onto the canvas as the background.
   */
  async loadImage(imageUrl: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';

      img.onload = () => {
        // Scale canvas to fit image while respecting screen width
        const maxWidth = this.canvas.parentElement?.clientWidth || window.innerWidth;
        const scale = Math.min(1, maxWidth / img.width);

        this.canvas.width = Math.floor(img.width * scale);
        this.canvas.height = Math.floor(img.height * scale);

        // Draw image
        this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);

        // Setup drawing context defaults
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        this.imageLoaded = true;

        // Save initial state
        this.saveState();
        this.emitState();

        resolve();
      };

      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = imageUrl;
    });
  }

  /**
   * Load image from a File or Blob.
   */
  async loadImageFromFile(file: File | Blob): Promise<void> {
    const url = URL.createObjectURL(file);
    try {
      await this.loadImage(url);
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  /**
   * Set the active tool.
   */
  setTool(tool: Tool): void {
    this.currentTool = tool;
    this.canvas.style.cursor = tool === 'text' ? 'text' : 'crosshair';
    this.emitState();
  }

  /**
   * Set pen stroke width.
   */
  setStrokeWidth(width: number): void {
    this.strokeWidth = Math.max(1, Math.min(20, width));
    this.emitState();
  }

  /**
   * Undo last action.
   */
  undo(): boolean {
    if (this.historyIndex > 0) {
      this.historyIndex--;
      this.ctx.putImageData(this.history[this.historyIndex], 0, 0);
      this.emitState();
      return true;
    }
    return false;
  }

  /**
   * Redo previously undone action.
   */
  redo(): boolean {
    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++;
      this.ctx.putImageData(this.history[this.historyIndex], 0, 0);
      this.emitState();
      return true;
    }
    return false;
  }

  /**
   * Subscribe to state changes (undo/redo availability, tool, etc.).
   */
  onState(callback: StateCallback): void {
    this.onStateChange = callback;
    this.emitState();
  }

  /**
   * Export the annotated canvas as a WebP Blob.
   */
  async exportAsWebP(quality = 0.9): Promise<Blob> {
    return new Promise((resolve, reject) => {
      this.canvas.toBlob(
        (blob) => {
          if (blob) resolve(blob);
          else reject(new Error('Failed to export canvas'));
        },
        'image/webp',
        quality
      );
    });
  }

  /**
   * Clear all annotations (keep background image).
   * Note: This reloads the image, clearing all markup.
   */
  clearAnnotations(): void {
    if (this.historyIndex >= 0 && this.history.length > 0) {
      // Restore to the first state (original image)
      this.ctx.putImageData(this.history[0], 0, 0);
      this.saveState();
      this.emitState();
    }
  }

  /**
   * Destroy the engine and remove event listeners.
   */
  destroy(): void {
    this.canvas.removeEventListener('touchstart', this.handleTouchStart);
    this.canvas.removeEventListener('touchmove', this.handleTouchMove);
    this.canvas.removeEventListener('touchend', this.handleTouchEnd);
    this.canvas.removeEventListener('mousedown', this.handleMouseDown);
    this.canvas.removeEventListener('mousemove', this.handleMouseMove);
    this.canvas.removeEventListener('mouseup', this.handleMouseUp);
    this.history = [];
  }

  // ---- Private: Event Handling ----

  private setupEventListeners(): void {
    // Bind methods for proper removal
    this.handleTouchStart = this.handleTouchStart.bind(this);
    this.handleTouchMove = this.handleTouchMove.bind(this);
    this.handleTouchEnd = this.handleTouchEnd.bind(this);
    this.handleMouseDown = this.handleMouseDown.bind(this);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.handleMouseUp = this.handleMouseUp.bind(this);

    // Touch events (mobile)
    this.canvas.addEventListener('touchstart', this.handleTouchStart, { passive: false });
    this.canvas.addEventListener('touchmove', this.handleTouchMove, { passive: false });
    this.canvas.addEventListener('touchend', this.handleTouchEnd);

    // Mouse events (desktop testing)
    this.canvas.addEventListener('mousedown', this.handleMouseDown);
    this.canvas.addEventListener('mousemove', this.handleMouseMove);
    this.canvas.addEventListener('mouseup', this.handleMouseUp);
  }

  private handleTouchStart(e: TouchEvent): void {
    e.preventDefault(); // Prevent scroll
    const touch = e.touches[0];
    const pos = this.getTouchPos(touch);

    if (this.currentTool === 'pen') {
      this.beginStroke(pos.x, pos.y);
    } else if (this.currentTool === 'text') {
      this.placeText(pos.x, pos.y);
    }
  }

  private handleTouchMove(e: TouchEvent): void {
    if (!this.isDrawing) return;
    e.preventDefault(); // Only prevent when actively drawing

    const touch = e.touches[0];
    const pos = this.getTouchPos(touch);
    this.continueStroke(pos.x, pos.y);
  }

  private handleTouchEnd(_e: TouchEvent): void {
    if (this.isDrawing) {
      this.endStroke();
    }
  }

  private handleMouseDown(e: MouseEvent): void {
    const pos = this.getMousePos(e);

    if (this.currentTool === 'pen') {
      this.beginStroke(pos.x, pos.y);
    } else if (this.currentTool === 'text') {
      this.placeText(pos.x, pos.y);
    }
  }

  private handleMouseMove(e: MouseEvent): void {
    if (!this.isDrawing) return;
    const pos = this.getMousePos(e);
    this.continueStroke(pos.x, pos.y);
  }

  private handleMouseUp(): void {
    if (this.isDrawing) {
      this.endStroke();
    }
  }

  // ---- Private: Drawing ----

  private beginStroke(x: number, y: number): void {
    this.isDrawing = true;
    this.lastX = x;
    this.lastY = y;
    this.prevX = x;
    this.prevY = y;
    this.strokeCount = 0;

    this.ctx.strokeStyle = this.strokeColor;
    this.ctx.lineWidth = this.strokeWidth;
    this.ctx.lineCap = 'round';
    this.ctx.lineJoin = 'round';

    this.ctx.beginPath();
    this.ctx.moveTo(x, y);
  }

  private continueStroke(x: number, y: number): void {
    this.strokeCount++;

    if (this.strokeCount < 3) {
      // First few points: simple line
      this.ctx.lineTo(x, y);
      this.ctx.stroke();
    } else {
      // Quadratic Bezier smoothing: use last point as control point
      // This produces smooth curves instead of jagged line segments
      const midX = (this.lastX + x) / 2;
      const midY = (this.lastY + y) / 2;

      this.ctx.beginPath();
      this.ctx.moveTo(this.prevX, this.prevY);
      this.ctx.quadraticCurveTo(this.lastX, this.lastY, midX, midY);
      this.ctx.stroke();

      this.prevX = midX;
      this.prevY = midY;
    }

    this.lastX = x;
    this.lastY = y;
  }

  private endStroke(): void {
    // Draw final segment to current position
    this.ctx.lineTo(this.lastX, this.lastY);
    this.ctx.stroke();

    this.isDrawing = false;
    this.saveState();
  }

  private placeText(x: number, y: number): void {
    const text = prompt('Enter annotation text:');
    if (!text) return;

    this.ctx.font = `${this.textSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
    this.ctx.fillStyle = this.textColor;
    this.ctx.textBaseline = 'top';

    // Background for readability
    const metrics = this.ctx.measureText(text);
    const padding = 4;
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
    this.ctx.fillRect(
      x - padding,
      y - padding,
      metrics.width + padding * 2,
      this.textSize + padding * 2
    );

    // Text
    this.ctx.fillStyle = this.textColor;
    this.ctx.fillText(text, x, y);

    this.saveState();
  }

  // ---- Private: Coordinate Helpers ----

  private getTouchPos(touch: Touch): { x: number; y: number } {
    const rect = this.canvas.getBoundingClientRect();
    return {
      x: (touch.clientX - rect.left) * (this.canvas.width / rect.width),
      y: (touch.clientY - rect.top) * (this.canvas.height / rect.height)
    };
  }

  private getMousePos(e: MouseEvent): { x: number; y: number } {
    const rect = this.canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (this.canvas.width / rect.width),
      y: (e.clientY - rect.top) * (this.canvas.height / rect.height)
    };
  }

  // ---- Private: History ----

  private saveState(): void {
    // Discard redo branch
    this.history = this.history.slice(0, this.historyIndex + 1);

    // Save current canvas state
    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    this.history.push(imageData);
    this.historyIndex++;

    // Enforce max history (drop oldest to stay under memory limit)
    if (this.history.length > this.MAX_HISTORY) {
      this.history.shift();
      this.historyIndex--;
    }

    this.emitState();
  }

  private emitState(): void {
    if (this.onStateChange) {
      this.onStateChange({
        canUndo: this.historyIndex > 0,
        canRedo: this.historyIndex < this.history.length - 1,
        tool: this.currentTool,
        strokeWidth: this.strokeWidth,
        hasImage: this.imageLoaded
      });
    }
  }
}
```

Key design decisions:
- Quadratic Bezier smoothing for pen strokes (smooth curves instead of jagged segments)
- ImageData for undo/redo history (not base64 toDataURL — saves ~10x memory)
- 20-state history limit to prevent mobile memory exhaustion
- touch-action: none on canvas to prevent scroll during drawing
- Coordinate scaling handles CSS vs canvas resolution mismatch
- Text tool uses prompt() for simplicity (acceptable for v1.1, richer UI in v1.2)
- Single dark color pen (no color picker — keep v1.1 simple per context decisions)
  </action>
  <verify>
1. portfolio/src/scripts/annotation-engine.ts exists with AnnotationEngine class
2. Class has methods: loadImage, loadImageFromFile, setTool, setStrokeWidth, undo, redo, exportAsWebP, destroy
3. Touch events use getTouchPos with coordinate scaling
4. Bezier smoothing implemented in continueStroke method
5. History uses ImageData (not toDataURL)
6. MAX_HISTORY is 20
7. touch-action: none set on canvas
8. `cd portfolio && npx tsc --noEmit` compiles without errors (or check via build)
  </verify>
  <done>
Annotation engine created with freehand pen drawing (quadratic Bezier smoothing), text placement (with white background for readability), full undo/redo stack (20 states, ImageData-based), adjustable stroke width, touch and mouse support, coordinate scaling for CSS/canvas mismatch, and WebP export. Memory-efficient design: ImageData over base64, capped history.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AnnotationCanvas component and annotation page</name>
  <files>
    portfolio/src/components/AnnotationCanvas.astro
    portfolio/src/pages/mobile/annotate.astro
  </files>
  <action>
Create the UI component and standalone page for screenshot annotation.

**Create portfolio/src/components/AnnotationCanvas.astro:**

```astro
---
/**
 * AnnotationCanvas: Canvas drawing surface with toolbar for screenshot markup.
 * Toolbar: Pen tool, Text tool, Stroke width slider, Undo, Redo, Save.
 */
export interface Props {
  atomSlug: string;
}

const { atomSlug } = Astro.props;
---

<div class="annotation-wrapper" data-atom-slug={atomSlug}>
  <!-- Image upload -->
  <div id="upload-area" class="upload-area">
    <label for="image-input" class="upload-label tap-target">
      <span class="upload-icon">+</span>
      <span class="upload-text">Tap to select image</span>
      <span class="upload-hint">Photo, screenshot, or camera</span>
    </label>
    <input type="file" id="image-input" accept="image/*" capture="environment" style="display: none;" />
  </div>

  <!-- Canvas (hidden until image loaded) -->
  <div id="canvas-area" class="canvas-area" style="display: none;">
    <!-- Toolbar -->
    <div class="annotation-toolbar" id="toolbar">
      <button class="tool-btn active" id="pen-tool" title="Pen">
        <span class="tool-icon">&#9998;</span>
      </button>
      <button class="tool-btn" id="text-tool" title="Text">
        <span class="tool-icon">T</span>
      </button>
      <div class="toolbar-divider"></div>
      <button class="tool-btn" id="undo-btn" title="Undo" disabled>
        <span class="tool-icon">&#8617;</span>
      </button>
      <button class="tool-btn" id="redo-btn" title="Redo" disabled>
        <span class="tool-icon">&#8618;</span>
      </button>
      <div class="toolbar-divider"></div>
      <div class="stroke-width-control">
        <label class="stroke-label">W:</label>
        <input type="range" id="stroke-width" min="1" max="15" value="3" class="stroke-slider" />
      </div>
      <div class="toolbar-spacer"></div>
      <button class="tool-btn save-btn" id="save-btn" title="Save">
        <span class="tool-icon">&#10003;</span>
      </button>
    </div>

    <!-- Canvas -->
    <canvas id="annotation-canvas" class="annotation-canvas"></canvas>
  </div>

  <!-- Save confirmation -->
  <div id="save-confirmation" class="save-confirmation" style="display: none;">
    <span class="save-check">&#10003;</span>
    <span>Annotation saved!</span>
  </div>
</div>

<script>
  import { AnnotationEngine } from '../scripts/annotation-engine';
  import { saveScreenshot } from '../scripts/db';

  async function initAnnotation() {
    const wrapper = document.querySelector('.annotation-wrapper') as HTMLElement;
    if (!wrapper) return;

    const atomSlug = wrapper.dataset.atomSlug || '';

    const uploadArea = document.getElementById('upload-area')!;
    const canvasArea = document.getElementById('canvas-area')!;
    const imageInput = document.getElementById('image-input') as HTMLInputElement;
    const canvas = document.getElementById('annotation-canvas') as HTMLCanvasElement;
    const penTool = document.getElementById('pen-tool')!;
    const textTool = document.getElementById('text-tool')!;
    const undoBtn = document.getElementById('undo-btn') as HTMLButtonElement;
    const redoBtn = document.getElementById('redo-btn') as HTMLButtonElement;
    const strokeWidth = document.getElementById('stroke-width') as HTMLInputElement;
    const saveBtn = document.getElementById('save-btn')!;
    const saveConfirmation = document.getElementById('save-confirmation')!;

    let engine: AnnotationEngine | null = null;

    // Handle image selection
    imageInput.addEventListener('change', async () => {
      const file = imageInput.files?.[0];
      if (!file) return;

      // Create engine and load image
      engine = new AnnotationEngine({
        canvas,
        strokeWidth: parseInt(strokeWidth.value, 10)
      });

      // Subscribe to state changes
      engine.onState((state) => {
        undoBtn.disabled = !state.canUndo;
        redoBtn.disabled = !state.canRedo;

        penTool.classList.toggle('active', state.tool === 'pen');
        textTool.classList.toggle('active', state.tool === 'text');
      });

      try {
        await engine.loadImageFromFile(file);

        // Show canvas, hide upload
        uploadArea.style.display = 'none';
        canvasArea.style.display = 'block';
      } catch (err) {
        alert('Failed to load image. Please try a different file.');
      }
    });

    // Tool selection
    penTool.addEventListener('click', () => engine?.setTool('pen'));
    textTool.addEventListener('click', () => engine?.setTool('text'));

    // Undo/Redo
    undoBtn.addEventListener('click', () => engine?.undo());
    redoBtn.addEventListener('click', () => engine?.redo());

    // Stroke width
    strokeWidth.addEventListener('input', () => {
      engine?.setStrokeWidth(parseInt(strokeWidth.value, 10));
    });

    // Save
    saveBtn.addEventListener('click', async () => {
      if (!engine) return;

      try {
        const imageBlob = await engine.exportAsWebP();

        await saveScreenshot({
          atomSlug,
          imageBlob,
          createdAt: new Date().toISOString(),
          synced: false
        });

        // Show confirmation
        saveConfirmation.style.display = 'flex';
        setTimeout(() => {
          saveConfirmation.style.display = 'none';
        }, 2000);

        // Notify other components
        window.dispatchEvent(new CustomEvent('eoe:screenshots-updated', {
          detail: { atomSlug }
        }));

      } catch (err) {
        alert('Failed to save annotation. Please try again.');
      }
    });
  }

  initAnnotation();
</script>

<style>
  .annotation-wrapper {
    padding: 0;
  }

  .upload-area {
    padding: 32px 16px;
  }

  .upload-label {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 48px 24px;
    border: 2px dashed #333;
    border-radius: 12px;
    cursor: pointer;
    transition: border-color 0.2s;
  }

  .upload-label:active {
    border-color: #6bb5ff;
  }

  .upload-icon {
    font-size: 2rem;
    color: #6bb5ff;
  }

  .upload-text {
    font-size: 1rem;
    font-weight: 600;
    color: #ccc;
  }

  .upload-hint {
    font-size: 0.8rem;
    color: #666;
  }

  .canvas-area {
    position: relative;
  }

  .annotation-toolbar {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 8px 12px;
    background: #111;
    border-bottom: 1px solid #222;
    position: sticky;
    top: 48px; /* Below mobile header */
    z-index: 50;
    flex-wrap: wrap;
  }

  .tool-btn {
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: #1a1a1a;
    color: #888;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1rem;
  }

  .tool-btn:active {
    background: #222;
  }

  .tool-btn.active {
    background: #222;
    color: #6bb5ff;
    border: 1px solid #6bb5ff;
  }

  .tool-btn:disabled {
    opacity: 0.3;
    cursor: default;
  }

  .tool-btn.save-btn {
    background: #1a2a1a;
    color: #6bff6b;
  }

  .tool-btn.save-btn:active {
    background: #2a3a2a;
  }

  .tool-icon {
    font-size: 1.1rem;
  }

  .toolbar-divider {
    width: 1px;
    height: 28px;
    background: #333;
    margin: 0 4px;
  }

  .toolbar-spacer {
    flex: 1;
  }

  .stroke-width-control {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .stroke-label {
    font-size: 0.75rem;
    color: #666;
  }

  .stroke-slider {
    width: 60px;
    height: 44px;
    -webkit-appearance: none;
    background: transparent;
  }

  .stroke-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #6bb5ff;
    margin-top: -8px;
  }

  .stroke-slider::-webkit-slider-runnable-track {
    height: 4px;
    background: #333;
    border-radius: 2px;
  }

  .annotation-canvas {
    display: block;
    width: 100%;
    background: #0a0a0a;
    touch-action: none; /* Prevent scroll while drawing */
  }

  .save-confirmation {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 24px;
    background: #1a2a1a;
    border: 1px solid #336633;
    border-radius: 8px;
    color: #6bff6b;
    font-size: 0.9rem;
    z-index: 200;
  }

  .save-check {
    font-size: 1.2rem;
  }
</style>
```

**Create portfolio/src/pages/mobile/annotate.astro:**

```astro
---
/**
 * Standalone annotation page.
 * Accessed via /mobile/annotate?atom=<slug>
 * Allows uploading an image, annotating it, and saving to the specified atom.
 */
import MobileLayout from '../../layouts/MobileLayout.astro';
import AnnotationCanvas from '../../components/AnnotationCanvas.astro';

// Note: atomSlug is read from URL query param on the client side.
// For SSG, we render a generic page that reads the param at runtime.
---

<MobileLayout title="Annotate" showBack={true} backHref="/mobile/gallery">
  <div id="annotation-page">
    <p id="atom-label" class="atom-label" style="display: none;">
      Annotating for: <strong id="atom-name"></strong>
    </p>

    <div id="annotation-mount"></div>
  </div>

  <script>
    import { AnnotationEngine } from '../../scripts/annotation-engine';
    import { saveScreenshot } from '../../scripts/db';

    // Read atom slug from URL query params
    const params = new URLSearchParams(window.location.search);
    const atomSlug = params.get('atom') || 'unassigned';

    // Show atom label
    const atomLabel = document.getElementById('atom-label');
    const atomName = document.getElementById('atom-name');
    if (atomLabel && atomName && atomSlug !== 'unassigned') {
      atomName.textContent = atomSlug;
      atomLabel.style.display = 'block';
    }

    // Mount the annotation component dynamically
    // Since we need to pass atomSlug at runtime, we create the component structure here
    const mount = document.getElementById('annotation-mount');
    if (mount) {
      // Create upload area
      mount.innerHTML = `
        <div class="annotation-wrapper" data-atom-slug="${atomSlug}">
          <div id="upload-area" class="upload-area">
            <label for="image-input" class="upload-label tap-target">
              <span class="upload-icon" style="font-size: 2rem; color: #6bb5ff;">+</span>
              <span style="font-size: 1rem; font-weight: 600; color: #ccc;">Tap to select image</span>
              <span style="font-size: 0.8rem; color: #666;">Photo, screenshot, or camera</span>
            </label>
            <input type="file" id="image-input" accept="image/*" capture="environment" style="display: none;" />
          </div>
          <div id="canvas-area" style="display: none;">
            <div class="annotation-toolbar" style="display: flex; align-items: center; gap: 4px; padding: 8px 12px; background: #111; border-bottom: 1px solid #222; position: sticky; top: 48px; z-index: 50;">
              <button id="pen-tool" class="tool-btn active" style="min-width:44px;min-height:44px;display:flex;align-items:center;justify-content:center;border:none;background:#222;color:#6bb5ff;border-radius:8px;cursor:pointer;border:1px solid #6bb5ff;">&#9998;</button>
              <button id="text-tool" class="tool-btn" style="min-width:44px;min-height:44px;display:flex;align-items:center;justify-content:center;border:none;background:#1a1a1a;color:#888;border-radius:8px;cursor:pointer;">T</button>
              <div style="width:1px;height:28px;background:#333;margin:0 4px;"></div>
              <button id="undo-btn" class="tool-btn" disabled style="min-width:44px;min-height:44px;display:flex;align-items:center;justify-content:center;border:none;background:#1a1a1a;color:#888;border-radius:8px;cursor:pointer;opacity:0.3;">&#8617;</button>
              <button id="redo-btn" class="tool-btn" disabled style="min-width:44px;min-height:44px;display:flex;align-items:center;justify-content:center;border:none;background:#1a1a1a;color:#888;border-radius:8px;cursor:pointer;opacity:0.3;">&#8618;</button>
              <div style="width:1px;height:28px;background:#333;margin:0 4px;"></div>
              <label style="font-size:0.75rem;color:#666;">W:</label>
              <input type="range" id="stroke-width" min="1" max="15" value="3" style="width:60px;height:44px;" />
              <div style="flex:1;"></div>
              <button id="save-btn" class="tool-btn" style="min-width:44px;min-height:44px;display:flex;align-items:center;justify-content:center;border:none;background:#1a2a1a;color:#6bff6b;border-radius:8px;cursor:pointer;">&#10003;</button>
            </div>
            <canvas id="annotation-canvas" style="display:block;width:100%;background:#0a0a0a;touch-action:none;"></canvas>
          </div>
          <div id="save-confirmation" style="display:none;position:fixed;bottom:80px;left:50%;transform:translateX(-50%);padding:12px 24px;background:#1a2a1a;border:1px solid #336633;border-radius:8px;color:#6bff6b;font-size:0.9rem;z-index:200;">Saved!</div>
        </div>
      `;

      // Initialize
      const imageInput = document.getElementById('image-input') as HTMLInputElement;
      const canvas = document.getElementById('annotation-canvas') as HTMLCanvasElement;
      const uploadArea = document.getElementById('upload-area')!;
      const canvasArea = document.getElementById('canvas-area')!;
      const penTool = document.getElementById('pen-tool')!;
      const textTool = document.getElementById('text-tool')!;
      const undoBtn = document.getElementById('undo-btn') as HTMLButtonElement;
      const redoBtn = document.getElementById('redo-btn') as HTMLButtonElement;
      const strokeWidthInput = document.getElementById('stroke-width') as HTMLInputElement;
      const saveBtn = document.getElementById('save-btn')!;
      const saveConfirmation = document.getElementById('save-confirmation')!;

      let engine: AnnotationEngine | null = null;

      imageInput.addEventListener('change', async () => {
        const file = imageInput.files?.[0];
        if (!file) return;

        engine = new AnnotationEngine({ canvas, strokeWidth: parseInt(strokeWidthInput.value, 10) });

        engine.onState((state) => {
          undoBtn.disabled = !state.canUndo;
          undoBtn.style.opacity = state.canUndo ? '1' : '0.3';
          redoBtn.disabled = !state.canRedo;
          redoBtn.style.opacity = state.canRedo ? '1' : '0.3';
          penTool.style.color = state.tool === 'pen' ? '#6bb5ff' : '#888';
          penTool.style.borderColor = state.tool === 'pen' ? '#6bb5ff' : 'transparent';
          textTool.style.color = state.tool === 'text' ? '#6bb5ff' : '#888';
          textTool.style.borderColor = state.tool === 'text' ? '#6bb5ff' : 'transparent';
        });

        await engine.loadImageFromFile(file);
        uploadArea.style.display = 'none';
        canvasArea.style.display = 'block';
      });

      penTool.addEventListener('click', () => engine?.setTool('pen'));
      textTool.addEventListener('click', () => engine?.setTool('text'));
      undoBtn.addEventListener('click', () => engine?.undo());
      redoBtn.addEventListener('click', () => engine?.redo());
      strokeWidthInput.addEventListener('input', () => engine?.setStrokeWidth(parseInt(strokeWidthInput.value, 10)));

      saveBtn.addEventListener('click', async () => {
        if (!engine) return;
        const imageBlob = await engine.exportAsWebP();
        await saveScreenshot({ atomSlug, imageBlob, createdAt: new Date().toISOString(), synced: false });
        saveConfirmation.style.display = 'flex';
        setTimeout(() => { saveConfirmation.style.display = 'none'; }, 2000);
        window.dispatchEvent(new CustomEvent('eoe:screenshots-updated', { detail: { atomSlug } }));
      });
    }
  </script>

  <style>
    .atom-label {
      font-size: 0.85rem;
      color: #888;
      margin-bottom: 16px;
    }

    .upload-area {
      padding: 32px 0;
    }

    .upload-label {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 48px 24px;
      border: 2px dashed #333;
      border-radius: 12px;
      cursor: pointer;
    }
  </style>
</MobileLayout>
```

**Update portfolio/src/pages/mobile/[slug].astro:**

Add an "Annotate" link in the atom detail view. Add a button/link that navigates to the annotation page with the atom slug:

In the atom header section (after the stage badge), add:
```html
<a href={`/mobile/annotate?atom=${atom.slug}`} class="btn btn-secondary" style="margin-top: 12px; display: inline-flex; font-size: 0.85rem; padding: 8px 16px;">
  Annotate Screenshot
</a>
```

This keeps the annotation tool as a separate page rather than a tab, since annotation is a focused full-screen activity that benefits from its own page (canvas needs maximum screen space).
  </action>
  <verify>
1. portfolio/src/components/AnnotationCanvas.astro exists with toolbar and canvas
2. portfolio/src/pages/mobile/annotate.astro exists with image upload and annotation tools
3. "Annotate Screenshot" link appears in atom detail view
4. /mobile/annotate page loads and shows image upload area
5. After selecting image, canvas appears with toolbar (pen, text, undo, redo, width, save)
6. Toolbar buttons are 44px minimum (touch-friendly)
7. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
AnnotationCanvas component created with image upload (file input with camera capture), drawing canvas, and toolbar (pen, text, undo, redo, stroke width, save). Standalone annotation page at /mobile/annotate?atom=<slug>. Integrated into atom detail view via "Annotate Screenshot" link. Canvas uses touch-action: none to prevent scroll conflicts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify annotation tool end-to-end</name>
  <files>
    (no new files -- verification task)
  </files>
  <action>
Verify the screenshot annotation workflow works correctly on mobile viewport.

**Build and serve:**
```bash
cd portfolio && npm run build && npm run preview
```

**Verification checks:**

1. **Image upload:**
   - Navigate to /mobile/annotate?atom=2026-01-30-my-first-sketch
   - Verify "Annotating for: 2026-01-30-my-first-sketch" label shows
   - Tap "Tap to select image"
   - Select any image file from device
   - Verify canvas appears with image scaled to screen width
   - Verify toolbar appears above canvas

2. **Pen drawing (use mouse on desktop, touch on mobile):**
   - Select pen tool (should be active by default)
   - Draw freehand on the canvas
   - Verify strokes are smooth (Bezier smoothing, no jagged lines)
   - Verify stroke width matches slider value
   - Draw several strokes at different speeds — all should be smooth

3. **Stroke width:**
   - Adjust the width slider (W) from 1 to 15
   - Draw new strokes — verify width changes
   - Verify fine strokes (width=1) and thick strokes (width=15) both work

4. **Text tool:**
   - Tap text tool button (T)
   - Tap on the canvas
   - Verify a prompt dialog appears asking for text
   - Type "test annotation" and confirm
   - Verify text appears at tap location with white background
   - Switch back to pen tool — verify drawing resumes normally

5. **Undo/Redo:**
   - Draw 3 strokes
   - Tap Undo — last stroke disappears
   - Tap Undo again — second stroke disappears
   - Tap Redo — second stroke reappears
   - Draw a new stroke — redo history should be cleared (no redo available)
   - Verify undo button is disabled when at initial state
   - Verify redo button is disabled when no redo history

6. **Save:**
   - Draw some annotations
   - Tap the save button (checkmark)
   - Verify "Saved!" confirmation appears briefly
   - Check DevTools > Application > IndexedDB > eoe-atoms > screenshots
   - Verify a new entry exists with atomSlug, imageBlob, and createdAt

7. **Mobile viewport:**
   - Test at 375px width
   - Verify canvas fills screen width
   - Verify toolbar buttons are easily tappable (44px)
   - Verify drawing with touch is smooth and responsive
   - Verify page doesn't scroll while drawing on canvas

8. **From atom detail:**
   - Navigate to /mobile/2026-01-30-my-first-sketch
   - Verify "Annotate Screenshot" link exists
   - Tap it — verify navigation to /mobile/annotate?atom=2026-01-30-my-first-sketch

Fix any issues. Most likely problems:
- Touch scroll conflict: verify touch-action: none on canvas
- Bezier smoothing producing artifacts on very short strokes (1-2 points)
- Canvas resolution mismatch on high-DPI screens
  </action>
  <verify>
1. Image uploads and displays on canvas correctly
2. Pen drawing produces smooth strokes (Bezier smoothing)
3. Stroke width slider changes pen thickness
4. Text tool places text with background at tapped location
5. Undo removes last action, Redo restores it
6. Undo/Redo buttons enable/disable correctly based on history state
7. Save stores annotated image as WebP in IndexedDB screenshots store
8. "Saved!" confirmation appears briefly
9. Canvas does not conflict with page scroll (touch-action: none)
10. Drawing feels natural on 375px mobile viewport with touch
  </verify>
  <done>
Screenshot annotation verified end-to-end: image upload works, pen drawing with Bezier smoothing feels natural, stroke width adjustable, text annotations placed with background, full undo/redo stack functional, save exports WebP to IndexedDB, canvas doesn't conflict with page scroll, "Annotate Screenshot" link works from atom detail view. IDEA-03 (screenshot annotations) functional.
  </done>
</task>

</tasks>

<verification>
1. Image upload works from file picker (photos, screenshots, camera)
2. Canvas scales image to screen width proportionally
3. Pen drawing with quadratic Bezier smoothing produces smooth strokes
4. Text annotation places readable text at touch location
5. Stroke width adjustable from 1-15 pixels via slider
6. Undo/Redo stack works for up to 20 actions
7. Undo/Redo buttons correctly enable/disable based on history state
8. Save exports annotated image as WebP to IndexedDB screenshots store
9. Canvas touch drawing does not interfere with page scroll
10. Annotation page accessible from atom detail view via link
</verification>

<success_criteria>
- User can upload/capture images and annotate with pen and text (IDEA-03)
- Pen tool produces smooth strokes via quadratic Bezier curve smoothing
- Stroke width adjustable (single dark color per context decisions)
- Full undo/redo stack (up to 20 steps) accessible via tap buttons
- Annotated images saved as WebP to IndexedDB (associated with atom)
- Drawing on canvas does not interfere with page scroll
- All toolbar buttons meet 44px minimum touch target
- Annotation works offline (no network needed for drawing/saving)
- Canvas memory stays bounded (ImageData history, not base64, capped at 20 states)
</success_criteria>

<output>
After completion, create `.planning/phases/04-mobile-gallery-ideation-tools/04-05-SUMMARY.md`
</output>
