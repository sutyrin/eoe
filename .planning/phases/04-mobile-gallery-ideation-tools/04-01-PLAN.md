---
phase: 04-mobile-gallery-ideation-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - portfolio/package.json
  - portfolio/astro.config.mjs
  - portfolio/public/manifest.webmanifest
  - portfolio/src/scripts/db.ts
  - portfolio/src/scripts/pwa-register.ts
  - portfolio/src/scripts/offline-status.ts
  - portfolio/src/components/OfflineIndicator.astro
  - portfolio/src/layouts/MobileLayout.astro
  - portfolio/src/styles/mobile.css
autonomous: true

must_haves:
  truths:
    - "Portfolio site registers a service worker on load via @vite-pwa/astro + Workbox"
    - "Web app manifest includes name, icons, theme_color, start_url, display: standalone"
    - "Service worker precaches app shell (HTML, CSS, JS) and uses runtime caching for atom assets"
    - "IndexedDB schema has stores for atoms (metadata), voiceNotes, screenshots, and configOverrides"
    - "Offline indicator component shows network status (online/offline) in the mobile layout"
    - "MobileLayout.astro provides touch-optimized layout with 44px minimum tap targets"
    - "navigator.storage.estimate() is used to monitor storage quota and warn at 80% usage"
    - "PWA installs to home screen on both iOS and Android"
    - "Site loads and renders gallery page when device is offline (airplane mode)"
  artifacts:
    - path: "portfolio/astro.config.mjs"
      provides: "Astro config with @vite-pwa/astro integration, service worker config, caching strategies"
      contains: "AstroPWA"
    - path: "portfolio/src/scripts/db.ts"
      provides: "IndexedDB schema and CRUD helpers for atoms, voiceNotes, screenshots, configOverrides"
      contains: "openDB"
    - path: "portfolio/src/scripts/pwa-register.ts"
      provides: "Service worker registration and update handling"
      contains: "registerSW"
    - path: "portfolio/src/scripts/offline-status.ts"
      provides: "Online/offline detection and storage quota monitoring"
      contains: "navigator.onLine"
    - path: "portfolio/src/components/OfflineIndicator.astro"
      provides: "Visual indicator for offline mode"
      contains: "offline"
    - path: "portfolio/src/layouts/MobileLayout.astro"
      provides: "Touch-optimized mobile layout extending Base.astro"
      contains: "MobileLayout"
    - path: "portfolio/src/styles/mobile.css"
      provides: "Mobile-specific styles: 44px tap targets, responsive typography, touch-action"
      contains: "min-height: 44px"
  key_links:
    - from: "portfolio/astro.config.mjs"
      to: "@vite-pwa/astro"
      via: "import AstroPWA"
      pattern: "AstroPWA"
    - from: "portfolio/src/scripts/db.ts"
      to: "idb"
      via: "import { openDB }"
      pattern: "openDB"
    - from: "portfolio/src/layouts/MobileLayout.astro"
      to: "portfolio/src/components/OfflineIndicator.astro"
      via: "import OfflineIndicator"
      pattern: "OfflineIndicator"
---

<objective>
Install the PWA foundation for the Engines of Experience portfolio site. After this plan, the Astro-based portfolio installs as a Progressive Web App (home screen icon on iOS/Android), caches its shell for offline use, provides an IndexedDB database for offline data storage, and shows online/offline status. This is the bedrock for all Phase 4 features — gallery, code viewer, voice notes, annotations, and parameter tweaking all depend on this offline-capable foundation.

Purpose: Without PWA infrastructure, no mobile feature can work offline. The service worker, IndexedDB schema, mobile layout, and offline detection must exist before any Phase 4 feature can be built. This plan delivers the infrastructure that Plans 4.2-4.5 build upon.
Output: Working PWA with installable manifest, Workbox service worker, IndexedDB schema, mobile layout, and offline indicator.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mobile-gallery-ideation-tools/04-CONTEXT.md
@.planning/phases/04-mobile-gallery-ideation-tools/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install PWA dependencies and configure @vite-pwa/astro</name>
  <files>
    portfolio/package.json
    portfolio/astro.config.mjs
    portfolio/public/manifest.webmanifest
  </files>
  <action>
Install the PWA toolchain in the portfolio directory. The portfolio uses Astro 5.x with Vite.

**Install dependencies in portfolio/:**
```bash
cd portfolio && npm install @vite-pwa/astro idb
```

`@vite-pwa/astro` provides the Vite PWA plugin adapted for Astro (generates service worker via Workbox, handles manifest). `idb` is Jake Archibald's IndexedDB wrapper (Promise-based API for IndexedDB).

**Update portfolio/astro.config.mjs:**

Replace the entire file with:
```javascript
import { defineConfig } from 'astro/config';
import AstroPWA from '@vite-pwa/astro';

export default defineConfig({
  integrations: [
    AstroPWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico'],
      manifest: {
        name: 'EOE Atoms Gallery',
        short_name: 'EOE',
        description: 'Browse and annotate visual/audio atoms',
        theme_color: '#0a0a0a',
        background_color: '#0a0a0a',
        display: 'standalone',
        scope: '/',
        start_url: '/',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable'
          }
        ]
      },
      workbox: {
        navigateFallback: '/404',
        globPatterns: ['**/*.{css,js,html,svg,png,webp,woff,woff2}'],
        runtimeCaching: [
          {
            // Atom code files - cache first (they rarely change)
            urlPattern: /\/atoms\/.*\.(js|html|json)$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'atom-code',
              expiration: {
                maxEntries: 200,
                maxAgeSeconds: 365 * 24 * 60 * 60
              }
            }
          },
          {
            // Thumbnails - stale while revalidate
            urlPattern: /\/thumbnails\/.*\.webp$/,
            handler: 'StaleWhileRevalidate',
            options: {
              cacheName: 'thumbnails',
              expiration: {
                maxEntries: 200,
                maxAgeSeconds: 30 * 24 * 60 * 60
              }
            }
          },
          {
            // API calls (Whisper transcription) - never cache
            urlPattern: /\/api\/.*/,
            handler: 'NetworkOnly'
          }
        ]
      }
    })
  ],
  vite: {
    server: {
      fs: {
        allow: ['..']
      }
    }
  }
});
```

**Create PWA icons:**

Generate placeholder PWA icons. Create simple solid-color PNG files at the required sizes. The portfolio uses a dark theme (#0a0a0a background), so use a light-on-dark icon. For now, create minimal placeholder PNGs in portfolio/public/:
- `pwa-192x192.png` (192x192 solid dark square with "EOE" text if possible, or a simple colored square)
- `pwa-512x512.png` (512x512 same)

Use a tool like ImageMagick (`convert`) or create programmatically. If ImageMagick is available:
```bash
convert -size 192x192 xc:'#1a1a1a' -fill '#6bb5ff' -gravity center -pointsize 48 -annotate 0 'EOE' portfolio/public/pwa-192x192.png
convert -size 512x512 xc:'#1a1a1a' -fill '#6bb5ff' -gravity center -pointsize 128 -annotate 0 'EOE' portfolio/public/pwa-512x512.png
```

If ImageMagick is not available, create them with Node.js or use any PNG generation method. The exact icon design is not critical for Phase 4 — functional correctness matters more.
  </action>
  <verify>
1. `cd portfolio && npm ls @vite-pwa/astro` shows installed version
2. `cd portfolio && npm ls idb` shows installed version
3. portfolio/astro.config.mjs imports AstroPWA and has workbox configuration
4. portfolio/public/pwa-192x192.png exists and is valid PNG
5. portfolio/public/pwa-512x512.png exists and is valid PNG
6. `cd portfolio && npm run build` completes without errors
7. dist/ output includes sw.js (service worker generated by Workbox)
8. dist/ output includes manifest.webmanifest
  </verify>
  <done>
PWA dependencies installed (@vite-pwa/astro, idb). Astro config updated with Workbox service worker strategies: CacheFirst for atom code, StaleWhileRevalidate for thumbnails, NetworkOnly for API calls. PWA manifest configured with app name, icons, standalone display. Placeholder PWA icons created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IndexedDB schema and storage helpers</name>
  <files>
    portfolio/src/scripts/db.ts
  </files>
  <action>
Create the IndexedDB database schema that all Phase 4 features will use for offline data storage. This uses the `idb` library for a clean Promise-based API.

**Create portfolio/src/scripts/db.ts:**

```typescript
/**
 * IndexedDB schema and CRUD helpers for offline atom data.
 * Uses Jake Archibald's idb wrapper for Promise-based IndexedDB access.
 *
 * Stores:
 * - atoms: Atom metadata (slug, title, date, type, thumbnailUrl)
 * - voiceNotes: Audio recordings with transcripts (Plan 4.4)
 * - screenshots: Annotated screenshot images (Plan 4.5)
 * - configOverrides: Local parameter tweaks (Plan 4.3)
 */
import { openDB, type IDBPDatabase } from 'idb';

const DB_NAME = 'eoe-atoms';
const DB_VERSION = 1;

// ---- Types ----

export interface AtomMetadata {
  slug: string;        // Folder name: "2026-01-30-my-first-sketch"
  title: string;       // Short name: "my-first-sketch"
  date: string;        // "2026-01-30"
  type: string;        // "visual" | "audio" | "audio-visual" | "composition"
  stage: string;       // From NOTES.md: "idea" | "wip" | "done"
  thumbnailUrl: string; // "/thumbnails/2026-01-30-my-first-sketch.webp"
  code: string;        // sketch.js content (for offline code viewing)
  notes: string;       // NOTES.md content (for offline notes viewing)
  configJson: string;  // config.json content (for parameter tweaking)
}

export interface VoiceNote {
  id?: number;
  atomSlug: string;
  audioBlob: Blob;
  mimeType: string;
  transcript: string;
  createdAt: string;  // ISO date string
  synced: boolean;
}

export interface ScreenshotAnnotation {
  id?: number;
  atomSlug: string;
  imageBlob: Blob;
  createdAt: string;  // ISO date string
  synced: boolean;
}

export interface ConfigOverride {
  atomSlug: string;    // Primary key
  overrides: Record<string, number | string | boolean>;
  updatedAt: string;   // ISO date string
  synced: boolean;
}

// ---- Database Init ----

let dbInstance: IDBPDatabase | null = null;

export async function getDB(): Promise<IDBPDatabase> {
  if (dbInstance) return dbInstance;

  dbInstance = await openDB(DB_NAME, DB_VERSION, {
    upgrade(db) {
      // Atoms metadata store
      if (!db.objectStoreNames.contains('atoms')) {
        const atomStore = db.createObjectStore('atoms', { keyPath: 'slug' });
        atomStore.createIndex('date', 'date');
        atomStore.createIndex('type', 'type');
      }

      // Voice notes store
      if (!db.objectStoreNames.contains('voiceNotes')) {
        const voiceStore = db.createObjectStore('voiceNotes', {
          keyPath: 'id',
          autoIncrement: true
        });
        voiceStore.createIndex('atomSlug', 'atomSlug');
        voiceStore.createIndex('synced', 'synced');
      }

      // Screenshots store
      if (!db.objectStoreNames.contains('screenshots')) {
        const screenshotStore = db.createObjectStore('screenshots', {
          keyPath: 'id',
          autoIncrement: true
        });
        screenshotStore.createIndex('atomSlug', 'atomSlug');
        screenshotStore.createIndex('synced', 'synced');
      }

      // Config overrides store (parameter tweaks)
      if (!db.objectStoreNames.contains('configOverrides')) {
        db.createObjectStore('configOverrides', { keyPath: 'atomSlug' });
      }
    }
  });

  return dbInstance;
}

// ---- Atom Metadata CRUD ----

export async function saveAtomMetadata(atom: AtomMetadata): Promise<void> {
  const db = await getDB();
  await db.put('atoms', atom);
}

export async function saveAllAtomMetadata(atoms: AtomMetadata[]): Promise<void> {
  const db = await getDB();
  const tx = db.transaction('atoms', 'readwrite');
  for (const atom of atoms) {
    await tx.store.put(atom);
  }
  await tx.done;
}

export async function getAtom(slug: string): Promise<AtomMetadata | undefined> {
  const db = await getDB();
  return db.get('atoms', slug);
}

export async function getAllAtomsSorted(): Promise<AtomMetadata[]> {
  const db = await getDB();
  const atoms = await db.getAllFromIndex('atoms', 'date');
  return atoms.reverse(); // Most recent first (YYYY-MM-DD sorts correctly)
}

export async function searchAtoms(query: string): Promise<AtomMetadata[]> {
  const atoms = await getAllAtomsSorted();
  const q = query.toLowerCase();
  return atoms.filter(a =>
    a.title.toLowerCase().includes(q) || a.slug.toLowerCase().includes(q)
  );
}

// ---- Voice Notes CRUD ----

export async function saveVoiceNote(note: Omit<VoiceNote, 'id'>): Promise<number> {
  const db = await getDB();
  return db.add('voiceNotes', { ...note, synced: false }) as Promise<number>;
}

export async function getVoiceNotesForAtom(atomSlug: string): Promise<VoiceNote[]> {
  const db = await getDB();
  return db.getAllFromIndex('voiceNotes', 'atomSlug', atomSlug);
}

export async function updateVoiceNoteTranscript(id: number, transcript: string): Promise<void> {
  const db = await getDB();
  const note = await db.get('voiceNotes', id);
  if (note) {
    note.transcript = transcript;
    await db.put('voiceNotes', note);
  }
}

// ---- Screenshot CRUD ----

export async function saveScreenshot(screenshot: Omit<ScreenshotAnnotation, 'id'>): Promise<number> {
  const db = await getDB();
  return db.add('screenshots', { ...screenshot, synced: false }) as Promise<number>;
}

export async function getScreenshotsForAtom(atomSlug: string): Promise<ScreenshotAnnotation[]> {
  const db = await getDB();
  return db.getAllFromIndex('screenshots', 'atomSlug', atomSlug);
}

// ---- Config Overrides CRUD ----

export async function saveConfigOverride(override: ConfigOverride): Promise<void> {
  const db = await getDB();
  await db.put('configOverrides', { ...override, synced: false });
}

export async function getConfigOverride(atomSlug: string): Promise<ConfigOverride | undefined> {
  const db = await getDB();
  return db.get('configOverrides', atomSlug);
}

// ---- Storage Quota ----

export async function getStorageEstimate(): Promise<{ usage: number; quota: number; percentUsed: number }> {
  if (navigator.storage && navigator.storage.estimate) {
    const estimate = await navigator.storage.estimate();
    const usage = estimate.usage || 0;
    const quota = estimate.quota || 0;
    const percentUsed = quota > 0 ? Math.round((usage / quota) * 100) : 0;
    return { usage, quota, percentUsed };
  }
  return { usage: 0, quota: 0, percentUsed: 0 };
}
```

This schema supports all Phase 4 features:
- `atoms` store: Gallery browsing (Plan 4.2) and offline code/notes viewing
- `voiceNotes` store: Voice note recordings and transcripts (Plan 4.4)
- `screenshots` store: Annotated screenshot images (Plan 4.5)
- `configOverrides` store: Parameter tweaks (Plan 4.3)

All stores include `synced` flags for future Phase 6 sync integration.
  </action>
  <verify>
1. portfolio/src/scripts/db.ts exists with all 4 object stores defined
2. TypeScript types are exported for AtomMetadata, VoiceNote, ScreenshotAnnotation, ConfigOverride
3. CRUD functions exist for each store (save, get, getAll)
4. getStorageEstimate() function exists for quota monitoring
5. `cd portfolio && npx tsc --noEmit src/scripts/db.ts` compiles without errors (or check via build)
  </verify>
  <done>
IndexedDB schema created with 4 stores: atoms (metadata + code + notes), voiceNotes (audio blobs + transcripts), screenshots (annotated images), configOverrides (parameter tweaks). All stores have synced flags for Phase 6. CRUD helpers exported for all stores. Storage quota monitoring via navigator.storage.estimate().
  </done>
</task>

<task type="auto">
  <name>Task 3: Create mobile layout, offline indicator, and PWA registration</name>
  <files>
    portfolio/src/layouts/MobileLayout.astro
    portfolio/src/components/OfflineIndicator.astro
    portfolio/src/scripts/pwa-register.ts
    portfolio/src/scripts/offline-status.ts
    portfolio/src/styles/mobile.css
  </files>
  <action>
Create the mobile-specific layout and offline infrastructure that all Phase 4 pages will use.

**Create portfolio/src/scripts/pwa-register.ts:**

```typescript
/**
 * PWA service worker registration.
 * @vite-pwa/astro auto-generates the service worker, this script
 * handles the registration lifecycle (install, update, activate).
 */

// @vite-pwa/astro provides a virtual module for registration
// This will be auto-handled by the plugin, but we expose a manual hook
// for showing update-available notifications.

export function setupPWA() {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      // Service worker is auto-registered by @vite-pwa/astro
      // Listen for updates
      navigator.serviceWorker.ready.then((registration) => {
        console.log('[PWA] Service worker active');

        // Check for updates periodically (every hour)
        setInterval(() => {
          registration.update();
        }, 60 * 60 * 1000);
      });

      navigator.serviceWorker.addEventListener('controllerchange', () => {
        console.log('[PWA] New service worker activated');
      });
    });
  }
}
```

**Create portfolio/src/scripts/offline-status.ts:**

```typescript
/**
 * Online/offline detection and storage quota monitoring.
 * Dispatches custom events that OfflineIndicator.astro listens to.
 */
import { getStorageEstimate } from './db';

export interface OfflineState {
  isOnline: boolean;
  storagePercent: number;
  storageWarning: boolean; // true if >80% used
}

const STORAGE_WARNING_THRESHOLD = 80; // percent

export function setupOfflineDetection() {
  // Dispatch initial state
  updateStatus();

  // Listen for network changes
  window.addEventListener('online', updateStatus);
  window.addEventListener('offline', updateStatus);

  // Check storage quota every 5 minutes
  setInterval(checkStorage, 5 * 60 * 1000);
  checkStorage(); // Initial check
}

function updateStatus() {
  const event = new CustomEvent('eoe:offline-status', {
    detail: { isOnline: navigator.onLine }
  });
  window.dispatchEvent(event);
}

async function checkStorage() {
  const estimate = await getStorageEstimate();
  const event = new CustomEvent('eoe:storage-status', {
    detail: {
      percentUsed: estimate.percentUsed,
      warning: estimate.percentUsed > STORAGE_WARNING_THRESHOLD,
      usageMB: Math.round(estimate.usage / (1024 * 1024)),
      quotaMB: Math.round(estimate.quota / (1024 * 1024))
    }
  });
  window.dispatchEvent(event);
}
```

**Create portfolio/src/components/OfflineIndicator.astro:**

```astro
---
// OfflineIndicator: Shows a small banner when device is offline
// Listens for eoe:offline-status custom events from offline-status.ts
---
<div id="offline-indicator" class="offline-indicator" style="display: none;">
  <span class="offline-dot"></span>
  <span class="offline-text">Offline</span>
</div>

<div id="storage-warning" class="storage-warning" style="display: none;">
  <span class="storage-text">Storage nearly full</span>
</div>

<script>
  // Listen for offline status changes
  window.addEventListener('eoe:offline-status', (e: CustomEvent) => {
    const indicator = document.getElementById('offline-indicator');
    if (indicator) {
      indicator.style.display = e.detail.isOnline ? 'none' : 'flex';
    }
  });

  // Listen for storage warnings
  window.addEventListener('eoe:storage-status', (e: CustomEvent) => {
    const warning = document.getElementById('storage-warning');
    if (warning) {
      warning.style.display = e.detail.warning ? 'flex' : 'none';
      const text = warning.querySelector('.storage-text');
      if (text) {
        text.textContent = `Storage: ${e.detail.usageMB}MB / ${e.detail.quotaMB}MB`;
      }
    }
  });

  // Show initial offline state immediately (don't wait for event)
  if (!navigator.onLine) {
    const indicator = document.getElementById('offline-indicator');
    if (indicator) indicator.style.display = 'flex';
  }
</script>

<style>
  .offline-indicator {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 8px;
    background: #333;
    color: #fff;
    font-size: 0.8rem;
    z-index: 1000;
  }

  .offline-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #ff6b6b;
  }

  .storage-warning {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px;
    background: #553300;
    color: #ffcc00;
    font-size: 0.75rem;
    z-index: 1000;
  }
</style>
```

**Create portfolio/src/styles/mobile.css:**

```css
/* Mobile-specific styles for PWA companion app */

/* Touch-friendly tap targets: minimum 44px as per Apple HIG */
.tap-target {
  min-height: 44px;
  min-width: 44px;
  display: flex;
  align-items: center;
}

/* Responsive typography */
.mobile-body {
  font-size: 16px; /* Prevents iOS zoom on input focus */
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
}

/* Safe area insets for notched phones */
.mobile-container {
  padding-left: env(safe-area-inset-left, 0);
  padding-right: env(safe-area-inset-right, 0);
  padding-bottom: env(safe-area-inset-bottom, 0);
}

/* Smooth scrolling */
.scroll-container {
  -webkit-overflow-scrolling: touch;
  overflow-y: auto;
}

/* Disable pull-to-refresh on PWA (prevents accidental navigation) */
html {
  overscroll-behavior-y: contain;
}

/* Prevent text selection during drawing */
.no-select {
  -webkit-user-select: none;
  user-select: none;
}

/* Search bar styling */
.search-bar {
  width: 100%;
  padding: 12px 16px;
  font-size: 16px; /* Prevents iOS zoom */
  background: #1a1a1a;
  border: 1px solid #333;
  border-radius: 8px;
  color: #e0e0e0;
  outline: none;
}

.search-bar:focus {
  border-color: #6bb5ff;
}

/* List item for gallery */
.list-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  min-height: 64px;
  border-bottom: 1px solid #1a1a1a;
  text-decoration: none;
  color: inherit;
}

.list-item:active {
  background: #1a1a1a;
}

/* Button styles */
.btn {
  min-height: 44px;
  padding: 10px 20px;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.btn-primary {
  background: #6bb5ff;
  color: #0a0a0a;
}

.btn-secondary {
  background: #333;
  color: #e0e0e0;
}

.btn-danger {
  background: #ff4444;
  color: #fff;
}

.btn:active {
  opacity: 0.8;
}

/* Slider control for parameters */
.slider-control {
  width: 100%;
  padding: 8px 0;
}

.slider-control input[type="range"] {
  width: 100%;
  height: 44px; /* Touch-friendly */
  -webkit-appearance: none;
  background: transparent;
}

.slider-control input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: #6bb5ff;
  cursor: pointer;
}

.slider-control input[type="range"]::-webkit-slider-runnable-track {
  height: 4px;
  background: #333;
  border-radius: 2px;
}
```

**Create portfolio/src/layouts/MobileLayout.astro:**

```astro
---
import OfflineIndicator from '../components/OfflineIndicator.astro';
import '../styles/mobile.css';

export interface Props {
  title: string;
  showBack?: boolean;
  backHref?: string;
}

const { title, showBack = false, backHref = '/' } = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0a0a">
  <title>{title} - EOE</title>
  <style is:global>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
      font-size: 16px;
      -webkit-text-size-adjust: 100%;
      overscroll-behavior-y: contain;
    }
    a { color: #6bb5ff; text-decoration: none; }
    a:active { opacity: 0.7; }
  </style>
</head>
<body class="mobile-body">
  <OfflineIndicator />

  <header class="mobile-header">
    {showBack && (
      <a href={backHref} class="back-btn tap-target">
        <span>&larr;</span>
      </a>
    )}
    <span class="header-title">{title}</span>
  </header>

  <main class="mobile-main mobile-container scroll-container">
    <slot />
  </main>

  <script>
    import { setupPWA } from '../scripts/pwa-register';
    import { setupOfflineDetection } from '../scripts/offline-status';

    setupPWA();
    setupOfflineDetection();
  </script>

  <style>
    .mobile-header {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: #0a0a0a;
      border-bottom: 1px solid #1a1a1a;
      z-index: 100;
      min-height: 48px;
    }

    .back-btn {
      color: #6bb5ff;
      font-size: 1.2rem;
    }

    .header-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #fff;
    }

    .mobile-main {
      padding: 16px;
      padding-bottom: calc(16px + env(safe-area-inset-bottom, 0));
      max-width: 600px;
      margin: 0 auto;
    }
  </style>
</body>
</html>
```

Note: MobileLayout uses a system font stack (-apple-system, etc.) instead of the monospace font from Base.astro. Mobile companion needs readability over code aesthetic. The layout includes safe-area-insets for notched phones, sticky header, and the offline indicator.
  </action>
  <verify>
1. portfolio/src/layouts/MobileLayout.astro exists with OfflineIndicator import
2. portfolio/src/components/OfflineIndicator.astro exists with event listeners
3. portfolio/src/scripts/pwa-register.ts exists with setupPWA function
4. portfolio/src/scripts/offline-status.ts exists with setupOfflineDetection function
5. portfolio/src/styles/mobile.css exists with tap target and slider styles
6. `cd portfolio && npm run build` completes without errors
7. Build output includes all new components in the generated pages
  </verify>
  <done>
Mobile layout created with sticky header, offline indicator, safe-area insets, and system font stack. OfflineIndicator shows banner when offline and warns when storage is >80% full. PWA registration handles service worker lifecycle and periodic update checks. Mobile CSS provides 44px tap targets, touch-friendly sliders, responsive search bar, and list item styles. All Phase 4 pages will use MobileLayout.astro as their base layout.
  </done>
</task>

<task type="auto">
  <name>Task 4: Verify PWA foundation end-to-end</name>
  <files>
    (no new files -- verification task)
  </files>
  <action>
Verify the PWA infrastructure works correctly before other plans build on it.

**Build and serve:**
```bash
cd portfolio && npm run build && npm run preview
```

**Verification checks:**

1. **Service worker registration:**
   - Open browser DevTools > Application > Service Workers
   - Verify a service worker is registered and active
   - Verify "Source" points to generated sw.js

2. **Manifest:**
   - DevTools > Application > Manifest
   - Verify name is "EOE Atoms Gallery", display is "standalone"
   - Verify icons are listed (192x192 and 512x512)

3. **Offline behavior:**
   - DevTools > Network tab > check "Offline" checkbox
   - Reload the page
   - Verify the app shell loads (HTML, CSS render)
   - Verify the OfflineIndicator shows "Offline" banner

4. **Cache storage:**
   - DevTools > Application > Cache Storage
   - Verify caches exist for workbox-precache and runtime caches

5. **IndexedDB:**
   - DevTools > Application > IndexedDB
   - Verify "eoe-atoms" database exists with 4 object stores: atoms, voiceNotes, screenshots, configOverrides

6. **Mobile layout:**
   - Use Chrome DevTools responsive mode (iPhone SE or similar 375px width)
   - Verify the gallery page renders correctly at mobile width
   - Verify header is sticky on scroll
   - Verify text is readable (16px base font)

7. **Lighthouse PWA audit:**
   - Run Lighthouse with PWA category
   - Target: all PWA criteria pass (installable, has manifest, has service worker, works offline)

If any check fails, fix the issue before marking this task complete. The most likely failure is the service worker not generating — check that @vite-pwa/astro is properly integrated in astro.config.mjs.
  </action>
  <verify>
1. Service worker is registered and active after build+preview
2. Manifest is valid with name, icons, display: standalone
3. App shell loads when network is offline
4. OfflineIndicator appears when offline, hides when online
5. IndexedDB "eoe-atoms" database has 4 stores
6. Mobile responsive layout renders correctly at 375px width
7. Lighthouse PWA audit passes core criteria
  </verify>
  <done>
PWA foundation verified end-to-end: service worker active, manifest valid, offline shell loads, IndexedDB schema initializes with 4 stores, offline indicator shows/hides on network change, mobile layout responsive, Lighthouse PWA audit passes. Foundation ready for Plans 4.2-4.5.
  </done>
</task>

</tasks>

<verification>
1. `cd portfolio && npm run build` completes without errors
2. Build output includes sw.js (Workbox service worker)
3. Build output includes manifest.webmanifest with PWA metadata
4. App shell loads when device is offline
5. IndexedDB "eoe-atoms" database initializes with atoms, voiceNotes, screenshots, configOverrides stores
6. OfflineIndicator shows "Offline" banner when network disconnected
7. Storage quota monitoring dispatches warning events at >80% usage
8. MobileLayout renders correctly on 375px (iPhone SE) viewport
9. All tap targets meet 44px minimum height
10. Lighthouse PWA audit passes core installability criteria
</verification>

<success_criteria>
- Portfolio site is a valid installable PWA (MOB-05 foundation)
- Service worker caches app shell and atom assets with appropriate strategies (CacheFirst for code, StaleWhileRevalidate for thumbnails)
- IndexedDB schema supports all Phase 4 data needs (atoms, voiceNotes, screenshots, configOverrides)
- Offline detection works reliably (navigator.onLine + event listeners)
- Storage quota monitoring warns at 80% usage to prevent iOS eviction surprises
- Mobile layout provides 44px tap targets, safe-area insets, sticky header, and readable typography
- All Phase 4 plans (4.2-4.5) can build on this foundation without infrastructure changes
</success_criteria>

<output>
After completion, create `.planning/phases/04-mobile-gallery-ideation-tools/04-01-SUMMARY.md`
</output>
