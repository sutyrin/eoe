---
phase: 04-mobile-gallery-ideation-tools
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - portfolio/src/components/ParamTweaker.astro
  - portfolio/src/scripts/param-engine.ts
  - portfolio/src/pages/mobile/[slug].astro
autonomous: true

must_haves:
  truths:
    - "User can see sliders and number inputs for each controller parameter in config.json"
    - "Moving a slider updates the displayed value instantly"
    - "Parameter changes are saved immediately to local IndexedDB configOverrides store"
    - "Parameters are rendered from the config.json 'controllers' object"
    - "Each slider has a label showing parameter name and current numeric value"
    - "Number inputs accept manual typed values within reasonable bounds"
    - "Tweaked parameters persist across page reloads (read from IndexedDB on load)"
    - "A reset button restores original config.json values"
    - "Message indicates 'Preview on desktop' since live preview is deferred to Phase 5"
  artifacts:
    - path: "portfolio/src/components/ParamTweaker.astro"
      provides: "Slider and number input UI for config.json controller parameters"
      contains: "input[type=range]"
    - path: "portfolio/src/scripts/param-engine.ts"
      provides: "Config parsing, override management, and persistence logic"
      contains: "saveConfigOverride"
  key_links:
    - from: "portfolio/src/pages/mobile/[slug].astro"
      to: "portfolio/src/components/ParamTweaker.astro"
      via: "import ParamTweaker"
      pattern: "ParamTweaker"
    - from: "portfolio/src/scripts/param-engine.ts"
      to: "portfolio/src/scripts/db.ts"
      via: "import { saveConfigOverride, getConfigOverride }"
      pattern: "saveConfigOverride"
---

<objective>
Create the parameter tweaking UI that lets users adjust atom config.json values via sliders and number inputs on mobile. After this plan, users can open any atom's detail view, see sliders for each parameter in config.json's "controllers" object, adjust values with instant visual feedback (slider position + numeric display), and have changes persist in IndexedDB across page reloads. Live visual preview is deferred to Phase 5 — this plan focuses on the parameter editing and persistence workflow.

Purpose: Parameter tweaking (MOB-04) is the primary creative interaction on mobile. Users can explore variations of their atoms by adjusting sliders, then see the results when they switch to desktop. Without this, mobile is purely passive (viewing only). Tweaking makes mobile a creative tool.
Output: ParamTweaker component with sliders/number inputs, param-engine.ts for config parsing and persistence, integration into the atom detail view.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mobile-gallery-ideation-tools/04-CONTEXT.md
@.planning/phases/04-mobile-gallery-ideation-tools/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parameter engine for config parsing and persistence</name>
  <files>
    portfolio/src/scripts/param-engine.ts
  </files>
  <action>
Create the TypeScript module that handles reading config.json controllers, managing overrides, and persisting to IndexedDB.

**Create portfolio/src/scripts/param-engine.ts:**

```typescript
/**
 * Parameter engine for config.json controller values.
 *
 * Responsibilities:
 * - Parse config.json "controllers" object into slider definitions
 * - Load overrides from IndexedDB (previously tweaked values)
 * - Save overrides to IndexedDB on change
 * - Compute effective values (original + override merge)
 * - Determine slider ranges from original values (heuristic)
 *
 * Config.json format (from existing atoms):
 * {
 *   "controllers": {
 *     "bgHue": 200,
 *     "shapeHue": 30,
 *     "size": 100,
 *     "speed": 1,
 *     "noiseScale": 0.01
 *   }
 * }
 */
import { saveConfigOverride, getConfigOverride, type ConfigOverride } from './db';

export interface ParamDef {
  name: string;
  originalValue: number;
  currentValue: number;
  min: number;
  max: number;
  step: number;
}

/**
 * Parse controllers object from config.json into parameter definitions.
 * Heuristic for ranges:
 * - Hue values (name contains "hue"): 0-360, step 1
 * - Scale values (name contains "scale"): 0 to 10x original, step = original/100
 * - Speed values (name contains "speed"): 0 to 10x original, step = original/100
 * - Size values (name contains "size"): 0 to 5x original, step 1
 * - General numeric: 0 to 2x original (minimum max: 10), step varies by magnitude
 */
export function parseControllers(configJson: string): ParamDef[] {
  try {
    const config = JSON.parse(configJson);
    const controllers = config.controllers || {};
    const params: ParamDef[] = [];

    for (const [name, value] of Object.entries(controllers)) {
      if (typeof value !== 'number') continue;

      const v = value as number;
      const { min, max, step } = inferRange(name, v);

      params.push({
        name,
        originalValue: v,
        currentValue: v,
        min,
        max,
        step
      });
    }

    return params;
  } catch (e) {
    console.error('[param-engine] Failed to parse config:', e);
    return [];
  }
}

function inferRange(name: string, value: number): { min: number; max: number; step: number } {
  const nameLower = name.toLowerCase();

  // Hue values: 0-360
  if (nameLower.includes('hue') || nameLower.includes('color')) {
    return { min: 0, max: 360, step: 1 };
  }

  // Boolean-like values (0 or 1)
  if (value === 0 || value === 1) {
    if (nameLower.includes('enable') || nameLower.includes('toggle') || nameLower.includes('show')) {
      return { min: 0, max: 1, step: 1 };
    }
  }

  // Very small values (noise scale, etc.)
  if (Math.abs(value) < 0.1 && value !== 0) {
    return {
      min: 0,
      max: Math.max(value * 10, 1),
      step: value / 100
    };
  }

  // Small values (speed, etc.)
  if (Math.abs(value) < 10) {
    return {
      min: 0,
      max: Math.max(value * 5, 10),
      step: 0.1
    };
  }

  // Medium values (size, etc.)
  if (Math.abs(value) < 1000) {
    return {
      min: 0,
      max: Math.max(value * 3, 100),
      step: 1
    };
  }

  // Large values
  return {
    min: 0,
    max: value * 2,
    step: Math.floor(value / 100) || 1
  };
}

/**
 * Apply saved overrides from IndexedDB to parameter definitions.
 */
export async function applyOverrides(atomSlug: string, params: ParamDef[]): Promise<ParamDef[]> {
  const override = await getConfigOverride(atomSlug);
  if (!override || !override.overrides) return params;

  return params.map(p => ({
    ...p,
    currentValue: typeof override.overrides[p.name] === 'number'
      ? override.overrides[p.name] as number
      : p.currentValue
  }));
}

/**
 * Save a single parameter change to IndexedDB.
 * Merges with existing overrides (only changed params stored).
 */
export async function saveParamChange(
  atomSlug: string,
  paramName: string,
  value: number
): Promise<void> {
  const existing = await getConfigOverride(atomSlug);
  const overrides = existing?.overrides || {};

  overrides[paramName] = value;

  await saveConfigOverride({
    atomSlug,
    overrides,
    updatedAt: new Date().toISOString(),
    synced: false
  });
}

/**
 * Reset all overrides for an atom (restore original config.json values).
 */
export async function resetOverrides(atomSlug: string): Promise<void> {
  await saveConfigOverride({
    atomSlug,
    overrides: {},
    updatedAt: new Date().toISOString(),
    synced: false
  });
}

/**
 * Get a merged config.json string with overrides applied.
 * Used to generate the effective config for desktop sync (Phase 6).
 */
export async function getEffectiveConfig(atomSlug: string, originalConfigJson: string): Promise<string> {
  try {
    const config = JSON.parse(originalConfigJson);
    const override = await getConfigOverride(atomSlug);

    if (override && override.overrides && config.controllers) {
      for (const [key, val] of Object.entries(override.overrides)) {
        if (key in config.controllers) {
          config.controllers[key] = val;
        }
      }
    }

    return JSON.stringify(config, null, 2);
  } catch (e) {
    return originalConfigJson;
  }
}
```

Key design decisions:
- Range inference is heuristic-based (hue detection, scale detection, magnitude-based fallback)
- Overrides stored separately from original config (easy to reset, easy to diff for sync)
- Only numeric controllers are supported (matching existing config.json structure)
- Step size inferred from value magnitude (small values get fine steps, large values get coarse steps)
  </action>
  <verify>
1. portfolio/src/scripts/param-engine.ts exists
2. parseControllers() correctly parses existing config.json format (controllers.bgHue, controllers.size, etc.)
3. inferRange() produces reasonable ranges (bgHue: 0-360, noiseScale: 0-0.1, size: 0-300)
4. applyOverrides() merges IndexedDB values with original params
5. saveParamChange() persists to IndexedDB configOverrides store
6. resetOverrides() clears all overrides for an atom
7. `cd portfolio && npx tsc --noEmit` compiles without errors (or check via build)
  </verify>
  <done>
Parameter engine created with config.json parsing, heuristic range inference (hue: 0-360, scale: adaptive, size: adaptive), IndexedDB override persistence, and reset functionality. Supports all existing atom config.json formats. Overrides stored separately from originals for clean reset and future sync.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ParamTweaker component and integrate into detail view</name>
  <files>
    portfolio/src/components/ParamTweaker.astro
    portfolio/src/pages/mobile/[slug].astro
  </files>
  <action>
Create the slider/number input UI component and add it as a new tab in the atom detail view.

**Create portfolio/src/components/ParamTweaker.astro:**

```astro
---
/**
 * ParamTweaker: Renders sliders and number inputs for atom config.json parameters.
 * Changes save immediately to IndexedDB. Live preview deferred to Phase 5.
 */
export interface Props {
  atomSlug: string;
  configJson: string;
}

const { atomSlug, configJson } = Astro.props;
---

<div class="param-tweaker" data-atom-slug={atomSlug} data-config-json={configJson}>
  <div class="param-info-banner">
    Changes saved locally. Preview on desktop with <code>eoe dev</code>.
  </div>

  <div id="param-list" class="param-list">
    <!-- Parameters rendered by client-side script -->
    <p class="param-loading">Loading parameters...</p>
  </div>

  <div class="param-actions">
    <button id="reset-params" class="btn btn-secondary" style="width: 100%;">
      Reset to Original
    </button>
  </div>
</div>

<script>
  import { parseControllers, applyOverrides, saveParamChange, resetOverrides, type ParamDef } from '../scripts/param-engine';

  async function initTweaker() {
    const container = document.querySelector('.param-tweaker') as HTMLElement;
    if (!container) return;

    const atomSlug = container.dataset.atomSlug || '';
    const configJson = container.dataset.configJson || '{}';
    const paramList = document.getElementById('param-list');
    if (!paramList) return;

    // Parse and apply saved overrides
    let params = parseControllers(configJson);
    params = await applyOverrides(atomSlug, params);

    if (params.length === 0) {
      paramList.innerHTML = '<p style="color: #555; font-style: italic;">No adjustable parameters in config.json.</p>';
      return;
    }

    // Render parameter controls
    paramList.innerHTML = '';
    for (const param of params) {
      const row = createParamRow(param, atomSlug);
      paramList.appendChild(row);
    }

    // Reset button
    const resetBtn = document.getElementById('reset-params');
    if (resetBtn) {
      resetBtn.addEventListener('click', async () => {
        await resetOverrides(atomSlug);
        // Re-parse original params (no overrides)
        const original = parseControllers(configJson);
        paramList.innerHTML = '';
        for (const param of original) {
          const row = createParamRow(param, atomSlug);
          paramList.appendChild(row);
        }
      });
    }
  }

  function createParamRow(param: ParamDef, atomSlug: string): HTMLElement {
    const row = document.createElement('div');
    row.className = 'param-row';

    // Label + value display
    const header = document.createElement('div');
    header.className = 'param-header';

    const label = document.createElement('span');
    label.className = 'param-name';
    label.textContent = param.name;

    const valueDisplay = document.createElement('span');
    valueDisplay.className = 'param-value';
    valueDisplay.textContent = formatValue(param.currentValue, param.step);

    header.appendChild(label);
    header.appendChild(valueDisplay);

    // Slider
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.className = 'param-slider';
    slider.min = String(param.min);
    slider.max = String(param.max);
    slider.step = String(param.step);
    slider.value = String(param.currentValue);

    // Number input
    const numInput = document.createElement('input');
    numInput.type = 'number';
    numInput.className = 'param-number';
    numInput.min = String(param.min);
    numInput.max = String(param.max);
    numInput.step = String(param.step);
    numInput.value = String(param.currentValue);

    // Slider change handler — instant feedback
    slider.addEventListener('input', async () => {
      const val = parseFloat(slider.value);
      valueDisplay.textContent = formatValue(val, param.step);
      numInput.value = String(val);
      await saveParamChange(atomSlug, param.name, val);
    });

    // Number input change handler
    numInput.addEventListener('change', async () => {
      let val = parseFloat(numInput.value);
      // Clamp to range
      val = Math.max(param.min, Math.min(param.max, val));
      numInput.value = String(val);
      slider.value = String(val);
      valueDisplay.textContent = formatValue(val, param.step);
      await saveParamChange(atomSlug, param.name, val);
    });

    // Changed indicator
    if (param.currentValue !== param.originalValue) {
      row.classList.add('param-changed');
    }

    row.appendChild(header);
    row.appendChild(slider);
    row.appendChild(numInput);

    return row;
  }

  function formatValue(value: number, step: number): string {
    if (step >= 1) return String(Math.round(value));
    if (step >= 0.1) return value.toFixed(1);
    if (step >= 0.01) return value.toFixed(2);
    return value.toFixed(4);
  }

  // Initialize when DOM is ready
  initTweaker();
</script>

<style>
  .param-tweaker {
    padding: 8px 0;
  }

  .param-info-banner {
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 16px;
    font-size: 0.8rem;
    color: #888;
    text-align: center;
  }

  .param-info-banner code {
    color: #6bb5ff;
    font-family: 'SF Mono', monospace;
  }

  .param-list {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-bottom: 24px;
  }

  .param-loading {
    color: #555;
    text-align: center;
    font-style: italic;
  }

  .param-row {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px;
    background: #111;
    border-radius: 8px;
    border-left: 3px solid transparent;
  }

  .param-row.param-changed {
    border-left-color: #6bb5ff;
  }

  .param-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .param-name {
    font-size: 0.85rem;
    font-weight: 600;
    color: #ccc;
  }

  .param-value {
    font-size: 0.85rem;
    font-weight: 600;
    color: #6bb5ff;
    font-family: 'SF Mono', monospace;
  }

  .param-slider {
    width: 100%;
    height: 44px;
    -webkit-appearance: none;
    background: transparent;
    cursor: pointer;
  }

  .param-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: #6bb5ff;
    cursor: pointer;
    margin-top: -12px;
  }

  .param-slider::-webkit-slider-runnable-track {
    height: 4px;
    background: #333;
    border-radius: 2px;
  }

  .param-slider::-moz-range-thumb {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: #6bb5ff;
    cursor: pointer;
    border: none;
  }

  .param-slider::-moz-range-track {
    height: 4px;
    background: #333;
    border-radius: 2px;
  }

  .param-number {
    width: 100%;
    padding: 8px 12px;
    font-size: 16px; /* Prevents iOS zoom */
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 6px;
    color: #e0e0e0;
    font-family: 'SF Mono', monospace;
    text-align: right;
  }

  .param-number:focus {
    border-color: #6bb5ff;
    outline: none;
  }

  .param-actions {
    padding-top: 8px;
  }
</style>
```

**Update portfolio/src/pages/mobile/[slug].astro:**

Add a "Params" tab to the existing tab navigation. In the existing [slug].astro file, make the following changes:

1. Add import for ParamTweaker at the top (in the frontmatter):
```javascript
import ParamTweaker from '../../components/ParamTweaker.astro';
```

2. Add "Params" button to the tab navigation (after the Notes tab button):
```html
<button class="tab" data-tab="params">Params</button>
```

3. Add the params tab content panel (after the notes tab content):
```html
<!-- Params tab -->
<div class="tab-content" id="tab-params" style="display: none;">
  <ParamTweaker atomSlug={atom.slug} configJson={atom.configJson} />
</div>
```

The tab order should be: Code | Config | Notes | Params

This gives the param tweaker its own dedicated tab, keeping the detail view organized. The user can switch between viewing code and tweaking parameters.
  </action>
  <verify>
1. portfolio/src/components/ParamTweaker.astro exists
2. portfolio/src/pages/mobile/[slug].astro includes ParamTweaker import
3. Detail view has 4 tabs: Code | Config | Notes | Params
4. Params tab renders sliders for each controller in config.json
5. Moving a slider updates the displayed value instantly
6. Slider thumb is 28px (easy to grab on mobile)
7. Number input accepts manual typed values
8. Reset button restores original config.json values
9. "Preview on desktop" message is visible
10. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
ParamTweaker component created with slider and number input for each config.json controller parameter. Heuristic range inference provides sensible defaults (hue: 0-360, size: 0-300, speed: 0-5, noiseScale: 0-0.1). Changes save immediately to IndexedDB with changed indicator (blue left border). Reset button restores original values. Integrated into detail view as Params tab.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify parameter tweaking end-to-end</name>
  <files>
    (no new files -- verification task)
  </files>
  <action>
Verify the parameter tweaker works correctly with existing atom config.json values.

**Build and serve:**
```bash
cd portfolio && npm run build && npm run preview
```

**Verification checks using atoms/2026-01-30-my-first-sketch/config.json:**

The existing config has:
```json
{
  "controllers": {
    "bgHue": 200,
    "shapeHue": 30,
    "size": 100,
    "speed": 1,
    "noiseScale": 0.01
  }
}
```

1. **Parameter rendering:**
   - Navigate to /mobile/2026-01-30-my-first-sketch, tap Params tab
   - Verify 5 sliders appear: bgHue, shapeHue, size, speed, noiseScale
   - Verify bgHue slider range is 0-360 (hue detection)
   - Verify shapeHue slider range is 0-360 (hue detection)
   - Verify size slider has reasonable range (~0-300)
   - Verify speed slider has reasonable range (~0-5)
   - Verify noiseScale slider has fine-grained steps (< 0.01)

2. **Instant feedback:**
   - Move bgHue slider — value display updates immediately as slider moves
   - Verify no lag or jank during slider movement

3. **Number input:**
   - Type "180" in bgHue number input, press Enter or blur
   - Verify slider position updates to match
   - Type a value outside range (e.g., 400 for bgHue) — verify it clamps to max

4. **Persistence:**
   - Change bgHue to 120, shapeHue to 60
   - Reload the page
   - Navigate to Params tab again
   - Verify bgHue shows 120, shapeHue shows 60 (persisted in IndexedDB)

5. **Reset:**
   - Click "Reset to Original"
   - Verify bgHue returns to 200, shapeHue to 30
   - Reload page — verify values are back to original

6. **Changed indicator:**
   - Change bgHue to a different value
   - Verify the bgHue row shows a blue left border (changed indicator)
   - Verify unchanged parameters have no border

7. **Mobile viewport:**
   - Test at 375px width
   - Verify sliders are full-width and easy to grab
   - Verify number input doesn't trigger iOS zoom (font-size: 16px)
   - Verify "Preview on desktop" banner is visible

8. **IndexedDB verification:**
   - Open DevTools > Application > IndexedDB > eoe-atoms > configOverrides
   - Verify override entry exists with atomSlug and overrides object

Fix any issues before marking complete. Most likely issue: slider range inference producing unhelpful ranges for edge-case parameter names.
  </action>
  <verify>
1. All 5 parameters from config.json rendered as sliders
2. Hue parameters detected and given 0-360 range
3. Slider movement shows instant value update
4. Number input works with manual entry
5. Values persist across page reloads via IndexedDB
6. Reset restores original config.json values
7. Changed parameters show visual indicator
8. Mobile viewport: no iOS zoom, sliders easy to grab
9. "Preview on desktop" message visible
  </verify>
  <done>
Parameter tweaker verified end-to-end: 5 parameters render from config.json, hue detection gives 0-360 range, sliders update instantly, number inputs work with clamping, values persist across reloads via IndexedDB, reset restores originals, changed indicator visible, mobile viewport interaction smooth. MOB-04 (tweak parameters) functional.
  </done>
</task>

</tasks>

<verification>
1. Params tab appears in atom detail view
2. All numeric controllers from config.json rendered as sliders + number inputs
3. Moving slider updates displayed value instantly (no lag)
4. Parameter changes saved immediately to IndexedDB configOverrides store
5. Tweaked values persist across page reloads
6. Reset button restores original config.json values
7. Changed parameters show blue left border indicator
8. "Preview on desktop" message visible in param tweaker
9. Slider thumb is 28px for easy mobile interaction
10. Number input font is 16px (prevents iOS zoom)
</verification>

<success_criteria>
- User can tweak atom parameters via sliders and number inputs on mobile (MOB-04)
- Changes save immediately to local IndexedDB (no Save button needed)
- Tweaked values persist across page reloads
- Reset button restores original config.json values
- Hue parameters get 0-360 range, other parameters get sensible inferred ranges
- All slider interactions feel responsive (no delay between thumb movement and value update)
- Number inputs don't trigger iOS Safari zoom (16px font size)
- Parameter tweaker works offline (reads from IndexedDB, saves to IndexedDB)
</success_criteria>

<output>
After completion, create `.planning/phases/04-mobile-gallery-ideation-tools/04-03-SUMMARY.md`
</output>
