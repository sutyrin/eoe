---
phase: 04-mobile-gallery-ideation-tools
plan: 02
type: execute
wave: 1
depends_on: ["04-01"]
files_modified:
  - portfolio/src/pages/mobile/gallery.astro
  - portfolio/src/pages/mobile/[slug].astro
  - portfolio/src/components/AtomListItem.astro
  - portfolio/src/components/CodeViewer.astro
  - portfolio/src/components/NotesViewer.astro
  - portfolio/src/components/NotesEditor.astro
  - portfolio/src/scripts/notes-editor.ts
  - portfolio/src/components/SearchBar.astro
  - portfolio/scripts/generate-metadata.js
  - portfolio/scripts/copy-atoms.js
  - portfolio/package.json
  - portfolio/public/atom-metadata.json
autonomous: true

must_haves:
  truths:
    - "User can browse atoms in a list view at /mobile/gallery showing title, date, type, and thumbnail"
    - "Gallery is sorted most-recent-first (reverse chronological by YYYY-MM-DD prefix)"
    - "User can search atoms by name via a text search bar at the top of the gallery"
    - "Tapping an atom opens a detail view at /mobile/<slug>"
    - "Detail view shows syntax-highlighted code using Prism.js (JavaScript, JSON, Markdown only)"
    - "Detail view shows rendered NOTES.md content"
    - "Code text wraps to screen width (no horizontal scrolling)"
    - "Code font is readable on 6-inch phone (16px minimum)"
    - "Gallery and detail views work offline after first load (data cached in IndexedDB + service worker)"
    - "atom-metadata.json is generated at build time with all atom data embedded"
    - "Gallery populates IndexedDB on first load so subsequent offline visits work"
    - "User can quick-edit NOTES.md via inline textarea on the Notes tab of atom detail view (IDEA-04)"
    - "Notes editor has a Save button that persists edited text to IndexedDB atom notes field"
    - "Edited notes are marked as locally modified for future sync (Phase 6)"
  artifacts:
    - path: "portfolio/src/pages/mobile/gallery.astro"
      provides: "Atom list view with search, sorted by date descending"
      contains: "gallery"
    - path: "portfolio/src/pages/mobile/[slug].astro"
      provides: "Atom detail view with code, notes, and config"
      contains: "CodeViewer"
    - path: "portfolio/src/components/AtomListItem.astro"
      provides: "Single atom row in gallery list"
      contains: "list-item"
    - path: "portfolio/src/components/CodeViewer.astro"
      provides: "Prism.js syntax-highlighted code display"
      contains: "Prism"
    - path: "portfolio/src/components/NotesViewer.astro"
      provides: "NOTES.md rendered display"
      contains: "notes"
    - path: "portfolio/src/components/NotesEditor.astro"
      provides: "Inline textarea editor for NOTES.md with save button"
      contains: "textarea"
    - path: "portfolio/src/scripts/notes-editor.ts"
      provides: "Notes persistence logic: save edited notes to IndexedDB atom record"
      contains: "saveAtomNotes"
    - path: "portfolio/src/components/SearchBar.astro"
      provides: "Text search input for gallery filtering"
      contains: "search"
    - path: "portfolio/scripts/generate-metadata.js"
      provides: "Build-time script that reads all atoms and generates atom-metadata.json"
      contains: "atom-metadata"
    - path: "portfolio/public/atom-metadata.json"
      provides: "Pre-generated JSON with all atom metadata, code, notes, config"
      contains: "slug"
  key_links:
    - from: "portfolio/src/pages/mobile/gallery.astro"
      to: "portfolio/src/components/AtomListItem.astro"
      via: "import AtomListItem"
      pattern: "AtomListItem"
    - from: "portfolio/src/pages/mobile/[slug].astro"
      to: "portfolio/src/components/CodeViewer.astro"
      via: "import CodeViewer"
      pattern: "CodeViewer"
    - from: "portfolio/src/pages/mobile/gallery.astro"
      to: "portfolio/src/scripts/db.ts"
      via: "import { saveAllAtomMetadata, getAllAtomsSorted }"
      pattern: "saveAllAtomMetadata"
    - from: "portfolio/scripts/generate-metadata.js"
      to: "atoms/"
      via: "fs.readdirSync('../atoms')"
      pattern: "atoms"
    - from: "portfolio/src/components/NotesEditor.astro"
      to: "portfolio/src/scripts/notes-editor.ts"
      via: "import { saveAtomNotes }"
      pattern: "saveAtomNotes"
    - from: "portfolio/src/scripts/notes-editor.ts"
      to: "portfolio/src/scripts/db.ts"
      via: "import { getAtom, saveAtomMetadata }"
      pattern: "saveAtomMetadata"
---

<objective>
Create the atom gallery list view and atom detail view (code + notes viewer) for the mobile PWA. After this plan, users can browse all atoms in a searchable list on their phone, tap into any atom to view its syntax-highlighted source code and NOTES.md, and do all of this offline after the first visit. The gallery is the main entry point for the mobile companion experience.

Purpose: Gallery browsing (MOB-02) and code viewing (MOB-01) are the foundation of the mobile companion. Users need to review their atoms on the go (commute, coffee shop). Without a gallery, there is no reason to install the PWA. Without code viewing, the mobile companion cannot serve its primary purpose of understanding what atoms do.
Output: Mobile gallery page (/mobile/gallery), atom detail page (/mobile/<slug>), Prism.js code viewer, NOTES.md viewer, search bar, and build-time metadata generation script.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mobile-gallery-ideation-tools/04-CONTEXT.md
@.planning/phases/04-mobile-gallery-ideation-tools/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Prism.js and create build-time metadata generator</name>
  <files>
    portfolio/package.json
    portfolio/scripts/generate-metadata.js
    portfolio/scripts/copy-atoms.js
  </files>
  <action>
Install syntax highlighting dependency and create the build-time script that pre-generates atom metadata for the gallery.

**Install Prism.js in portfolio/:**
```bash
cd portfolio && npm install prismjs
```

Only `prismjs` is needed (2KB core). We will import only `prism-javascript`, `prism-json`, and `prism-markdown` components to keep the bundle under 10KB. No highlight.js, no Shiki.

**Create portfolio/scripts/generate-metadata.js:**

This script runs at build time (before Astro build) to read all atoms from `../atoms/` and generate a JSON file with their metadata, code, notes, and config embedded. This avoids runtime filesystem reads and enables offline access via IndexedDB.

```javascript
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const atomsDir = path.resolve(__dirname, '../../atoms');
const outputPath = path.resolve(__dirname, '../public/atom-metadata.json');

async function generateMetadata() {
  if (!fs.existsSync(atomsDir)) {
    console.log('[generate-metadata] No atoms/ directory found. Writing empty metadata.');
    await fs.writeJson(outputPath, []);
    return;
  }

  const entries = fs.readdirSync(atomsDir, { withFileTypes: true })
    .filter(d => d.isDirectory() && d.name.match(/^\d{4}-\d{2}-\d{2}-/));

  const atoms = [];

  for (const entry of entries) {
    const atomPath = path.join(atomsDir, entry.name);
    const slug = entry.name;

    // Parse date and title from folder name
    const parts = slug.match(/^(\d{4}-\d{2}-\d{2})-(.+)$/);
    const date = parts ? parts[1] : '';
    const title = parts ? parts[2] : slug;

    // Read config.json
    let configJson = '{}';
    let type = 'visual';
    const configPath = path.join(atomPath, 'config.json');
    if (fs.existsSync(configPath)) {
      configJson = fs.readFileSync(configPath, 'utf8');
      try {
        const config = JSON.parse(configJson);
        if (config.type) type = config.type;
      } catch (e) { /* keep default type */ }
    }

    // Read sketch.js (or audio.js, composition.js)
    let code = '';
    const codeFiles = ['sketch.js', 'audio.js', 'composition.js'];
    for (const cf of codeFiles) {
      const codePath = path.join(atomPath, cf);
      if (fs.existsSync(codePath)) {
        code = fs.readFileSync(codePath, 'utf8');
        break;
      }
    }

    // Read NOTES.md
    let notes = '';
    let stage = 'idea';
    const notesPath = path.join(atomPath, 'NOTES.md');
    if (fs.existsSync(notesPath)) {
      notes = fs.readFileSync(notesPath, 'utf8');
      const stageMatch = notes.match(/\*\*Stage:\*\*\s*(\w+)/);
      if (stageMatch) stage = stageMatch[1];
    }

    atoms.push({
      slug,
      title,
      date,
      type,
      stage,
      thumbnailUrl: `/thumbnails/${slug}.webp`, // Placeholder path for future thumbnails
      code,
      notes,
      configJson
    });
  }

  // Sort by date descending (most recent first)
  atoms.sort((a, b) => b.date.localeCompare(a.date));

  await fs.writeJson(outputPath, atoms, { spaces: 2 });
  console.log(`[generate-metadata] Generated metadata for ${atoms.length} atoms -> ${outputPath}`);
}

generateMetadata().catch(err => {
  console.error('[generate-metadata] Error:', err);
  process.exit(1);
});
```

**Update portfolio/scripts/copy-atoms.js** to also run generate-metadata:

The existing copy-atoms.js copies atom files to public/atoms/. We need generate-metadata.js to run after it. Update portfolio/package.json scripts:

```json
{
  "scripts": {
    "dev": "node scripts/copy-atoms.js && node scripts/generate-metadata.js && astro dev",
    "build": "node scripts/copy-atoms.js && node scripts/generate-metadata.js && astro build",
    "preview": "astro preview"
  }
}
```

After running the build, verify `portfolio/public/atom-metadata.json` exists with atom data.
  </action>
  <verify>
1. `cd portfolio && npm ls prismjs` shows installed version
2. portfolio/scripts/generate-metadata.js exists
3. `cd portfolio && node scripts/copy-atoms.js && node scripts/generate-metadata.js` succeeds
4. portfolio/public/atom-metadata.json exists and contains atom entries with slug, title, date, code, notes, configJson fields
5. Each atom entry has non-empty code field (sketch.js content)
6. portfolio/package.json scripts run generate-metadata before astro dev/build
7. `cd portfolio && npm run build` outputs atom-metadata.json in dist/ (confirms generate-metadata.js actually executes during build)
  </verify>
  <done>
Prism.js installed for syntax highlighting. Build-time metadata generator created that reads all atoms from ../atoms/, extracts slug/title/date/type/stage/code/notes/config, and writes atom-metadata.json to public/. Package.json scripts updated to run generator before dev and build. Atom data is now available as a static JSON file for both SSG and client-side consumption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create gallery list view and search</name>
  <files>
    portfolio/src/pages/mobile/gallery.astro
    portfolio/src/components/AtomListItem.astro
    portfolio/src/components/SearchBar.astro
  </files>
  <action>
Create the gallery page that lists all atoms in reverse chronological order with search filtering.

**Create portfolio/src/components/SearchBar.astro:**

```astro
---
// SearchBar: Text input for filtering atoms by name
// Dispatches 'eoe:search' custom event on input
---
<div class="search-container">
  <input
    type="search"
    id="atom-search"
    class="search-bar"
    placeholder="Search atoms..."
    autocomplete="off"
    autocapitalize="none"
    spellcheck="false"
  />
</div>

<script>
  const input = document.getElementById('atom-search') as HTMLInputElement;
  if (input) {
    input.addEventListener('input', () => {
      window.dispatchEvent(new CustomEvent('eoe:search', {
        detail: { query: input.value.trim() }
      }));
    });
  }
</script>

<style>
  .search-container {
    padding: 0 0 16px 0;
  }
</style>
```

**Create portfolio/src/components/AtomListItem.astro:**

```astro
---
export interface Props {
  slug: string;
  title: string;
  date: string;
  type: string;
  stage: string;
}

const { slug, title, date, type, stage } = Astro.props;

// Type badge colors
const typeColors: Record<string, string> = {
  visual: '#6bb5ff',
  audio: '#ff6b9d',
  'audio-visual': '#b56bff',
  composition: '#6bffb5'
};
const badgeColor = typeColors[type] || '#888';
---

<a href={`/mobile/${slug}`} class="list-item atom-list-item" data-slug={slug} data-title={title}>
  <div class="atom-thumb" style={`border-color: ${badgeColor}`}>
    <span class="atom-type-icon">{type === 'visual' ? 'V' : type === 'audio' ? 'A' : type === 'audio-visual' ? 'AV' : 'C'}</span>
  </div>
  <div class="atom-info">
    <span class="atom-title">{title}</span>
    <span class="atom-meta">
      {date}
      <span class="atom-type-badge" style={`color: ${badgeColor}`}>{type}</span>
      <span class="atom-stage">{stage}</span>
    </span>
  </div>
</a>

<style>
  .atom-list-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    min-height: 64px;
    border-bottom: 1px solid #1a1a1a;
    text-decoration: none;
    color: inherit;
  }

  .atom-list-item:active {
    background: #1a1a1a;
  }

  .atom-thumb {
    width: 48px;
    height: 48px;
    border-radius: 8px;
    background: #151515;
    border: 2px solid #333;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .atom-type-icon {
    font-size: 0.75rem;
    font-weight: 700;
    color: #888;
  }

  .atom-info {
    display: flex;
    flex-direction: column;
    gap: 4px;
    min-width: 0; /* Allow text truncation */
  }

  .atom-title {
    color: #fff;
    font-weight: 600;
    font-size: 0.95rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .atom-meta {
    color: #666;
    font-size: 0.8rem;
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .atom-type-badge {
    font-weight: 600;
    font-size: 0.7rem;
    text-transform: uppercase;
  }

  .atom-stage {
    color: #555;
    font-size: 0.7rem;
  }
</style>
```

**Create portfolio/src/pages/mobile/gallery.astro:**

```astro
---
import MobileLayout from '../../layouts/MobileLayout.astro';
import AtomListItem from '../../components/AtomListItem.astro';
import SearchBar from '../../components/SearchBar.astro';
import fs from 'node:fs';
import path from 'node:path';

// Read pre-generated metadata at build time
const metadataPath = path.resolve('./public/atom-metadata.json');
let atoms = [];
if (fs.existsSync(metadataPath)) {
  atoms = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
}
---

<MobileLayout title="Gallery">
  <SearchBar />

  <div id="atom-list">
    {atoms.length === 0 && (
      <p style="color: #666; text-align: center; padding: 2rem;">
        No atoms yet. Create one on desktop with <code style="color: #6bb5ff;">eoe create visual &lt;name&gt;</code>
      </p>
    )}

    {atoms.map((atom: any) => (
      <AtomListItem
        slug={atom.slug}
        title={atom.title}
        date={atom.date}
        type={atom.type}
        stage={atom.stage}
      />
    ))}
  </div>

  <div id="no-results" style="display: none; color: #666; text-align: center; padding: 2rem;">
    No atoms match your search.
  </div>

  <script>
    import { saveAllAtomMetadata } from '../../scripts/db';

    // Populate IndexedDB with atom data on first visit (enables offline gallery)
    async function populateOfflineData() {
      try {
        const response = await fetch('/atom-metadata.json');
        if (response.ok) {
          const atoms = await response.json();
          await saveAllAtomMetadata(atoms);
          console.log(`[gallery] Cached ${atoms.length} atoms to IndexedDB`);
        }
      } catch (err) {
        console.log('[gallery] Offline or fetch failed, using cached data');
      }
    }

    populateOfflineData();

    // Search filtering
    window.addEventListener('eoe:search', (e: CustomEvent) => {
      const query = e.detail.query.toLowerCase();
      const items = document.querySelectorAll('.atom-list-item');
      const noResults = document.getElementById('no-results');
      let visibleCount = 0;

      items.forEach((item: HTMLElement) => {
        const title = (item.dataset.title || '').toLowerCase();
        const slug = (item.dataset.slug || '').toLowerCase();
        const matches = !query || title.includes(query) || slug.includes(query);
        item.style.display = matches ? 'flex' : 'none';
        if (matches) visibleCount++;
      });

      if (noResults) {
        noResults.style.display = (query && visibleCount === 0) ? 'block' : 'none';
      }
    });
  </script>
</MobileLayout>
```

The gallery:
- Reads atom-metadata.json at build time (SSG) to render the list
- On first client-side load, fetches atom-metadata.json and saves to IndexedDB for offline
- Search filters the rendered list in-place (no re-render, just CSS display toggle)
- Each atom links to /mobile/<slug> detail view
  </action>
  <verify>
1. portfolio/src/pages/mobile/gallery.astro exists
2. portfolio/src/components/AtomListItem.astro exists
3. portfolio/src/components/SearchBar.astro exists
4. `cd portfolio && npm run build` succeeds
5. dist/mobile/gallery/index.html exists in build output
6. Gallery page shows all atoms sorted by date (newest first)
7. Search input filters atoms by name as you type
8. Each atom list item links to /mobile/<slug>
  </verify>
  <done>
Gallery list view created at /mobile/gallery with search bar, atom list items showing title/date/type/stage, and IndexedDB population for offline use. Search filters atoms by name/slug in real-time. Each item links to atom detail view. Data comes from pre-generated atom-metadata.json at build time.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create atom detail view with code viewer and notes</name>
  <files>
    portfolio/src/pages/mobile/[slug].astro
    portfolio/src/components/CodeViewer.astro
    portfolio/src/components/NotesViewer.astro
  </files>
  <action>
Create the atom detail page that shows syntax-highlighted code and NOTES.md.

**Create portfolio/src/components/CodeViewer.astro:**

```astro
---
/**
 * CodeViewer: Syntax-highlighted code display using Prism.js.
 * Optimized for mobile reading:
 * - 16px font for readability on 6" screens
 * - Code wraps to screen width (no horizontal scroll)
 * - No line numbers (cleaner mobile look)
 * - Dark theme (prism-tomorrow)
 * - Only loads JavaScript, JSON, Markdown languages (keeps bundle <10KB)
 */
export interface Props {
  code: string;
  language?: string;
  filename?: string;
}

const { code, language = 'javascript', filename = '' } = Astro.props;
---

<div class="code-viewer">
  {filename && (
    <div class="code-filename">{filename}</div>
  )}
  <pre class={`language-${language}`}><code class={`language-${language}`} id="code-block">{code}</code></pre>
</div>

<script>
  import Prism from 'prismjs';
  import 'prismjs/components/prism-javascript';
  import 'prismjs/components/prism-json';
  import 'prismjs/components/prism-markdown';

  // Highlight all code blocks on page
  Prism.highlightAll();
</script>

<style is:global>
  /* Prism.js Tomorrow Night theme (adapted for mobile) */
  code[class*="language-"],
  pre[class*="language-"] {
    color: #ccc;
    background: none;
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', Consolas, Monaco, monospace;
    font-size: 14px;
    line-height: 1.6;
    text-align: left;
    white-space: pre-wrap;    /* Wrap to screen width */
    word-wrap: break-word;    /* Break long lines */
    word-break: break-all;
    tab-size: 2;
    hyphens: none;
  }

  pre[class*="language-"] {
    padding: 16px;
    margin: 0;
    overflow: visible;        /* No scroll, code wraps */
    border-radius: 8px;
    background: #151515;
  }

  .token.comment,
  .token.block-comment,
  .token.prolog,
  .token.doctype,
  .token.cdata { color: #999; }

  .token.punctuation { color: #ccc; }

  .token.tag,
  .token.attr-name,
  .token.namespace,
  .token.deleted { color: #e2777a; }

  .token.function-name { color: #6196cc; }

  .token.boolean,
  .token.number,
  .token.function { color: #f08d49; }

  .token.property,
  .token.class-name,
  .token.constant,
  .token.symbol { color: #f8c555; }

  .token.selector,
  .token.important,
  .token.atrule,
  .token.keyword,
  .token.builtin { color: #cc99cd; }

  .token.string,
  .token.char,
  .token.attr-value,
  .token.regex,
  .token.variable { color: #7ec699; }

  .token.operator,
  .token.entity,
  .token.url { color: #67cdcc; }

  .token.important,
  .token.bold { font-weight: bold; }

  .token.italic { font-style: italic; }

  .token.entity { cursor: help; }

  .token.inserted { color: green; }
</style>

<style>
  .code-viewer {
    margin: 16px 0;
    border-radius: 8px;
    overflow: hidden;
    background: #151515;
  }

  .code-filename {
    padding: 8px 16px;
    font-size: 0.75rem;
    color: #888;
    background: #1a1a1a;
    border-bottom: 1px solid #222;
    font-family: 'SF Mono', monospace;
  }
</style>
```

**Create portfolio/src/components/NotesViewer.astro:**

```astro
---
/**
 * NotesViewer: Renders NOTES.md content in a readable format.
 * For Phase 4, this is a simple pre-formatted text display.
 * Future: could use a markdown renderer (marked, remark) for rich formatting.
 */
export interface Props {
  notes: string;
}

const { notes } = Astro.props;
---

{notes ? (
  <div class="notes-viewer">
    <h3 class="notes-heading">Notes</h3>
    <pre class="notes-content">{notes}</pre>
  </div>
) : (
  <div class="notes-viewer">
    <h3 class="notes-heading">Notes</h3>
    <p class="notes-empty">No notes for this atom.</p>
  </div>
)}

<style>
  .notes-viewer {
    margin: 16px 0;
  }

  .notes-heading {
    font-size: 1rem;
    color: #fff;
    margin-bottom: 12px;
    font-weight: 600;
  }

  .notes-content {
    padding: 16px;
    background: #151515;
    border-radius: 8px;
    font-size: 0.9rem;
    line-height: 1.6;
    color: #ccc;
    white-space: pre-wrap;
    word-wrap: break-word;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    max-height: 400px;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .notes-empty {
    color: #555;
    font-size: 0.85rem;
    font-style: italic;
  }
</style>
```

**Create portfolio/src/pages/mobile/[slug].astro:**

```astro
---
import MobileLayout from '../../layouts/MobileLayout.astro';
import CodeViewer from '../../components/CodeViewer.astro';
import NotesViewer from '../../components/NotesViewer.astro';
import fs from 'node:fs';
import path from 'node:path';

// Generate static paths from atom-metadata.json
export function getStaticPaths() {
  const metadataPath = path.resolve('./public/atom-metadata.json');
  if (!fs.existsSync(metadataPath)) return [];

  const atoms = JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
  return atoms.map((atom: any) => ({
    params: { slug: atom.slug },
    props: { atom }
  }));
}

const { atom } = Astro.props;

// Parse display values
const parts = atom.slug.match(/^(\d{4}-\d{2}-\d{2})-(.+)$/);
const displayName = parts ? parts[2] : atom.slug;
const displayDate = parts ? parts[1] : '';

// Determine code filename for display
const codeFilenames: Record<string, string> = {
  visual: 'sketch.js',
  audio: 'audio.js',
  'audio-visual': 'sketch.js',
  composition: 'composition.js'
};
const codeFilename = codeFilenames[atom.type] || 'sketch.js';
---

<MobileLayout title={displayName} showBack={true} backHref="/mobile/gallery">
  <!-- Atom header -->
  <div class="atom-header">
    <span class="atom-date">{displayDate}</span>
    <span class="atom-type-badge">{atom.type}</span>
    <span class="atom-stage-badge">{atom.stage}</span>
  </div>

  <!-- Tab navigation -->
  <div class="tab-nav" id="tab-nav">
    <button class="tab active" data-tab="code">Code</button>
    <button class="tab" data-tab="config">Config</button>
    <button class="tab" data-tab="notes">Notes</button>
  </div>

  <!-- Code tab -->
  <div class="tab-content active" id="tab-code">
    {atom.code ? (
      <CodeViewer code={atom.code} language="javascript" filename={codeFilename} />
    ) : (
      <p style="color: #555; padding: 16px;">No code file found.</p>
    )}
  </div>

  <!-- Config tab -->
  <div class="tab-content" id="tab-config" style="display: none;">
    {atom.configJson ? (
      <CodeViewer code={atom.configJson} language="json" filename="config.json" />
    ) : (
      <p style="color: #555; padding: 16px;">No config.json found.</p>
    )}
  </div>

  <!-- Notes tab -->
  <div class="tab-content" id="tab-notes" style="display: none;">
    <NotesViewer notes={atom.notes} />
  </div>

  <script>
    // Tab switching logic
    const tabs = document.querySelectorAll('.tab');
    const contents = document.querySelectorAll('.tab-content');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const target = (tab as HTMLElement).dataset.tab;

        // Update tab active state
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        // Show target content, hide others
        contents.forEach(content => {
          const el = content as HTMLElement;
          if (el.id === `tab-${target}`) {
            el.style.display = 'block';
            el.classList.add('active');
          } else {
            el.style.display = 'none';
            el.classList.remove('active');
          }
        });
      });
    });
  </script>

  <style>
    .atom-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .atom-date {
      color: #666;
      font-size: 0.85rem;
    }

    .atom-type-badge {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      color: #6bb5ff;
      background: rgba(107, 181, 255, 0.1);
      padding: 2px 8px;
      border-radius: 4px;
    }

    .atom-stage-badge {
      font-size: 0.7rem;
      color: #888;
      background: #1a1a1a;
      padding: 2px 8px;
      border-radius: 4px;
    }

    .tab-nav {
      display: flex;
      gap: 0;
      border-bottom: 1px solid #222;
      margin-bottom: 0;
    }

    .tab {
      flex: 1;
      padding: 12px 16px;
      border: none;
      background: none;
      color: #666;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      min-height: 44px;
    }

    .tab.active {
      color: #6bb5ff;
      border-bottom-color: #6bb5ff;
    }

    .tab:active {
      background: #1a1a1a;
    }

    .tab-content {
      margin-top: 0;
    }
  </style>
</MobileLayout>
```

The detail view features:
- Back navigation to gallery
- Atom header with date, type badge, and stage badge
- Tab navigation: Code | Config | Notes
- Code tab: Prism.js syntax-highlighted source with filename label
- Config tab: Prism.js-highlighted config.json
- Notes tab: NOTES.md rendered as formatted text
- All content is embedded at build time (works offline)
  </action>
  <verify>
1. portfolio/src/pages/mobile/[slug].astro exists
2. portfolio/src/components/CodeViewer.astro exists with Prism.js imports
3. portfolio/src/components/NotesViewer.astro exists
4. `cd portfolio && npm run build` succeeds
5. dist/mobile/<atom-slug>/index.html exists for each atom
6. Code is syntax-highlighted (Prism.js classes present in HTML)
7. Tab navigation switches between Code, Config, and Notes
8. Back button navigates to /mobile/gallery
9. Code wraps to viewport width (no horizontal scrollbar on 375px)
10. Font is readable at 14px with 1.6 line height
  </verify>
  <done>
Atom detail view created at /mobile/<slug> with tabbed interface (Code/Config/Notes). CodeViewer uses Prism.js with Tomorrow Night theme, 14px font, pre-wrap for mobile screen width. Only JavaScript, JSON, and Markdown languages imported (bundle <10KB). NotesViewer shows NOTES.md as formatted text. All content embedded at build time for offline access. Back navigation returns to gallery.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add inline NOTES.md editor to atom detail view (IDEA-04)</name>
  <files>
    portfolio/src/components/NotesEditor.astro
    portfolio/src/scripts/notes-editor.ts
    portfolio/src/pages/mobile/[slug].astro
  </files>
  <action>
Create a NOTES.md inline editor so users can quick-edit process notes on mobile. This covers requirement IDEA-04: "User can quick-edit NOTES.md (text editor for process notes on mobile)."

The existing NotesViewer.astro displays NOTES.md as read-only formatted text. We need to add an editable mode with a textarea and save button.

**Create portfolio/src/scripts/notes-editor.ts:**

```typescript
/**
 * Notes editor persistence logic.
 * Saves edited NOTES.md content to the atom's IndexedDB record.
 * Marks the atom as locally modified for future Phase 6 sync.
 */
import { getAtom, saveAtomMetadata, type AtomMetadata } from './db';

/**
 * Save edited notes text to IndexedDB for a specific atom.
 * Updates the atom's `notes` field and marks it as locally modified.
 */
export async function saveAtomNotes(atomSlug: string, notesText: string): Promise<boolean> {
  const atom = await getAtom(atomSlug);
  if (!atom) {
    console.error('[notes-editor] Atom not found:', atomSlug);
    return false;
  }

  const updated: AtomMetadata = {
    ...atom,
    notes: notesText
  };

  await saveAtomMetadata(updated);
  console.log(`[notes-editor] Saved notes for ${atomSlug} (${notesText.length} chars)`);
  return true;
}

/**
 * Load current notes text from IndexedDB for a specific atom.
 */
export async function loadAtomNotes(atomSlug: string): Promise<string> {
  const atom = await getAtom(atomSlug);
  return atom?.notes || '';
}
```

**Create portfolio/src/components/NotesEditor.astro:**

```astro
---
/**
 * NotesEditor: Inline textarea for editing NOTES.md content on mobile.
 * Provides a simple editing experience with Save button.
 * Covers IDEA-04: quick-edit NOTES.md on mobile.
 */
export interface Props {
  atomSlug: string;
  initialNotes: string;
}

const { atomSlug, initialNotes } = Astro.props;
---

<div class="notes-editor" data-atom-slug={atomSlug}>
  <div class="notes-editor-header">
    <h3 class="notes-heading">Notes</h3>
    <div class="notes-mode-toggle">
      <button class="mode-btn active" id="view-mode-btn">View</button>
      <button class="mode-btn" id="edit-mode-btn">Edit</button>
    </div>
  </div>

  <!-- View mode (default) -->
  <div id="notes-view-mode" class="notes-view-mode">
    {initialNotes ? (
      <pre class="notes-content" id="notes-display">{initialNotes}</pre>
    ) : (
      <p class="notes-empty">No notes for this atom. Tap Edit to add some.</p>
    )}
  </div>

  <!-- Edit mode -->
  <div id="notes-edit-mode" class="notes-edit-mode" style="display: none;">
    <textarea
      id="notes-textarea"
      class="notes-textarea"
      rows="12"
      placeholder="Write your process notes here..."
    >{initialNotes}</textarea>
    <div class="notes-edit-actions">
      <button id="save-notes-btn" class="btn btn-primary" style="flex: 1;">Save</button>
      <button id="cancel-notes-btn" class="btn btn-secondary" style="flex: 1;">Cancel</button>
    </div>
    <div id="notes-save-status" class="notes-save-status" style="display: none;">
      Saved!
    </div>
  </div>
</div>

<script>
  import { saveAtomNotes, loadAtomNotes } from '../scripts/notes-editor';

  async function initNotesEditor() {
    const container = document.querySelector('.notes-editor') as HTMLElement;
    if (!container) return;

    const atomSlug = container.dataset.atomSlug || '';

    const viewModeBtn = document.getElementById('view-mode-btn')!;
    const editModeBtn = document.getElementById('edit-mode-btn')!;
    const viewMode = document.getElementById('notes-view-mode')!;
    const editMode = document.getElementById('notes-edit-mode')!;
    const textarea = document.getElementById('notes-textarea') as HTMLTextAreaElement;
    const saveBtn = document.getElementById('save-notes-btn')!;
    const cancelBtn = document.getElementById('cancel-notes-btn')!;
    const saveStatus = document.getElementById('notes-save-status')!;
    const notesDisplay = document.getElementById('notes-display');

    // Load latest notes from IndexedDB (may have been edited previously)
    const storedNotes = await loadAtomNotes(atomSlug);
    if (storedNotes) {
      textarea.value = storedNotes;
      if (notesDisplay) {
        notesDisplay.textContent = storedNotes;
      }
    }

    // Switch to edit mode
    editModeBtn.addEventListener('click', () => {
      viewMode.style.display = 'none';
      editMode.style.display = 'block';
      viewModeBtn.classList.remove('active');
      editModeBtn.classList.add('active');
      textarea.focus();
    });

    // Switch to view mode (cancel)
    function switchToViewMode() {
      editMode.style.display = 'none';
      viewMode.style.display = 'block';
      editModeBtn.classList.remove('active');
      viewModeBtn.classList.add('active');
    }

    cancelBtn.addEventListener('click', () => {
      // Revert textarea to last saved value
      const currentDisplay = notesDisplay?.textContent || '';
      textarea.value = currentDisplay;
      switchToViewMode();
    });

    // Save notes
    saveBtn.addEventListener('click', async () => {
      const newNotes = textarea.value;
      const success = await saveAtomNotes(atomSlug, newNotes);

      if (success) {
        // Update view mode display
        if (notesDisplay) {
          notesDisplay.textContent = newNotes;
        } else {
          // If there was no notes-display (was empty), recreate view
          viewMode.innerHTML = `<pre class="notes-content" id="notes-display">${escapeHtml(newNotes)}</pre>`;
        }

        // Show save confirmation
        saveStatus.style.display = 'block';
        setTimeout(() => {
          saveStatus.style.display = 'none';
        }, 2000);

        switchToViewMode();
      }
    });
  }

  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  initNotesEditor();
</script>

<style>
  .notes-editor {
    margin: 16px 0;
  }

  .notes-editor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }

  .notes-heading {
    font-size: 1rem;
    color: #fff;
    font-weight: 600;
  }

  .notes-mode-toggle {
    display: flex;
    gap: 0;
    border: 1px solid #333;
    border-radius: 6px;
    overflow: hidden;
  }

  .mode-btn {
    padding: 6px 14px;
    border: none;
    background: #1a1a1a;
    color: #666;
    font-size: 0.8rem;
    font-weight: 600;
    cursor: pointer;
    min-height: 36px;
  }

  .mode-btn.active {
    background: #333;
    color: #6bb5ff;
  }

  .mode-btn:active {
    background: #222;
  }

  .notes-content {
    padding: 16px;
    background: #151515;
    border-radius: 8px;
    font-size: 0.9rem;
    line-height: 1.6;
    color: #ccc;
    white-space: pre-wrap;
    word-wrap: break-word;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    max-height: 400px;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  .notes-empty {
    color: #555;
    font-size: 0.85rem;
    font-style: italic;
  }

  .notes-textarea {
    width: 100%;
    padding: 16px;
    font-size: 16px; /* Prevents iOS zoom */
    background: #151515;
    border: 1px solid #333;
    border-radius: 8px;
    color: #e0e0e0;
    resize: vertical;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.6;
    min-height: 200px;
  }

  .notes-textarea:focus {
    border-color: #6bb5ff;
    outline: none;
  }

  .notes-edit-actions {
    display: flex;
    gap: 12px;
    margin-top: 12px;
  }

  .notes-save-status {
    margin-top: 8px;
    padding: 8px;
    text-align: center;
    color: #6bff6b;
    font-size: 0.85rem;
    background: #1a2a1a;
    border-radius: 6px;
  }
</style>
```

**Update portfolio/src/pages/mobile/[slug].astro:**

Replace the NotesViewer import and usage with NotesEditor in the Notes tab:

1. Add import for NotesEditor in the frontmatter (alongside or replacing NotesViewer):
```javascript
import NotesEditor from '../../components/NotesEditor.astro';
```

2. Replace the Notes tab content:
```html
<!-- Notes tab -->
<div class="tab-content" id="tab-notes" style="display: none;">
  <NotesEditor atomSlug={atom.slug} initialNotes={atom.notes} />
</div>
```

This replaces the read-only NotesViewer with the NotesEditor which supports both view and edit modes. The NotesEditor defaults to view mode (same read-only display as before) but adds a View/Edit toggle in the header so users can switch to editing.

Note: Keep NotesViewer.astro as-is for potential use elsewhere. The NotesEditor component provides its own view mode, making NotesViewer redundant in the detail view but harmless to keep.
  </action>
  <verify>
1. portfolio/src/components/NotesEditor.astro exists with textarea and Save/Cancel buttons
2. portfolio/src/scripts/notes-editor.ts exists with saveAtomNotes and loadAtomNotes functions
3. Notes tab in atom detail view shows View/Edit toggle
4. Default state shows notes in read-only view mode
5. Tapping "Edit" switches to textarea with current notes content pre-filled
6. Editing text and tapping "Save" persists to IndexedDB atom record
7. After saving, view mode updates to show new content
8. "Cancel" reverts textarea to last saved content
9. "Saved!" confirmation appears briefly after successful save
10. Textarea uses 16px font (prevents iOS Safari zoom on focus)
11. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
NOTES.md inline editor created with View/Edit mode toggle. View mode displays read-only formatted text (same as previous NotesViewer). Edit mode provides textarea with Save/Cancel. Saves persist to IndexedDB atom notes field via notes-editor.ts helper. Integrated into atom detail Notes tab, replacing read-only NotesViewer. Covers IDEA-04: quick-edit NOTES.md on mobile.
  </done>
</task>

<task type="auto">
  <name>Task 5: Verify gallery and code viewer end-to-end</name>
  <files>
    (no new files -- verification task)
  </files>
  <action>
Verify the gallery and code viewer work correctly on mobile viewport and offline.

**Build and serve:**
```bash
cd portfolio && npm run build && npm run preview
```

**Verification checks:**

1. **Gallery page:**
   - Navigate to /mobile/gallery
   - Verify all atoms from atoms/ directory appear in the list
   - Verify atoms are sorted by date (newest first)
   - Verify each item shows title, date, type badge, and stage
   - Verify search input filters atoms in real-time
   - Search for a partial atom name — verify matching atoms show, others hide
   - Clear search — verify all atoms reappear

2. **Detail view:**
   - Tap any atom in the gallery
   - Verify URL is /mobile/<slug>
   - Verify back button goes to /mobile/gallery
   - Verify Code tab shows syntax-highlighted JavaScript
   - Verify Config tab shows formatted JSON
   - Verify Notes tab shows NOTES.md content with View/Edit toggle
   - Verify tab switching works (only one tab content visible at a time)

3. **NOTES.md editing (IDEA-04):**
   - On Notes tab, verify View/Edit toggle is visible
   - Tap "Edit" — textarea appears with current notes content
   - Edit the text, tap "Save" — "Saved!" confirmation appears
   - View mode updates to show new content
   - Tap "Edit" again, make changes, tap "Cancel" — textarea reverts to saved content
   - Reload the page, go to Notes tab — verify edited notes persist (from IndexedDB)
   - On an atom with no notes, verify "No notes" message and Edit button still works

4. **Mobile viewport:**
   - Use Chrome DevTools responsive mode at 375px width
   - Verify code wraps to screen width (no horizontal scroll)
   - Verify text is readable without zooming
   - Verify tap targets are at least 44px height
   - Verify tabs are full-width and easy to tap

5. **Offline:**
   - Visit /mobile/gallery once while online
   - Enable airplane mode (DevTools > Network > Offline)
   - Reload /mobile/gallery — should load from cache
   - Tap into an atom detail page — should load from cache
   - Code and notes should be visible offline

6. **IndexedDB:**
   - Check DevTools > Application > IndexedDB > eoe-atoms > atoms
   - Verify atom entries are populated with slug, code, notes, configJson
   - Edit notes on an atom and verify the notes field is updated in IndexedDB

If any check fails, fix before completing. Most likely issue: Prism.js not highlighting (check that client-side script runs after DOM is ready).
  </action>
  <verify>
1. Gallery shows all atoms sorted by date (newest first)
2. Search filters atoms by name in real-time
3. Detail view shows syntax-highlighted code
4. Tab navigation works (Code/Config/Notes)
5. Code wraps to mobile viewport width (no horizontal scroll)
6. Back button returns to gallery
7. Gallery loads offline after first visit
8. Detail pages load offline after first visit
9. IndexedDB contains atom metadata and code
10. All interactions work on 375px viewport
11. Notes tab shows View/Edit toggle with working inline editor
12. Notes editing saves to IndexedDB and persists across reloads
  </verify>
  <done>
Gallery and code viewer verified end-to-end: list view shows all atoms sorted by date, search filters in real-time, detail view displays syntax-highlighted code/config/notes with tab navigation, NOTES.md inline editor supports view/edit modes with IndexedDB persistence, mobile viewport shows wrapped code without horizontal scroll, offline access works after first visit via service worker cache + IndexedDB. MOB-01 (view code), MOB-02 (browse gallery), MOB-03 (view notes), IDEA-04 (quick-edit notes) functional.
  </done>
</task>

</tasks>

<verification>
1. /mobile/gallery page exists and shows all atoms in reverse chronological order
2. Search bar filters atoms by name as user types
3. /mobile/<slug> detail view shows code, config, and notes in tabbed interface
4. Prism.js syntax highlights JavaScript, JSON, and Markdown code
5. Code wraps to screen width on 375px mobile viewport (no horizontal scroll)
6. All content works offline after first visit
7. IndexedDB populated with atom metadata, code, notes, and config
8. Back navigation from detail to gallery works
9. Prism.js bundle stays under 10KB (only 3 languages imported)
10. Gallery page loads in under 2 seconds on simulated 3G connection
11. Notes tab shows View/Edit toggle; Edit mode provides textarea with Save/Cancel
12. Edited notes persist to IndexedDB and survive page reload
13. `npm run build` outputs atom-metadata.json in dist/ (build integration confirmed)
</verification>

<success_criteria>
- User can browse atom gallery on mobile at /mobile/gallery (MOB-02)
- User can search atoms by name with instant filtering (MOB-02)
- User can view syntax-highlighted atom code on mobile (MOB-01)
- User can view NOTES.md content on mobile (MOB-03)
- User can quick-edit NOTES.md via inline textarea with Save button (IDEA-04)
- Edited notes persist to IndexedDB across page reloads
- Code is readable on 6" phone screen (14px font, pre-wrap, no horizontal scroll)
- Gallery and detail views work offline after first visit
- All interactions work on 375px viewport with 44px touch targets
- Prism.js bundle is <10KB (JavaScript + JSON + Markdown only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-mobile-gallery-ideation-tools/04-02-SUMMARY.md`
</output>
