---
phase: 03-video-capture-distribution
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - package.json
  - cli/package.json
  - cli/index.js
  - cli/commands/auth.js
  - cli/commands/publish.js
  - lib/platforms/youtube-client.js
  - lib/platforms/tiktok-client.js
  - lib/platforms/oauth-manager.js
  - lib/platforms/index.js
  - lib/utils/retry.js
  - lib/utils/credentials.js
  - lib/utils/index.js
autonomous: true

must_haves:
  truths:
    - "User can run `eoe auth youtube` to authenticate with YouTube via OAuth2 browser flow"
    - "User can run `eoe auth tiktok` to authenticate with TikTok via OAuth2 browser flow"
    - "OAuth2 tokens (access + refresh) stored in ~/.eoe/credentials.json with restricted permissions"
    - "User can run `eoe publish <video.mp4> --platform youtube --title 'My Title'` to upload video"
    - "YouTube upload uses resumable upload protocol via googleapis library"
    - "TikTok upload uses two-step init + PUT via Content Posting API"
    - "Published URLs automatically appended to the atom's NOTES.md under a Published section"
    - "API failures retried 3 times with exponential backoff (0.5s, 1s, 2s)"
    - "Auth failures (401/403) NOT retried, user prompted to re-authenticate"
    - "Title is required for publish, description and tags are optional flags"
    - "`eoe capture` summary includes `Next: eoe publish` with suggested command (implemented in 03-02, verified here)"
  artifacts:
    - path: "cli/commands/auth.js"
      provides: "CLI command: eoe auth youtube|tiktok"
      contains: "authCommand"
    - path: "cli/commands/publish.js"
      provides: "CLI command: eoe publish <video> --platform --title"
      contains: "publishCommand"
    - path: "lib/platforms/youtube-client.js"
      provides: "YouTube Data API v3 upload wrapper"
      contains: "uploadToYouTube"
    - path: "lib/platforms/tiktok-client.js"
      provides: "TikTok Content Posting API upload wrapper"
      contains: "uploadToTikTok"
    - path: "lib/platforms/oauth-manager.js"
      provides: "OAuth2 token storage, refresh, and browser flow"
      contains: "getAuthUrl"
    - path: "lib/utils/retry.js"
      provides: "Exponential backoff retry wrapper"
      contains: "withRetry"
    - path: "lib/utils/credentials.js"
      provides: "File-based credential storage at ~/.eoe/credentials.json"
      contains: "loadCredentials"
  key_links:
    - from: "cli/commands/publish.js"
      to: "lib/platforms/youtube-client.js"
      via: "import uploadToYouTube"
      pattern: "import.*youtube"
    - from: "cli/commands/publish.js"
      to: "lib/platforms/tiktok-client.js"
      via: "import uploadToTikTok"
      pattern: "import.*tiktok"
    - from: "cli/commands/publish.js"
      to: "lib/utils/retry.js"
      via: "import withRetry"
      pattern: "import.*retry"
    - from: "cli/commands/auth.js"
      to: "lib/platforms/oauth-manager.js"
      via: "import getAuthUrl, exchangeCode"
      pattern: "import.*oauth"
    - from: "lib/platforms/youtube-client.js"
      to: "lib/utils/credentials.js"
      via: "import loadCredentials"
      pattern: "import.*credentials"
    - from: "lib/platforms/oauth-manager.js"
      to: "lib/utils/credentials.js"
      via: "import saveCredentials"
      pattern: "import.*credentials"
---

<objective>
Build the publishing pipeline for uploading captured videos to YouTube and TikTok, with OAuth2 authentication, credential storage, retry logic, and distribution tracking. After this plan, users can authenticate with platforms, upload videos via CLI, and track published URLs in atom NOTES.md files.

Purpose: This completes the creation-to-distribution pipeline. Users can now go from `eoe create` to `eoe capture` to `eoe publish` in a single workflow. The manual publishing experience will reveal pain points for future automation (per project constraint: "manual first, automate proven pain points").
Output: Working `eoe auth` and `eoe publish` CLI commands, YouTube and TikTok API clients, OAuth2 credential management, exponential backoff retry logic, and NOTES.md distribution tracking.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-video-capture-distribution/03-CONTEXT.md
@.planning/phases/03-video-capture-distribution/03-RESEARCH.md
@.planning/phases/03-video-capture-distribution/03-01-PLAN.md
@.planning/phases/03-video-capture-distribution/03-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install platform dependencies and create utility libraries</name>
  <files>
    package.json
    cli/package.json
    lib/utils/retry.js
    lib/utils/credentials.js
    lib/utils/index.js
  </files>
  <action>
Install googleapis and exponential-backoff as root dependencies. Add open (for opening browser during OAuth flow) to the CLI package.

**Update root package.json dependencies:**
```json
"dependencies": {
  "p5": "^2.2.0",
  "lil-gui": "^0.21.0",
  "tone": "^15.1.22",
  "fluent-ffmpeg": "^2.1.3",
  "ffmpeg-static": "^5.2.0",
  "googleapis": "^144.0.0",
  "exponential-backoff": "^3.1.1"
}
```

**Update cli/package.json dependencies:**
```json
"dependencies": {
  "commander": "^14.0.2",
  "fs-extra": "^11.0.0",
  "chalk": "^5.0.0",
  "tabtab": "^3.0.2",
  "open": "^10.0.0"
}
```

Run `npm install`.

**Create lib/utils/retry.js** -- Exponential backoff retry wrapper:

```javascript
import { backOff } from 'exponential-backoff';

/**
 * Execute a function with exponential backoff retry logic.
 * Retries on network/server errors only -- NOT on auth failures (401/403).
 *
 * @param {function} fn - Async function to execute
 * @param {object} options
 * @param {number} options.maxRetries - Maximum number of retry attempts (default: 3)
 * @param {number} options.startingDelay - Initial delay in ms (default: 500)
 * @param {function} options.onRetry - Callback on retry (error, attemptNumber)
 * @returns {Promise<any>} Result of fn()
 */
export async function withRetry(fn, options = {}) {
  const {
    maxRetries = 3,
    startingDelay = 500,
    onRetry
  } = options;

  return backOff(fn, {
    numOfAttempts: maxRetries,
    startingDelay,
    timeMultiple: 2,
    maxDelay: 8000,
    retry: (error, attemptNumber) => {
      // Never retry auth errors
      const status = error.response?.status || error.code;
      if (status === 401 || status === 403) {
        return false;
      }

      // Retry on network errors and server errors
      const retryable =
        error.code === 'ENOTFOUND' ||
        error.code === 'ETIMEDOUT' ||
        error.code === 'ECONNRESET' ||
        error.code === 'ECONNREFUSED' ||
        (error.response && error.response.status >= 500);

      if (retryable && onRetry) {
        onRetry(error, attemptNumber);
      }

      return retryable;
    }
  });
}

/**
 * Check if an error is an authentication error (not retryable).
 * @param {Error} error
 * @returns {boolean}
 */
export function isAuthError(error) {
  const status = error.response?.status || error.code;
  return status === 401 || status === 403;
}
```

**Create lib/utils/credentials.js** -- File-based credential storage:

```javascript
import fs from 'fs-extra';
import path from 'path';
import os from 'os';

const CREDENTIALS_DIR = path.join(os.homedir(), '.eoe');
const CREDENTIALS_FILE = path.join(CREDENTIALS_DIR, 'credentials.json');

/**
 * Load all stored credentials.
 * @returns {Promise<object>} Credentials object keyed by platform
 */
export async function loadCredentials() {
  try {
    if (await fs.pathExists(CREDENTIALS_FILE)) {
      return await fs.readJson(CREDENTIALS_FILE);
    }
  } catch (e) {
    // Corrupted file -- start fresh
  }
  return {};
}

/**
 * Load credentials for a specific platform.
 * @param {string} platform - Platform key ('youtube' or 'tiktok')
 * @returns {Promise<object|null>} Platform credentials or null
 */
export async function loadPlatformCredentials(platform) {
  const creds = await loadCredentials();
  return creds[platform] || null;
}

/**
 * Save credentials for a specific platform.
 * Merges with existing credentials (other platforms preserved).
 *
 * @param {string} platform - Platform key
 * @param {object} tokens - Token data to store
 */
export async function saveCredentials(platform, tokens) {
  await fs.ensureDir(CREDENTIALS_DIR);

  const creds = await loadCredentials();
  creds[platform] = {
    ...tokens,
    savedAt: new Date().toISOString()
  };

  await fs.writeJson(CREDENTIALS_FILE, creds, { spaces: 2 });

  // Restrict file permissions (owner read/write only)
  try {
    await fs.chmod(CREDENTIALS_FILE, 0o600);
  } catch (e) {
    // chmod may not work on all platforms (Windows)
  }
}

/**
 * Remove credentials for a specific platform.
 * @param {string} platform - Platform key
 */
export async function removeCredentials(platform) {
  const creds = await loadCredentials();
  delete creds[platform];
  await fs.writeJson(CREDENTIALS_FILE, creds, { spaces: 2 });
}

/**
 * Check if credentials exist for a platform.
 * @param {string} platform - Platform key
 * @returns {Promise<boolean>}
 */
export async function hasCredentials(platform) {
  const creds = await loadPlatformCredentials(platform);
  return creds !== null;
}

/**
 * Get the credentials file path (for display/debugging).
 * @returns {string}
 */
export function getCredentialsPath() {
  return CREDENTIALS_FILE;
}
```

**Create lib/utils/index.js** -- Barrel export:

```javascript
export { withRetry, isAuthError } from './retry.js';
export {
  loadCredentials,
  loadPlatformCredentials,
  saveCredentials,
  removeCredentials,
  hasCredentials,
  getCredentialsPath
} from './credentials.js';
```

After creating all files, run `npm install`.
  </action>
  <verify>
1. `npm install` completes with googleapis, exponential-backoff, open added
2. All lib/utils/ files exist: retry.js, credentials.js, index.js
3. `node -e "import('./lib/utils/index.js').then(m => console.log(Object.keys(m)))"` prints all exports
4. `node -e "import('./lib/utils/credentials.js').then(m => console.log(m.getCredentialsPath()))"` prints ~/.eoe/credentials.json path
5. `node -e "import('exponential-backoff').then(m => console.log(typeof m.backOff))"` confirms library loads
  </verify>
  <done>
Utility libraries created: retry.js with exponential backoff (3 retries, 500ms start, doubles each time, caps at 8s, skips auth errors), credentials.js with file-based storage at ~/.eoe/credentials.json (chmod 600, per-platform token storage, load/save/remove/check operations). googleapis and exponential-backoff installed. open package added to CLI for browser-based OAuth flows.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create platform API clients (YouTube and TikTok)</name>
  <files>
    lib/platforms/youtube-client.js
    lib/platforms/tiktok-client.js
    lib/platforms/oauth-manager.js
    lib/platforms/index.js
  </files>
  <action>
Create the platform API client wrappers for YouTube and TikTok.

**Create lib/platforms/oauth-manager.js** -- OAuth2 flow manager:

```javascript
import { google } from 'googleapis';
import http from 'http';
import { URL } from 'url';
import { saveCredentials, loadPlatformCredentials } from '../utils/credentials.js';

const YOUTUBE_SCOPES = ['https://www.googleapis.com/auth/youtube.upload'];
const REDIRECT_PORT = 8085;
const REDIRECT_URI = `http://localhost:${REDIRECT_PORT}/callback`;

/**
 * Create an OAuth2 client for YouTube.
 * Requires YOUTUBE_CLIENT_ID and YOUTUBE_CLIENT_SECRET environment variables,
 * or stored in ~/.eoe/credentials.json under 'youtube_app'.
 *
 * @returns {object} Google OAuth2 client
 */
export function createYouTubeOAuth2Client() {
  const clientId = process.env.YOUTUBE_CLIENT_ID;
  const clientSecret = process.env.YOUTUBE_CLIENT_SECRET;

  if (!clientId || !clientSecret) {
    throw new Error(
      'YouTube API credentials not found.\n' +
      'Set YOUTUBE_CLIENT_ID and YOUTUBE_CLIENT_SECRET environment variables.\n' +
      'Get credentials at: https://console.cloud.google.com/apis/credentials'
    );
  }

  return new google.auth.OAuth2(clientId, clientSecret, REDIRECT_URI);
}

/**
 * Generate YouTube OAuth2 authorization URL.
 * @param {object} oauth2Client - Google OAuth2 client
 * @returns {string} Authorization URL to open in browser
 */
export function getYouTubeAuthUrl(oauth2Client) {
  return oauth2Client.generateAuthUrl({
    access_type: 'offline',
    scope: YOUTUBE_SCOPES,
    prompt: 'consent' // Force consent to always get refresh_token
  });
}

/**
 * Start local HTTP server to receive OAuth2 callback, exchange code for tokens.
 * Opens browser to auth URL, waits for redirect with code, exchanges and stores tokens.
 *
 * @param {object} oauth2Client - Google OAuth2 client
 * @returns {Promise<object>} Token data { access_token, refresh_token, expiry_date }
 */
export async function executeYouTubeAuthFlow(oauth2Client) {
  const authUrl = getYouTubeAuthUrl(oauth2Client);

  return new Promise((resolve, reject) => {
    const server = http.createServer(async (req, res) => {
      try {
        const url = new URL(req.url, `http://localhost:${REDIRECT_PORT}`);
        if (url.pathname !== '/callback') {
          res.writeHead(404);
          res.end('Not found');
          return;
        }

        const code = url.searchParams.get('code');
        if (!code) {
          res.writeHead(400);
          res.end('No authorization code received');
          reject(new Error('No authorization code in callback'));
          return;
        }

        // Exchange code for tokens
        const { tokens } = await oauth2Client.getToken(code);
        oauth2Client.setCredentials(tokens);

        // Store tokens
        await saveCredentials('youtube', {
          access_token: tokens.access_token,
          refresh_token: tokens.refresh_token,
          expiry_date: tokens.expiry_date
        });

        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<html><body><h1>YouTube authentication successful!</h1><p>You can close this window.</p></body></html>');

        server.close();
        resolve(tokens);
      } catch (err) {
        res.writeHead(500);
        res.end('Authentication failed');
        server.close();
        reject(err);
      }
    });

    server.listen(REDIRECT_PORT, () => {
      // Return authUrl for the caller to open
      server._authUrl = authUrl;
    });

    server.on('error', reject);

    // Timeout after 2 minutes
    setTimeout(() => {
      server.close();
      reject(new Error('Authentication timed out (2 minutes). Try again.'));
    }, 120000);
  });
}

/**
 * Get an authenticated YouTube OAuth2 client.
 * Loads stored tokens if available, otherwise returns null.
 *
 * @returns {Promise<object|null>} Authenticated OAuth2 client or null
 */
export async function getAuthenticatedYouTubeClient() {
  const tokens = await loadPlatformCredentials('youtube');
  if (!tokens) return null;

  const oauth2Client = createYouTubeOAuth2Client();
  oauth2Client.setCredentials({
    access_token: tokens.access_token,
    refresh_token: tokens.refresh_token,
    expiry_date: tokens.expiry_date
  });

  // googleapis will auto-refresh if token is expired
  return oauth2Client;
}

/**
 * TikTok OAuth2 is simpler -- uses standard OAuth2 with PKCE.
 * For now, we store the access token directly.
 * TikTok tokens are obtained from developer portal.
 *
 * @returns {Promise<string|null>} TikTok access token or null
 */
export async function getTikTokAccessToken() {
  const tokens = await loadPlatformCredentials('tiktok');
  if (!tokens) return null;
  return tokens.access_token;
}
```

**Create lib/platforms/youtube-client.js** -- YouTube upload wrapper:

```javascript
import { google } from 'googleapis';
import fs from 'fs';
import path from 'path';
import { withRetry } from '../utils/retry.js';
import { getAuthenticatedYouTubeClient } from './oauth-manager.js';

/**
 * Upload a video to YouTube using the Data API v3.
 * Uses resumable upload protocol for reliability.
 *
 * @param {object} options
 * @param {string} options.videoPath - Path to MP4 video file
 * @param {string} options.title - Video title (required)
 * @param {string} options.description - Video description (optional)
 * @param {string[]} options.tags - Video tags (optional)
 * @param {string} options.privacyStatus - 'public', 'private', or 'unlisted' (default: 'public')
 * @param {string} options.thumbnailPath - Path to thumbnail image (optional)
 * @param {function} options.onProgress - Progress callback (bytesUploaded, totalBytes)
 * @returns {Promise<{videoId: string, url: string}>}
 */
export async function uploadToYouTube(options) {
  const {
    videoPath,
    title,
    description = '',
    tags = [],
    privacyStatus = 'public',
    thumbnailPath,
    onProgress
  } = options;

  // Get authenticated client
  const oauth2Client = await getAuthenticatedYouTubeClient();
  if (!oauth2Client) {
    throw new Error('Not authenticated with YouTube. Run `eoe auth youtube` first.');
  }

  const youtube = google.youtube({ version: 'v3', auth: oauth2Client });

  // Upload video with retry logic
  const response = await withRetry(
    async () => {
      return youtube.videos.insert({
        part: 'snippet,status',
        requestBody: {
          snippet: {
            title,
            description,
            tags,
            categoryId: '22' // People & Blogs (fits creative coding)
          },
          status: {
            privacyStatus
          }
        },
        media: {
          body: fs.createReadStream(videoPath)
        }
      });
    },
    {
      maxRetries: 3,
      onRetry: (error, attempt) => {
        if (onProgress) {
          onProgress(null, null, `Retry attempt ${attempt}: ${error.message}`);
        }
      }
    }
  );

  const videoId = response.data.id;
  const url = `https://www.youtube.com/watch?v=${videoId}`;

  // Upload custom thumbnail if provided
  if (thumbnailPath && await fs.promises.access(thumbnailPath).then(() => true).catch(() => false)) {
    try {
      await withRetry(async () => {
        return youtube.thumbnails.set({
          videoId,
          media: {
            body: fs.createReadStream(thumbnailPath)
          }
        });
      });
    } catch (err) {
      // Thumbnail upload is non-critical -- log but don't fail
      console.warn(`Warning: Thumbnail upload failed: ${err.message}`);
    }
  }

  return { videoId, url };
}
```

**Create lib/platforms/tiktok-client.js** -- TikTok upload wrapper:

```javascript
import fs from 'fs';
import { withRetry } from '../utils/retry.js';
import { getTikTokAccessToken } from './oauth-manager.js';

const TIKTOK_API_BASE = 'https://open.tiktokapis.com/v2';

/**
 * Upload a video to TikTok using the Content Posting API.
 * Two-step process: initialize upload, then PUT video to upload URL.
 *
 * Note: Videos from unverified API clients are private-only until audit approval.
 *
 * @param {object} options
 * @param {string} options.videoPath - Path to MP4 video file
 * @param {string} options.title - Video title/caption (required)
 * @param {string} options.privacyLevel - 'PUBLIC_TO_EVERYONE', 'SELF_ONLY', etc. (default: 'SELF_ONLY')
 * @param {number} options.coverTimestamp - Cover frame timestamp in ms (default: 1000)
 * @returns {Promise<{publishId: string, status: string}>}
 */
export async function uploadToTikTok(options) {
  const {
    videoPath,
    title,
    privacyLevel = 'SELF_ONLY', // Safe default until audit
    coverTimestamp = 1000
  } = options;

  const accessToken = await getTikTokAccessToken();
  if (!accessToken) {
    throw new Error('Not authenticated with TikTok. Run `eoe auth tiktok` first.');
  }

  const videoSize = fs.statSync(videoPath).size;

  // Step 1: Initialize upload
  const initResponse = await withRetry(async () => {
    const res = await fetch(`${TIKTOK_API_BASE}/post/publish/video/init/`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json; charset=UTF-8'
      },
      body: JSON.stringify({
        post_info: {
          title,
          privacy_level: privacyLevel,
          disable_duet: false,
          disable_comment: false,
          disable_stitch: false,
          video_cover_timestamp_ms: coverTimestamp
        },
        source_info: {
          source: 'FILE_UPLOAD',
          video_size: videoSize,
          chunk_size: videoSize, // Single chunk for small files
          total_chunk_count: 1
        }
      })
    });

    if (!res.ok) {
      const errorData = await res.json().catch(() => ({}));
      const error = new Error(`TikTok init failed: ${res.status} ${errorData.error?.message || res.statusText}`);
      error.response = { status: res.status };
      throw error;
    }

    return res.json();
  });

  const { publish_id, upload_url } = initResponse.data;

  // Step 2: Upload video to provided URL
  const videoBuffer = fs.readFileSync(videoPath);

  await withRetry(async () => {
    const res = await fetch(upload_url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'video/mp4',
        'Content-Length': String(videoBuffer.length)
      },
      body: videoBuffer
    });

    if (!res.ok) {
      const error = new Error(`TikTok upload failed: ${res.status} ${res.statusText}`);
      error.response = { status: res.status };
      throw error;
    }
  });

  return {
    publishId: publish_id,
    status: privacyLevel === 'SELF_ONLY' ? 'private (audit required for public)' : 'submitted'
  };
}
```

**Create lib/platforms/index.js** -- Barrel export:

```javascript
export { uploadToYouTube } from './youtube-client.js';
export { uploadToTikTok } from './tiktok-client.js';
export {
  createYouTubeOAuth2Client,
  getYouTubeAuthUrl,
  executeYouTubeAuthFlow,
  getAuthenticatedYouTubeClient,
  getTikTokAccessToken
} from './oauth-manager.js';
```
  </action>
  <verify>
1. `npm install` completes with googleapis, exponential-backoff, open installed
2. All lib/platforms/ files exist: youtube-client.js, tiktok-client.js, oauth-manager.js, index.js
3. `node -e "import('./lib/platforms/index.js').then(m => console.log(Object.keys(m)))"` prints all exports
4. `node -e "import('./lib/utils/retry.js').then(m => console.log(typeof m.withRetry))"` prints 'function'
5. `node -e "import('googleapis').then(m => console.log(typeof m.google.youtube))"` prints 'function'
  </verify>
  <done>
Platform API clients created: YouTube client with resumable upload via googleapis (video + optional thumbnail), TikTok client with two-step init+PUT upload, OAuth2 manager with local HTTP callback server for YouTube browser auth flow. All uploads wrapped in exponential backoff retry (3 attempts, skip 401/403). TikTok defaults to SELF_ONLY privacy until audit. Barrel export at lib/platforms/index.js.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create `eoe auth` and `eoe publish` CLI commands</name>
  <files>
    cli/commands/auth.js
    cli/commands/publish.js
    cli/index.js
  </files>
  <action>
Create the auth and publish CLI commands for platform authentication and video uploading.

**Create cli/commands/auth.js:**

```javascript
import { Command } from 'commander';
import chalk from 'chalk';

export const authCommand = new Command('auth')
  .argument('<platform>', 'Platform to authenticate with (youtube, tiktok)')
  .description('Authenticate with a publishing platform')
  .action(async (platform) => {
    const validPlatforms = ['youtube', 'tiktok'];
    if (!validPlatforms.includes(platform)) {
      console.error(chalk.red(`Platform "${platform}" not supported. Available: ${validPlatforms.join(', ')}`));
      process.exit(1);
    }

    if (platform === 'youtube') {
      await authYouTube();
    } else if (platform === 'tiktok') {
      await authTikTok();
    }
  });

async function authYouTube() {
  try {
    const { createYouTubeOAuth2Client, executeYouTubeAuthFlow, getYouTubeAuthUrl } = await import('../../lib/platforms/oauth-manager.js');

    console.log(chalk.blue('Authenticating with YouTube...'));
    console.log(chalk.gray('A browser window will open for you to grant access.\n'));

    const oauth2Client = createYouTubeOAuth2Client();
    const authUrl = getYouTubeAuthUrl(oauth2Client);

    console.log(chalk.gray(`If the browser doesn't open, visit this URL:\n${authUrl}\n`));

    // Open browser
    const open = (await import('open')).default;
    await open(authUrl);

    // Wait for callback
    const tokens = await executeYouTubeAuthFlow(oauth2Client);

    console.log(chalk.green('\nYouTube authentication successful!'));
    console.log(chalk.gray('Credentials saved. You can now use `eoe publish`.'));

  } catch (err) {
    if (err.message.includes('YOUTUBE_CLIENT_ID')) {
      console.error(chalk.red('\nYouTube API credentials not configured.'));
      console.error(chalk.gray('1. Go to https://console.cloud.google.com/apis/credentials'));
      console.error(chalk.gray('2. Create an OAuth 2.0 Client ID'));
      console.error(chalk.gray('3. Set environment variables:'));
      console.error(chalk.gray('   export YOUTUBE_CLIENT_ID="your-client-id"'));
      console.error(chalk.gray('   export YOUTUBE_CLIENT_SECRET="your-client-secret"'));
    } else {
      console.error(chalk.red(`\nAuthentication failed: ${err.message}`));
    }
    process.exit(1);
  }
}

async function authTikTok() {
  // TikTok auth is more manual due to API complexity
  // For now, accept a token directly
  console.log(chalk.blue('TikTok Authentication Setup'));
  console.log();
  console.log(chalk.gray('TikTok requires developer app registration:'));
  console.log(chalk.gray('1. Go to https://developers.tiktok.com/'));
  console.log(chalk.gray('2. Create an app with Content Posting API scope'));
  console.log(chalk.gray('3. Complete OAuth flow to get access token'));
  console.log(chalk.gray('4. Run: eoe auth tiktok --token <your-access-token>'));
  console.log();
  console.log(chalk.yellow('Note: Videos from unverified apps are private-only until audit approval.'));

  // Check if --token flag was passed (Commander doesn't support this natively on the parent,
  // so we check process.argv directly)
  const tokenIdx = process.argv.indexOf('--token');
  if (tokenIdx !== -1 && process.argv[tokenIdx + 1]) {
    const token = process.argv[tokenIdx + 1];
    const { saveCredentials } = await import('../../lib/utils/credentials.js');
    await saveCredentials('tiktok', { access_token: token });
    console.log(chalk.green('\nTikTok token saved successfully!'));
    console.log(chalk.gray('You can now use `eoe publish --platform tiktok`.'));
  }
}
```

**Create cli/commands/publish.js:**

```javascript
import { Command } from 'commander';
import path from 'path';
import fs from 'fs-extra';
import chalk from 'chalk';
import { resolveAtomPath } from '../lib/resolve-atom.js';

export const publishCommand = new Command('publish')
  .argument('<video>', 'Path to video file (e.g., videos/youtube/2026-01-30-my-sketch.mp4)')
  .requiredOption('-p, --platform <platform>', 'Target platform (youtube, tiktok)')
  .requiredOption('-t, --title <title>', 'Video title')
  .option('--description <text>', 'Video description')
  .option('--tags <tags>', 'Comma-separated tags', '')
  .option('--thumbnail <path>', 'Path to thumbnail image')
  .option('--privacy <status>', 'Privacy status (public, private, unlisted)', 'public')
  .option('--atom <name>', 'Atom name (for NOTES.md tracking)')
  .description('Publish a video to a platform')
  .action(async (videoArg, options) => {
    const videoPath = path.resolve(videoArg);

    // Validate video file exists
    if (!await fs.pathExists(videoPath)) {
      console.error(chalk.red(`Video file not found: ${videoPath}`));
      process.exit(1);
    }

    // Validate platform
    const validPlatforms = ['youtube', 'tiktok'];
    if (!validPlatforms.includes(options.platform)) {
      console.error(chalk.red(`Platform "${options.platform}" not supported. Available: ${validPlatforms.join(', ')}`));
      process.exit(1);
    }

    // Check authentication
    const { hasCredentials } = await import('../../lib/utils/credentials.js');
    if (!await hasCredentials(options.platform)) {
      console.error(chalk.red(`Not authenticated with ${options.platform}.`));
      console.error(chalk.gray(`Run: eoe auth ${options.platform}`));
      process.exit(1);
    }

    const tags = options.tags ? options.tags.split(',').map(t => t.trim()).filter(Boolean) : [];
    const fileSizeMB = ((await fs.stat(videoPath)).size / (1024 * 1024)).toFixed(2);

    console.log(chalk.blue(`Publishing to ${options.platform}...`));
    console.log(chalk.gray(`  Video: ${videoPath} (${fileSizeMB} MB)`));
    console.log(chalk.gray(`  Title: ${options.title}`));
    if (options.description) console.log(chalk.gray(`  Description: ${options.description.substring(0, 80)}...`));
    if (tags.length) console.log(chalk.gray(`  Tags: ${tags.join(', ')}`));
    console.log(chalk.gray(`  Privacy: ${options.privacy}`));
    console.log();

    try {
      let result;

      if (options.platform === 'youtube') {
        const { uploadToYouTube } = await import('../../lib/platforms/youtube-client.js');
        result = await uploadToYouTube({
          videoPath,
          title: options.title,
          description: options.description || '',
          tags,
          privacyStatus: options.privacy,
          thumbnailPath: options.thumbnail ? path.resolve(options.thumbnail) : undefined,
          onProgress: (uploaded, total, message) => {
            if (message) {
              console.log(chalk.yellow(`  ${message}`));
            }
          }
        });

        console.log(chalk.green(`\nPublished to YouTube!`));
        console.log(chalk.gray(`  Video ID: ${result.videoId}`));
        console.log(chalk.blue(`  URL: ${result.url}`));

      } else if (options.platform === 'tiktok') {
        const { uploadToTikTok } = await import('../../lib/platforms/tiktok-client.js');
        result = await uploadToTikTok({
          videoPath,
          title: options.title,
          privacyLevel: options.privacy === 'public' ? 'PUBLIC_TO_EVERYONE' : 'SELF_ONLY'
        });

        console.log(chalk.green(`\nPublished to TikTok!`));
        console.log(chalk.gray(`  Publish ID: ${result.publishId}`));
        console.log(chalk.gray(`  Status: ${result.status}`));
      }

      // Track in NOTES.md if atom specified or derivable from video path
      const atomName = options.atom || deriveAtomName(videoPath);
      if (atomName) {
        await trackPublication(atomName, options.platform, result);
      }

    } catch (err) {
      const { isAuthError } = await import('../../lib/utils/retry.js');
      if (isAuthError(err)) {
        console.error(chalk.red(`\nAuthentication expired or revoked.`));
        console.error(chalk.gray(`Run: eoe auth ${options.platform}`));
      } else {
        console.error(chalk.red(`\nPublish failed: ${err.message}`));
      }
      process.exit(1);
    }
  });

/**
 * Derive atom name from video file path.
 * e.g., videos/youtube/2026-01-30-my-sketch.mp4 -> 2026-01-30-my-sketch
 */
function deriveAtomName(videoPath) {
  const basename = path.basename(videoPath, path.extname(videoPath));
  // Check if this corresponds to an atom
  const atomPath = path.resolve('atoms', basename);
  // Return the basename as potential atom name (will be validated in trackPublication)
  return basename;
}

/**
 * Append publication record to atom's NOTES.md.
 * Creates a "## Published" section if it doesn't exist.
 */
async function trackPublication(atomName, platform, result) {
  // Try to resolve atom path
  const atomResult = await resolveAtomPath(atomName);
  if (atomResult.error) return; // Silently skip if atom not found

  const notesPath = path.join(atomResult.path, 'NOTES.md');
  if (!await fs.pathExists(notesPath)) return;

  let content = await fs.readFile(notesPath, 'utf8');
  const timestamp = new Date().toISOString().replace('T', ' ').split('.')[0];

  // Build publication entry
  let entry;
  if (platform === 'youtube') {
    entry = `- **YouTube:** ${result.url} (${timestamp})`;
  } else if (platform === 'tiktok') {
    entry = `- **TikTok:** publish_id:${result.publishId} (${timestamp})`;
  }

  // Find or create Published section
  if (content.includes('## Published')) {
    // Append to existing Published section
    content = content.replace('## Published\n', `## Published\n${entry}\n`);
  } else {
    // Add Published section before Session Log
    if (content.includes('## Session Log')) {
      content = content.replace('## Session Log', `## Published\n${entry}\n\n## Session Log`);
    } else {
      // Append to end
      content += `\n## Published\n${entry}\n`;
    }
  }

  await fs.writeFile(notesPath, content);
  console.log(chalk.gray(`\n  Tracked in ${notesPath}`));
}
```

**Update cli/index.js** -- Register auth and publish commands:

Add to the imports:
```javascript
import { authCommand } from './commands/auth.js';
import { publishCommand } from './commands/publish.js';
```

Add to the program commands:
```javascript
program.addCommand(authCommand);
program.addCommand(publishCommand);
```
  </action>
  <verify>
1. `eoe auth --help` shows usage
2. `eoe auth youtube` attempts YouTube OAuth flow (will fail without credentials, but runs)
3. `eoe auth tiktok` displays TikTok setup instructions
4. `eoe auth tiktok --token test-token` saves token to ~/.eoe/credentials.json
5. `eoe publish --help` shows usage with --platform, --title, --description, --tags
6. `eoe publish nonexistent.mp4 --platform youtube --title "Test"` shows "file not found" error
7. `eoe publish video.mp4 --platform invalid --title "Test"` shows "not supported" error
8. `eoe publish video.mp4 --platform youtube --title "Test"` without auth shows "Not authenticated" error
9. Command structure follows existing CLI patterns (Commander, chalk, resolveAtomPath)
  </verify>
  <done>
CLI auth and publish commands created. `eoe auth youtube` runs OAuth2 browser flow with local callback server, saves tokens to ~/.eoe/credentials.json. `eoe auth tiktok` provides setup instructions with --token flag for manual token entry. `eoe publish` uploads video to specified platform with required title, optional description/tags/thumbnail/privacy, retry logic, and NOTES.md tracking of published URLs. Auth errors prompt re-authentication.
  </done>
</task>

<task type="auto">
  <name>Task 4: Verify full creation-to-distribution pipeline end-to-end</name>
  <files>
    (no new files -- verification task only)
  </files>
  <action>
Verify the complete creation-to-distribution pipeline end-to-end. This task performs NO file modifications -- all capture.js changes (encoding integration and publish guidance) were consolidated in Plan 03-02 Task 2. This task purely validates that the full pipeline works correctly.

**Full Pipeline Verification:**

1. **Create:** `eoe create visual pipeline-test`
2. **Dev (optional):** `eoe dev pipeline-test` -- verify it runs
3. **Capture:** `eoe capture pipeline-test --duration 5`
   - Verify master WebM created in videos/masters/
   - Verify YouTube MP4 created (1920x1080) in videos/youtube/
   - Verify TikTok MP4 created (1080x1920) in videos/tiktok/
   - Verify thumbnails extracted (1s, 2s, best) in videos/thumbnails/
   - Verify publish guidance printed (shows suggested `eoe publish` commands)
4. **Auth (dry run):** `eoe auth youtube` -- verify it attempts OAuth flow
5. **Publish (dry run):** Without real credentials, verify error handling:
   - `eoe publish videos/youtube/<atom>.mp4 --platform youtube --title "Test"` shows auth error
6. **NOTES.md tracking:** Verify the NOTES.md tracking function correctly finds or creates Published section
7. **Retry logic:** Verify withRetry handles network errors (3 retries) and skips auth errors (401/403)

**Error Path Tests:**
8. `eoe capture nonexistent` -- verify clean "not found" error
9. `eoe publish missing.mp4 --platform youtube --title "Test"` -- verify clean "file not found" error
10. `eoe auth invalid-platform` -- verify clean "not supported" error

**Clean up test atom and outputs after verification:**
```bash
rm -rf atoms/YYYY-MM-DD-pipeline-test
rm -rf videos/masters/YYYY-MM-DD-pipeline-test.webm
rm -rf videos/youtube/YYYY-MM-DD-pipeline-test.mp4
rm -rf videos/tiktok/YYYY-MM-DD-pipeline-test.mp4
rm -rf videos/thumbnails/YYYY-MM-DD-pipeline-test-*.jpg
```
  </action>
  <verify>
1. Full pipeline runs: create -> capture -> (auth) -> (publish)
2. `eoe capture` output includes publish command suggestions (from 03-02 integration)
3. All CLI commands have proper help text and error handling
4. Error messages are clear and actionable
5. NOTES.md tracking function correctly finds Published section or creates one
6. Auth errors prompt re-authentication (not retry)
7. Network errors retry 3 times with backoff
8. All new commands registered in cli/index.js
9. No file modifications made during this task -- purely verification
  </verify>
  <done>
Full creation-to-distribution pipeline verified end-to-end. Capture produces master WebM + encoded MP4s + thumbnails + publish guidance in a single run. Auth and publish commands handle errors cleanly. NOTES.md tracks published URLs. Retry logic skips auth errors, retries network errors 3 times. Complete CLI workflow: create -> dev -> capture -> auth -> publish.
  </done>
</task>

</tasks>

<verification>
1. `npm install` succeeds with googleapis, exponential-backoff, open
2. `eoe auth youtube` runs OAuth2 browser flow with callback server
3. `eoe auth tiktok --token <token>` saves token to ~/.eoe/credentials.json
4. `eoe publish <video> --platform youtube --title "Title"` uploads to YouTube
5. `eoe publish <video> --platform tiktok --title "Title"` uploads to TikTok
6. Published URLs tracked in atom NOTES.md under Published section
7. API failures retried 3 times with exponential backoff (0.5s, 1s, 2s)
8. Auth failures (401/403) not retried, prompt re-authentication
9. Credentials stored at ~/.eoe/credentials.json with chmod 600
10. `eoe capture` output includes publish command suggestions
</verification>

<success_criteria>
- `eoe auth youtube` completes OAuth2 flow and stores tokens (CLI-04 complete)
- `eoe auth tiktok` stores access token for API use
- `eoe publish` uploads to YouTube via googleapis with resumable upload
- `eoe publish` uploads to TikTok via Content Posting API two-step flow
- Title required, description/tags optional for publish
- Published URLs appended to atom NOTES.md under Published section
- Retry 3x with exponential backoff on network/server errors
- Auth errors (401/403) caught and prompt re-authentication
- Credentials at ~/.eoe/credentials.json with restricted permissions
- TikTok defaults to SELF_ONLY privacy (audit requirement documented)
- Full pipeline: create -> capture -> auth -> publish works end-to-end
- Complete Phase 3: VID-01, VID-02, VID-03, VID-04, CLI-04 all delivered
</success_criteria>

<output>
After completion, create `.planning/phases/03-video-capture-distribution/03-03-SUMMARY.md`
</output>
