---
phase: 03-video-capture-distribution
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - package.json
  - lib/encoding/ffmpeg-encoder.js
  - lib/encoding/aspect-ratio.js
  - lib/encoding/thumbnail.js
  - lib/encoding/index.js
  - cli/commands/capture.js
autonomous: true

must_haves:
  truths:
    - "Master WebM automatically encoded to YouTube 16:9 MP4 (1920x1080, H.264 High, AAC) after capture"
    - "Master WebM automatically encoded to TikTok 9:16 MP4 (1080x1920, H.264 High, AAC) after capture"
    - "800x800 canvas centered with black letterbox/pillarbox bars (no stretching or distortion)"
    - "Three thumbnails extracted from captured video at 1s, 5s, and duration/2 timestamps"
    - "Thumbnails saved as JPEG at native resolution with quality level 2"
    - "Output files organized: videos/youtube/<atom>.mp4, videos/tiktok/<atom>.mp4, videos/thumbnails/<atom>-*.jpg"
    - "FFmpeg encoding uses -pix_fmt yuv420p and -movflags +faststart for maximum platform compatibility"
    - "fluent-ffmpeg wraps all FFmpeg operations (no manual CLI string construction)"
    - "ffmpeg-static provides bundled FFmpeg binary (no system dependency required)"
    - "`eoe capture` command produces master + encoded + thumbnails in a single run, with publish guidance showing next step"
  artifacts:
    - path: "lib/encoding/ffmpeg-encoder.js"
      provides: "FFmpeg encoding to YouTube and TikTok formats"
      contains: "encodeForYouTube"
    - path: "lib/encoding/aspect-ratio.js"
      provides: "Aspect ratio conversion with letterbox/pillarbox"
      contains: "getVideoFilters"
    - path: "lib/encoding/thumbnail.js"
      provides: "Thumbnail extraction at specific timestamps"
      contains: "extractThumbnails"
    - path: "lib/encoding/index.js"
      provides: "Barrel export for encoding library"
      contains: "encodeForYouTube"
  key_links:
    - from: "cli/commands/capture.js"
      to: "lib/encoding/ffmpeg-encoder.js"
      via: "import encodeForAllPlatforms"
      pattern: "import.*encoder"
    - from: "cli/commands/capture.js"
      to: "lib/encoding/thumbnail.js"
      via: "import extractThumbnails"
      pattern: "import.*thumbnail"
    - from: "lib/encoding/ffmpeg-encoder.js"
      to: "lib/encoding/aspect-ratio.js"
      via: "import getVideoFilters"
      pattern: "import.*aspect"
---

<objective>
Add FFmpeg-based video encoding and thumbnail extraction to the capture pipeline. After this plan, `eoe capture` produces not just a master WebM but also YouTube-ready 16:9 MP4, TikTok-ready 9:16 MP4, and three thumbnail images -- all from a single command.

Purpose: Raw WebM master files cannot be uploaded to platforms directly. YouTube and TikTok require specific aspect ratios, codecs (H.264), and containers (MP4). This plan bridges the gap between capture and publishing. Thumbnails are required for platform uploads and portfolio display.
Output: FFmpeg encoding library with platform profiles, aspect ratio handling, thumbnail extraction, and integrated `eoe capture` command that produces all outputs.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-video-capture-distribution/03-CONTEXT.md
@.planning/phases/03-video-capture-distribution/03-RESEARCH.md
@.planning/phases/03-video-capture-distribution/03-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install FFmpeg dependencies and create encoding library</name>
  <files>
    package.json
    lib/encoding/aspect-ratio.js
    lib/encoding/ffmpeg-encoder.js
    lib/encoding/thumbnail.js
    lib/encoding/index.js
  </files>
  <action>
Install fluent-ffmpeg and ffmpeg-static as root dependencies. ffmpeg-static bundles the FFmpeg binary so users don't need to install FFmpeg system-wide.

**Update root package.json dependencies:**
```json
"dependencies": {
  "p5": "^2.2.0",
  "lil-gui": "^0.21.0",
  "tone": "^15.1.22",
  "fluent-ffmpeg": "^2.1.3",
  "ffmpeg-static": "^5.2.0"
}
```

Run `npm install`.

**Create lib/encoding/aspect-ratio.js** -- Aspect ratio conversion utilities:

```javascript
/**
 * Aspect ratio utilities for platform-specific video encoding.
 * All atoms are 800x800 (1:1). Platforms need different aspect ratios:
 *   YouTube: 16:9 (1920x1080) - atom centered with black letterbox bars top/bottom
 *   TikTok:  9:16 (1080x1920) - atom centered with black pillarbox bars top/bottom
 *
 * Strategy: Use FFmpeg scale filter to fit within target, then pad to exact dimensions.
 * Never stretch or crop -- always preserve original content with black bars.
 */

/**
 * Platform encoding profiles.
 */
export const PLATFORMS = {
  youtube: {
    width: 1920,
    height: 1080,
    name: 'YouTube',
    aspect: '16:9'
  },
  tiktok: {
    width: 1080,
    height: 1920,
    name: 'TikTok',
    aspect: '9:16'
  }
};

/**
 * Get FFmpeg video filter string for scaling + padding to target dimensions.
 * Uses force_original_aspect_ratio=decrease to fit within bounds,
 * then pads to exact dimensions with black bars centered.
 *
 * @param {object} platform - Platform profile from PLATFORMS
 * @returns {string[]} Array of FFmpeg video filter strings
 */
export function getVideoFilters(platform) {
  const { width, height } = platform;
  return [
    `scale=${width}:${height}:force_original_aspect_ratio=decrease`,
    `pad=${width}:${height}:(ow-iw)/2:(oh-ih)/2:black`
  ];
}

/**
 * Get the subdirectory name for a platform's output files.
 * @param {string} platformKey - Key from PLATFORMS (e.g., 'youtube', 'tiktok')
 * @returns {string} Directory name
 */
export function getPlatformDir(platformKey) {
  return platformKey; // 'youtube' or 'tiktok'
}
```

**Create lib/encoding/ffmpeg-encoder.js** -- FFmpeg encoding functions:

```javascript
import ffmpeg from 'fluent-ffmpeg';
import ffmpegStatic from 'ffmpeg-static';
import path from 'path';
import fs from 'fs-extra';
import { PLATFORMS, getVideoFilters } from './aspect-ratio.js';

// Configure fluent-ffmpeg to use bundled FFmpeg binary
ffmpeg.setFfmpegPath(ffmpegStatic);

/**
 * Encode a master video for a specific platform profile.
 *
 * @param {string} masterPath - Path to master WebM file
 * @param {string} outputPath - Path for output MP4 file
 * @param {string} platformKey - Platform key ('youtube' or 'tiktok')
 * @param {function} onProgress - Optional progress callback (percent: number)
 * @returns {Promise<{outputPath: string, fileSize: number}>}
 */
export async function encodeForPlatform(masterPath, outputPath, platformKey, onProgress) {
  const platform = PLATFORMS[platformKey];
  if (!platform) {
    throw new Error(`Unknown platform: ${platformKey}. Available: ${Object.keys(PLATFORMS).join(', ')}`);
  }

  // Ensure output directory exists
  await fs.ensureDir(path.dirname(outputPath));

  const filters = getVideoFilters(platform);

  return new Promise((resolve, reject) => {
    let command = ffmpeg(masterPath)
      .videoCodec('libx264')
      .audioCodec('aac')
      .audioBitrate('128k')
      .outputOptions([
        '-profile:v high',
        '-level 4.2',
        '-preset slow',
        '-crf 23',
        '-movflags +faststart',
        '-pix_fmt yuv420p',
        '-bf 2',
        '-g 48'
      ])
      .videoFilters(filters)
      .output(outputPath);

    if (onProgress) {
      command = command.on('progress', (progress) => {
        if (progress.percent) {
          onProgress(Math.round(progress.percent));
        }
      });
    }

    command
      .on('end', async () => {
        const stat = await fs.stat(outputPath);
        resolve({
          outputPath,
          fileSize: stat.size
        });
      })
      .on('error', (err) => {
        reject(new Error(`FFmpeg encoding failed for ${platform.name}: ${err.message}`));
      })
      .run();
  });
}

/**
 * Encode master video for YouTube (16:9, 1920x1080).
 *
 * @param {string} masterPath - Path to master WebM file
 * @param {string} outputDir - Base output directory (videos/youtube/ will be used)
 * @param {string} atomName - Atom name for output filename
 * @param {function} onProgress - Optional progress callback
 * @returns {Promise<{outputPath: string, fileSize: number}>}
 */
export async function encodeForYouTube(masterPath, outputDir, atomName, onProgress) {
  const outputPath = path.join(outputDir, 'youtube', `${atomName}.mp4`);
  return encodeForPlatform(masterPath, outputPath, 'youtube', onProgress);
}

/**
 * Encode master video for TikTok (9:16, 1080x1920).
 *
 * @param {string} masterPath - Path to master WebM file
 * @param {string} outputDir - Base output directory (videos/tiktok/ will be used)
 * @param {string} atomName - Atom name for output filename
 * @param {function} onProgress - Optional progress callback
 * @returns {Promise<{outputPath: string, fileSize: number}>}
 */
export async function encodeForTikTok(masterPath, outputDir, atomName, onProgress) {
  const outputPath = path.join(outputDir, 'tiktok', `${atomName}.mp4`);
  return encodeForPlatform(masterPath, outputPath, 'tiktok', onProgress);
}

/**
 * Encode master video for all supported platforms.
 *
 * @param {string} masterPath - Path to master WebM file
 * @param {string} outputDir - Base output directory
 * @param {string} atomName - Atom name for output filenames
 * @param {function} onProgress - Optional progress callback (platform: string, percent: number)
 * @returns {Promise<Array<{platform: string, outputPath: string, fileSize: number}>>}
 */
export async function encodeForAllPlatforms(masterPath, outputDir, atomName, onProgress) {
  const results = [];

  for (const [platformKey, platform] of Object.entries(PLATFORMS)) {
    const progressCb = onProgress
      ? (percent) => onProgress(platform.name, percent)
      : undefined;

    const result = await encodeForPlatform(
      masterPath,
      path.join(outputDir, platformKey, `${atomName}.mp4`),
      platformKey,
      progressCb
    );

    results.push({
      platform: platform.name,
      aspect: platform.aspect,
      ...result
    });
  }

  return results;
}
```

**Create lib/encoding/thumbnail.js** -- Thumbnail extraction:

```javascript
import ffmpeg from 'fluent-ffmpeg';
import ffmpegStatic from 'ffmpeg-static';
import path from 'path';
import fs from 'fs-extra';

// Configure fluent-ffmpeg to use bundled FFmpeg binary
ffmpeg.setFfmpegPath(ffmpegStatic);

/**
 * Extract thumbnail images from a video at specific timestamps.
 * Default timestamps: 1s, 5s, and duration/2 (midpoint).
 *
 * @param {string} videoPath - Path to video file
 * @param {string} outputDir - Directory for thumbnail output (videos/thumbnails/)
 * @param {string} atomName - Atom name for output filenames
 * @param {object} options
 * @param {number[]} options.timestamps - Timestamps in seconds to extract (default: [1, 5, midpoint])
 * @param {number} options.duration - Video duration in seconds (for midpoint calculation)
 * @returns {Promise<string[]>} Array of output thumbnail paths
 */
export async function extractThumbnails(videoPath, outputDir, atomName, options = {}) {
  const { duration = 10 } = options;
  const timestamps = options.timestamps || [1, 5, Math.floor(duration / 2)];

  // Ensure thumbnails directory exists
  const thumbDir = path.join(outputDir, 'thumbnails');
  await fs.ensureDir(thumbDir);

  const outputPaths = [];

  for (const timestamp of timestamps) {
    // Skip timestamps beyond video duration
    if (timestamp > duration) continue;

    const outputPath = path.join(thumbDir, `${atomName}-${timestamp}s.jpg`);

    await new Promise((resolve, reject) => {
      ffmpeg(videoPath)
        .seekInput(timestamp)
        .outputOptions([
          '-frames:v 1',
          '-q:v 2'
        ])
        .output(outputPath)
        .on('end', resolve)
        .on('error', (err) => {
          reject(new Error(`Thumbnail extraction failed at ${timestamp}s: ${err.message}`));
        })
        .run();
    });

    outputPaths.push(outputPath);
  }

  return outputPaths;
}

/**
 * Extract the "best" thumbnail using FFmpeg's thumbnail filter.
 * Analyzes frames to find the most representative one.
 *
 * @param {string} videoPath - Path to video file
 * @param {string} outputDir - Directory for thumbnail output
 * @param {string} atomName - Atom name for output filename
 * @returns {Promise<string>} Path to extracted thumbnail
 */
export async function extractBestThumbnail(videoPath, outputDir, atomName) {
  const thumbDir = path.join(outputDir, 'thumbnails');
  await fs.ensureDir(thumbDir);

  const outputPath = path.join(thumbDir, `${atomName}-best.jpg`);

  await new Promise((resolve, reject) => {
    ffmpeg(videoPath)
      .outputOptions([
        '-vf', 'thumbnail=300',
        '-frames:v 1',
        '-q:v 2'
      ])
      .output(outputPath)
      .on('end', resolve)
      .on('error', (err) => {
        reject(new Error(`Best thumbnail extraction failed: ${err.message}`));
      })
      .run();
  });

  return outputPath;
}
```

**Create lib/encoding/index.js** -- Barrel export:

```javascript
export { encodeForYouTube, encodeForTikTok, encodeForAllPlatforms, encodeForPlatform } from './ffmpeg-encoder.js';
export { extractThumbnails, extractBestThumbnail } from './thumbnail.js';
export { PLATFORMS, getVideoFilters, getPlatformDir } from './aspect-ratio.js';
```

After creating all files, run `npm install`.
  </action>
  <verify>
1. `npm install` completes with fluent-ffmpeg and ffmpeg-static installed
2. All lib/encoding/ files exist: ffmpeg-encoder.js, aspect-ratio.js, thumbnail.js, index.js
3. `node -e "import('ffmpeg-static').then(m => console.log(m.default))"` prints path to FFmpeg binary
4. `node -e "import('./lib/encoding/index.js').then(m => console.log(Object.keys(m)))"` prints all exports
5. `node -e "import('./lib/encoding/aspect-ratio.js').then(m => console.log(JSON.stringify(m.PLATFORMS)))"` prints platform profiles
  </verify>
  <done>
FFmpeg encoding library created at lib/encoding/ with: platform profiles (YouTube 1920x1080 16:9, TikTok 1080x1920 9:16), aspect ratio utilities (scale+pad filters, no stretching), H.264 High encoding with AAC audio and faststart, thumbnail extraction at specific timestamps and FFmpeg thumbnail filter for "best" frame. ffmpeg-static bundled so no system FFmpeg required.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate encoding, thumbnails, and publish guidance into `eoe capture` command</name>
  <files>
    cli/commands/capture.js
  </files>
  <action>
Extend the existing `eoe capture` command to automatically encode for all platforms, extract thumbnails, and display publish guidance after the master WebM capture completes. The user runs a single command and gets everything, including next-step instructions for publishing.

**Update cli/commands/capture.js** -- After the master capture completes, add encoding and thumbnail extraction steps:

Add a `--skip-encode` flag to allow capturing master-only (useful for quick tests):

```javascript
.option('--skip-encode', 'Skip platform encoding (master WebM only)', false)
.option('--skip-thumbnails', 'Skip thumbnail extraction', false)
```

After the capture result block (where it reports "Capture complete!"), add:

```javascript
// --- Encoding Phase ---
if (!options.skipEncode) {
  console.log(chalk.blue('\nEncoding for platforms...'));

  const { encodeForAllPlatforms } = await import('../../lib/encoding/ffmpeg-encoder.js');
  const videosDir = path.resolve('videos');

  const encodingResults = await encodeForAllPlatforms(
    result.outputPath,
    videosDir,
    resolvedName,
    (platform, percent) => {
      process.stdout.write(`\r  ${platform}: ${percent}%`);
    }
  );

  console.log(); // Clear progress line
  for (const enc of encodingResults) {
    const sizeMB = (enc.fileSize / (1024 * 1024)).toFixed(2);
    console.log(chalk.green(`  ${enc.platform} (${enc.aspect}): ${enc.outputPath} (${sizeMB} MB)`));
  }
}

// --- Thumbnail Extraction ---
if (!options.skipThumbnails) {
  console.log(chalk.blue('\nExtracting thumbnails...'));

  const { extractThumbnails, extractBestThumbnail } = await import('../../lib/encoding/thumbnail.js');
  const videosDir = path.resolve('videos');

  const thumbPaths = await extractThumbnails(
    result.outputPath,
    videosDir,
    resolvedName,
    { duration }
  );

  const bestThumb = await extractBestThumbnail(
    result.outputPath,
    videosDir,
    resolvedName
  );

  console.log(chalk.green(`  ${thumbPaths.length} thumbnails + 1 best frame extracted`));
  for (const thumbPath of [...thumbPaths, bestThumb]) {
    console.log(chalk.gray(`    ${thumbPath}`));
  }
}

// Summary
console.log(chalk.blue('\n--- Output Summary ---'));
console.log(chalk.gray(`  Master:     videos/masters/${resolvedName}.webm`));
if (!options.skipEncode) {
  console.log(chalk.gray(`  YouTube:    videos/youtube/${resolvedName}.mp4`));
  console.log(chalk.gray(`  TikTok:     videos/tiktok/${resolvedName}.mp4`));
}
if (!options.skipThumbnails) {
  console.log(chalk.gray(`  Thumbnails: videos/thumbnails/${resolvedName}-*.jpg`));
}

// Publish guidance -- show suggested next commands
console.log();
console.log(chalk.gray('Next steps:'));
console.log(chalk.gray(`  YouTube: eoe publish videos/youtube/${resolvedName}.mp4 --platform youtube --title "Your Title"`));
console.log(chalk.gray(`  TikTok:  eoe publish videos/tiktok/${resolvedName}.mp4 --platform tiktok --title "Your Title"`));
```

Restructure the full command action to integrate these phases into the existing try/catch block. The flow is:

1. Resolve atom name
2. Capture master WebM (existing)
3. Encode for platforms (new)
4. Extract thumbnails (new)
5. Print summary

The full action handler should wrap all three phases in the try/catch, so any failure in encoding or thumbnails is caught and reported cleanly.
  </action>
  <verify>
1. `eoe capture my-first-sketch` produces master WebM + YouTube MP4 + TikTok MP4 + thumbnails
2. `ls videos/masters/` shows <atom>.webm
3. `ls videos/youtube/` shows <atom>.mp4
4. `ls videos/tiktok/` shows <atom>.mp4
5. `ls videos/thumbnails/` shows <atom>-1s.jpg, <atom>-5s.jpg, <atom>-Xs.jpg, <atom>-best.jpg
6. YouTube MP4 is 1920x1080 (verify with `ffprobe videos/youtube/<atom>.mp4`)
7. TikTok MP4 is 1080x1920 (verify with `ffprobe videos/tiktok/<atom>.mp4`)
8. Content is centered with black bars (not stretched or cropped)
9. `eoe capture my-first-sketch --skip-encode` produces master only (no MP4s)
10. `eoe capture my-first-sketch --skip-thumbnails` produces master + MP4s (no thumbnails)
11. Progress output shows encoding percentage during conversion
12. Output summary lists all generated files
13. Publish guidance printed after output summary with suggested `eoe publish` commands for YouTube and TikTok
  </verify>
  <done>
`eoe capture` command now produces complete output pipeline: master WebM capture, YouTube 16:9 MP4 encoding, TikTok 9:16 MP4 encoding, and thumbnail extraction at 1s, 5s, midpoint, and "best" frame. --skip-encode and --skip-thumbnails flags available for partial runs. Progress reporting during encoding. Complete output summary with publish guidance (next step: eoe publish) printed at end.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify encoding quality and platform compatibility</name>
  <files>
    (no new files -- verification task)
  </files>
  <action>
Test the full capture+encode+thumbnail pipeline end-to-end and verify output quality and platform compatibility.

**Full Pipeline Test:**
1. `eoe capture my-first-sketch` -- run complete pipeline
2. Verify all output files exist:
   - `videos/masters/2026-01-30-my-first-sketch.webm`
   - `videos/youtube/2026-01-30-my-first-sketch.mp4`
   - `videos/tiktok/2026-01-30-my-first-sketch.mp4`
   - `videos/thumbnails/2026-01-30-my-first-sketch-1s.jpg`
   - `videos/thumbnails/2026-01-30-my-first-sketch-5s.jpg`
   - `videos/thumbnails/2026-01-30-my-first-sketch-*s.jpg` (midpoint)
   - `videos/thumbnails/2026-01-30-my-first-sketch-best.jpg`

**Quality Verification (use ffprobe from ffmpeg-static):**
3. YouTube MP4:
   - Resolution: 1920x1080
   - Video codec: H.264 High profile
   - Audio codec: AAC
   - Pixel format: yuv420p
   - Container: MP4 with faststart
4. TikTok MP4:
   - Resolution: 1080x1920
   - Video codec: H.264 High profile
   - Audio codec: AAC
   - Pixel format: yuv420p

**Visual Quality Check:**
5. Open YouTube MP4 -- atom content centered, black bars on top/bottom (letterbox)
6. Open TikTok MP4 -- atom content centered, black bars on top/bottom (pillarbox)
7. No stretching, squashing, or cropping of original 800x800 content
8. Smooth animation (no dropped frames, no stuttering)

**Thumbnail Quality Check:**
9. All thumbnail JPEGs are valid and viewable
10. Thumbnails show different frames from the video (not all identical)
11. "Best" thumbnail shows a visually interesting frame

**File Size Reasonableness:**
12. Master WebM: Should be roughly proportional to duration
13. YouTube MP4: Should be similar or smaller than master (H.264 efficient)
14. TikTok MP4: Should be similar to YouTube but slightly different due to resolution

**Edge Cases:**
15. `eoe capture my-first-sketch --duration 3` -- verify 3s capture produces correct thumbnails (should skip 5s timestamp)
16. `eoe capture my-first-sketch --skip-encode --skip-thumbnails` -- verify master-only output

If encoding produces errors, check that ffmpeg-static binary is accessible and the WebM master file is valid. If thumbnails are black, the video may not have rendered properly -- increase the initialization wait time in browser-capture.js.
  </action>
  <verify>
1. All output files exist in correct directories
2. YouTube MP4 is 1920x1080 H.264 High profile with AAC audio
3. TikTok MP4 is 1080x1920 H.264 High profile with AAC audio
4. Content centered with black bars, no distortion
5. Thumbnails are valid JPEGs showing different frames
6. File sizes are reasonable for duration
7. Short captures (3s) handle missing timestamps gracefully
8. --skip flags work correctly for partial output
  </verify>
  <done>
Full capture+encode+thumbnail pipeline verified end-to-end. YouTube and TikTok MP4s meet platform specifications (H.264 High, AAC, yuv420p, faststart). Aspect ratio handling produces centered content with black bars. Thumbnails extracted at multiple timestamps plus best-frame selection. File sizes reasonable. Edge cases handled (short durations, skip flags).
  </done>
</task>

</tasks>

<verification>
1. `npm install` succeeds with fluent-ffmpeg and ffmpeg-static
2. `eoe capture <atom>` produces master WebM + encoded MP4s + thumbnails in single run
3. YouTube MP4 is 1920x1080 16:9 with H.264 High profile
4. TikTok MP4 is 1080x1920 9:16 with H.264 High profile
5. 800x800 content centered with black letterbox/pillarbox bars
6. Thumbnails extracted at 1s, 5s, midpoint, and best frame
7. --skip-encode and --skip-thumbnails flags work
8. Progress output during encoding
9. yuv420p pixel format and faststart flag for platform compatibility
10. ffmpeg-static provides bundled binary (no system dependency)
</verification>

<success_criteria>
- Master WebM encoded to YouTube 16:9 MP4 automatically (VID-02)
- Master WebM encoded to TikTok 9:16 MP4 automatically (VID-02)
- 800x800 canvas centered with black bars, never stretched (VID-02)
- Three timestamp thumbnails + best-frame thumbnail extracted (VID-03)
- H.264 High profile, AAC audio, yuv420p, movflags faststart (VID-02)
- fluent-ffmpeg wraps all FFmpeg operations cleanly (VID-02)
- ffmpeg-static bundles FFmpeg binary (no system dependency)
- Single `eoe capture` run produces all outputs (CLI-04 complete)
- --skip-encode and --skip-thumbnails for partial runs
- Platform-compatible files ready for upload (VID-01 complete, VID-02 complete, VID-03 complete)
</success_criteria>

<output>
After completion, create `.planning/phases/03-video-capture-distribution/03-02-SUMMARY.md`
</output>
