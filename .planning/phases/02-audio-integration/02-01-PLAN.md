---
phase: 02-audio-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cli/templates/audio/index.html
  - cli/templates/audio/audio.js
  - cli/templates/audio/config.json
  - cli/templates/audio/NOTES.md
  - cli/commands/create.js
  - package.json
  - lib/audio/synths.js
  - lib/audio/effects.js
  - lib/audio/transport.js
  - lib/audio/cleanup.js
autonomous: true

must_haves:
  truths:
    - "User can run `eoe create audio <name>` and get a date-prefixed audio atom folder with all template files"
    - "User can run `eoe dev <atom>` on an audio atom and hear sound playing in browser after clicking play"
    - "Audio atom template creates a working Tone.js synth with sequence from config.json"
    - "lil-gui panel appears with synth parameter controls (oscillator type, ADSR envelope, BPM)"
    - "Tone.js audio context starts only after user gesture (play button click)"
    - "Calling cleanup/dispose frees all Tone.js nodes without errors or memory leaks"
    - "HMR cleanup disposes audio nodes before re-creating on hot reload"
  artifacts:
    - path: "cli/templates/audio/audio.js"
      provides: "Audio atom template with Tone.js synth, sequence, and effects chain"
      contains: "Tone.Synth"
    - path: "cli/templates/audio/index.html"
      provides: "Audio atom HTML with play/stop transport controls"
      contains: "play"
    - path: "cli/templates/audio/config.json"
      provides: "Audio atom config with synth, sequence, effects, and transport parameters"
      contains: "synth"
    - path: "cli/templates/audio/NOTES.md"
      provides: "Creative log template for audio atoms"
      contains: "Session Log"
    - path: "lib/audio/synths.js"
      provides: "Synth factory functions (mono, poly, drums)"
      contains: "createSynth"
    - path: "lib/audio/effects.js"
      provides: "Effects chain factory"
      contains: "createEffectsChain"
    - path: "lib/audio/transport.js"
      provides: "Transport utilities (start, stop, BPM management)"
      contains: "Transport"
    - path: "lib/audio/cleanup.js"
      provides: "Safe disposal pattern for Tone.js nodes"
      contains: "dispose"
  key_links:
    - from: "cli/commands/create.js"
      to: "cli/templates/audio/"
      via: "fs-extra copy for audio type"
      pattern: "templates/audio"
    - from: "cli/templates/audio/audio.js"
      to: "lib/audio/synths.js"
      via: "import createSynth"
      pattern: "import.*synths"
    - from: "cli/templates/audio/audio.js"
      to: "lib/audio/effects.js"
      via: "import createEffectsChain"
      pattern: "import.*effects"
    - from: "cli/templates/audio/audio.js"
      to: "lib/audio/cleanup.js"
      via: "import disposeAll"
      pattern: "import.*cleanup"
    - from: "cli/templates/audio/audio.js"
      to: "config.json"
      via: "fetch('./config.json')"
      pattern: "fetch.*config\\.json"
---

<objective>
Create the audio atom template and shared audio library. After this plan, users can scaffold audio atoms with `eoe create audio <name>`, start developing them with `eoe dev`, and hear Tone.js synths playing sequences with effects in the browser. The template follows the same structural pattern as visual atoms (index.html + main JS + config.json + NOTES.md) but adds Tone.js synthesis, transport controls, and audio-specific cleanup.

Purpose: This is the foundation for all audio work in Phase 2. Without a working audio atom template, no audio atoms can be created. Without the shared lib/audio/ utilities, every atom would duplicate synth setup and cleanup logic.
Output: Working `eoe create audio <name>` command, audio atom template with Tone.js, shared audio library with synth factories, effects chain, transport utilities, and proven disposal patterns.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-integration/02-CONTEXT.md
@.planning/phases/02-audio-integration/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Tone.js and create shared audio library</name>
  <files>
    package.json
    lib/audio/synths.js
    lib/audio/effects.js
    lib/audio/transport.js
    lib/audio/cleanup.js
    lib/audio/index.js
  </files>
  <action>
Add Tone.js as a root dependency in package.json alongside p5 and lil-gui.

**Update package.json dependencies:**
```json
"dependencies": {
  "p5": "^2.2.0",
  "lil-gui": "^0.21.0",
  "tone": "^15.1.22"
}
```

Run `npm install` to install Tone.js.

**Create lib/audio/synths.js** -- Factory functions for the three basic synth types defined in CONTEXT.md (polyphonic synth, monophonic synth, drum kit):

```javascript
import * as Tone from 'tone';

/**
 * Create a synth instance based on type and config.
 * Supported types: 'mono', 'poly', 'drums'
 *
 * @param {object} synthConfig - Synth configuration from config.json
 * @returns {object} Tone.js synth instance
 */
export function createSynth(synthConfig) {
  const { type = 'mono', oscillator = {}, envelope = {}, voices = 4 } = synthConfig;

  const synthOptions = {
    oscillator: { type: oscillator.type || 'sine' },
    envelope: {
      attack: envelope.attack ?? 0.01,
      decay: envelope.decay ?? 0.2,
      sustain: envelope.sustain ?? 0.5,
      release: envelope.release ?? 1.0
    }
  };

  switch (type) {
    case 'poly':
      return new Tone.PolySynth(Tone.Synth, {
        maxPolyphony: voices,
        voice: Tone.Synth,
        options: synthOptions
      });

    case 'drums':
      return createDrumKit(synthConfig);

    case 'mono':
    default:
      return new Tone.Synth(synthOptions);
  }
}

/**
 * Create a simple drum kit using Tone.MembraneSynth (kick),
 * Tone.MetalSynth (hihat), and Tone.NoiseSynth (snare).
 * Returns an object with trigger methods.
 */
function createDrumKit(config) {
  const kick = new Tone.MembraneSynth({
    pitchDecay: 0.05,
    octaves: 6,
    oscillator: { type: 'sine' },
    envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
  });

  const snare = new Tone.NoiseSynth({
    noise: { type: 'white' },
    envelope: { attack: 0.005, decay: 0.15, sustain: 0 }
  });

  const hihat = new Tone.MetalSynth({
    frequency: 200,
    envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
    harmonicity: 5.1,
    modulationIndex: 32,
    resonance: 4000,
    octaves: 1.5
  });

  // Wrap in a duck-typed object with connect/dispose interface
  const kit = {
    kick,
    snare,
    hihat,
    _voices: [kick, snare, hihat],

    connect(destination) {
      this._voices.forEach(v => v.connect(destination));
      return this;
    },

    toDestination() {
      this._voices.forEach(v => v.toDestination());
      return this;
    },

    triggerAttackRelease(note, duration, time) {
      // For drum kit, note selects the voice
      const n = typeof note === 'string' ? note.toLowerCase() : note;
      if (n === 'kick' || n === 'k' || n === 'C2') kick.triggerAttackRelease(n === 'kick' || n === 'k' ? 'C2' : n, duration, time);
      else if (n === 'snare' || n === 's') snare.triggerAttackRelease(duration, time);
      else if (n === 'hihat' || n === 'h') hihat.triggerAttackRelease(duration, time);
    },

    dispose() {
      this._voices.forEach(v => v.dispose());
    }
  };

  return kit;
}
```

**Create lib/audio/effects.js** -- Effects chain factory:

```javascript
import * as Tone from 'tone';

/**
 * Create an effects chain from config.
 * Each effect in the config array is instantiated and chained together.
 * Returns { chain: Tone.js node (first effect), effects: [all effects], dispose() }.
 *
 * @param {object} effectsConfig - Effects configuration from config.json
 * @returns {object} { chain, effects, dispose }
 */
export function createEffectsChain(effectsConfig = {}) {
  const effects = [];

  if (effectsConfig.reverb) {
    effects.push(new Tone.Reverb({
      decay: effectsConfig.reverb.decay ?? 2.5,
      wet: effectsConfig.reverb.wet ?? 0.3
    }));
  }

  if (effectsConfig.delay) {
    effects.push(new Tone.FeedbackDelay({
      delayTime: effectsConfig.delay.delayTime ?? 0.25,
      feedback: effectsConfig.delay.feedback ?? 0.2,
      wet: effectsConfig.delay.wet ?? 0.3
    }));
  }

  if (effectsConfig.filter) {
    effects.push(new Tone.Filter({
      frequency: effectsConfig.filter.frequency ?? 1000,
      type: effectsConfig.filter.type ?? 'lowpass',
      Q: effectsConfig.filter.Q ?? 1
    }));
  }

  if (effectsConfig.distortion) {
    effects.push(new Tone.Distortion({
      distortion: effectsConfig.distortion.amount ?? 0.4,
      wet: effectsConfig.distortion.wet ?? 0.5
    }));
  }

  if (effectsConfig.compressor) {
    effects.push(new Tone.Compressor({
      threshold: effectsConfig.compressor.threshold ?? -24,
      ratio: effectsConfig.compressor.ratio ?? 4,
      attack: effectsConfig.compressor.attack ?? 0.003,
      release: effectsConfig.compressor.release ?? 0.25
    }));
  }

  // If no effects, return a passthrough Gain node
  if (effects.length === 0) {
    const passthrough = new Tone.Gain(1);
    return {
      chain: passthrough,
      effects: [passthrough],
      dispose() {
        passthrough.dispose();
      }
    };
  }

  // Chain effects: first -> second -> ... -> last -> destination
  for (let i = 0; i < effects.length - 1; i++) {
    effects[i].connect(effects[i + 1]);
  }

  return {
    chain: effects[0],        // Connect synth to this
    output: effects[effects.length - 1], // Connect this to destination
    effects,
    dispose() {
      effects.forEach(fx => fx.dispose());
    }
  };
}
```

**Create lib/audio/transport.js** -- Transport utilities:

```javascript
import * as Tone from 'tone';

/**
 * Ensure audio context is running (requires user gesture).
 * Call this from a click/keydown handler.
 */
export async function ensureAudioContext() {
  if (Tone.context.state !== 'running') {
    await Tone.start();
  }
}

/**
 * Configure and start Tone.Transport with given BPM.
 * @param {number} bpm - Beats per minute
 */
export function startTransport(bpm = 120) {
  Tone.getTransport().bpm.value = bpm;
  Tone.getTransport().start();
}

/**
 * Stop Tone.Transport and cancel all scheduled events.
 */
export function stopTransport() {
  Tone.getTransport().stop();
  Tone.getTransport().cancel();
}

/**
 * Get current transport time in seconds.
 * @returns {number}
 */
export function getTransportTime() {
  return Tone.getTransport().seconds;
}

/**
 * Get current transport position as bar:beat:sixteenth string.
 * @returns {string}
 */
export function getTransportPosition() {
  return Tone.getTransport().position;
}

/**
 * Create a Tone.Sequence from config.
 * @param {function} synth - Synth with triggerAttackRelease method
 * @param {object} seqConfig - { notes, duration, interval }
 * @returns {Tone.Sequence}
 */
export function createSequence(synth, seqConfig) {
  const { notes = ['C4'], duration = '8n', interval = '4n' } = seqConfig;

  const sequence = new Tone.Sequence((time, note) => {
    if (note !== null && note !== 'rest') {
      synth.triggerAttackRelease(note, duration, time);
    }
  }, notes, interval);

  return sequence;
}
```

**Create lib/audio/cleanup.js** -- Safe disposal pattern:

```javascript
import * as Tone from 'tone';

/**
 * Safely dispose all Tone.js nodes in order:
 * 1. Stop transport and cancel events
 * 2. Wait brief moment for notes to release
 * 3. Dispose sequences, then effects, then synths
 * 4. Clear all references
 *
 * @param {object} resources - { sequences, effects, synths, gui, extras }
 */
export async function disposeAll(resources = {}) {
  const {
    sequences = [],
    effects = null,
    synths = [],
    gui = null,
    extras = []
  } = resources;

  // 1. Stop transport
  Tone.getTransport().stop();
  Tone.getTransport().cancel();

  // 2. Stop and dispose sequences
  for (const seq of sequences) {
    if (seq) {
      seq.stop();
      seq.dispose();
    }
  }

  // 3. Brief wait for note releases to complete
  await new Promise(resolve => setTimeout(resolve, 100));

  // 4. Dispose synths
  for (const synth of synths) {
    if (synth) {
      synth.dispose();
    }
  }

  // 5. Dispose effects chain
  if (effects && effects.dispose) {
    effects.dispose();
  }

  // 6. Dispose extras (analysers, gains, etc.)
  for (const node of extras) {
    if (node && node.dispose) {
      node.dispose();
    }
  }

  // 7. Destroy GUI
  if (gui) {
    gui.destroy();
  }
}
```

**Create lib/audio/index.js** -- Barrel export:

```javascript
export { createSynth } from './synths.js';
export { createEffectsChain } from './effects.js';
export { ensureAudioContext, startTransport, stopTransport, getTransportTime, getTransportPosition, createSequence } from './transport.js';
export { disposeAll } from './cleanup.js';
```

After creating all files, run `npm install` to install Tone.js.
  </action>
  <verify>
1. `npm install` completes without errors
2. `node -e "import('tone').then(() => console.log('Tone.js loaded'))"` confirms Tone.js is installed
3. All lib/audio/ files exist: synths.js, effects.js, transport.js, cleanup.js, index.js
4. `node -e "import('./lib/audio/index.js').then(m => console.log(Object.keys(m)))"` prints all exports
  </verify>
  <done>
Tone.js installed as root dependency. Shared audio library created at lib/audio/ with synth factories (mono, poly, drums), effects chain builder (reverb, delay, filter, distortion, compressor), transport utilities (start/stop/BPM/sequence creation), and safe disposal pattern. All exported from lib/audio/index.js barrel file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audio atom template and extend CLI create command</name>
  <files>
    cli/templates/audio/index.html
    cli/templates/audio/audio.js
    cli/templates/audio/config.json
    cli/templates/audio/NOTES.md
    cli/commands/create.js
  </files>
  <action>
Create the audio atom template files parallel to the visual template, then extend the `eoe create` command to support the `audio` type.

**cli/templates/audio/index.html** -- Audio atom entry point with transport controls:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ATOM_NAME}}</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: #0a0a0a;
      color: #e0e0e0;
      font-family: 'SF Mono', 'Fira Code', monospace;
    }
    .transport {
      display: flex;
      gap: 1rem;
      margin: 2rem 0;
    }
    .transport button {
      padding: 0.75rem 2rem;
      border: 1px solid #333;
      border-radius: 6px;
      background: #151515;
      color: #e0e0e0;
      font-family: inherit;
      font-size: 1rem;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
    }
    .transport button:hover {
      border-color: #555;
      background: #1a1a1a;
    }
    .transport button.active {
      border-color: #6bb5ff;
      color: #6bb5ff;
    }
    .info {
      color: #555;
      font-size: 0.85rem;
      margin-top: 1rem;
    }
    h1 {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .position {
      font-size: 1.1rem;
      color: #888;
      font-variant-numeric: tabular-nums;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <h1>{{ATOM_NAME}}</h1>
  <div class="transport">
    <button id="playBtn">Play</button>
    <button id="stopBtn">Stop</button>
  </div>
  <div class="position" id="position">0:0:0</div>
  <div class="info">Click Play to start audio (browser requires user gesture)</div>
  <script type="module" src="./audio.js"></script>
</body>
</html>
```

**cli/templates/audio/audio.js** -- Main audio atom script:

```javascript
import * as Tone from 'tone';
import GUI from 'lil-gui';
import {
  createSynth,
  createEffectsChain,
  ensureAudioContext,
  startTransport,
  stopTransport,
  getTransportPosition,
  createSequence,
  disposeAll
} from '../../lib/audio/index.js';

// --- State ---
let synth = null;
let effectsChain = null;
let sequence = null;
let gui = null;
let positionInterval = null;
let isPlaying = false;

// --- Config ---
let config = {
  synth: {
    type: 'mono',
    oscillator: { type: 'sine' },
    envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 1.0 }
  },
  sequence: {
    notes: ['C4', 'E4', 'G4', 'B4', 'C5', 'B4', 'G4', 'E4'],
    duration: '8n',
    interval: '8n'
  },
  effects: {
    reverb: { decay: 2.5, wet: 0.3 }
  },
  transport: {
    bpm: 120
  }
};

async function init() {
  // Load config from JSON
  try {
    const response = await fetch('./config.json');
    const saved = await response.json();
    config = { ...config, ...saved };
  } catch (e) {
    console.log('No saved config, using defaults');
  }

  setupAudio();
  setupGUI();
  setupTransportControls();
}

function setupAudio() {
  // Create effects chain
  effectsChain = createEffectsChain(config.effects);
  effectsChain.output.toDestination();

  // Create synth and connect to effects chain
  synth = createSynth(config.synth);
  synth.connect(effectsChain.chain);

  // Create sequence
  sequence = createSequence(synth, config.sequence);
}

function setupTransportControls() {
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const positionEl = document.getElementById('position');

  playBtn.addEventListener('click', async () => {
    await ensureAudioContext();

    if (!isPlaying) {
      sequence.start(0);
      startTransport(config.transport.bpm);
      isPlaying = true;
      playBtn.classList.add('active');

      // Update position display
      positionInterval = setInterval(() => {
        positionEl.textContent = getTransportPosition();
      }, 100);
    }
  });

  stopBtn.addEventListener('click', () => {
    if (isPlaying) {
      sequence.stop();
      stopTransport();
      isPlaying = false;
      playBtn.classList.remove('active');

      if (positionInterval) {
        clearInterval(positionInterval);
        positionInterval = null;
      }
      positionEl.textContent = '0:0:0';
    }
  });
}

function setupGUI() {
  gui = new GUI({ title: '{{ATOM_NAME}} Parameters' });

  // Synth controls
  const synthFolder = gui.addFolder('Synth');
  synthFolder.add(config.synth.oscillator, 'type', ['sine', 'triangle', 'sawtooth', 'square'])
    .name('Oscillator')
    .onChange(val => {
      if (synth && synth.oscillator) synth.oscillator.type = val;
    });
  synthFolder.add(config.synth.envelope, 'attack', 0.001, 2).name('Attack')
    .onChange(val => { if (synth && synth.envelope) synth.envelope.attack = val; });
  synthFolder.add(config.synth.envelope, 'decay', 0.01, 2).name('Decay')
    .onChange(val => { if (synth && synth.envelope) synth.envelope.decay = val; });
  synthFolder.add(config.synth.envelope, 'sustain', 0, 1).name('Sustain')
    .onChange(val => { if (synth && synth.envelope) synth.envelope.sustain = val; });
  synthFolder.add(config.synth.envelope, 'release', 0.01, 5).name('Release')
    .onChange(val => { if (synth && synth.envelope) synth.envelope.release = val; });

  // Transport controls
  const transportFolder = gui.addFolder('Transport');
  transportFolder.add(config.transport, 'bpm', 40, 200).step(1).name('BPM')
    .onChange(val => {
      Tone.getTransport().bpm.value = val;
    });

  // Effects controls
  if (config.effects.reverb) {
    const reverbFolder = gui.addFolder('Reverb');
    reverbFolder.add(config.effects.reverb, 'decay', 0.1, 10).name('Decay');
    reverbFolder.add(config.effects.reverb, 'wet', 0, 1).name('Wet');
  }

  gui.onChange(() => {
    console.log('Copy to config.json:', JSON.stringify(config, null, 2));
  });
}

// --- Cleanup ---
async function cleanup() {
  if (positionInterval) {
    clearInterval(positionInterval);
    positionInterval = null;
  }

  await disposeAll({
    sequences: [sequence],
    effects: effectsChain,
    synths: [synth],
    gui
  });

  synth = null;
  effectsChain = null;
  sequence = null;
  gui = null;
  isPlaying = false;
}

// Initialize
init();

// Vite HMR cleanup (prevents audio duplication and memory leaks)
if (import.meta.hot) {
  import.meta.hot.dispose(async () => {
    await cleanup();
  });
}
```

**cli/templates/audio/config.json:**

```json
{
  "type": "audio",
  "synth": {
    "type": "mono",
    "oscillator": { "type": "sine" },
    "envelope": {
      "attack": 0.01,
      "decay": 0.2,
      "sustain": 0.5,
      "release": 1.0
    }
  },
  "sequence": {
    "notes": ["C4", "E4", "G4", "B4", "C5", "B4", "G4", "E4"],
    "duration": "8n",
    "interval": "8n"
  },
  "effects": {
    "reverb": {
      "decay": 2.5,
      "wet": 0.3
    }
  },
  "transport": {
    "bpm": 120
  }
}
```

**cli/templates/audio/NOTES.md:**

```markdown
# {{ATOM_NAME}}

**Created:** {{DATE}}
**Stage:** idea
**Type:** audio

## Intent
What am I exploring with this audio atom? What mood or texture?

## Sound Design
- Synth type:
- Key/scale:
- Tempo:
- Effects chain:

## Technical Decisions
- Why this approach?
- What synthesis techniques?

## Session Log

### {{DATE}} {{TIME}}
- Created audio atom
- Initial setup
```

**Update cli/commands/create.js** -- Add `audio` to supported types:

The current create.js only supports `visual`. Extend it to support `audio` as well. The key change is:
1. Accept both `visual` and `audio` as valid type arguments
2. Select the correct template directory based on type
3. Keep all other logic (date prefix, placeholder replacement) the same

Update the type check:
```javascript
const validTypes = ['visual', 'audio'];
if (!validTypes.includes(type)) {
  console.error(chalk.red(`Type "${type}" not supported. Available: ${validTypes.join(', ')}`));
  process.exit(1);
}
```

Update the template path:
```javascript
const templatePath = path.join(__dirname, `../templates/${type}`);
```

This is a minimal change -- just widen the type check from `type !== 'visual'` to use an array of valid types, and use the type variable in the template path instead of hardcoding 'visual'.
  </action>
  <verify>
1. `eoe create audio test-synth` creates `atoms/YYYY-MM-DD-test-synth/` with audio.js, index.html, config.json, NOTES.md
2. Verify template placeholders replaced: `grep "test-synth" atoms/*/audio.js` shows atom name in GUI title
3. No `{{ATOM_NAME}}` placeholders remain: `grep -r "{{" atoms/*/`
4. `eoe create audio test-synth` (again) shows error "already exists"
5. `eoe create video something` shows error "not supported. Available: visual, audio"
6. `eoe dev <audio-atom-name>` starts Vite and opens the audio atom page
7. Click Play in browser -- sound plays (requires manual browser interaction)
8. Click Stop -- sound stops, position resets
9. lil-gui panel shows synth, transport, and reverb controls
10. Changing oscillator type in GUI updates the sound in real time
11. Hot reload: edit audio.js, save -- audio restarts cleanly without duplicate sounds
  </verify>
  <done>
Audio atom template created with Tone.js synth, sequence, effects chain, transport controls (play/stop), lil-gui parameter panel, and HMR cleanup. CLI `eoe create` extended to support both `visual` and `audio` types. Audio atoms follow the same structural pattern as visual atoms (self-contained folder with index.html, main JS, config.json, NOTES.md).
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify end-to-end audio atom workflow and cleanup patterns</name>
  <files>
    (no new files -- verification task)
  </files>
  <action>
Run the complete audio atom workflow end-to-end and verify all critical behaviors, particularly the disposal/cleanup patterns that are the highest risk area per research.

**Full Workflow Test:**
1. `eoe create audio my-first-tune` -- scaffolds audio atom
2. `eoe dev <full-atom-name>` -- starts Vite dev server
3. Open browser, click Play -- hear sequence playing
4. Adjust BPM via lil-gui -- tempo changes live
5. Change oscillator type -- sound character changes
6. Click Stop -- audio stops cleanly
7. Click Play again -- resumes without duplication
8. Edit audio.js (change a note in the default sequence) -- HMR kicks in, audio restarts cleanly
9. Edit config.json (change BPM to 140) -- reload picks up new config
10. Stop, close browser

**Cleanup Verification:**
- Open browser developer tools (Performance/Memory tab)
- Play audio, stop audio, repeat 5 times -- no memory growth
- Hot reload 5 times while playing -- no stacking audio contexts
- Check console for disposal errors (should be clean)

**Error Handling:**
- Load page without clicking play first -- no auto-play errors
- Rapid play/stop clicking -- no crash
- Open two tabs with same atom -- both work independently

**Config Round-Trip:**
- Copy GUI output (logged to console) back to config.json
- Reload page -- GUI shows updated values, audio uses updated parameters

If any issues are found, fix them in the relevant files (audio.js template, lib/audio/ modules, cleanup.js).

Clean up test atom after verification:
```bash
rm -rf atoms/YYYY-MM-DD-my-first-tune
```
  </action>
  <verify>
1. Full create-to-dev-to-play workflow works without errors
2. Transport controls (play/stop) work reliably
3. lil-gui parameter changes apply in real time
4. HMR cleanup prevents audio duplication
5. No memory leaks after repeated play/stop cycles
6. No console errors during normal operation
7. Config.json round-trip (edit -> reload) works correctly
8. Browser autoplay policy respected (no sound until user clicks)
  </verify>
  <done>
End-to-end audio atom workflow verified: scaffold, develop, play, tweak, stop, hot-reload. Cleanup/disposal patterns proven to prevent memory leaks and audio duplication. Config round-trip works. Browser autoplay policy respected. Audio atom template is production-ready for creative use.
  </done>
</task>

</tasks>

<verification>
1. `npm install` succeeds with Tone.js added to dependencies
2. `eoe create audio <name>` scaffolds a working audio atom
3. `eoe dev <atom>` starts Vite and opens audio atom in browser
4. Play button starts audio (Tone.js synth + sequence + effects)
5. Stop button stops audio and resets transport position
6. lil-gui panel controls synth parameters in real time
7. HMR cleanup disposes audio cleanly (no duplication)
8. Memory stable after repeated play/stop cycles
9. lib/audio/ modules importable and functional
10. Both `visual` and `audio` types work in `eoe create`
</verification>

<success_criteria>
- `eoe create audio <name>` scaffolds complete audio atom in <2 seconds (AUD-01, AUD-04)
- Audio atom plays Tone.js synth with sequence and effects from config.json
- Three synth types available: mono, poly, drums (per CONTEXT.md)
- lil-gui panel with oscillator type, ADSR envelope, BPM, effects controls
- Transport controls: play/stop with position display
- Audio context starts only after user gesture (browser autoplay policy)
- HMR cleanup prevents audio duplication and memory leaks
- Disposal pattern: stop transport -> cancel events -> wait -> dispose nodes
- config.json is source of truth for synth/sequence/effects/transport parameters
- Shared lib/audio/ modules reusable across all audio atoms
</success_criteria>

<output>
After completion, create `.planning/phases/02-audio-integration/02-01-SUMMARY.md`
</output>
