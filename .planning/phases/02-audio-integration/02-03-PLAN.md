---
phase: 02-audio-integration
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - cli/templates/composition/index.html
  - cli/templates/composition/composition.js
  - cli/templates/composition/config.json
  - cli/templates/composition/NOTES.md
  - cli/commands/create.js
  - cli/commands/build.js
  - cli/commands/list.js
  - cli/commands/note.js
  - cli/commands/status.js
  - cli/index.js
  - lib/audio/composition-manager.js
  - lib/audio/index.js
autonomous: true

must_haves:
  truths:
    - "User can run `eoe create composition <name>` and get a composition atom that orchestrates audio + visual atoms"
    - "Composition atom template has a parent orchestrator that manages child audio and visual atoms"
    - "Beat-based scheduling works via Tone.Transport (bars:beats:sixteenths notation)"
    - "CompositionManager tracks all child atoms and provides centralized start/stop/dispose"
    - "`eoe build <atom>` produces a production-ready bundle in dist/<atom>/"
    - "`eoe list` shows all atoms with type (visual/audio/audio-visual/composition) and stage (idea/wip/done)"
    - "`eoe note <atom>` opens the NOTES.md for a specific atom in the default editor"
    - "`eoe status` enhanced to show WIP tracker with type column and progress summary"
  artifacts:
    - path: "cli/templates/composition/composition.js"
      provides: "Composition orchestrator template using CompositionManager"
      contains: "CompositionManager"
    - path: "cli/templates/composition/index.html"
      provides: "Composition HTML with transport and visual canvas"
      contains: "composition"
    - path: "cli/templates/composition/config.json"
      provides: "Composition config with audio, visual, and timeline sections"
      contains: "timeline"
    - path: "lib/audio/composition-manager.js"
      provides: "CompositionManager class for multi-atom orchestration"
      contains: "class CompositionManager"
    - path: "cli/commands/build.js"
      provides: "eoe build command producing production bundles"
      contains: "buildCommand"
    - path: "cli/commands/list.js"
      provides: "eoe list command showing all atoms with type and status"
      contains: "listCommand"
  key_links:
    - from: "cli/templates/composition/composition.js"
      to: "lib/audio/composition-manager.js"
      via: "import CompositionManager"
      pattern: "import.*CompositionManager"
    - from: "cli/index.js"
      to: "cli/commands/build.js"
      via: "commander addCommand"
      pattern: "addCommand.*buildCommand"
    - from: "cli/index.js"
      to: "cli/commands/list.js"
      via: "commander addCommand"
      pattern: "addCommand.*listCommand"
    - from: "cli/commands/build.js"
      to: "vite"
      via: "spawn vite build"
      pattern: "vite.*build"
    - from: "cli/commands/list.js"
      to: "atoms/"
      via: "fs.readdir to scan atoms"
      pattern: "readdir.*atoms"
---

<objective>
Create composition atoms (parent orchestrators that combine audio + visual atoms), the CompositionManager utility, and the remaining CLI commands (build, list, enhanced note/status). After this plan, users can compose multi-atom experiences with beat-based scheduling, build production bundles, and manage their full creative workflow from the CLI.

Purpose: Compositions are where audio and visual atoms come together as unified pieces. The CLI enhancements (build, list, WIP tracker) complete the creative cockpit for Phase 2. This plan fulfills the remaining Phase 2 requirements: AUD-02, CLI-03, CLI-05, NOTE-03, NOTE-04.
Output: Composition atom template, CompositionManager class, `eoe build`, `eoe list`, enhanced `eoe note` and `eoe status` commands.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audio-integration/02-CONTEXT.md
@.planning/phases/02-audio-integration/02-RESEARCH.md
@.planning/phases/02-audio-integration/02-01-PLAN.md
@.planning/phases/02-audio-integration/02-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CompositionManager and composition atom template</name>
  <files>
    lib/audio/composition-manager.js
    lib/audio/index.js
    cli/templates/composition/index.html
    cli/templates/composition/composition.js
    cli/templates/composition/config.json
    cli/templates/composition/NOTES.md
    cli/commands/create.js
  </files>
  <action>
Create the CompositionManager class that orchestrates multiple audio and visual atoms, then create the composition atom template.

**lib/audio/composition-manager.js** -- Multi-atom orchestration:

```javascript
import * as Tone from 'tone';
import { ensureAudioContext, disposeAll } from './index.js';

/**
 * CompositionManager orchestrates multiple audio and visual atoms
 * with centralized transport, scheduling, and lifecycle management.
 *
 * Usage:
 *   const manager = new CompositionManager({ bpm: 120 });
 *   const audioAtom = manager.addAudioAtom('synth1', initFn);
 *   const visualAtom = manager.addVisualAtom('visual1', p5Instance);
 *   manager.schedule('0:0:0', (time) => { ... });
 *   await manager.start();
 */
export class CompositionManager {
  /**
   * @param {object} config
   * @param {number} config.bpm - Beats per minute (default: 120)
   * @param {number} config.timeSignature - Beats per measure (default: 4)
   * @param {number} config.loopLength - Loop length in measures (default: 0 = no loop)
   */
  constructor(config = {}) {
    this.bpm = config.bpm ?? 120;
    this.timeSignature = config.timeSignature ?? 4;
    this.loopLength = config.loopLength ?? 0;

    this.audioAtoms = new Map();   // name -> { node, sequences, dispose }
    this.visualAtoms = new Map();  // name -> { instance, update, dispose }
    this.scheduledEvents = [];     // Transport event IDs
    this.isPlaying = false;

    // Configure transport
    Tone.getTransport().bpm.value = this.bpm;
    Tone.getTransport().timeSignature = this.timeSignature;

    if (this.loopLength > 0) {
      Tone.getTransport().loop = true;
      Tone.getTransport().loopEnd = `${this.loopLength}m`;
    }
  }

  /**
   * Register an audio atom with the composition.
   *
   * @param {string} name - Unique identifier for this atom
   * @param {object} atom - { node, sequences, dispose } where:
   *   - node: Tone.js audio node (synth, effects output, etc.)
   *   - sequences: Array of Tone.Sequence/Part/Loop objects
   *   - dispose: Cleanup function
   * @returns {object} The registered atom
   */
  addAudioAtom(name, atom) {
    this.audioAtoms.set(name, atom);
    return atom;
  }

  /**
   * Register a visual atom with the composition.
   *
   * @param {string} name - Unique identifier
   * @param {object} atom - { instance, updateParams, dispose } where:
   *   - instance: p5 instance
   *   - updateParams: function(audioData) to inject audio-reactive parameters
   *   - dispose: Cleanup function
   * @returns {object} The registered atom
   */
  addVisualAtom(name, atom) {
    this.visualAtoms.set(name, atom);
    return atom;
  }

  /**
   * Schedule an event at a specific transport time.
   * Uses Tone.Transport time notation (bars:beats:sixteenths).
   *
   * @param {string} time - Transport time (e.g., '0:0:0', '4:0:0', '1m', '4n')
   * @param {function} callback - Function called at scheduled time. Receives (time).
   * @returns {number} Event ID
   */
  schedule(time, callback) {
    const id = Tone.getTransport().schedule(callback, time);
    this.scheduledEvents.push(id);
    return id;
  }

  /**
   * Schedule a repeating event.
   *
   * @param {string} interval - Repeat interval (e.g., '4n', '1m')
   * @param {function} callback - Function called on each repeat
   * @param {string} startTime - When to start (default: '0:0:0')
   * @returns {number} Event ID
   */
  scheduleRepeat(interval, callback, startTime = '0:0:0') {
    const id = Tone.getTransport().scheduleRepeat(callback, interval, startTime);
    this.scheduledEvents.push(id);
    return id;
  }

  /**
   * Start the composition.
   * Ensures audio context is active, starts all sequences, begins transport.
   */
  async start() {
    await ensureAudioContext();

    // Start all audio atom sequences
    for (const [, atom] of this.audioAtoms) {
      if (atom.sequences) {
        atom.sequences.forEach(seq => seq.start(0));
      }
    }

    Tone.getTransport().start();
    this.isPlaying = true;
  }

  /**
   * Stop the composition.
   * Stops transport and all sequences.
   */
  stop() {
    // Stop all sequences
    for (const [, atom] of this.audioAtoms) {
      if (atom.sequences) {
        atom.sequences.forEach(seq => seq.stop());
      }
    }

    Tone.getTransport().stop();
    Tone.getTransport().position = '0:0:0';
    this.isPlaying = false;
  }

  /**
   * Pause the composition (stops transport without resetting position).
   */
  pause() {
    Tone.getTransport().pause();
    this.isPlaying = false;
  }

  /**
   * Get current transport position as string.
   * @returns {string}
   */
  getPosition() {
    return Tone.getTransport().position;
  }

  /**
   * Get current transport time in seconds.
   * @returns {number}
   */
  getSeconds() {
    return Tone.getTransport().seconds;
  }

  /**
   * Dispose all atoms and clear scheduled events.
   * Safe disposal order: stop -> cancel -> wait -> dispose atoms.
   */
  async dispose() {
    // Stop everything
    this.stop();
    Tone.getTransport().cancel();

    // Clear scheduled events
    this.scheduledEvents = [];

    // Wait for notes to release
    await new Promise(resolve => setTimeout(resolve, 150));

    // Dispose audio atoms
    for (const [name, atom] of this.audioAtoms) {
      if (atom.dispose) {
        await atom.dispose();
      }
    }
    this.audioAtoms.clear();

    // Dispose visual atoms
    for (const [name, atom] of this.visualAtoms) {
      if (atom.dispose) {
        atom.dispose();
      }
    }
    this.visualAtoms.clear();
  }
}
```

**Update lib/audio/index.js** -- Add CompositionManager export:

Append to existing barrel file:
```javascript
export { CompositionManager } from './composition-manager.js';
```

**cli/templates/composition/index.html** -- Composition atom entry point:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ATOM_NAME}}</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      background: #0a0a0a;
      color: #e0e0e0;
      font-family: 'SF Mono', 'Fira Code', monospace;
    }
    .transport {
      display: flex;
      gap: 1rem;
      align-items: center;
      margin: 1rem 0;
      z-index: 10;
    }
    .transport button {
      padding: 0.5rem 1.5rem;
      border: 1px solid #333;
      border-radius: 6px;
      background: #151515;
      color: #e0e0e0;
      font-family: inherit;
      font-size: 0.9rem;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    .transport button:hover { border-color: #555; }
    .transport button.active { border-color: #6bb5ff; color: #6bb5ff; }
    .position {
      font-variant-numeric: tabular-nums;
      color: #888;
      font-size: 0.9rem;
      min-width: 80px;
    }
    h1 {
      font-size: 1.2rem;
      font-weight: 600;
      margin-top: 1rem;
      margin-bottom: 0;
    }
  </style>
</head>
<body>
  <h1>{{ATOM_NAME}}</h1>
  <div class="transport">
    <button id="playBtn">Play</button>
    <button id="stopBtn">Stop</button>
    <span class="position" id="position">0:0:0</span>
  </div>
  <div id="canvas-container"></div>
  <script type="module" src="./composition.js"></script>
</body>
</html>
```

**cli/templates/composition/composition.js** -- Composition orchestrator:

```javascript
import p5 from 'p5';
import * as Tone from 'tone';
import GUI from 'lil-gui';
import {
  CompositionManager,
  createSynth,
  createEffectsChain,
  createSequence,
  AudioDataProvider,
  applyMapping
} from '../../lib/audio/index.js';

// --- State ---
let manager = null;
let audioDataProvider = null;
let p5Instance = null;
let gui = null;
let positionInterval = null;

// --- Config ---
let config = {
  // Composition metadata
  title: '{{ATOM_NAME}}',

  // Transport
  transport: {
    bpm: 120,
    timeSignature: 4,
    loopLength: 4  // Loop after 4 measures (0 = no loop)
  },

  // Audio atoms
  audio: {
    lead: {
      synth: {
        type: 'mono',
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.8 }
      },
      sequence: {
        notes: ['C4', 'E4', 'G4', 'B4', 'C5', null, 'G4', 'E4'],
        duration: '8n',
        interval: '8n'
      },
      effects: {
        reverb: { decay: 2.5, wet: 0.3 },
        delay: { delayTime: 0.25, feedback: 0.15, wet: 0.2 }
      }
    },
    bass: {
      synth: {
        type: 'mono',
        oscillator: { type: 'sine' },
        envelope: { attack: 0.01, decay: 0.4, sustain: 0.6, release: 0.5 }
      },
      sequence: {
        notes: ['C2', null, 'C2', null, 'G2', null, 'G2', null],
        duration: '4n',
        interval: '8n'
      },
      effects: {}
    }
  },

  // Visual parameters
  visual: {
    bgHue: 240,
    baseSize: 80,
    bassSizeScale: 150,
    midsHueShift: 120,
    beatFlash: 0.6
  },

  // Analysis
  analysis: {
    fftSize: 1024,
    smoothing: 0.8,
    outputSmoothing: 0.15,
    beatThreshold: 0.15
  }
};

async function init() {
  // Load config
  try {
    const response = await fetch('./config.json');
    const saved = await response.json();
    config = deepMerge(config, saved);
  } catch (e) {
    console.log('No saved config, using defaults');
  }

  // Create composition manager
  manager = new CompositionManager(config.transport);

  // Setup audio atoms
  setupAudioAtoms();

  // Setup visual atom
  setupVisualAtom();

  // Setup GUI
  setupGUI();

  // Setup transport buttons
  setupTransportControls();
}

function setupAudioAtoms() {
  // A Gain node to mix all audio atoms together before analysis
  const mixBus = new Tone.Gain(1).toDestination();

  for (const [name, atomConfig] of Object.entries(config.audio)) {
    // Create effects chain
    const effects = createEffectsChain(atomConfig.effects || {});
    effects.output.connect(mixBus);

    // Create synth
    const synth = createSynth(atomConfig.synth || {});
    synth.connect(effects.chain);

    // Create sequence
    const sequence = createSequence(synth, atomConfig.sequence || {});

    // Register with manager
    manager.addAudioAtom(name, {
      node: synth,
      sequences: [sequence],
      effects,
      async dispose() {
        sequence.stop();
        sequence.dispose();
        await new Promise(r => setTimeout(r, 50));
        synth.dispose();
        effects.dispose();
      }
    });
  }

  // Create AudioDataProvider on the mix bus (analyzes combined output)
  audioDataProvider = new AudioDataProvider(mixBus, config.analysis);
}

function setupVisualAtom() {
  const sketch = (p) => {
    let time = 0;

    p.setup = () => {
      const container = document.getElementById('canvas-container');
      const canvas = p.createCanvas(800, 800);
      canvas.parent(container);
      p.colorMode(p.HSB, 360, 100, 100, 100);
      p.noStroke();
    };

    p.draw = () => {
      const audio = audioDataProvider ? audioDataProvider.update() : {
        bass: 0, mid: 0, treble: 0, mids: 0, energy: 0, beat: 0, envelope: 0, highMid: 0
      };
      const v = config.visual;

      // Background
      p.background(v.bgHue, 15, 8 + audio.envelope * 4);

      // Beat flash
      if (audio.beat > 0.1) {
        p.fill(0, 0, 100, audio.beat * v.beatFlash * 80);
        p.rect(0, 0, p.width, p.height);
      }

      p.push();
      p.translate(p.width / 2, p.height / 2);

      // Outer ring: driven by bass
      const ringRadius = applyMapping(audio.bass, {
        min: v.baseSize,
        max: v.baseSize + v.bassSizeScale,
        curve: 'cubicOut'
      });
      const numRing = 16;
      for (let i = 0; i < numRing; i++) {
        const angle = (p.TWO_PI / numRing) * i + time * 0.3;
        const x = p.cos(angle) * ringRadius;
        const y = p.sin(angle) * ringRadius;
        const hue = (v.bgHue + v.midsHueShift * audio.mids + i * (360 / numRing)) % 360;
        const sz = 12 + audio.bass * 25;
        p.fill(hue, 65, 85, 70 + audio.energy * 30);
        p.circle(x, y, sz);
      }

      // Inner particles: driven by mids and treble
      const innerCount = 8 + Math.floor(audio.highMid * 16);
      for (let i = 0; i < innerCount; i++) {
        const angle = (p.TWO_PI / innerCount) * i - time * 0.5;
        const r = 30 + audio.mid * 60;
        const x = p.cos(angle) * r;
        const y = p.sin(angle) * r;
        const hue = (v.bgHue + 180 + audio.treble * 90 + i * 15) % 360;
        p.fill(hue, 80, 90, 50 + audio.treble * 40);
        p.circle(x, y, 6 + audio.treble * 10);
      }

      // Center core: pulsing with envelope
      const coreSize = 20 + audio.envelope * 50;
      p.fill((v.bgHue + 60) % 360, 40, 95, 90);
      p.circle(0, 0, coreSize);

      p.pop();
      time += 0.016;
    };
  };

  p5Instance = new p5(sketch);

  manager.addVisualAtom('main', {
    instance: p5Instance,
    dispose() {
      if (p5Instance) {
        p5Instance.remove();
        p5Instance = null;
      }
    }
  });
}

function setupTransportControls() {
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const positionEl = document.getElementById('position');

  playBtn.addEventListener('click', async () => {
    if (!manager.isPlaying) {
      await manager.start();
      playBtn.classList.add('active');

      positionInterval = setInterval(() => {
        positionEl.textContent = manager.getPosition();
      }, 100);
    }
  });

  stopBtn.addEventListener('click', () => {
    if (manager.isPlaying) {
      manager.stop();
      playBtn.classList.remove('active');
      if (audioDataProvider) audioDataProvider.reset();

      if (positionInterval) {
        clearInterval(positionInterval);
        positionInterval = null;
      }
      positionEl.textContent = '0:0:0';
    }
  });
}

function setupGUI() {
  gui = new GUI({ title: config.title });

  // Transport
  const transportFolder = gui.addFolder('Transport');
  transportFolder.add(config.transport, 'bpm', 40, 200).step(1).name('BPM')
    .onChange(val => { Tone.getTransport().bpm.value = val; });

  // Visual mapping
  const visualFolder = gui.addFolder('Visual');
  visualFolder.add(config.visual, 'bgHue', 0, 360).name('Background Hue');
  visualFolder.add(config.visual, 'baseSize', 20, 200).name('Base Size');
  visualFolder.add(config.visual, 'bassSizeScale', 0, 400).name('Bass Scale');
  visualFolder.add(config.visual, 'midsHueShift', 0, 360).name('Mids Hue');
  visualFolder.add(config.visual, 'beatFlash', 0, 1).name('Beat Flash');

  gui.onChange(() => {
    console.log('Copy to config.json:', JSON.stringify(config, null, 2));
  });
}

function deepMerge(target, source) {
  const result = { ...target };
  for (const key of Object.keys(source)) {
    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
      result[key] = deepMerge(target[key] || {}, source[key]);
    } else {
      result[key] = source[key];
    }
  }
  return result;
}

// --- Cleanup ---
async function cleanup() {
  if (positionInterval) {
    clearInterval(positionInterval);
    positionInterval = null;
  }

  if (audioDataProvider) {
    audioDataProvider.dispose();
    audioDataProvider = null;
  }

  if (manager) {
    await manager.dispose();
    manager = null;
  }

  if (gui) {
    gui.destroy();
    gui = null;
  }
}

// Initialize
init();

// Vite HMR cleanup
if (import.meta.hot) {
  import.meta.hot.dispose(async () => {
    await cleanup();
  });
}
```

**cli/templates/composition/config.json:**

```json
{
  "type": "composition",
  "title": "{{ATOM_NAME}}",
  "transport": {
    "bpm": 120,
    "timeSignature": 4,
    "loopLength": 4
  },
  "audio": {
    "lead": {
      "synth": {
        "type": "mono",
        "oscillator": { "type": "triangle" },
        "envelope": {
          "attack": 0.01,
          "decay": 0.3,
          "sustain": 0.4,
          "release": 0.8
        }
      },
      "sequence": {
        "notes": ["C4", "E4", "G4", "B4", "C5", null, "G4", "E4"],
        "duration": "8n",
        "interval": "8n"
      },
      "effects": {
        "reverb": { "decay": 2.5, "wet": 0.3 },
        "delay": { "delayTime": 0.25, "feedback": 0.15, "wet": 0.2 }
      }
    },
    "bass": {
      "synth": {
        "type": "mono",
        "oscillator": { "type": "sine" },
        "envelope": {
          "attack": 0.01,
          "decay": 0.4,
          "sustain": 0.6,
          "release": 0.5
        }
      },
      "sequence": {
        "notes": ["C2", null, "C2", null, "G2", null, "G2", null],
        "duration": "4n",
        "interval": "8n"
      },
      "effects": {}
    }
  },
  "visual": {
    "bgHue": 240,
    "baseSize": 80,
    "bassSizeScale": 150,
    "midsHueShift": 120,
    "beatFlash": 0.6
  },
  "analysis": {
    "fftSize": 1024,
    "smoothing": 0.8,
    "outputSmoothing": 0.15,
    "beatThreshold": 0.15
  }
}
```

**cli/templates/composition/NOTES.md:**

```markdown
# {{ATOM_NAME}}

**Created:** {{DATE}}
**Stage:** idea
**Type:** composition

## Intent
What story or experience does this composition tell? What should the viewer/listener feel?

## Audio Design
- Lead synth:
- Bass synth:
- Additional voices:
- Effects:
- Tempo/feel:

## Visual Design
- Palette:
- Shapes/patterns:
- Movement:

## Timeline / Structure
- Intro (bars 1-4):
- Main (bars 5-12):
- Outro (bars 13-16):

## Audio-Visual Mapping
- Bass drives:
- Mids drive:
- Treble drives:
- Beat triggers:

## Session Log

### {{DATE}} {{TIME}}
- Created composition atom
- Initial setup
```

**Update cli/commands/create.js** -- Add `composition` type:

Update the valid types array:
```javascript
const validTypes = ['visual', 'audio', 'audio-visual', 'composition'];
```

The template path pattern `path.join(__dirname, '../templates/${type}')` handles this automatically.
  </action>
  <verify>
1. `eoe create composition my-piece` creates composition atom folder
2. All template files present: index.html, composition.js, config.json, NOTES.md
3. No {{ATOM_NAME}} placeholders remaining
4. `eoe dev <composition-atom>` starts Vite and opens composition
5. Click Play -- both lead and bass synths play, visuals react to combined audio
6. Click Stop -- everything stops cleanly
7. Position display updates during playback
8. Composition loops after 4 measures (per config.json loopLength: 4)
9. lil-gui shows Transport and Visual sections
10. HMR cleanup: edit composition.js while playing -- restarts cleanly
  </verify>
  <done>
CompositionManager created for multi-atom orchestration with centralized transport, scheduling, and disposal. Composition atom template demonstrates two synths (lead + bass) with effects, combined audio analysis driving a reactive p5.js sketch. Beat-based scheduling via Tone.Transport with bars:beats:sixteenths notation. CLI extended with `composition` type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement `eoe build <atom>` CLI command</name>
  <files>
    cli/commands/build.js
    cli/index.js
  </files>
  <action>
Create the `eoe build <atom>` command that produces a production-ready bundle using Vite's build mode. The output goes to `dist/<atom>/` and contains all necessary HTML, JS, and CSS for standalone deployment.

**cli/commands/build.js:**

```javascript
import { Command } from 'commander';
import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs-extra';
import chalk from 'chalk';

export const buildCommand = new Command('build')
  .argument('<atom>', 'Atom name to build (e.g., 2026-01-30-my-tune)')
  .description('Build a production bundle for an atom')
  .action(async (atomName) => {
    const atomPath = path.resolve('atoms', atomName);
    const distPath = path.resolve('dist', atomName);

    // Validate atom exists
    if (!await fs.pathExists(atomPath)) {
      console.error(chalk.red(`Atom "${atomName}" not found in atoms/`));
      process.exit(1);
    }

    // Validate atom has index.html
    const indexPath = path.join(atomPath, 'index.html');
    if (!await fs.pathExists(indexPath)) {
      console.error(chalk.red(`Atom "${atomName}" has no index.html`));
      process.exit(1);
    }

    console.log(chalk.blue(`Building ${atomName}...`));

    // Run Vite build with the atom's index.html as entry point
    // Output to dist/<atom>/
    const vite = spawn('npx', [
      'vite', 'build',
      '--outDir', distPath,
      '--emptyOutDir',
      '--base', './',
      `atoms/${atomName}/index.html`
    ], {
      stdio: 'inherit',
      cwd: process.cwd()
    });

    return new Promise((resolve, reject) => {
      vite.on('close', async (code) => {
        if (code !== 0) {
          console.error(chalk.red(`Build failed with code ${code}`));
          process.exit(code);
        }

        // Verify output
        if (await fs.pathExists(distPath)) {
          const files = await fs.readdir(distPath, { recursive: true });
          console.log(chalk.green(`\nBuild complete: dist/${atomName}/`));
          console.log(chalk.gray(`  ${files.length} files produced`));
          console.log(chalk.gray(`  Preview: npx vite preview --outDir dist/${atomName}`));
        } else {
          console.error(chalk.red('Build completed but output directory not found'));
          process.exit(1);
        }

        resolve();
      });

      vite.on('error', (err) => {
        console.error(chalk.red(`Build error: ${err.message}`));
        reject(err);
      });
    });
  });
```

**Update cli/index.js** -- Add build command:

Add import and registration:
```javascript
import { buildCommand } from './commands/build.js';
// ...
program.addCommand(buildCommand);
```
  </action>
  <verify>
1. Create a test atom: `eoe create visual build-test`
2. `eoe build <full-atom-name>` runs Vite build without errors
3. `dist/<atom>/` directory created with bundled files
4. Open `dist/<atom>/index.html` in browser (or use `npx vite preview`) -- atom works standalone
5. `eoe build nonexistent` shows error "not found"
6. `eoe --help` shows build command in list
  </verify>
  <done>
`eoe build <atom>` command produces a production-ready bundle in dist/<atom>/ using Vite build mode. Validates atom exists and has index.html. Reports file count and preview command on success. Handles build failures gracefully with error codes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement `eoe list` command with type and status columns</name>
  <files>
    cli/commands/list.js
    cli/index.js
  </files>
  <action>
Create the `eoe list` command that shows all atoms with their type (visual/audio/audio-visual/composition) and stage (idea/sketch/refine/done). This is more detailed than `eoe status` and fulfills CLI-05.

**cli/commands/list.js:**

```javascript
import { Command } from 'commander';
import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';

export const listCommand = new Command('list')
  .description('List all atoms with type and status')
  .option('-t, --type <type>', 'Filter by type (visual, audio, audio-visual, composition)')
  .option('-s, --stage <stage>', 'Filter by stage (idea, sketch, refine, done)')
  .action(async (options) => {
    const atomsDir = path.resolve('atoms');

    if (!await fs.pathExists(atomsDir)) {
      console.log(chalk.yellow('No atoms directory found'));
      return;
    }

    const entries = await fs.readdir(atomsDir, { withFileTypes: true });
    const atomDirs = entries.filter(d => d.isDirectory());

    if (atomDirs.length === 0) {
      console.log(chalk.yellow('No atoms yet. Run `eoe create <type> <name>` to start.'));
      return;
    }

    // Collect atom metadata
    let rows = [];
    for (const dir of atomDirs) {
      const atomPath = path.join(atomsDir, dir.name);
      const configPath = path.join(atomPath, 'config.json');
      const notesPath = path.join(atomPath, 'NOTES.md');
      const stat = await fs.stat(atomPath);

      // Detect type from config.json or file structure
      let type = 'visual'; // default
      if (await fs.pathExists(configPath)) {
        try {
          const configContent = await fs.readJson(configPath);
          if (configContent.type) {
            type = configContent.type;
          }
        } catch (e) {
          // Fall back to file detection
        }
      }

      // Fallback type detection from files present
      if (type === 'visual') {
        const hasAudioJs = await fs.pathExists(path.join(atomPath, 'audio.js'));
        const hasSketchJs = await fs.pathExists(path.join(atomPath, 'sketch.js'));
        const hasCompositionJs = await fs.pathExists(path.join(atomPath, 'composition.js'));

        if (hasCompositionJs) type = 'composition';
        else if (hasAudioJs && hasSketchJs) type = 'audio-visual';
        else if (hasAudioJs) type = 'audio';
      }

      // Read stage from NOTES.md
      let stage = 'idea';
      if (await fs.pathExists(notesPath)) {
        const notes = await fs.readFile(notesPath, 'utf8');
        const stageMatch = notes.match(/\*\*Stage:\*\*\s*(\w[\w-]*)/);
        if (stageMatch) stage = stageMatch[1];
      }

      // Parse name and date
      const parts = dir.name.match(/^(\d{4}-\d{2}-\d{2})-(.+)$/);
      const date = parts ? parts[1] : 'unknown';
      const name = parts ? parts[2] : dir.name;

      rows.push({
        fullName: dir.name,
        name,
        type,
        stage,
        created: date,
        modified: stat.mtime.toISOString().split('T')[0]
      });
    }

    // Apply filters
    if (options.type) {
      rows = rows.filter(r => r.type === options.type);
    }
    if (options.stage) {
      rows = rows.filter(r => r.stage === options.stage);
    }

    if (rows.length === 0) {
      console.log(chalk.yellow('No atoms match the given filters.'));
      return;
    }

    // Sort newest first
    rows.sort((a, b) => b.created.localeCompare(a.created));

    // Color functions
    const typeColors = {
      visual: chalk.cyan,
      audio: chalk.magenta,
      'audio-visual': chalk.yellow,
      composition: chalk.green
    };
    const stageColors = {
      idea: chalk.gray,
      sketch: chalk.blue,
      refine: chalk.yellow,
      done: chalk.green
    };

    // Calculate column widths
    const nameWidth = Math.max(4, ...rows.map(r => r.name.length));
    const typeWidth = Math.max(4, ...rows.map(r => r.type.length));

    // Print header
    const header = `${'NAME'.padEnd(nameWidth)}  ${'TYPE'.padEnd(typeWidth)}  ${'STAGE'.padEnd(7)}  ${'CREATED'.padEnd(10)}  MODIFIED`;
    console.log(chalk.bold(header));
    console.log('-'.repeat(header.length));

    // Print rows
    for (const row of rows) {
      const typeColor = typeColors[row.type] || chalk.white;
      const stageColor = stageColors[row.stage] || chalk.white;
      console.log(
        `${row.name.padEnd(nameWidth)}  ${typeColor(row.type.padEnd(typeWidth))}  ${stageColor(row.stage.padEnd(7))}  ${row.created.padEnd(10)}  ${row.modified}`
      );
    }

    // Summary
    const typeCounts = {};
    const stageCounts = {};
    for (const row of rows) {
      typeCounts[row.type] = (typeCounts[row.type] || 0) + 1;
      stageCounts[row.stage] = (stageCounts[row.stage] || 0) + 1;
    }

    console.log('');
    console.log(chalk.gray(`${rows.length} atom(s)`));

    // Type breakdown
    const typeBreakdown = Object.entries(typeCounts)
      .map(([t, c]) => `${c} ${t}`)
      .join(', ');
    console.log(chalk.gray(`Types: ${typeBreakdown}`));

    // Stage breakdown (WIP tracker - NOTE-03)
    const stageBreakdown = Object.entries(stageCounts)
      .map(([s, c]) => {
        const color = stageColors[s] || chalk.white;
        return color(`${c} ${s}`);
      })
      .join(', ');
    console.log(chalk.gray('Stages: ') + stageBreakdown);
  });
```

**Update cli/index.js** -- Add list command:

Add import and registration:
```javascript
import { listCommand } from './commands/list.js';
// ...
program.addCommand(listCommand);
```
  </action>
  <verify>
1. `eoe list` shows all atoms with NAME, TYPE, STAGE, CREATED, MODIFIED columns
2. Type detection works: visual atoms show 'visual', audio atoms show 'audio', etc.
3. Stage reads from NOTES.md correctly
4. `eoe list --type audio` filters to audio atoms only
5. `eoe list --stage done` filters to completed atoms only
6. Summary shows total count, type breakdown, and stage breakdown
7. Color coding: types and stages have distinct colors
8. `eoe --help` shows list command
  </verify>
  <done>
`eoe list` command shows all atoms with name, type (visual/audio/audio-visual/composition), stage (idea/sketch/refine/done), created date, and modified date. Supports --type and --stage filters. Type detected from config.json "type" field with fallback to file structure detection. Summary includes type and stage breakdowns (fulfills NOTE-03 WIP tracker). Color-coded output for scanability.
  </done>
</task>

<task type="auto">
  <name>Task 4: Enhance `eoe note` and `eoe status` for per-atom notes and WIP tracker</name>
  <files>
    cli/commands/note.js
    cli/commands/status.js
    cli/index.js
  </files>
  <action>
Enhance the existing note command to support per-atom notes (`eoe note <atom>` opens NOTES.md) alongside the existing quick-capture (`eoe note "text"`). Enhance status to show type column and WIP summary.

**Update cli/commands/note.js** -- Support both global notes and per-atom notes:

The current note command takes a text argument and appends to ideas.md. Enhance it to:
1. `eoe note "some text"` -- quick capture to ideas.md (existing behavior)
2. `eoe note <atom-name>` -- opens the atom's NOTES.md in the default editor

Detection logic: if the argument matches an existing atom folder name, open NOTES.md. Otherwise, treat as text to append to ideas.md.

```javascript
import { Command } from 'commander';
import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import { spawn } from 'child_process';

export const noteCommand = new Command('note')
  .argument('<text>', 'Idea text OR atom name to open notes for')
  .description('Capture idea to ideas.md, or open atom notes with `eoe note <atom-name>`')
  .action(async (text) => {
    // Check if the argument is an atom name
    const atomPath = path.resolve('atoms', text);
    const notesPath = path.join(atomPath, 'NOTES.md');

    if (await fs.pathExists(notesPath)) {
      // Open NOTES.md in default editor
      const editor = process.env.EDITOR || process.env.VISUAL || 'vim';
      console.log(chalk.blue(`Opening notes for ${text}...`));

      const child = spawn(editor, [notesPath], {
        stdio: 'inherit'
      });

      child.on('close', (code) => {
        if (code === 0) {
          console.log(chalk.green('Notes saved.'));
        }
      });

      return;
    }

    // Otherwise, capture as quick idea
    const ideasPath = path.resolve('ideas.md');

    if (!await fs.pathExists(ideasPath)) {
      await fs.writeFile(ideasPath, '# Ideas\n\nQuick-capture creative ideas. Add via `eoe note "your idea"` or edit directly.\n\n---\n');
    }

    const timestamp = new Date().toISOString().replace('T', ' ').split('.')[0];
    const entry = `\n- **${timestamp}:** ${text}\n`;
    await fs.appendFile(ideasPath, entry);

    console.log(chalk.green(`Noted: "${text}"`));
    console.log(chalk.gray(`  Saved to ideas.md`));
  });
```

**Update cli/commands/status.js** -- Add type column and WIP summary:

Enhance the existing status command to also detect and show atom type (like the list command) and add a WIP progress summary at the bottom. The status command becomes a quick overview, while list is the detailed view.

```javascript
import { Command } from 'commander';
import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';

export const statusCommand = new Command('status')
  .description('Show WIP status of all atoms')
  .action(async () => {
    const atomsDir = path.resolve('atoms');

    if (!await fs.pathExists(atomsDir)) {
      console.log(chalk.yellow('No atoms directory found'));
      return;
    }

    const entries = await fs.readdir(atomsDir, { withFileTypes: true });
    const atoms = entries.filter(d => d.isDirectory());

    if (atoms.length === 0) {
      console.log(chalk.yellow('No atoms yet. Run `eoe create <type> <name>` to start.'));
      return;
    }

    // Collect atom data
    const rows = [];
    for (const atom of atoms) {
      const atomPath = path.join(atomsDir, atom.name);
      const configPath = path.join(atomPath, 'config.json');
      const notesPath = path.join(atomPath, 'NOTES.md');
      const stat = await fs.stat(atomPath);

      // Detect type
      let type = 'visual';
      if (await fs.pathExists(configPath)) {
        try {
          const config = await fs.readJson(configPath);
          if (config.type) type = config.type;
        } catch (e) { /* ignore */ }
      }

      // Read stage
      let stage = 'idea';
      if (await fs.pathExists(notesPath)) {
        const notes = await fs.readFile(notesPath, 'utf8');
        const stageMatch = notes.match(/\*\*Stage:\*\*\s*(\w[\w-]*)/);
        if (stageMatch) stage = stageMatch[1];
      }

      // Parse name and date
      const parts = atom.name.match(/^(\d{4}-\d{2}-\d{2})-(.+)$/);
      const date = parts ? parts[1] : 'unknown';
      const name = parts ? parts[2] : atom.name;

      rows.push({
        name,
        type,
        stage,
        created: date,
        modified: stat.mtime.toISOString().split('T')[0]
      });
    }

    // Sort newest first
    rows.sort((a, b) => b.created.localeCompare(a.created));

    // Color functions
    const typeColors = {
      visual: chalk.cyan,
      audio: chalk.magenta,
      'audio-visual': chalk.yellow,
      composition: chalk.green
    };
    const stageColors = {
      idea: chalk.gray,
      sketch: chalk.blue,
      refine: chalk.yellow,
      done: chalk.green
    };

    // Calculate column widths
    const nameWidth = Math.max(4, ...rows.map(r => r.name.length));
    const typeWidth = Math.max(4, ...rows.map(r => r.type.length));

    // Print header
    const header = `${'NAME'.padEnd(nameWidth)}  ${'TYPE'.padEnd(typeWidth)}  ${'STAGE'.padEnd(7)}  ${'CREATED'.padEnd(10)}  MODIFIED`;
    console.log(chalk.bold(header));
    console.log('-'.repeat(header.length));

    // Print rows
    for (const row of rows) {
      const typeColor = typeColors[row.type] || chalk.white;
      const stageColor = stageColors[row.stage] || chalk.white;
      console.log(
        `${row.name.padEnd(nameWidth)}  ${typeColor(row.type.padEnd(typeWidth))}  ${stageColor(row.stage.padEnd(7))}  ${row.created.padEnd(10)}  ${row.modified}`
      );
    }

    // WIP Summary (NOTE-03)
    console.log('');
    const stageCounts = {};
    const typeCounts = {};
    for (const row of rows) {
      stageCounts[row.stage] = (stageCounts[row.stage] || 0) + 1;
      typeCounts[row.type] = (typeCounts[row.type] || 0) + 1;
    }

    // Progress bar
    const total = rows.length;
    const done = stageCounts.done || 0;
    const wip = (stageCounts.sketch || 0) + (stageCounts.refine || 0);
    const ideas = stageCounts.idea || 0;

    const barWidth = 30;
    const doneBars = Math.round((done / total) * barWidth);
    const wipBars = Math.round((wip / total) * barWidth);
    const ideaBars = barWidth - doneBars - wipBars;

    const bar = chalk.green('='.repeat(doneBars)) +
                chalk.yellow('='.repeat(wipBars)) +
                chalk.gray('-'.repeat(Math.max(0, ideaBars)));

    console.log(`Progress: [${bar}] ${done}/${total} done`);
    console.log(
      chalk.gray('  ') +
      chalk.green(`${done} done`) + chalk.gray(' | ') +
      chalk.yellow(`${wip} wip`) + chalk.gray(' | ') +
      chalk.gray(`${ideas} idea`)
    );

    // Type summary
    const typeBreakdown = Object.entries(typeCounts)
      .map(([t, c]) => {
        const color = typeColors[t] || chalk.white;
        return color(`${c} ${t}`);
      })
      .join(chalk.gray(' | '));
    console.log(chalk.gray('  ') + typeBreakdown);

    console.log(chalk.gray(`\n${total} atom(s) total`));
  });
```

The status command is now the WIP tracker (NOTE-03) showing:
- Full table with name, type, stage, dates
- Progress bar (green=done, yellow=wip, gray=idea)
- Stage breakdown
- Type breakdown
  </action>
  <verify>
1. `eoe note "some creative idea"` still appends to ideas.md (backward compatible)
2. `eoe note <existing-atom-name>` opens NOTES.md in editor
3. `eoe note <nonexistent-name>` treats it as text and appends to ideas.md (fallback)
4. `eoe status` shows enhanced table with TYPE column
5. `eoe status` shows progress bar and WIP summary at bottom
6. Progress bar shows green for done, yellow for WIP, gray for idea
7. Stage and type breakdowns accurate
8. `eoe --help` shows all commands: create, dev, build, list, note, status
  </verify>
  <done>
`eoe note` enhanced: `eoe note <atom-name>` opens atom's NOTES.md in default editor; `eoe note "text"` still captures to ideas.md. `eoe status` enhanced with TYPE column, visual progress bar, and WIP summary showing done/wip/idea counts and type breakdown. Together with `eoe list`, fulfills NOTE-03 (WIP tracker) and NOTE-04 (CLI integration for notes).
  </done>
</task>

<task type="auto">
  <name>Task 5: Verify full Phase 2 integration end-to-end</name>
  <files>
    (no new files -- integration verification task)
  </files>
  <action>
Run a comprehensive end-to-end test of the entire Phase 2 feature set to verify all requirements are met and all atom types work together.

**Full CLI Verification:**
1. `eoe --help` -- shows all 6 commands: create, dev, build, list, note, status
2. `eoe create visual test-visual` -- creates visual atom
3. `eoe create audio test-audio` -- creates audio atom
4. `eoe create audio-visual test-av` -- creates audio-visual atom
5. `eoe create composition test-comp` -- creates composition atom
6. `eoe list` -- shows all 4 atoms with correct types
7. `eoe list --type audio` -- shows only audio atom
8. `eoe status` -- shows WIP tracker with progress bar
9. `eoe note "testing phase 2"` -- captures to ideas.md
10. `eoe note <composition-atom>` -- opens NOTES.md in editor (verify, then exit)

**Composition Playback Test:**
11. `eoe dev <composition-atom>` -- starts dev server
12. Open in browser, click Play
13. Verify: both lead and bass synths play
14. Verify: visual sketch reacts to audio (ring expands with bass, colors shift with mids)
15. Verify: composition loops after 4 measures
16. Verify: position counter updates
17. Adjust BPM in GUI -- tempo changes live
18. Click Stop -- everything stops, position resets

**Build Test:**
19. `eoe build <composition-atom>` -- produces production bundle
20. Verify `dist/<atom>/` contains bundled files
21. Open built files to verify they work standalone

**Audio-Visual Binding Test:**
22. `eoe dev <audio-visual-atom>` -- start audio-visual atom
23. Click Play -- verify visual reactivity:
    - Bass: circle ring expands/contracts
    - Mids: hue shifts
    - Treble: element detail changes
    - Beat: flash overlay
24. These should feel like "reacting" not "being controlled" (per CONTEXT.md specific)

**Cleanup and Disposal Test:**
25. With composition playing, edit composition.js and save -- HMR cleanup runs
26. No audio duplication after hot reload
27. Open DevTools Memory tab, play/stop 10 times -- no significant memory growth
28. Open two atoms in separate tabs -- both work independently

**Cleanup test atoms:**
```bash
rm -rf atoms/YYYY-MM-DD-test-visual
rm -rf atoms/YYYY-MM-DD-test-audio
rm -rf atoms/YYYY-MM-DD-test-av
rm -rf atoms/YYYY-MM-DD-test-comp
rm -rf dist/YYYY-MM-DD-test-comp
```

If any integration issues are found, fix them in the relevant files and re-verify.
  </action>
  <verify>
1. All 6 CLI commands work correctly
2. All 4 atom types scaffoldable and developable
3. Composition plays multiple synths with reactive visuals
4. Beat-based scheduling with Tone.Transport works
5. Audio analysis pipeline produces meaningful 0-1 values
6. Visual reactivity feels natural ("reacting" not "controlled")
7. Build produces standalone production bundles
8. List shows types and stages correctly
9. Status shows WIP tracker with progress bar
10. Note command supports both quick capture and per-atom notes
11. HMR cleanup prevents all resource duplication
12. No memory leaks after repeated play/stop/reload cycles
  </verify>
  <done>
Full Phase 2 integration verified end-to-end. All requirements met: AUD-01 (audio atoms), AUD-02 (synths/sequences/effects via composition), AUD-03 (audio-reactive visuals), AUD-04 (audio atom template), CLI-03 (build), CLI-05 (list with type/status), NOTE-03 (WIP tracker), NOTE-04 (CLI note/status integration). Creative workflow complete from scaffold to build.
  </done>
</task>

</tasks>

<verification>
1. `eoe create composition <name>` scaffolds multi-atom composition
2. CompositionManager orchestrates audio + visual atoms with centralized lifecycle
3. Beat-based scheduling works (bars:beats:sixteenths notation via Tone.Transport)
4. `eoe build <atom>` produces production bundle in dist/
5. `eoe list` shows atoms with type (visual/audio/audio-visual/composition) and stage
6. `eoe note <atom>` opens per-atom NOTES.md in editor
7. `eoe status` shows WIP tracker with progress bar and breakdowns
8. All Phase 2 requirements verified in integration test
</verification>

<success_criteria>
- Composition atom template orchestrates multiple audio atoms + visual atom (AUD-02)
- CompositionManager provides add/start/stop/dispose for multi-atom lifecycle
- Beat-based scheduling via Tone.Transport with tempo-relative notation
- Composition loops at configurable measure count
- Mix bus combines multiple audio sources for unified analysis
- `eoe build <atom>` produces standalone bundle in dist/ (CLI-03)
- `eoe list` shows type + stage with filters and summary (CLI-05)
- `eoe note <atom>` opens NOTES.md in editor (NOTE-04)
- `eoe status` shows WIP progress bar with done/wip/idea counts (NOTE-03)
- All 4 atom types: visual, audio, audio-visual, composition (AUD-04 complete)
- Full creative workflow: create -> dev -> tune -> build -> list -> status
- HMR cleanup prevents resource duplication across all atom types
- config.json round-trip works for all atom types
</success_criteria>

<output>
After completion, create `.planning/phases/02-audio-integration/02-03-SUMMARY.md`
</output>
