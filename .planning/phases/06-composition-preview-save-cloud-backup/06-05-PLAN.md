---
phase: 06-composition-preview-save-cloud-backup
plan: 05
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
duration: 3h
autonomous: true
files_modified:
  - portfolio/src/pages/c/[id].astro
  - server/backup-server.js
  - portfolio/src/scripts/composition-snapshot.ts
  - portfolio/astro.config.mjs
  - portfolio/src/pages/mobile/compositions.astro

must_haves:
  truths:
    - "Shareable URL at /c/[id] renders a read-only composition view"
    - "Read-only view shows composition name, atom list, route graph, and play button"
    - "Server endpoint GET /api/snapshot/:id returns snapshot data for the shared URL"
    - "Composition snapshot is stored on the server as part of backup data"
    - "Read-only view can preview (play) the composition using captured atom code"
    - "Share button on composition page copies URL to clipboard"
    - "Shared compositions load without requiring IndexedDB data (server-fetched)"
    - "End-to-end Phase 6 verification confirms all requirements (COMP-04, COMP-05, SYNC-01, SYNC-02, SYNC-03)"
  artifacts:
    - path: "portfolio/src/pages/c/[id].astro"
      provides: "Read-only composition viewer at /c/[id]"
      contains: "composition-viewer"
    - path: "server/backup-server.js"
      provides: "Updated with GET /api/snapshot/:id endpoint"
      contains: "/api/snapshot"
  key_links:
    - from: "portfolio/src/pages/c/[id].astro"
      to: "server/backup-server.js"
      via: "fetch /api/snapshot/:id"
      pattern: "/api/snapshot"
    - from: "portfolio/src/pages/c/[id].astro"
      to: "portfolio/src/scripts/preview-engine.ts"
      via: "import { PreviewEngine }"
      pattern: "PreviewEngine"
---

<objective>
Create shareable composition URLs and perform end-to-end Phase 6 verification. After this plan, users can share a composition via URL (/c/[id]) that renders a read-only view of the composition with playback capability. The shared page loads the snapshot from the server, so recipients don't need local IndexedDB data. Additionally, this plan verifies all Phase 6 requirements are met.

Purpose: Shareable URLs turn compositions into artifacts that can be shown to others -- a crucial step toward compositions as creative outputs rather than just internal tools. The verification ensures Phase 6 delivers everything it promised.

Output: /c/[id] read-only composition page, server snapshot endpoint, share button, full Phase 6 verification.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-composition-preview-save-cloud-backup/06-CONTEXT.md
@portfolio/src/scripts/composition-snapshot.ts
@portfolio/src/scripts/preview-engine.ts
@portfolio/src/scripts/atom-runtime.ts
@portfolio/src/scripts/composition-types.ts
@server/backup-server.js
@portfolio/astro.config.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add snapshot sharing endpoint to backup server</name>
  <files>
    server/backup-server.js
  </files>
  <action>
Add an endpoint to the backup server that serves individual snapshots by ID. This enables the /c/[id] page to fetch snapshot data from the server without needing local IndexedDB.

**Add to server/backup-server.js** (before the listen call):

```javascript
/**
 * GET /api/snapshot/:id
 * Get a specific snapshot by ID from any backup.
 * Searches through all backups to find the snapshot.
 * Used by the shareable /c/[id] page.
 */
app.get('/api/snapshot/:id', async (req, res) => {
  try {
    const snapshotId = req.params.id;
    const files = await readdir(DATA_DIR);
    const backupFiles = files
      .filter(f => f.startsWith('backup-') && f.endsWith('.json'))
      .sort()
      .reverse(); // Most recent first

    for (const file of backupFiles) {
      const filepath = join(DATA_DIR, file);
      const content = await readFile(filepath, 'utf-8');
      const backup = JSON.parse(content);

      if (backup.data && backup.data.snapshots) {
        const snapshot = backup.data.snapshots.find(s => s.id === snapshotId);
        if (snapshot) {
          return res.json(snapshot);
        }
      }
    }

    return res.status(404).json({ error: 'Snapshot not found' });
  } catch (err) {
    console.error('[backup] Error fetching snapshot:', err);
    res.status(500).json({ error: 'Failed to fetch snapshot' });
  }
});

/**
 * POST /api/snapshot
 * Upload a single snapshot for sharing.
 * This allows sharing without requiring a full backup.
 *
 * Body: CompositionSnapshot JSON
 * Returns: { id, url }
 */
app.post('/api/snapshot', async (req, res) => {
  try {
    const snapshot = req.body;
    if (!snapshot || !snapshot.id || !snapshot.atoms) {
      return res.status(400).json({ error: 'Invalid snapshot data' });
    }

    // Store as a standalone snapshot file
    const filepath = join(DATA_DIR, `snapshot-${snapshot.id}.json`);
    await writeFile(filepath, JSON.stringify(snapshot, null, 2), 'utf-8');

    console.log(`[backup] Shared snapshot: ${snapshot.id}`);
    res.json({
      id: snapshot.id,
      url: `/c/${snapshot.id}`,
    });
  } catch (err) {
    console.error('[backup] Error sharing snapshot:', err);
    res.status(500).json({ error: 'Failed to share snapshot' });
  }
});
```

Also update the GET /api/snapshot/:id handler to also check standalone snapshot files:

After searching through backups, add:

```javascript
// Also check standalone snapshot files
const standaloneFile = join(DATA_DIR, `snapshot-${snapshotId}.json`);
if (existsSync(standaloneFile)) {
  const content = await readFile(standaloneFile, 'utf-8');
  return res.json(JSON.parse(content));
}
```

This ensures snapshots can be found whether they were uploaded as part of a backup or shared individually.
  </action>
  <verify>
1. GET /api/snapshot/:id searches backups for snapshot
2. GET /api/snapshot/:id also checks standalone snapshot files
3. POST /api/snapshot stores standalone snapshot file
4. Returns 404 when snapshot not found
5. No changes break existing backup endpoints
  </verify>
  <done>
Snapshot sharing endpoints added: GET /api/snapshot/:id (search backups + standalone), POST /api/snapshot (upload for sharing). Snapshots findable whether in backups or shared individually.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shareable composition viewer page</name>
  <files>
    portfolio/src/pages/c/[id].astro
  </files>
  <action>
Create the /c/[id] page that renders a read-only composition view from a server-fetched snapshot.

**Create portfolio/src/pages/c/ directory and portfolio/src/pages/c/[id].astro:**

```astro
---
/**
 * Shareable Composition Viewer
 *
 * Read-only view of a composition snapshot at /c/[id].
 * Fetches snapshot data from the server API, not from IndexedDB.
 * Enables sharing compositions via URL without requiring the recipient
 * to have local data.
 *
 * Features:
 * - Composition name and metadata display
 * - Atom list with parameters
 * - Route visualization
 * - Play button to preview the composition
 * - No editing capabilities (read-only)
 */
import MobileLayout from '../../layouts/MobileLayout.astro';
import '../../styles/canvas.css';

export interface Props {
  id: string;
}

const { id } = Astro.params;
---

<MobileLayout title="Composition" showBack={true} backHref="/">
  <div class="viewer-page">
    <!-- Loading state -->
    <div id="viewer-loading" class="viewer-loading">
      <div class="viewer-spinner"></div>
      <div>Loading composition...</div>
    </div>

    <!-- Error state -->
    <div id="viewer-error" class="viewer-error" style="display: none;">
      <div class="viewer-error-icon">?</div>
      <div class="viewer-error-text">Composition not found</div>
      <div class="viewer-error-sub">This composition may have been deleted or the link may be incorrect.</div>
    </div>

    <!-- Composition content -->
    <div id="viewer-content" class="viewer-content" style="display: none;">
      <!-- Header -->
      <div class="viewer-header">
        <h1 id="viewer-name" class="viewer-name"></h1>
        <div id="viewer-meta" class="viewer-meta"></div>
      </div>

      <!-- Atoms list -->
      <div class="viewer-section">
        <h2 class="viewer-section-title">Atoms</h2>
        <div id="viewer-atoms" class="viewer-atoms-list"></div>
      </div>

      <!-- Routes -->
      <div class="viewer-section">
        <h2 class="viewer-section-title">Routes</h2>
        <div id="viewer-routes" class="viewer-routes-list"></div>
      </div>

      <!-- Preview area (hidden iframes) -->
      <div id="preview-area" style="position: fixed; bottom: 0; left: 0; width: 0; height: 0; overflow: hidden;"></div>

      <!-- Play button -->
      <div class="viewer-play-section">
        <button id="viewer-play-btn" class="viewer-play-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"/>
          </svg>
          <span id="play-label">Play Composition</span>
        </button>
      </div>

      <!-- Share button -->
      <div class="viewer-share-section">
        <button id="viewer-share-btn" class="viewer-share-btn">
          Copy Link
        </button>
      </div>
    </div>
  </div>
</MobileLayout>

<script define:vars={{ id }}>
  window.__compositionId = id;
</script>

<script>
  const compositionId = (window as any).__compositionId;
  const loading = document.getElementById('viewer-loading')!;
  const error = document.getElementById('viewer-error')!;
  const content = document.getElementById('viewer-content')!;
  const nameEl = document.getElementById('viewer-name')!;
  const metaEl = document.getElementById('viewer-meta')!;
  const atomsEl = document.getElementById('viewer-atoms')!;
  const routesEl = document.getElementById('viewer-routes')!;
  const playBtn = document.getElementById('viewer-play-btn')!;
  const playLabel = document.getElementById('play-label')!;
  const shareBtn = document.getElementById('viewer-share-btn')!;

  let snapshot: any = null;
  let isPlaying = false;

  async function loadComposition() {
    try {
      // Try server first (shared snapshots)
      const res = await fetch(`/api/snapshot/${compositionId}`);
      if (res.ok) {
        snapshot = await res.json();
        renderSnapshot();
        return;
      }

      // Try local IndexedDB (own snapshots)
      try {
        const { getSnapshot } = await import('../../scripts/db');
        const localSnapshot = await getSnapshot(compositionId);
        if (localSnapshot) {
          snapshot = localSnapshot;
          renderSnapshot();
          return;
        }
      } catch { /* IndexedDB may not have this snapshot */ }

      // Not found
      showError();
    } catch (err) {
      console.error('[viewer] Failed to load:', err);
      showError();
    }
  }

  function showError() {
    loading.style.display = 'none';
    error.style.display = 'flex';
  }

  function renderSnapshot() {
    loading.style.display = 'none';
    content.style.display = 'block';

    // Name and metadata
    nameEl.textContent = snapshot.name;
    const date = new Date(snapshot.createdAt).toLocaleDateString();
    const atomCount = snapshot.atoms?.length || 0;
    const routeCount = snapshot.routes?.length || 0;
    metaEl.textContent = `${atomCount} atom${atomCount !== 1 ? 's' : ''} · ${routeCount} route${routeCount !== 1 ? 's' : ''} · ${date}`;

    // Atoms list
    atomsEl.innerHTML = '';
    for (const atom of snapshot.atoms || []) {
      const item = document.createElement('div');
      item.className = 'viewer-atom-item';
      item.innerHTML = `
        <div class="viewer-atom-name">${atom.title || atom.atomSlug}</div>
        <div class="viewer-atom-type">${atom.type || 'visual'}</div>
      `;
      atomsEl.appendChild(item);
    }

    // Routes list
    routesEl.innerHTML = '';
    for (const route of snapshot.routes || []) {
      const sourceAtom = snapshot.atoms.find((a: any) => a.nodeId === route.sourceNodeId);
      const targetAtom = snapshot.atoms.find((a: any) => a.nodeId === route.targetNodeId);
      const sourceName = sourceAtom?.title || '?';
      const targetName = targetAtom?.title || '?';

      const item = document.createElement('div');
      item.className = 'viewer-route-item';
      item.innerHTML = `
        <span class="route-source">${sourceName}.${route.sourceParam}</span>
        <span class="route-arrow">&rarr;</span>
        <span class="route-target">${targetName}.${route.targetParam}</span>
      `;
      routesEl.appendChild(item);
    }

    if ((snapshot.routes || []).length === 0) {
      routesEl.innerHTML = '<div class="viewer-empty">No parameter routes</div>';
    }
  }

  // Play/Stop toggle
  playBtn.addEventListener('click', async () => {
    if (!snapshot) return;

    if (isPlaying) {
      // Stop
      window.dispatchEvent(new CustomEvent('eoe:preview-stop'));
      playLabel.textContent = 'Play Composition';
      isPlaying = false;
      return;
    }

    // Play: use PreviewEngine with snapshot data
    try {
      const { PreviewEngine } = await import('../../scripts/preview-engine');
      const { buildAtomsMapFromSnapshot } = await import('../../scripts/composition-snapshot');

      const atomsMap = buildAtomsMapFromSnapshot(snapshot);

      // Convert snapshot to composition-like object for preview engine
      const composition = {
        id: snapshot.compositionId || snapshot.id,
        name: snapshot.name,
        createdAt: snapshot.createdAt,
        updatedAt: snapshot.createdAt,
        atoms: snapshot.atoms.map((a: any) => ({
          nodeId: a.nodeId,
          atomSlug: a.atomSlug,
          position: a.position,
          paramOverrides: a.paramOverrides,
        })),
        routes: snapshot.routes,
        viewport: snapshot.viewport || { x: 0, y: 0, zoom: 1 },
        synced: true,
        playbackMode: snapshot.playbackMode || 'simultaneous',
      };

      const engine = new PreviewEngine({
        onStateChange: (state) => {
          isPlaying = state === 'playing';
          playLabel.textContent = isPlaying ? 'Stop' : 'Play Composition';
        },
        onRouteActive: () => {},
        onAtomReady: () => {},
        onAtomError: (nodeId, msg) => console.warn('[viewer] Atom error:', nodeId, msg),
        onGlitch: () => console.warn('[viewer] Audio glitch detected'),
      });

      await engine.init(composition as any, atomsMap);
      engine.play();
      isPlaying = true;
      playLabel.textContent = 'Stop';

      // Store engine reference for cleanup
      (window as any).__viewerEngine = engine;
    } catch (err) {
      console.error('[viewer] Failed to play:', err);
      playLabel.textContent = 'Play failed';
    }
  });

  // Share: copy URL to clipboard
  shareBtn.addEventListener('click', async () => {
    const url = window.location.href;
    try {
      await navigator.clipboard.writeText(url);
      shareBtn.textContent = 'Copied!';
      setTimeout(() => { shareBtn.textContent = 'Copy Link'; }, 2000);
    } catch {
      // Fallback for older browsers
      const input = document.createElement('input');
      input.value = url;
      document.body.appendChild(input);
      input.select();
      document.execCommand('copy');
      document.body.removeChild(input);
      shareBtn.textContent = 'Copied!';
      setTimeout(() => { shareBtn.textContent = 'Copy Link'; }, 2000);
    }
  });

  // Cleanup on navigation
  window.addEventListener('beforeunload', () => {
    const engine = (window as any).__viewerEngine;
    if (engine) engine.cleanup();
  });

  // Load composition
  loadComposition();
</script>

<style>
  .viewer-page {
    padding: 16px;
    min-height: 60vh;
  }

  .viewer-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 48px;
    color: #666;
  }

  .viewer-spinner {
    width: 24px;
    height: 24px;
    border: 3px solid #333;
    border-top-color: #6bb5ff;
    border-radius: 50%;
    animation: viewer-spin 0.8s linear infinite;
  }

  @keyframes viewer-spin {
    to { transform: rotate(360deg); }
  }

  .viewer-error {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 48px;
    text-align: center;
  }

  .viewer-error-icon {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: #333;
    color: #666;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    font-weight: 700;
  }

  .viewer-error-text {
    font-size: 1.1rem;
    font-weight: 600;
    color: #ccc;
  }

  .viewer-error-sub {
    font-size: 0.85rem;
    color: #666;
    max-width: 280px;
  }

  .viewer-header {
    margin-bottom: 24px;
  }

  .viewer-name {
    font-size: 1.4rem;
    font-weight: 700;
    color: #fff;
    margin: 0 0 6px;
  }

  .viewer-meta {
    font-size: 0.85rem;
    color: #888;
  }

  .viewer-section {
    margin-bottom: 20px;
  }

  .viewer-section-title {
    font-size: 0.8rem;
    font-weight: 600;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin: 0 0 10px;
  }

  .viewer-atoms-list, .viewer-routes-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .viewer-atom-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 14px;
    background: #1a1a1a;
    border-radius: 8px;
  }

  .viewer-atom-name {
    font-size: 0.9rem;
    font-weight: 600;
    color: #ccc;
  }

  .viewer-atom-type {
    font-size: 0.75rem;
    font-weight: 700;
    color: #6bb5ff;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .viewer-route-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 14px;
    background: #1a1a1a;
    border-radius: 8px;
    font-size: 0.85rem;
  }

  .route-source {
    color: #6bb5ff;
    font-weight: 600;
  }

  .route-arrow {
    color: #444;
  }

  .route-target {
    color: #6bff6b;
    font-weight: 600;
  }

  .viewer-empty {
    padding: 12px;
    text-align: center;
    color: #555;
    font-size: 0.85rem;
  }

  .viewer-play-section {
    margin: 24px 0 12px;
  }

  .viewer-play-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    width: 100%;
    padding: 16px;
    background: #6bb5ff;
    color: #0a0a0a;
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 700;
    cursor: pointer;
    min-height: 56px;
    -webkit-tap-highlight-color: transparent;
  }

  .viewer-play-btn:active {
    background: #5aa0e8;
  }

  .viewer-share-section {
    margin-bottom: 24px;
  }

  .viewer-share-btn {
    display: block;
    width: 100%;
    padding: 14px;
    background: #222;
    color: #ccc;
    border: 1px solid #333;
    border-radius: 10px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    min-height: 48px;
    -webkit-tap-highlight-color: transparent;
  }

  .viewer-share-btn:active {
    background: #2a2a2a;
  }
</style>
```

**Important:** Since this is a dynamic route ([id].astro), Astro needs to know this is a server-rendered or client-rendered page. Since the portfolio builds as static (default), we need to handle this as a client-side route. The [id].astro page should work as a static page with client-side JavaScript fetching the snapshot data. The `Astro.params.id` is available at build time for SSG, but since we want dynamic IDs, we use a catch-all approach.

For Astro static mode, the page needs `getStaticPaths`. Since we can't predict all snapshot IDs at build time, we should either:
1. Use Astro SSR mode for this route (more complex)
2. Use a client-side approach where the page reads the ID from the URL

The simplest approach for v1.1: use client-side URL parsing. The page extracts the ID from `window.location.pathname`:

Replace the `define:vars` script with:

```typescript
const pathParts = window.location.pathname.split('/');
const compositionId = pathParts[pathParts.length - 1] || pathParts[pathParts.length - 2];
```

And handle the static paths with a placeholder:

```astro
---
export function getStaticPaths() {
  // Return a placeholder - actual IDs resolved client-side
  return [{ params: { id: 'view' } }];
}
---
```

Actually, the cleanest approach for this use case: create a non-dynamic page at `/c/index.astro` that reads the ID from query params or URL hash. This avoids SSG/SSR complexity entirely.

**Alternative: Create portfolio/src/pages/c/[id].astro** with getStaticPaths returning an empty array, and rely on the SPA fallback in nginx (try_files $uri $uri/ /index.html). The page will load, read the URL, and fetch the snapshot. But Astro will not generate the page at build time.

**Simplest approach:** Create the page as a regular page that uses the URL. Since nginx has `try_files $uri $uri/ /index.html`, any /c/* URL will fall through to index.html. But that's the main page, not our composition viewer.

**Best approach for Astro static:** Create a catch-all page. Use `[...slug].astro` in the c/ directory:

```astro
---
export function getStaticPaths() {
  return [{ params: { slug: undefined } }];
}
const slug = Astro.params.slug;
---
```

This generates /c/index.html which nginx serves for /c/anything. The client-side script parses the actual URL to get the ID.

The executor should choose the approach that works with the existing Astro config. The key requirement is: visiting /c/abc123 loads a page that fetches /api/snapshot/abc123.
  </action>
  <verify>
1. /c/[id] page (or equivalent) renders composition viewer
2. Page fetches snapshot from /api/snapshot/:id
3. Falls back to local IndexedDB if server fetch fails
4. Shows composition name, atom list, route list
5. Play button starts preview using PreviewEngine
6. Copy Link button copies URL to clipboard
7. Error state shown when snapshot not found
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Shareable composition viewer created at /c/[id] with read-only view, server-fetched snapshot data, playback via PreviewEngine, share button for URL copying, and fallback to local IndexedDB.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add share button to composition snapshot cards</name>
  <files>
    portfolio/src/pages/mobile/compositions.astro
    portfolio/src/scripts/composition-snapshot.ts
  </files>
  <action>
Add a share button to snapshot cards in the compositions list that uploads the snapshot to the server and copies the shareable URL.

**Update portfolio/src/pages/mobile/compositions.astro:**

In the renderSnapshots function (added in Plan 06-02), add a "Share" button alongside each snapshot item:

Update the snapshot item HTML template to include a share button:

```html
<div class="snapshot-actions">
  <a href="/mobile/compose?snapshot=${snap.id}" class="snapshot-open-btn">Open</a>
  <button class="snapshot-share-btn" data-snapshot-id="${snap.id}">Share</button>
</div>
```

Add the share button click handler:

```typescript
// Share snapshot handlers
list.querySelectorAll('.snapshot-share-btn').forEach(btn => {
  btn.addEventListener('click', async (e) => {
    e.preventDefault();
    const el = e.target as HTMLButtonElement;
    const snapId = el.getAttribute('data-snapshot-id');
    if (!snapId) return;

    el.textContent = 'Uploading...';
    el.disabled = true;

    try {
      const { shareSnapshot } = await import('../../scripts/composition-snapshot');
      const url = await shareSnapshot(snapId);

      if (url) {
        await navigator.clipboard.writeText(window.location.origin + url);
        el.textContent = 'Link copied!';
      } else {
        el.textContent = 'Share failed';
      }
    } catch {
      el.textContent = 'Share failed';
    }

    setTimeout(() => {
      el.textContent = 'Share';
      el.disabled = false;
    }, 2000);
  });
});
```

Add CSS for the share button:

```css
.snapshot-actions {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.snapshot-open-btn, .snapshot-share-btn {
  padding: 6px 14px;
  border: none;
  border-radius: 6px;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  min-height: 32px;
  -webkit-tap-highlight-color: transparent;
}

.snapshot-open-btn {
  background: #333;
  color: #6bb5ff;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
}

.snapshot-share-btn {
  background: #222;
  color: #ccc;
  border: 1px solid #333;
}
```

**Update portfolio/src/scripts/composition-snapshot.ts:**

Add a shareSnapshot function that uploads the snapshot to the server:

```typescript
/**
 * Upload a snapshot to the server for sharing.
 * Returns the shareable URL path (e.g., /c/abc123).
 */
export async function shareSnapshot(snapshotId: string): Promise<string | null> {
  try {
    const snapshot = await getSnapshot(snapshotId);
    if (!snapshot) return null;

    const res = await fetch('/api/snapshot', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(snapshot),
    });

    if (!res.ok) throw new Error(`Server returned ${res.status}`);

    const data = await res.json();
    return data.url || `/c/${snapshot.id}`;
  } catch (err) {
    console.error('[snapshot] Share failed:', err);
    return null;
  }
}
```

Add the import for getSnapshot at the top (it already imports from db.ts, just verify getSnapshot is imported).
  </action>
  <verify>
1. Share button appears on each snapshot in compositions list
2. Clicking Share uploads snapshot to server and copies URL
3. shareSnapshot function in composition-snapshot.ts uploads to /api/snapshot
4. URL is copied to clipboard on success
5. Visual feedback: "Uploading..." -> "Link copied!" -> "Share"
6. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Share button added to snapshot cards. Uploads snapshot to server, generates /c/[id] URL, copies to clipboard. Visual feedback for upload/success/error states.
  </done>
</task>

<task type="auto">
  <name>Task 4: End-to-end Phase 6 verification</name>
  <files>
    (verification task - no files modified)
  </files>
  <action>
Verify all Phase 6 requirements are met by checking each deliverable against the success criteria from the ROADMAP.

**COMP-04: User can preview composition**
Verify:
- [ ] PreviewEngine loads atoms from composition and executes in iframes
- [ ] Simultaneous mode starts all atoms at once
- [ ] Sequential mode starts one atom at a time with Next button
- [ ] Parameter routes applied in real-time during playback (30fps loop)
- [ ] Active routes highlighted with pulsing animation on canvas edges
- [ ] Audio glitches show warning with Continue/Restart buttons
- [ ] Preview cleans up all resources when stopped
- [ ] Play/Pause/Stop controls accessible from compose page toolbar

**COMP-05: User can save composition**
Verify:
- [ ] Save button in toolbar creates immutable snapshot
- [ ] Snapshot captures inline atom code, config, routes, metadata
- [ ] Snapshot uses hybrid structure (slug + inline code)
- [ ] Save/reload cycle is lossless
- [ ] Snapshots appear in compositions list with metadata
- [ ] Snapshot playback uses captured code (immutability)
- [ ] Shareable URL at /c/[id] renders read-only composition view

**SYNC-01: User can backup atoms to cloud**
Verify:
- [ ] Backup server accepts POST /api/backup with full creative content
- [ ] Backup includes: atoms, compositions, snapshots, voice notes (metadata), config overrides
- [ ] Auto-backup on app close (visibilitychange + sendBeacon)
- [ ] Manual backup from /mobile/backup page
- [ ] No storage limits enforced
- [ ] All backups kept indefinitely

**SYNC-02: User can see backup status**
Verify:
- [ ] Badge visible in app header on all mobile pages
- [ ] Badge shows: synced (green), pending (orange+count), active (blue spinner), error (red)
- [ ] Badge navigates to /mobile/backup on tap
- [ ] Sync status indicator shows backup progress

**SYNC-03: User can restore from backup**
Verify:
- [ ] GET /api/backup/list returns all available backups
- [ ] Restore modal shows backup contents with category checkboxes
- [ ] Selective restore: user picks atoms/compositions/snapshots
- [ ] Restore writes to IndexedDB and reloads page
- [ ] Conflict resolver UI available for per-item decisions
- [ ] Auto-retry: 3 attempts with exponential backoff

**Performance and UX:**
- [ ] `cd portfolio && npm run build` completes without errors
- [ ] Cloud backup completes in <30 seconds
- [ ] All touch targets >= 44px (Apple HIG)
- [ ] Dark theme consistent across all new UI
- [ ] No regressions in Phase 5 features

**Build the project and verify:**

```bash
cd portfolio && npm run build
```

Count pages built and verify no errors. Expected: 18+ pages (17 from Phase 5 + backup page + composition viewer).

**Verify files created in Phase 6:**

New files:
- portfolio/src/scripts/preview-engine.ts
- portfolio/src/scripts/atom-runtime.ts
- portfolio/src/scripts/composition-snapshot.ts
- portfolio/src/scripts/backup-client.ts
- portfolio/src/components/PreviewControls.astro
- portfolio/src/components/BackupStatusBadge.astro
- portfolio/src/components/RestoreModal.astro
- portfolio/src/components/ConflictResolver.astro
- portfolio/src/pages/mobile/backup.astro
- portfolio/src/pages/c/[id].astro (or equivalent)
- server/backup-server.js
- server/package.json
- server/Dockerfile

Modified files:
- portfolio/src/scripts/composition-types.ts (playbackMode, snapshot types)
- portfolio/src/scripts/db.ts (DB_VERSION 3, snapshots store)
- portfolio/src/scripts/composition-store.ts (if any changes needed)
- portfolio/src/components/OfflineIndicator.astro (SHOW_SYNC_STATUS = true)
- portfolio/src/components/CompositionCanvas.astro (preview integration)
- portfolio/src/components/CompositionToolbar.astro (save button)
- portfolio/src/pages/mobile/compose.astro (preview engine, snapshot loading)
- portfolio/src/pages/mobile/compositions.astro (snapshots section, share button)
- portfolio/src/layouts/MobileLayout.astro (backup badge)
- portfolio/src/styles/canvas.css (route animation, preview glow)
- portfolio/docker-compose.yml (backup service)
- portfolio/nginx.conf (/api/ proxy)
- deploy.sh (backup server health check)
  </action>
  <verify>
All Phase 6 requirements verified against ROADMAP success criteria.
Build succeeds with all new pages and components.
No regressions in Phase 4/5 features.
  </verify>
  <done>
End-to-end Phase 6 verification complete. All requirements (COMP-04, COMP-05, SYNC-01, SYNC-02, SYNC-03) verified. Build succeeds. No regressions.
  </done>
</task>

</tasks>

<verification>
1. `cd portfolio && npm run build` completes without errors
2. /c/[id] page renders composition viewer with name, atoms, routes, play button
3. Share button uploads snapshot and copies URL to clipboard
4. Server endpoint GET /api/snapshot/:id returns snapshot data
5. POST /api/snapshot stores standalone snapshot for sharing
6. Shared compositions playable from the /c/[id] URL
7. All Phase 6 requirements verified: COMP-04, COMP-05, SYNC-01, SYNC-02, SYNC-03
8. No regressions in Phase 4/5 features
9. 18+ pages build successfully
10. All new files exist and are properly linked
</verification>

<success_criteria>
- Shareable URL at /c/[id] renders read-only composition view with playback
- Share button on snapshots copies URL to clipboard
- Server stores and serves shared snapshots
- Full Phase 6 verification confirms all requirements met
- COMP-04: Preview with real-time routing
- COMP-05: Immutable snapshot save with hybrid structure
- SYNC-01: Cloud backup of all creative content
- SYNC-02: Backup status badge visible at all times
- SYNC-03: Selective restore from any backup
</success_criteria>

<output>
After completion, create:
- `.planning/phases/06-composition-preview-save-cloud-backup/06-05-SUMMARY.md`
- `.planning/phases/06-composition-preview-save-cloud-backup/06-VERIFICATION.md`
</output>
