---
phase: 06-composition-preview-save-cloud-backup
plan: 02
type: execute
wave: 1
depends_on: []
duration: 3h
autonomous: true
files_modified:
  - portfolio/src/scripts/composition-snapshot.ts
  - portfolio/src/scripts/composition-store.ts
  - portfolio/src/scripts/composition-types.ts
  - portfolio/src/scripts/db.ts
  - portfolio/src/pages/mobile/compositions.astro
  - portfolio/src/components/CompositionToolbar.astro

must_haves:
  truths:
    - "Composition save produces an immutable snapshot: once saved, the composition always plays the exact atom code it captured"
    - "Snapshot JSON stores both inline atom code AND atom slug references (hybrid structure)"
    - "Save/reload cycle is lossless: save composition, reload app, composition is identical"
    - "Compositions list shows snapshot metadata (atom count, route count, creation date, snapshot size)"
    - "Each snapshot has a unique ID suitable for shareable URLs (e.g., /c/[id])"
    - "IndexedDB 'snapshots' store holds immutable composition snapshots"
    - "Existing composition CRUD (create, edit, delete) continues to work for draft compositions"
    - "User can explicitly save a composition as a snapshot via toolbar button"
  artifacts:
    - path: "portfolio/src/scripts/composition-snapshot.ts"
      provides: "Snapshot creation, loading, and serialization logic"
      contains: "createSnapshot"
    - path: "portfolio/src/scripts/db.ts"
      provides: "Updated IndexedDB schema with snapshots store (DB_VERSION 3)"
      contains: "snapshots"
  key_links:
    - from: "portfolio/src/scripts/composition-snapshot.ts"
      to: "portfolio/src/scripts/composition-types.ts"
      via: "import { Composition, CompositionSnapshot }"
      pattern: "CompositionSnapshot"
    - from: "portfolio/src/scripts/composition-snapshot.ts"
      to: "portfolio/src/scripts/db.ts"
      via: "import { getDB, getAtom }"
      pattern: "getDB"
    - from: "portfolio/src/pages/mobile/compositions.astro"
      to: "portfolio/src/scripts/composition-snapshot.ts"
      via: "import { getAllSnapshots }"
      pattern: "getAllSnapshots"
---

<objective>
Implement composition save/load with immutable snapshots. After this plan, users can save a composition as a permanent snapshot that captures the exact atom code, parameter values, and routing graph at that moment in time. Even if the original atoms evolve later, the snapshot always plays the exact code it captured. Snapshots are stored in IndexedDB and appear in the compositions list alongside draft compositions.

Purpose: Immutable snapshots are the "lock in a moment" feature -- they let users experiment freely knowing they can always return to a saved state. This is the persistence layer that makes compositions shareable and restorable.

Output: CompositionSnapshot type, snapshot creation/loading logic, updated IndexedDB schema, toolbar save button, compositions list showing both drafts and snapshots.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-composition-preview-save-cloud-backup/06-CONTEXT.md
@portfolio/src/scripts/composition-types.ts
@portfolio/src/scripts/composition-store.ts
@portfolio/src/scripts/db.ts
@portfolio/src/pages/mobile/compositions.astro
@portfolio/src/components/CompositionToolbar.astro
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define CompositionSnapshot types</name>
  <files>
    portfolio/src/scripts/composition-types.ts
  </files>
  <action>
Add the CompositionSnapshot interface and related types to the composition types file.

**Append to portfolio/src/scripts/composition-types.ts:**

```typescript
/**
 * Immutable composition snapshot.
 *
 * A snapshot captures EVERYTHING needed to replay a composition:
 * - Full atom code (sketch.js, audio.js, config.json) inline
 * - All parameter routes with values at time of save
 * - Composition metadata (name, playback mode, viewport)
 *
 * Snapshots are immutable: once created, they never change.
 * This ensures "lock in a moment" behavior -- even if original
 * atoms evolve, the snapshot plays the exact code it captured.
 */
export interface CompositionSnapshot {
  id: string;                        // UUID, suitable for /c/[id] URLs
  compositionId: string;             // ID of source draft composition
  name: string;                      // Inherited from composition name
  createdAt: string;                 // ISO timestamp of snapshot creation
  playbackMode: 'simultaneous' | 'sequential';
  viewport: { x: number; y: number; zoom: number };
  atoms: SnapshotAtom[];             // Full atom data captured at snapshot time
  routes: ParameterRoute[];          // Routes at snapshot time
  synced: boolean;                   // Cloud backup flag
}

/**
 * Atom captured within a snapshot.
 * Contains both the slug reference AND the inline code.
 * Hybrid structure: slug for linkability, inline code for portability.
 */
export interface SnapshotAtom {
  nodeId: string;                    // Position in the composition graph
  atomSlug: string;                  // Original atom slug (for reference/linking)
  position: { x: number; y: number };
  title: string;                     // Atom title at snapshot time
  type: string;                      // "visual" | "audio" | "audio-visual"
  code: string;                      // sketch.js content (inline, immutable)
  configJson: string;                // config.json content (full original config)
  paramOverrides?: Record<string, number | string | boolean>;
}
```

These types ensure:
- CompositionSnapshot is self-contained (all code inline)
- Hybrid: slug for reference, inline code for immutability
- Routes reference nodeIds within the snapshot's own atom list
- synced flag for Phase 6 cloud backup
  </action>
  <verify>
1. CompositionSnapshot interface is exported with id, compositionId, atoms, routes fields
2. SnapshotAtom interface includes code, configJson (inline captures)
3. SnapshotAtom includes atomSlug (hybrid reference)
4. synced field exists on CompositionSnapshot
5. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
CompositionSnapshot and SnapshotAtom types defined with hybrid structure (inline code + slug reference), immutable snapshot semantics, and cloud sync flag.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update IndexedDB schema with snapshots store</name>
  <files>
    portfolio/src/scripts/db.ts
  </files>
  <action>
Bump the IndexedDB version and add a 'snapshots' object store for immutable composition snapshots.

**Modify portfolio/src/scripts/db.ts:**

1. Change `DB_VERSION` from 2 to 3:

```typescript
const DB_VERSION = 3;
```

2. In the `upgrade` function inside `openDB`, add the snapshots store creation. Add this AFTER the existing compositions store block:

```typescript
// Snapshots store (Phase 6 - immutable composition snapshots)
if (!db.objectStoreNames.contains('snapshots')) {
  const snapshotStore = db.createObjectStore('snapshots', { keyPath: 'id' });
  snapshotStore.createIndex('compositionId', 'compositionId');
  snapshotStore.createIndex('createdAt', 'createdAt');
  snapshotStore.createIndex('synced', 'synced');
  snapshotStore.createIndex('name', 'name');
}
```

3. Add CRUD functions for snapshots at the end of the file, after the existing storage quota section:

```typescript
// ---- Snapshots CRUD (Phase 6) ----

import type { CompositionSnapshot } from './composition-types';

export async function saveSnapshot(snapshot: CompositionSnapshot): Promise<void> {
  const db = await getDB();
  await db.put('snapshots', snapshot);
}

export async function getSnapshot(id: string): Promise<CompositionSnapshot | undefined> {
  const db = await getDB();
  return db.get('snapshots', id);
}

export async function getAllSnapshots(): Promise<CompositionSnapshot[]> {
  const db = await getDB();
  const snapshots = await db.getAllFromIndex('snapshots', 'createdAt');
  return snapshots.reverse(); // Most recent first
}

export async function getSnapshotsForComposition(compositionId: string): Promise<CompositionSnapshot[]> {
  const db = await getDB();
  return db.getAllFromIndex('snapshots', 'compositionId', compositionId);
}

export async function deleteSnapshot(id: string): Promise<void> {
  const db = await getDB();
  await db.delete('snapshots', id);
}

export async function getUnsyncedSnapshots(): Promise<CompositionSnapshot[]> {
  const db = await getDB();
  return db.getAllFromIndex('snapshots', 'synced', false);
}
```

Important: The DB_VERSION bump from 2 to 3 triggers the upgrade callback. The upgrade function uses `if (!db.objectStoreNames.contains(...))` guards, so existing stores are not recreated. Only the new 'snapshots' store is added. Existing data in 'atoms', 'compositions', 'voiceNotes', etc. is preserved.

Note: The import of `CompositionSnapshot` must be a type-only import to avoid circular dependencies, or placed inline. Since db.ts already has types defined locally, and composition-types.ts doesn't import from db.ts for types, this import is safe. However, to be cautious, use inline typing or a re-export pattern if the build fails. The simplest approach: move the import to the top of the file alongside the existing local type definitions.
  </action>
  <verify>
1. DB_VERSION is now 3
2. 'snapshots' object store is created in upgrade callback
3. Indexes: compositionId, createdAt, synced, name
4. saveSnapshot, getSnapshot, getAllSnapshots, deleteSnapshot functions exist
5. getSnapshotsForComposition returns snapshots for a specific composition
6. getUnsyncedSnapshots returns all unsynced snapshots (for cloud backup)
7. `cd portfolio && npm run build` succeeds
8. Existing IndexedDB data is preserved (upgrade is additive only)
  </verify>
  <done>
IndexedDB schema bumped to version 3 with new 'snapshots' store. CRUD operations added: save, get, getAll, delete, getByComposition, getUnsynced. Existing stores preserved via conditional creation guards.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create snapshot creation and loading logic</name>
  <files>
    portfolio/src/scripts/composition-snapshot.ts
  </files>
  <action>
Create the snapshot service that converts a draft composition into an immutable snapshot.

**Create portfolio/src/scripts/composition-snapshot.ts:**

```typescript
/**
 * Composition Snapshot Service.
 *
 * Creates immutable snapshots from draft compositions.
 * A snapshot captures all atom code, config, routes, and metadata
 * at a specific point in time. Once created, a snapshot never changes.
 *
 * Hybrid structure: each snapshot atom stores both:
 * - atomSlug (reference to original atom for linking)
 * - Inline code/config (for immutability and portability)
 */

import type {
  Composition,
  CompositionSnapshot,
  SnapshotAtom,
} from './composition-types';
import { generateId } from './composition-types';
import { getAtom, saveSnapshot, getSnapshot, getAllSnapshots } from './db';
import type { AtomMetadata } from './db';

/**
 * Create an immutable snapshot from a draft composition.
 *
 * Process:
 * 1. For each atom in the composition, fetch its full metadata from IndexedDB
 * 2. Capture code (sketch.js), config (config.json), title, type inline
 * 3. Preserve all routes and parameter overrides
 * 4. Generate unique snapshot ID
 * 5. Save to IndexedDB 'snapshots' store
 *
 * @returns The created snapshot, or null if any atom is missing
 */
export async function createSnapshotFromComposition(
  composition: Composition,
): Promise<CompositionSnapshot | null> {
  const snapshotAtoms: SnapshotAtom[] = [];

  for (const atom of composition.atoms) {
    const metadata = await getAtom(atom.atomSlug);
    if (!metadata) {
      console.error(`[snapshot] Atom not found: ${atom.atomSlug}`);
      return null; // Can't create snapshot with missing atoms
    }

    snapshotAtoms.push({
      nodeId: atom.nodeId,
      atomSlug: atom.atomSlug,
      position: { ...atom.position },
      title: metadata.title,
      type: metadata.type,
      code: metadata.code,
      configJson: metadata.configJson,
      paramOverrides: atom.paramOverrides
        ? { ...atom.paramOverrides }
        : undefined,
    });
  }

  const snapshot: CompositionSnapshot = {
    id: generateId(),
    compositionId: composition.id,
    name: composition.name,
    createdAt: new Date().toISOString(),
    playbackMode: composition.playbackMode || 'simultaneous',
    viewport: { ...composition.viewport },
    atoms: snapshotAtoms,
    routes: composition.routes.map(r => ({ ...r })),
    synced: false,
  };

  await saveSnapshot(snapshot);
  return snapshot;
}

/**
 * Load a snapshot and reconstruct it as a playable composition.
 * This converts a CompositionSnapshot back into a Composition-like
 * structure that the preview engine can use.
 *
 * The key difference: snapshot atoms have inline code, so they don't
 * need to be fetched from the atoms IndexedDB store.
 */
export async function loadSnapshot(
  snapshotId: string,
): Promise<CompositionSnapshot | null> {
  const snapshot = await getSnapshot(snapshotId);
  return snapshot || null;
}

/**
 * Get all snapshots sorted by creation date (newest first).
 */
export async function listSnapshots(): Promise<CompositionSnapshot[]> {
  return getAllSnapshots();
}

/**
 * Export a snapshot as a JSON string.
 * This is the format used for sharing and cloud backup.
 */
export function exportSnapshotJSON(snapshot: CompositionSnapshot): string {
  return JSON.stringify(snapshot, null, 2);
}

/**
 * Import a snapshot from JSON string.
 * Validates required fields before saving.
 */
export async function importSnapshotJSON(json: string): Promise<CompositionSnapshot | null> {
  try {
    const snapshot = JSON.parse(json) as CompositionSnapshot;

    // Validate required fields
    if (!snapshot.id || !snapshot.name || !snapshot.atoms || !snapshot.routes) {
      console.error('[snapshot] Invalid snapshot JSON: missing required fields');
      return null;
    }

    // Ensure it has a unique ID (regenerate to avoid collisions on import)
    snapshot.id = generateId();
    snapshot.synced = false;

    await saveSnapshot(snapshot);
    return snapshot;
  } catch (err) {
    console.error('[snapshot] Failed to import snapshot:', err);
    return null;
  }
}

/**
 * Calculate approximate snapshot size in bytes.
 * Useful for UI display and storage management.
 */
export function getSnapshotSize(snapshot: CompositionSnapshot): number {
  return new Blob([JSON.stringify(snapshot)]).size;
}

/**
 * Build an AtomMetadata-compatible map from snapshot atoms.
 * This allows the preview engine and canvas to work with snapshots
 * using the same API as draft compositions.
 */
export function buildAtomsMapFromSnapshot(
  snapshot: CompositionSnapshot,
): Map<string, AtomMetadata> {
  const map = new Map<string, AtomMetadata>();

  for (const atom of snapshot.atoms) {
    map.set(atom.atomSlug, {
      slug: atom.atomSlug,
      title: atom.title,
      date: '', // Not relevant for snapshot playback
      type: atom.type,
      stage: 'done',
      thumbnailUrl: '',
      code: atom.code,
      notes: '',
      configJson: atom.configJson,
    });
  }

  return map;
}
```

Key design decisions:
- createSnapshotFromComposition fetches all atom metadata and captures inline
- Returns null if any atom is missing (can't create incomplete snapshot)
- importSnapshotJSON regenerates ID to prevent collisions
- buildAtomsMapFromSnapshot enables preview engine compatibility
- exportSnapshotJSON produces the format used for sharing and cloud backup
  </action>
  <verify>
1. portfolio/src/scripts/composition-snapshot.ts exists
2. createSnapshotFromComposition captures inline atom code and config
3. Returns null if any atom is missing
4. Snapshot ID is UUID, suitable for /c/[id] URLs
5. exportSnapshotJSON / importSnapshotJSON roundtrip is lossless
6. buildAtomsMapFromSnapshot returns Map<string, AtomMetadata>
7. getSnapshotSize returns byte count
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Composition snapshot service created with immutable capture (inline atom code + config), JSON export/import, AtomMetadata map builder for preview compatibility, and size calculation. Snapshots store both slug references and inline code (hybrid structure).
  </done>
</task>

<task type="auto">
  <name>Task 4: Add save-as-snapshot button to toolbar</name>
  <files>
    portfolio/src/components/CompositionToolbar.astro
    portfolio/src/pages/mobile/compose.astro
  </files>
  <action>
Add a "Save Snapshot" button to the composition toolbar that creates an immutable snapshot of the current composition.

**Update portfolio/src/components/CompositionToolbar.astro:**

Add a save/snapshot button to the toolbar. The toolbar currently has rename and delete buttons. Add a "Save" button between them. Find the toolbar buttons section and add:

```html
<!-- Save as snapshot button -->
<button id="toolbar-save-snapshot" class="toolbar-btn" title="Save snapshot">
  <svg width="18" height="18" viewBox="0 0 18 18" fill="none" stroke="currentColor" stroke-width="1.5">
    <path d="M14 6l-5 5-3-3"/>
    <rect x="2" y="2" width="14" height="14" rx="2"/>
  </svg>
  <span class="toolbar-btn-label">Save</span>
</button>
```

Add the click handler in the toolbar's script section:

```typescript
// Save as snapshot
const saveSnapshotBtn = document.getElementById('toolbar-save-snapshot');
saveSnapshotBtn?.addEventListener('click', () => {
  window.dispatchEvent(new CustomEvent('eoe:save-snapshot'));
});

// Update save button state (disable when no atoms)
window.addEventListener('eoe:composition-atom-count', ((e: CustomEvent) => {
  if (saveSnapshotBtn) {
    const count = e.detail?.count || 0;
    (saveSnapshotBtn as HTMLButtonElement).disabled = count === 0;
    saveSnapshotBtn.style.opacity = count === 0 ? '0.4' : '1';
  }
}) as EventListener);
```

Add CSS for the save button (should match existing toolbar button styles). If not already styled:

```css
.toolbar-btn-label {
  font-size: 0.7rem;
  font-weight: 600;
}
```

**Update portfolio/src/pages/mobile/compose.astro:**

Add the snapshot creation handler in the script section. Add this import:

```typescript
import { createSnapshotFromComposition } from '../../scripts/composition-snapshot';
```

Add the event handler:

```typescript
// Save as snapshot
window.addEventListener('eoe:save-snapshot', async () => {
  if (currentComposition.atoms.length === 0) {
    showToast('Add atoms before saving');
    return;
  }

  const snapshot = await createSnapshotFromComposition(currentComposition);
  if (snapshot) {
    showToast('Snapshot saved!');
  } else {
    showToast('Failed to save: missing atoms');
  }
});
```

Also dispatch atom count whenever canvas refreshes. Add at the end of `refreshCanvas()`:

```typescript
// Update toolbar save button state
window.dispatchEvent(new CustomEvent('eoe:composition-atom-count', {
  detail: { count: currentComposition.atoms.length }
}));
```

And after `initComposition()` setup:

```typescript
window.dispatchEvent(new CustomEvent('eoe:composition-atom-count', {
  detail: { count: currentComposition.atoms.length }
}));
```
  </action>
  <verify>
1. "Save" button appears in composition toolbar
2. Button is disabled when composition has no atoms
3. Clicking Save creates an immutable snapshot via createSnapshotFromComposition
4. Toast shows "Snapshot saved!" on success
5. Toast shows "Failed to save: missing atoms" on failure
6. Save button has min 44px touch target
7. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Save Snapshot button added to composition toolbar. Creates immutable snapshot on click. Disabled when composition is empty. Toast feedback on success/failure. Atom count events keep button state in sync.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update compositions list to show snapshots</name>
  <files>
    portfolio/src/pages/mobile/compositions.astro
  </files>
  <action>
Update the compositions list page to show both draft compositions and saved snapshots in separate sections.

**Update portfolio/src/pages/mobile/compositions.astro:**

The existing page shows draft compositions from IndexedDB. Add a "Saved Snapshots" section below. Update the script section:

Add import for snapshot functions:

```typescript
import { listSnapshots, getSnapshotSize } from '../../scripts/composition-snapshot';
```

In the initialization function that loads compositions, also load snapshots:

```typescript
// Load saved snapshots
const snapshots = await listSnapshots();
```

Add a "Saved Snapshots" section to the HTML. After the existing compositions list, add:

```html
<!-- Saved Snapshots Section -->
<div id="snapshots-section" style="display: none;">
  <h2 class="section-title" style="margin-top: 24px; padding: 0 16px; color: #888; font-size: 0.85rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">
    Saved Snapshots
  </h2>
  <div id="snapshots-list" class="compositions-list"></div>
</div>
```

Render snapshots similarly to compositions but with a different badge. Each snapshot item shows:
- Name
- Atom count
- Route count
- Creation date
- Approximate size (from getSnapshotSize)
- A "snapshot" badge (distinguished from drafts)

```typescript
function renderSnapshots(snapshots) {
  const section = document.getElementById('snapshots-section');
  const list = document.getElementById('snapshots-list');
  if (!section || !list) return;

  if (snapshots.length === 0) {
    section.style.display = 'none';
    return;
  }

  section.style.display = 'block';
  list.innerHTML = '';

  for (const snap of snapshots) {
    const size = getSnapshotSize(snap);
    const sizeKB = Math.round(size / 1024);
    const date = new Date(snap.createdAt).toLocaleDateString();

    const item = document.createElement('a');
    item.className = 'composition-item';
    item.href = `/mobile/compose?snapshot=${snap.id}`;
    item.innerHTML = `
      <div class="composition-item-header">
        <span class="composition-name">${snap.name}</span>
        <span class="snapshot-badge">SNAPSHOT</span>
      </div>
      <div class="composition-meta">
        ${snap.atoms.length} atom${snap.atoms.length !== 1 ? 's' : ''}
        · ${snap.routes.length} route${snap.routes.length !== 1 ? 's' : ''}
        · ${sizeKB}KB
        · ${date}
      </div>
    `;
    list.appendChild(item);
  }
}
```

Add CSS for the snapshot badge:

```css
.snapshot-badge {
  font-size: 0.65rem;
  font-weight: 700;
  color: #6bff6b;
  background: rgba(107, 255, 107, 0.1);
  padding: 2px 6px;
  border-radius: 4px;
  letter-spacing: 0.5px;
}
```

**Also update portfolio/src/pages/mobile/compose.astro** to handle the `?snapshot=` URL parameter:

In `initComposition()`, add snapshot loading:

```typescript
const snapshotId = params.get('snapshot');
if (snapshotId) {
  const { loadSnapshot, buildAtomsMapFromSnapshot } = await import('../../scripts/composition-snapshot');
  const snapshot = await loadSnapshot(snapshotId);
  if (snapshot) {
    // Build a Composition-like object from the snapshot for the canvas
    currentComposition = {
      id: snapshot.compositionId,
      name: snapshot.name + ' (snapshot)',
      createdAt: snapshot.createdAt,
      updatedAt: snapshot.createdAt,
      atoms: snapshot.atoms.map(a => ({
        nodeId: a.nodeId,
        atomSlug: a.atomSlug,
        position: a.position,
        paramOverrides: a.paramOverrides,
      })),
      routes: snapshot.routes,
      viewport: snapshot.viewport,
      synced: snapshot.synced,
      playbackMode: snapshot.playbackMode,
    };

    // Use snapshot's inline atom data instead of IndexedDB
    atomsMap = buildAtomsMapFromSnapshot(snapshot);

    history.clear();
    history.push(currentComposition);
    updateHistoryButtons();

    window.dispatchEvent(new CustomEvent('eoe:composition-name-changed', {
      detail: { name: currentComposition.name }
    }));

    await refreshCanvas();
    return;
  }
}
```

This loads snapshots with their inline code, so they work even if the original atoms have changed or been deleted.
  </action>
  <verify>
1. Compositions page shows both "Compositions" and "Saved Snapshots" sections
2. Snapshots show name, atom count, route count, size, date
3. Snapshot items have green "SNAPSHOT" badge
4. Tapping a snapshot navigates to compose page with ?snapshot= parameter
5. Compose page loads snapshot with inline atom code
6. Snapshot playback uses captured code (not current atom code)
7. Snapshot section hidden when no snapshots exist
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Compositions list updated with separate Saved Snapshots section. Snapshots show metadata with green badge. Compose page handles ?snapshot= parameter to load immutable snapshots with inline atom code. Save/reload cycle is lossless.
  </done>
</task>

</tasks>

<verification>
1. `cd portfolio && npm run build` completes without errors
2. CompositionSnapshot type has id, compositionId, atoms (with inline code), routes
3. IndexedDB version bumped to 3 with 'snapshots' store
4. createSnapshotFromComposition captures all atom code inline
5. Snapshot is immutable: loading a snapshot uses captured code, not current atoms
6. Save button in toolbar creates snapshot with toast feedback
7. Compositions page shows drafts and snapshots in separate sections
8. Snapshot badge visually distinguishes saved snapshots from drafts
9. Clicking snapshot navigates to compose page that loads it correctly
10. Save/reload cycle is lossless (save composition, reload, identical result)
11. exportSnapshotJSON/importSnapshotJSON roundtrip produces valid snapshot
12. Backward compatible: existing compositions without playbackMode still work
13. buildAtomsMapFromSnapshot enables preview engine to work with snapshots
14. No regressions in Phase 5 features (composition CRUD, autosave, undo/redo)
</verification>

<success_criteria>
- COMP-05: User can save composition as immutable snapshot
- Hybrid structure: inline code + slug references (portability + linkability)
- Save/reload cycle is lossless
- Snapshots visible in compositions list with metadata
- Snapshot playback uses captured code (immutability guarantee)
- Foundation for cloud backup (Plan 06-03) and shareable URLs (Plan 06-05)
</success_criteria>

<output>
After completion, create `.planning/phases/06-composition-preview-save-cloud-backup/06-02-SUMMARY.md`
</output>
