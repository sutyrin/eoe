---
phase: 06-composition-preview-save-cloud-backup
plan: 04
type: execute
wave: 3
depends_on: ["06-03"]
duration: 3h
autonomous: true
files_modified:
  - portfolio/src/components/BackupStatusBadge.astro
  - portfolio/src/components/RestoreModal.astro
  - portfolio/src/components/ConflictResolver.astro
  - portfolio/src/scripts/backup-client.ts
  - portfolio/src/layouts/MobileLayout.astro
  - portfolio/src/pages/mobile/backup.astro

must_haves:
  truths:
    - "Backup status badge is visible in the app header at all times (synced/pending/error)"
    - "Badge shows count of pending (unsynced) items"
    - "Tapping the badge navigates to backup management page"
    - "Backup management page shows list of available backups with timestamps and item counts"
    - "User can trigger manual backup from the backup page"
    - "User can browse a backup and selectively restore items (atoms, compositions, snapshots)"
    - "Conflict resolution: when local item differs from backup, user chooses which version to keep"
    - "Auto-retry: failed backups retry 3 times, then show persistent error badge"
    - "Restore writes to IndexedDB and refreshes the current page view"
  artifacts:
    - path: "portfolio/src/components/BackupStatusBadge.astro"
      provides: "Header badge showing sync status with pending count"
      contains: "backup-badge"
    - path: "portfolio/src/components/RestoreModal.astro"
      provides: "Modal for browsing backups and selecting items to restore"
      contains: "restore-modal"
    - path: "portfolio/src/components/ConflictResolver.astro"
      provides: "Per-item conflict resolution UI (keep local vs. keep backup)"
      contains: "conflict-resolver"
    - path: "portfolio/src/pages/mobile/backup.astro"
      provides: "Backup management page at /mobile/backup"
      contains: "backup-list"
  key_links:
    - from: "portfolio/src/components/BackupStatusBadge.astro"
      to: "portfolio/src/scripts/backup-client.ts"
      via: "import { getBackupStatus }"
      pattern: "getBackupStatus"
    - from: "portfolio/src/pages/mobile/backup.astro"
      to: "portfolio/src/scripts/backup-client.ts"
      via: "import { listBackups, createBackup, restoreFromBackup }"
      pattern: "listBackups"
    - from: "portfolio/src/layouts/MobileLayout.astro"
      to: "portfolio/src/components/BackupStatusBadge.astro"
      via: "import BackupStatusBadge"
      pattern: "BackupStatusBadge"
---

<objective>
Build the backup status UI: a persistent header badge showing sync state, a backup management page for viewing/restoring backups, and a conflict resolution modal for handling divergent data. After this plan, users always know their backup status (synced/pending/error) at a glance, can manually trigger backups, browse past backups, selectively restore items, and resolve conflicts when local and cloud data diverge.

Purpose: Visibility and control over backup status builds trust. Users need to know their creative work is safe, and when it isn't, they need clear pathways to fix it. The conflict resolver empowers users to decide when data diverges, avoiding "mystery overwrites."

Output: BackupStatusBadge in header, /mobile/backup management page, RestoreModal with selective restore, ConflictResolver for per-item decisions.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-composition-preview-save-cloud-backup/06-CONTEXT.md
@portfolio/src/scripts/backup-client.ts
@portfolio/src/scripts/db.ts
@portfolio/src/scripts/composition-store.ts
@portfolio/src/layouts/MobileLayout.astro
@portfolio/src/components/OfflineIndicator.astro
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BackupStatusBadge component</name>
  <files>
    portfolio/src/components/BackupStatusBadge.astro
  </files>
  <action>
Create the backup status badge that lives in the app header and shows sync status at all times.

**Create portfolio/src/components/BackupStatusBadge.astro:**

```astro
---
/**
 * BackupStatusBadge: Persistent badge in app header showing backup status.
 *
 * States:
 * - synced (green checkmark): All items backed up
 * - pending (orange dot with count): N items not yet backed up
 * - backing-up (blue spinner): Backup in progress
 * - error (red exclamation): Last backup failed
 *
 * Tapping the badge navigates to /mobile/backup management page.
 */
---

<a href="/mobile/backup" id="backup-badge" class="backup-badge" title="Backup status">
  <span id="badge-icon" class="badge-icon badge-icon-synced">
    <!-- Synced: checkmark -->
    <svg id="icon-synced" width="14" height="14" viewBox="0 0 14 14" fill="currentColor" style="display: none;">
      <path d="M11.5 3.5l-6 6L2.5 6.5" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <!-- Pending: count -->
    <span id="icon-pending" class="badge-count" style="display: none;">0</span>
    <!-- Backing up: spinner -->
    <span id="icon-backing-up" class="badge-spinner" style="display: none;"></span>
    <!-- Error: exclamation -->
    <span id="icon-error" style="display: none;">!</span>
  </span>
</a>

<script>
  type BadgeState = 'synced' | 'pending' | 'backing-up' | 'error';

  const badge = document.getElementById('backup-badge')!;
  const iconSynced = document.getElementById('icon-synced')!;
  const iconPending = document.getElementById('icon-pending')!;
  const iconBackingUp = document.getElementById('icon-backing-up')!;
  const iconError = document.getElementById('icon-error')!;
  const badgeIcon = document.getElementById('badge-icon')!;

  function updateBadge(state: BadgeState, count = 0) {
    // Hide all icons
    iconSynced.style.display = 'none';
    iconPending.style.display = 'none';
    iconBackingUp.style.display = 'none';
    iconError.style.display = 'none';

    // Remove all state classes
    badgeIcon.className = 'badge-icon';

    switch (state) {
      case 'synced':
        iconSynced.style.display = 'block';
        badgeIcon.classList.add('badge-icon-synced');
        break;
      case 'pending':
        iconPending.style.display = 'inline';
        iconPending.textContent = String(count);
        badgeIcon.classList.add('badge-icon-pending');
        break;
      case 'backing-up':
        iconBackingUp.style.display = 'inline-block';
        badgeIcon.classList.add('badge-icon-active');
        break;
      case 'error':
        iconError.style.display = 'inline';
        badgeIcon.classList.add('badge-icon-error');
        break;
    }
  }

  // Listen for backup status events
  window.addEventListener('eoe:backup-status', ((e: CustomEvent) => {
    const { status } = e.detail;
    switch (status) {
      case 'idle':
        // Check for pending items
        checkPendingCount();
        break;
      case 'backing-up':
        updateBadge('backing-up');
        break;
      case 'success':
        updateBadge('synced');
        // Recheck after a moment (items may have changed)
        setTimeout(checkPendingCount, 5000);
        break;
      case 'error':
        updateBadge('error');
        break;
    }
  }) as EventListener);

  // Check pending count on load and periodically
  async function checkPendingCount() {
    try {
      const { getUnsyncedCount } = await import('../scripts/composition-store');
      const compCount = await getUnsyncedCount();

      let snapCount = 0;
      try {
        const { getUnsyncedSnapshots } = await import('../scripts/db');
        const unsynced = await getUnsyncedSnapshots();
        snapCount = unsynced.length;
      } catch { /* ok */ }

      const total = compCount + snapCount;
      if (total > 0) {
        updateBadge('pending', total);
      } else {
        updateBadge('synced');
      }
    } catch {
      // Default to synced if we can't check
      updateBadge('synced');
    }
  }

  // Initial check
  setTimeout(checkPendingCount, 1500);
  // Periodic check every 60 seconds
  setInterval(checkPendingCount, 60000);
</script>

<style>
  .backup-badge {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    text-decoration: none;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.15s;
  }

  .backup-badge:active {
    background: rgba(255, 255, 255, 0.1);
  }

  .badge-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    font-size: 10px;
    font-weight: 700;
    line-height: 1;
  }

  .badge-icon-synced {
    color: #6bff6b;
  }

  .badge-icon-pending {
    background: #ffb56b;
    color: #0a0a0a;
  }

  .badge-icon-active {
    color: #6bb5ff;
  }

  .badge-icon-error {
    background: #ff6b6b;
    color: #fff;
  }

  .badge-count {
    font-size: 10px;
    font-weight: 700;
  }

  .badge-spinner {
    width: 12px;
    height: 12px;
    border: 2px solid rgba(107, 181, 255, 0.3);
    border-top-color: #6bb5ff;
    border-radius: 50%;
    animation: badge-spin 0.8s linear infinite;
  }

  @keyframes badge-spin {
    to { transform: rotate(360deg); }
  }
</style>
```
  </action>
  <verify>
1. portfolio/src/components/BackupStatusBadge.astro exists
2. Badge shows 4 states: synced (green check), pending (orange count), backing-up (blue spinner), error (red !)
3. Badge links to /mobile/backup
4. Checks pending count on load and every 60 seconds
5. Responds to eoe:backup-status events
6. All interactive elements >= 32px touch target (badge itself is a link)
7. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
BackupStatusBadge created with 4 visual states (synced/pending/active/error), pending count display, periodic checking, backup status event handling, and navigation link to /mobile/backup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add BackupStatusBadge to MobileLayout header</name>
  <files>
    portfolio/src/layouts/MobileLayout.astro
  </files>
  <action>
Integrate the BackupStatusBadge into the MobileLayout header so it's visible on every mobile page.

**Read portfolio/src/layouts/MobileLayout.astro** to understand the current header structure, then add the badge.

Import BackupStatusBadge at the top of the frontmatter:

```astro
---
import BackupStatusBadge from '../components/BackupStatusBadge.astro';
// ... existing imports
---
```

In the header section, add the BackupStatusBadge. Place it on the right side of the header bar, before any existing right-side elements. The typical pattern for a mobile header is:

```html
<header class="mobile-header">
  <!-- Left: back button (if showBack) -->
  <!-- Center: title -->
  <!-- Right: backup badge -->
  <BackupStatusBadge />
</header>
```

Find the header element in MobileLayout.astro and add `<BackupStatusBadge />` inside it, positioned on the right side. If the header uses flexbox, the badge should be placed after the title or in a right-aligned container.

If the header currently doesn't have a right-side area, add one:

```html
<div class="header-right">
  <BackupStatusBadge />
</div>
```

With corresponding CSS:

```css
.header-right {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
}
```

The exact integration depends on the current MobileLayout structure, which the executor should read and adapt. The key requirements:
1. Badge is visible on every page that uses MobileLayout
2. Badge is on the right side of the header
3. Badge does not interfere with back button or title
4. Badge is always visible (not hidden by scroll)
  </action>
  <verify>
1. BackupStatusBadge is imported in MobileLayout.astro
2. Badge renders in the header area on the right side
3. Badge is visible on all mobile pages (gallery, compose, compositions, etc.)
4. Badge does not overlap with back button or title
5. `cd portfolio && npm run build` succeeds
6. All existing pages still render correctly
  </verify>
  <done>
BackupStatusBadge integrated into MobileLayout header. Visible on all mobile pages. Positioned on right side without interfering with existing header elements.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create backup management page</name>
  <files>
    portfolio/src/pages/mobile/backup.astro
  </files>
  <action>
Create the /mobile/backup page where users can view backup history, trigger manual backups, and initiate restore.

**Create portfolio/src/pages/mobile/backup.astro:**

```astro
---
import MobileLayout from '../../layouts/MobileLayout.astro';
---

<MobileLayout title="Backup" showBack={true} backHref="/mobile/gallery">
  <div class="backup-page">
    <!-- Manual backup button -->
    <section class="backup-section">
      <button id="manual-backup-btn" class="backup-action-btn">
        <span class="backup-action-icon">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M10 3v10M6 9l4 4 4-4"/>
            <path d="M3 14v2a1 1 0 001 1h12a1 1 0 001-1v-2"/>
          </svg>
        </span>
        <span>
          <span class="backup-action-title">Back Up Now</span>
          <span id="last-backup-time" class="backup-action-subtitle">Never backed up</span>
        </span>
      </button>
    </section>

    <!-- Backup status -->
    <div id="backup-progress" class="backup-progress" style="display: none;">
      <div class="backup-progress-bar">
        <div id="progress-fill" class="backup-progress-fill"></div>
      </div>
      <span id="progress-text" class="backup-progress-text">Backing up...</span>
    </div>

    <!-- Available backups -->
    <section class="backup-section">
      <h2 class="section-heading">Available Backups</h2>
      <div id="backup-list" class="backup-list">
        <div class="backup-empty">Loading...</div>
      </div>
    </section>
  </div>
</MobileLayout>

<script>
  import { createBackup, listBackups, restoreFromBackup, getBackupStatus } from '../../scripts/backup-client';
  import type { BackupSummary } from '../../scripts/backup-client';

  const manualBtn = document.getElementById('manual-backup-btn')!;
  const lastBackupEl = document.getElementById('last-backup-time')!;
  const progressEl = document.getElementById('backup-progress')!;
  const progressText = document.getElementById('progress-text')!;
  const backupListEl = document.getElementById('backup-list')!;

  // Manual backup
  manualBtn.addEventListener('click', async () => {
    manualBtn.setAttribute('disabled', 'true');
    manualBtn.style.opacity = '0.5';
    progressEl.style.display = 'flex';
    progressText.textContent = 'Backing up...';

    const result = await createBackup();

    if (result) {
      progressText.textContent = `Backup complete (${Math.round(result.size / 1024)}KB)`;
      lastBackupEl.textContent = `Last: ${formatTime(result.timestamp)}`;

      // Refresh backup list
      await loadBackupList();
    } else {
      progressText.textContent = 'Backup failed. Tap to retry.';
    }

    manualBtn.removeAttribute('disabled');
    manualBtn.style.opacity = '1';

    // Hide progress after 3 seconds
    setTimeout(() => {
      progressEl.style.display = 'none';
    }, 3000);
  });

  // Load backup list
  async function loadBackupList() {
    const backups = await listBackups();

    if (backups.length === 0) {
      backupListEl.innerHTML = '<div class="backup-empty">No backups yet. Tap "Back Up Now" to create one.</div>';
      return;
    }

    backupListEl.innerHTML = '';

    for (const backup of backups) {
      const item = document.createElement('div');
      item.className = 'backup-item';
      item.innerHTML = `
        <div class="backup-item-header">
          <span class="backup-item-date">${formatTime(backup.timestamp)}</span>
          <span class="backup-item-size">${formatSize(backup.size)}</span>
        </div>
        <div class="backup-item-counts">
          ${backup.counts.atoms} atoms
          · ${backup.counts.compositions} compositions
          · ${backup.counts.snapshots} snapshots
        </div>
        <div class="backup-item-actions">
          <button class="restore-btn" data-backup-id="${backup.id}">Restore</button>
        </div>
      `;
      backupListEl.appendChild(item);
    }

    // Restore button handlers
    backupListEl.querySelectorAll('.restore-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        const backupId = (e.target as HTMLElement).getAttribute('data-backup-id');
        if (!backupId) return;

        // Open restore modal
        window.dispatchEvent(new CustomEvent('eoe:open-restore-modal', {
          detail: { backupId }
        }));
      });
    });
  }

  // Format helpers
  function formatTime(isoString: string): string {
    const date = new Date(isoString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMin = Math.floor(diffMs / 60000);

    if (diffMin < 1) return 'Just now';
    if (diffMin < 60) return `${diffMin}m ago`;

    const diffHr = Math.floor(diffMin / 60);
    if (diffHr < 24) return `${diffHr}h ago`;

    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function formatSize(bytes: number): string {
    if (bytes < 1024) return `${bytes}B`;
    if (bytes < 1024 * 1024) return `${Math.round(bytes / 1024)}KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
  }

  // Show last backup time
  const status = getBackupStatus();
  if (status.lastBackupTime) {
    lastBackupEl.textContent = `Last: ${formatTime(status.lastBackupTime)}`;
  }

  // Initial load
  loadBackupList();
</script>

<style>
  .backup-page {
    padding: 16px;
  }

  .backup-section {
    margin-bottom: 24px;
  }

  .section-heading {
    font-size: 0.85rem;
    font-weight: 600;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 12px;
  }

  .backup-action-btn {
    display: flex;
    align-items: center;
    gap: 12px;
    width: 100%;
    padding: 16px;
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 12px;
    color: #fff;
    cursor: pointer;
    text-align: left;
    -webkit-tap-highlight-color: transparent;
    min-height: 60px;
  }

  .backup-action-btn:active {
    background: #222;
  }

  .backup-action-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
    background: #6bb5ff;
    color: #0a0a0a;
    border-radius: 10px;
    flex-shrink: 0;
  }

  .backup-action-title {
    display: block;
    font-size: 1rem;
    font-weight: 600;
  }

  .backup-action-subtitle {
    display: block;
    font-size: 0.8rem;
    color: #666;
    margin-top: 2px;
  }

  .backup-progress {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    background: #1a3a1a;
    border-radius: 8px;
    margin-bottom: 16px;
  }

  .backup-progress-bar {
    flex: 1;
    height: 4px;
    background: #333;
    border-radius: 2px;
    overflow: hidden;
  }

  .backup-progress-fill {
    height: 100%;
    background: #6bb5ff;
    border-radius: 2px;
    width: 100%;
    animation: progress-pulse 1.5s ease-in-out infinite;
  }

  @keyframes progress-pulse {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 1; }
  }

  .backup-progress-text {
    font-size: 0.8rem;
    color: #6bff6b;
    white-space: nowrap;
  }

  .backup-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .backup-empty {
    padding: 24px;
    text-align: center;
    color: #555;
    font-size: 0.9rem;
  }

  .backup-item {
    padding: 14px 16px;
    background: #1a1a1a;
    border: 1px solid #222;
    border-radius: 10px;
  }

  .backup-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .backup-item-date {
    font-size: 0.9rem;
    font-weight: 600;
    color: #ccc;
  }

  .backup-item-size {
    font-size: 0.8rem;
    color: #666;
  }

  .backup-item-counts {
    font-size: 0.8rem;
    color: #888;
    margin-bottom: 10px;
  }

  .backup-item-actions {
    display: flex;
    gap: 8px;
  }

  .restore-btn {
    padding: 8px 16px;
    background: #333;
    border: none;
    border-radius: 6px;
    color: #6bb5ff;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    min-height: 36px;
    -webkit-tap-highlight-color: transparent;
  }

  .restore-btn:active {
    background: #444;
  }
</style>
```
  </action>
  <verify>
1. /mobile/backup page renders with MobileLayout
2. "Back Up Now" button triggers createBackup()
3. Last backup time shown after successful backup
4. Backup list loads from server on page mount
5. Each backup shows timestamp, size, item counts
6. Restore button on each backup dispatches eoe:open-restore-modal
7. Progress indicator shown during backup
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
Backup management page created at /mobile/backup with manual backup button, progress indicator, backup list with timestamps/sizes/counts, and restore buttons per backup.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create RestoreModal and ConflictResolver components</name>
  <files>
    portfolio/src/components/RestoreModal.astro
    portfolio/src/components/ConflictResolver.astro
  </files>
  <action>
Create the restore modal for selective item restore and the conflict resolver for per-item version decisions.

**Create portfolio/src/components/RestoreModal.astro:**

```astro
---
/**
 * RestoreModal: Allows user to browse a backup and select items to restore.
 *
 * Features:
 * - Checkbox selection per category (atoms, compositions, snapshots)
 * - Preview of items in each category
 * - Conflict detection: highlights items that differ locally
 * - "Restore Selected" button triggers selective restore
 */
---

<div id="restore-modal" class="restore-modal" style="display: none;">
  <div class="restore-modal-content">
    <div class="restore-modal-header">
      <h2 class="restore-modal-title">Restore from Backup</h2>
      <button id="restore-close-btn" class="restore-close-btn">&times;</button>
    </div>

    <div id="restore-body" class="restore-modal-body">
      <div class="restore-loading">Loading backup contents...</div>
    </div>

    <div class="restore-modal-footer">
      <button id="restore-cancel-btn" class="restore-footer-btn restore-cancel">Cancel</button>
      <button id="restore-confirm-btn" class="restore-footer-btn restore-confirm" disabled>Restore Selected</button>
    </div>
  </div>
</div>

<script>
  import { restoreFromBackup } from '../scripts/backup-client';

  const modal = document.getElementById('restore-modal')!;
  const body = document.getElementById('restore-body')!;
  const closeBtn = document.getElementById('restore-close-btn')!;
  const cancelBtn = document.getElementById('restore-cancel-btn')!;
  const confirmBtn = document.getElementById('restore-confirm-btn')! as HTMLButtonElement;

  let currentBackupId: string | null = null;
  let selectedCategories: Record<string, boolean> = {};

  // Open modal
  window.addEventListener('eoe:open-restore-modal', (async (e: CustomEvent) => {
    currentBackupId = e.detail.backupId;
    modal.style.display = 'flex';

    // Load backup contents
    try {
      const res = await fetch(`/api/backup/${currentBackupId}`);
      if (!res.ok) throw new Error('Failed to load backup');
      const backup = await res.json();

      renderBackupContents(backup.data);
    } catch (err) {
      body.innerHTML = '<div class="restore-error">Failed to load backup contents.</div>';
    }
  }) as EventListener);

  // Close modal
  closeBtn.addEventListener('click', closeModal);
  cancelBtn.addEventListener('click', closeModal);

  // Close on backdrop click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeModal();
  });

  function closeModal() {
    modal.style.display = 'none';
    currentBackupId = null;
    selectedCategories = {};
    confirmBtn.disabled = true;
  }

  // Render backup contents
  function renderBackupContents(data: any) {
    const categories = [
      { key: 'atoms', label: 'Atoms', items: data.atoms || [], icon: 'A' },
      { key: 'compositions', label: 'Compositions', items: data.compositions || [], icon: 'C' },
      { key: 'snapshots', label: 'Snapshots', items: data.snapshots || [], icon: 'S' },
    ];

    let html = '';
    for (const cat of categories) {
      if (cat.items.length === 0) continue;

      html += `
        <div class="restore-category">
          <label class="restore-category-header">
            <input type="checkbox" class="restore-checkbox" data-category="${cat.key}">
            <span class="restore-category-icon">${cat.icon}</span>
            <span class="restore-category-label">${cat.label}</span>
            <span class="restore-category-count">${cat.items.length}</span>
          </label>
          <div class="restore-items">
            ${cat.items.slice(0, 10).map((item: any) => `
              <div class="restore-item">
                <span class="restore-item-name">${item.name || item.title || item.slug || 'Unknown'}</span>
                <span class="restore-item-date">${item.updatedAt ? new Date(item.updatedAt).toLocaleDateString() : ''}</span>
              </div>
            `).join('')}
            ${cat.items.length > 10 ? `<div class="restore-item restore-item-more">+${cat.items.length - 10} more</div>` : ''}
          </div>
        </div>
      `;
    }

    if (html === '') {
      html = '<div class="restore-empty">This backup is empty.</div>';
    }

    body.innerHTML = html;

    // Checkbox handlers
    body.querySelectorAll('.restore-checkbox').forEach(cb => {
      cb.addEventListener('change', (e) => {
        const el = e.target as HTMLInputElement;
        const category = el.getAttribute('data-category')!;
        selectedCategories[category] = el.checked;
        updateConfirmButton();
      });
    });
  }

  function updateConfirmButton() {
    const anySelected = Object.values(selectedCategories).some(v => v);
    confirmBtn.disabled = !anySelected;
  }

  // Confirm restore
  confirmBtn.addEventListener('click', async () => {
    if (!currentBackupId) return;

    confirmBtn.disabled = true;
    confirmBtn.textContent = 'Restoring...';

    const result = await restoreFromBackup(currentBackupId, selectedCategories);

    if (result) {
      confirmBtn.textContent = `Restored: ${result.atomsRestored} atoms, ${result.compositionsRestored} compositions, ${result.snapshotsRestored} snapshots`;

      // Dispatch event for conflict checking
      window.dispatchEvent(new CustomEvent('eoe:restore-complete', {
        detail: result
      }));

      // Close after delay
      setTimeout(() => {
        closeModal();
        // Reload page to reflect restored data
        window.location.reload();
      }, 2000);
    } else {
      confirmBtn.textContent = 'Restore failed';
      setTimeout(() => {
        confirmBtn.textContent = 'Restore Selected';
        confirmBtn.disabled = false;
      }, 2000);
    }
  });
</script>

<style>
  .restore-modal {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    background: rgba(0, 0, 0, 0.6);
    z-index: 200;
    backdrop-filter: blur(4px);
  }

  .restore-modal-content {
    background: #111;
    border-radius: 16px 16px 0 0;
    width: 100%;
    max-width: 480px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
  }

  .restore-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
    border-bottom: 1px solid #222;
  }

  .restore-modal-title {
    font-size: 1.1rem;
    font-weight: 700;
    color: #fff;
    margin: 0;
  }

  .restore-close-btn {
    background: none;
    border: none;
    color: #666;
    font-size: 24px;
    cursor: pointer;
    padding: 4px 8px;
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .restore-modal-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px 20px;
  }

  .restore-category {
    margin-bottom: 16px;
  }

  .restore-category-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0;
    cursor: pointer;
    min-height: 44px;
  }

  .restore-checkbox {
    width: 20px;
    height: 20px;
    accent-color: #6bb5ff;
  }

  .restore-category-icon {
    width: 24px;
    height: 24px;
    border-radius: 6px;
    background: #333;
    color: #6bb5ff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: 700;
  }

  .restore-category-label {
    font-size: 0.95rem;
    font-weight: 600;
    color: #ccc;
    flex: 1;
  }

  .restore-category-count {
    font-size: 0.8rem;
    color: #666;
    background: #222;
    padding: 2px 8px;
    border-radius: 10px;
  }

  .restore-items {
    padding-left: 54px;
  }

  .restore-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 0;
    border-bottom: 1px solid #1a1a1a;
  }

  .restore-item-name {
    font-size: 0.85rem;
    color: #aaa;
  }

  .restore-item-date {
    font-size: 0.75rem;
    color: #555;
  }

  .restore-item-more {
    color: #666;
    font-size: 0.8rem;
    font-style: italic;
    border: none;
    justify-content: center;
  }

  .restore-modal-footer {
    display: flex;
    gap: 12px;
    padding: 16px 20px;
    border-top: 1px solid #222;
    padding-bottom: calc(16px + env(safe-area-inset-bottom, 0));
  }

  .restore-footer-btn {
    flex: 1;
    padding: 14px;
    border: none;
    border-radius: 10px;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    min-height: 48px;
    -webkit-tap-highlight-color: transparent;
  }

  .restore-cancel {
    background: #333;
    color: #ccc;
  }

  .restore-confirm {
    background: #6bb5ff;
    color: #0a0a0a;
  }

  .restore-confirm:disabled {
    background: #333;
    color: #555;
    cursor: not-allowed;
  }

  .restore-loading, .restore-empty, .restore-error {
    padding: 24px;
    text-align: center;
    color: #555;
  }

  .restore-error {
    color: #ff6b6b;
  }
</style>
```

**Create portfolio/src/components/ConflictResolver.astro:**

```astro
---
/**
 * ConflictResolver: Per-item conflict resolution when restoring.
 *
 * When local data differs from backup data, this component shows
 * a notification for each conflict and lets the user choose:
 * - Keep local version
 * - Use backup version
 *
 * Conflicts are detected by comparing updatedAt timestamps.
 * If both have changed since last sync, it's a conflict.
 */
---

<div id="conflict-resolver" class="conflict-resolver" style="display: none;">
  <div class="conflict-header">
    <span class="conflict-icon">!</span>
    <span class="conflict-title">Conflict Detected</span>
  </div>
  <div id="conflict-body" class="conflict-body">
    <!-- Filled dynamically -->
  </div>
</div>

<script>
  const resolver = document.getElementById('conflict-resolver')!;
  const conflictBody = document.getElementById('conflict-body')!;

  interface ConflictItem {
    type: 'atom' | 'composition' | 'snapshot';
    name: string;
    localUpdated: string;
    backupUpdated: string;
    localData: unknown;
    backupData: unknown;
  }

  let conflicts: ConflictItem[] = [];
  let resolvedCount = 0;

  // Show conflicts
  window.addEventListener('eoe:show-conflicts', ((e: CustomEvent) => {
    conflicts = e.detail.conflicts || [];
    resolvedCount = 0;

    if (conflicts.length === 0) return;

    renderConflicts();
    resolver.style.display = 'block';
  }) as EventListener);

  function renderConflicts() {
    conflictBody.innerHTML = '';

    for (let i = 0; i < conflicts.length; i++) {
      const conflict = conflicts[i];
      const localDate = new Date(conflict.localUpdated).toLocaleString();
      const backupDate = new Date(conflict.backupUpdated).toLocaleString();

      const item = document.createElement('div');
      item.className = 'conflict-item';
      item.id = `conflict-${i}`;
      item.innerHTML = `
        <div class="conflict-item-name">
          <span class="conflict-type-badge">${conflict.type.toUpperCase()}</span>
          ${conflict.name}
        </div>
        <div class="conflict-item-details">
          <div class="conflict-version">
            <span class="conflict-label">Local:</span>
            <span class="conflict-date">${localDate}</span>
          </div>
          <div class="conflict-version">
            <span class="conflict-label">Backup:</span>
            <span class="conflict-date">${backupDate}</span>
          </div>
        </div>
        <div class="conflict-actions">
          <button class="conflict-btn conflict-btn-local" data-index="${i}" data-choice="local">Keep Local</button>
          <button class="conflict-btn conflict-btn-backup" data-index="${i}" data-choice="backup">Use Backup</button>
        </div>
      `;
      conflictBody.appendChild(item);
    }

    // Button handlers
    conflictBody.querySelectorAll('.conflict-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const el = e.target as HTMLElement;
        const index = parseInt(el.getAttribute('data-index')!);
        const choice = el.getAttribute('data-choice')!;

        resolveConflict(index, choice as 'local' | 'backup');
      });
    });
  }

  async function resolveConflict(index: number, choice: 'local' | 'backup') {
    const conflict = conflicts[index];
    const itemEl = document.getElementById(`conflict-${index}`);

    if (choice === 'backup') {
      // Write backup data to IndexedDB
      window.dispatchEvent(new CustomEvent('eoe:apply-conflict-resolution', {
        detail: {
          type: conflict.type,
          data: conflict.backupData,
          choice: 'backup',
        }
      }));
    }
    // If 'local', do nothing (local data already in place)

    // Mark as resolved in UI
    if (itemEl) {
      itemEl.classList.add('conflict-resolved');
      itemEl.innerHTML = `
        <div class="conflict-resolved-text">
          <span class="conflict-type-badge">${conflict.type.toUpperCase()}</span>
          ${conflict.name}: kept ${choice} version
        </div>
      `;
    }

    resolvedCount++;

    // All resolved?
    if (resolvedCount >= conflicts.length) {
      setTimeout(() => {
        resolver.style.display = 'none';
        window.dispatchEvent(new CustomEvent('eoe:conflicts-resolved'));
      }, 1500);
    }
  }
</script>

<style>
  .conflict-resolver {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: #1a1a1a;
    border-top: 2px solid #ffb56b;
    z-index: 180;
    max-height: 60vh;
    overflow-y: auto;
    padding-bottom: env(safe-area-inset-bottom, 0);
  }

  .conflict-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 14px 20px;
    border-bottom: 1px solid #333;
  }

  .conflict-icon {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: #ffb56b;
    color: #0a0a0a;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 14px;
  }

  .conflict-title {
    font-size: 1rem;
    font-weight: 700;
    color: #ffb56b;
  }

  .conflict-body {
    padding: 12px 20px;
  }

  .conflict-item {
    padding: 12px 0;
    border-bottom: 1px solid #222;
  }

  .conflict-item-name {
    font-size: 0.95rem;
    font-weight: 600;
    color: #ccc;
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .conflict-type-badge {
    font-size: 0.65rem;
    font-weight: 700;
    color: #ffb56b;
    background: rgba(255, 181, 107, 0.15);
    padding: 2px 6px;
    border-radius: 3px;
    letter-spacing: 0.5px;
  }

  .conflict-item-details {
    display: flex;
    gap: 20px;
    margin-bottom: 10px;
  }

  .conflict-version {
    font-size: 0.8rem;
  }

  .conflict-label {
    color: #666;
    margin-right: 4px;
  }

  .conflict-date {
    color: #aaa;
  }

  .conflict-actions {
    display: flex;
    gap: 8px;
  }

  .conflict-btn {
    flex: 1;
    padding: 10px;
    border: none;
    border-radius: 6px;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    min-height: 40px;
    -webkit-tap-highlight-color: transparent;
  }

  .conflict-btn-local {
    background: #333;
    color: #ccc;
  }

  .conflict-btn-backup {
    background: #6bb5ff;
    color: #0a0a0a;
  }

  .conflict-resolved {
    opacity: 0.5;
  }

  .conflict-resolved-text {
    font-size: 0.85rem;
    color: #6bff6b;
    display: flex;
    align-items: center;
    gap: 8px;
  }
</style>
```
  </action>
  <verify>
1. RestoreModal shows backup contents with category checkboxes
2. Selective restore: user checks categories then confirms
3. Restore writes to IndexedDB and reloads page
4. ConflictResolver shows per-item conflicts with local/backup timestamps
5. User can choose "Keep Local" or "Use Backup" per item
6. Resolved items show confirmation with green text
7. All buttons have >= 40px min height (touch accessible)
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
RestoreModal and ConflictResolver created. RestoreModal allows category-based selective restore with visual preview of backup contents. ConflictResolver shows per-item version choice (keep local vs. use backup) with timestamps and resolution feedback.
  </done>
</task>

<task type="auto">
  <name>Task 5: Integrate restore and conflict UI into backup page</name>
  <files>
    portfolio/src/pages/mobile/backup.astro
  </files>
  <action>
Add RestoreModal and ConflictResolver to the backup page and wire up the conflict detection logic.

**Update portfolio/src/pages/mobile/backup.astro:**

Import and include the new components:

```astro
---
import MobileLayout from '../../layouts/MobileLayout.astro';
import RestoreModal from '../../components/RestoreModal.astro';
import ConflictResolver from '../../components/ConflictResolver.astro';
---
```

Add the components at the end of the page body (before closing MobileLayout):

```html
<!-- Restore modal (shared across backup items) -->
<RestoreModal />

<!-- Conflict resolver (shown during restore if conflicts found) -->
<ConflictResolver />
```

Add conflict detection logic in the script section. When a restore completes, check for items that exist both locally and in the backup with different updatedAt timestamps:

```typescript
// Handle conflict resolution
window.addEventListener('eoe:apply-conflict-resolution', (async (e: CustomEvent) => {
  const { type, data } = e.detail;
  const { getDB } = await import('../../scripts/db');
  const db = await getDB();

  try {
    switch (type) {
      case 'atom':
        await db.put('atoms', data);
        break;
      case 'composition':
        await db.put('compositions', data);
        break;
      case 'snapshot':
        await db.put('snapshots', data);
        break;
    }
  } catch (err) {
    console.error('[conflict] Failed to apply resolution:', err);
  }
}) as EventListener);

// After all conflicts resolved, refresh
window.addEventListener('eoe:conflicts-resolved', () => {
  window.location.reload();
});
```

The conflict detection itself is best done client-side during restore. Update the backup-client.ts `restoreFromBackup` function to compare timestamps before writing. This is handled by emitting the `eoe:show-conflicts` event when differences are detected.

However, for v1.1 simplicity, the current implementation uses "last-write-wins" on restore (backup overwrites local). Conflicts are surfaced only when the user explicitly checks -- the ConflictResolver UI is ready for Phase 6 enhancements but the basic flow is: user chooses to restore, restore writes data, page reloads.

The conflict resolver infrastructure is in place and can be activated when more sophisticated sync detection is added.
  </action>
  <verify>
1. RestoreModal and ConflictResolver rendered on /mobile/backup page
2. eoe:apply-conflict-resolution writes chosen data to IndexedDB
3. Page reloads after all conflicts resolved
4. No errors when no conflicts exist (graceful handling)
5. `cd portfolio && npm run build` succeeds
6. No regressions in backup list or manual backup functionality
  </verify>
  <done>
RestoreModal and ConflictResolver integrated into backup page. Conflict resolution writes to IndexedDB and triggers page reload. Infrastructure ready for enhanced conflict detection in future phases.
  </done>
</task>

</tasks>

<verification>
1. `cd portfolio && npm run build` completes without errors
2. BackupStatusBadge visible in app header on all mobile pages
3. Badge shows 4 states: synced (green), pending (orange+count), active (blue spinner), error (red)
4. Tapping badge navigates to /mobile/backup
5. /mobile/backup page shows "Back Up Now" button and backup list
6. Manual backup creates backup and refreshes list
7. Each backup in list shows timestamp, size, and item counts
8. Restore button opens RestoreModal with category checkboxes
9. Selective restore: user picks atoms/compositions/snapshots to restore
10. Restore writes to IndexedDB and reloads page
11. ConflictResolver UI exists for per-item version decisions
12. All touch targets >= 40px (mobile accessible)
13. Dark theme consistent with existing UI
</verification>

<success_criteria>
- SYNC-02: User can see backup status (badge always visible in header)
- SYNC-03: User can restore from backup (selective restore via modal)
- Badge shows pending count, active backup state, success/error states
- Backup management page provides full control over backups
- Conflict resolution UI empowers user to choose per item
- Foundation is complete for all Phase 6 backup requirements
</success_criteria>

<output>
After completion, create `.planning/phases/06-composition-preview-save-cloud-backup/06-04-SUMMARY.md`
</output>
