---
phase: 06-composition-preview-save-cloud-backup
plan: 01
type: execute
wave: 1
depends_on: []
duration: 4h
autonomous: true
files_modified:
  - portfolio/src/scripts/preview-engine.ts
  - portfolio/src/scripts/atom-runtime.ts
  - portfolio/src/components/PreviewControls.astro
  - portfolio/src/components/CompositionCanvas.astro
  - portfolio/src/pages/mobile/compose.astro
  - portfolio/src/styles/canvas.css
  - portfolio/src/scripts/composition-types.ts
  - portfolio/src/scripts/atom-node.tsx

must_haves:
  truths:
    - "Preview engine can load atom code from IndexedDB and execute it in sandboxed iframes"
    - "User can choose simultaneous or sequential playback mode per composition"
    - "Parameter routes are applied in real-time during preview (changing a source value instantly updates target)"
    - "Active routes are visually highlighted during playback (animated pulse on edges)"
    - "Audio glitches show a warning toast with Continue/Restart buttons (user has agency)"
    - "Play/Pause/Stop controls are accessible from the compose page toolbar"
    - "Preview cleans up all resources (audio, iframes, animations) when stopped"
    - "Composition type includes playbackMode field (simultaneous | sequential)"
  artifacts:
    - path: "portfolio/src/scripts/preview-engine.ts"
      provides: "Core preview orchestrator: load atoms, apply routes, manage playback lifecycle"
      contains: "PreviewEngine"
    - path: "portfolio/src/scripts/atom-runtime.ts"
      provides: "Sandboxed atom execution: iframe creation, message-based parameter control"
      contains: "AtomRuntime"
    - path: "portfolio/src/components/PreviewControls.astro"
      provides: "Play/Pause/Stop buttons, playback mode toggle, glitch warning UI"
      contains: "preview-controls"
  key_links:
    - from: "portfolio/src/scripts/preview-engine.ts"
      to: "portfolio/src/scripts/atom-runtime.ts"
      via: "import { AtomRuntime }"
      pattern: "AtomRuntime"
    - from: "portfolio/src/scripts/preview-engine.ts"
      to: "portfolio/src/scripts/composition-types.ts"
      via: "import { Composition }"
      pattern: "Composition"
    - from: "portfolio/src/pages/mobile/compose.astro"
      to: "portfolio/src/scripts/preview-engine.ts"
      via: "import { PreviewEngine }"
      pattern: "PreviewEngine"
---

<objective>
Build the composition preview engine that plays atoms in real-time with parameter routing applied. After this plan, users can tap Play on a composition and hear/see all atoms running simultaneously (or sequentially), with routed parameter values flowing between atoms in real-time. Active routes are visually highlighted on the canvas during playback.

Purpose: Preview is the moment where composition becomes audible and visible -- it transforms the abstract graph into a live experience. Without preview, compositions are just static connection diagrams. This is the core value proposition of Phase 6: the composition comes alive.

Output: PreviewEngine class, AtomRuntime sandboxed execution, PreviewControls UI, route visualization during playback, glitch handling with user agency.
</objective>

<execution_context>
@/home/pavel/.claude/get-shit-done/workflows/execute-plan.md
@/home/pavel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-composition-preview-save-cloud-backup/06-CONTEXT.md
@portfolio/src/scripts/composition-types.ts
@portfolio/src/scripts/composition-store.ts
@portfolio/src/scripts/routing-engine.ts
@portfolio/src/scripts/atom-node.tsx
@portfolio/src/components/CompositionCanvas.astro
@portfolio/src/pages/mobile/compose.astro
@atoms/2026-01-30-av1/audio.js
@atoms/2026-01-30-av1/sketch.js
@lib/audio/composition-manager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend composition types with preview-related fields</name>
  <files>
    portfolio/src/scripts/composition-types.ts
  </files>
  <action>
Add preview-related fields to the Composition interface and create preview state types.

**Modify portfolio/src/scripts/composition-types.ts:**

Add `playbackMode` to the Composition interface:

```typescript
export interface Composition {
  id: string;
  name: string;
  createdAt: string;
  updatedAt: string;
  atoms: CompositionAtom[];
  routes: ParameterRoute[];
  viewport: {
    x: number;
    y: number;
    zoom: number;
  };
  synced: boolean;
  playbackMode: 'simultaneous' | 'sequential';  // Phase 6: user chooses per composition
}
```

Update the `createEmptyComposition` factory function to include the new field:

```typescript
export function createEmptyComposition(name: string): Composition {
  const now = new Date().toISOString();
  return {
    id: generateId(),
    name,
    createdAt: now,
    updatedAt: now,
    atoms: [],
    routes: [],
    viewport: { x: 0, y: 0, zoom: 1 },
    synced: false,
    playbackMode: 'simultaneous',  // Default: all atoms play together
  };
}
```

Add preview state types at the end of the file:

```typescript
/**
 * Preview playback state for UI binding.
 */
export type PreviewState = 'stopped' | 'playing' | 'paused';

/**
 * Message types for iframe <-> parent communication during preview.
 */
export interface AtomMessage {
  type: 'param-update' | 'ready' | 'error' | 'audio-glitch';
  atomNodeId: string;
  payload?: Record<string, unknown>;
}
```

Important: The `playbackMode` default of 'simultaneous' means existing compositions (created in Phase 5 without this field) need backward compatibility. The preview engine will treat missing `playbackMode` as 'simultaneous'.
  </action>
  <verify>
1. Composition interface includes `playbackMode: 'simultaneous' | 'sequential'`
2. createEmptyComposition returns `playbackMode: 'simultaneous'`
3. PreviewState and AtomMessage types are exported
4. `cd portfolio && npm run build` succeeds (no TypeScript errors from existing code using Composition without playbackMode -- the field is optional in existing IndexedDB data, preview engine handles missing field)
  </verify>
  <done>
Composition type extended with playbackMode (simultaneous | sequential), PreviewState type, and AtomMessage interface for iframe communication. Backward-compatible with existing Phase 5 compositions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AtomRuntime for sandboxed atom execution</name>
  <files>
    portfolio/src/scripts/atom-runtime.ts
  </files>
  <action>
Create the AtomRuntime class that manages sandboxed execution of individual atoms in iframes. Each atom runs in its own iframe to prevent interference between atoms and enable parameter injection via postMessage.

**Create portfolio/src/scripts/atom-runtime.ts:**

```typescript
/**
 * AtomRuntime: Sandboxed execution of an atom in an iframe.
 *
 * Each atom runs in a sandboxed iframe with:
 * - Its own p5.js/Tone.js instance (loaded from atom's index.html)
 * - postMessage-based parameter control from parent
 * - Error isolation (one atom crashing doesn't kill others)
 *
 * Communication protocol:
 * Parent -> Iframe: { type: 'param-update', params: Record<string, value> }
 * Parent -> Iframe: { type: 'play' | 'pause' | 'stop' }
 * Iframe -> Parent: { type: 'ready', atomNodeId: string }
 * Iframe -> Parent: { type: 'error', atomNodeId: string, message: string }
 * Iframe -> Parent: { type: 'audio-glitch', atomNodeId: string }
 */

export interface AtomRuntimeConfig {
  nodeId: string;           // CompositionAtom.nodeId
  atomSlug: string;         // Reference to atom folder
  atomCode: string;         // sketch.js content
  atomHtml: string;         // index.html content (or template)
  configJson: string;       // config.json for initial parameters
  paramOverrides?: Record<string, number | string | boolean>;
}

export class AtomRuntime {
  private iframe: HTMLIFrameElement | null = null;
  private nodeId: string;
  private atomSlug: string;
  private ready = false;
  private container: HTMLElement;
  private onError: (nodeId: string, message: string) => void;
  private onGlitch: (nodeId: string) => void;
  private onReady: (nodeId: string) => void;
  private messageHandler: ((e: MessageEvent) => void) | null = null;

  constructor(
    config: AtomRuntimeConfig,
    container: HTMLElement,
    callbacks: {
      onReady: (nodeId: string) => void;
      onError: (nodeId: string, message: string) => void;
      onGlitch: (nodeId: string) => void;
    }
  ) {
    this.nodeId = config.nodeId;
    this.atomSlug = config.atomSlug;
    this.container = container;
    this.onReady = callbacks.onReady;
    this.onError = callbacks.onError;
    this.onGlitch = callbacks.onGlitch;
  }

  /**
   * Initialize the iframe and load the atom.
   * The atom's index.html is loaded in a sandboxed iframe.
   * We inject a message listener into the atom's code so it can receive
   * parameter updates from the parent.
   */
  async init(config: AtomRuntimeConfig): Promise<void> {
    // Create iframe element
    this.iframe = document.createElement('iframe');
    this.iframe.style.cssText = `
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 4px;
      background: #0a0a0a;
    `;
    this.iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
    this.iframe.setAttribute('data-node-id', this.nodeId);

    // Listen for messages from iframe
    this.messageHandler = (e: MessageEvent) => {
      if (!this.iframe || e.source !== this.iframe.contentWindow) return;
      const msg = e.data;
      if (!msg || !msg.type) return;

      switch (msg.type) {
        case 'eoe-atom-ready':
          this.ready = true;
          this.onReady(this.nodeId);
          break;
        case 'eoe-atom-error':
          this.onError(this.nodeId, msg.message || 'Unknown error');
          break;
        case 'eoe-audio-glitch':
          this.onGlitch(this.nodeId);
          break;
      }
    };
    window.addEventListener('message', this.messageHandler);

    // Build the iframe content
    // We wrap the atom's code with a message listener for parameter injection
    const iframeContent = this.buildIframeContent(config);

    // Append to container and load content
    this.container.appendChild(this.iframe);

    // Write content directly to iframe
    const doc = this.iframe.contentDocument || this.iframe.contentWindow?.document;
    if (doc) {
      doc.open();
      doc.write(iframeContent);
      doc.close();
    }
  }

  /**
   * Build HTML content for the iframe.
   * Injects parameter listening and error reporting into the atom's page.
   */
  private buildIframeContent(config: AtomRuntimeConfig): string {
    // Parse config to get initial controller values
    let controllers: Record<string, unknown> = {};
    try {
      const parsed = JSON.parse(config.configJson);
      controllers = parsed.controllers || {};
    } catch { /* use empty */ }

    // Apply param overrides
    if (config.paramOverrides) {
      for (const [key, val] of Object.entries(config.paramOverrides)) {
        controllers[key] = val;
      }
    }

    // Build the page: load atom from its URL path
    // Atoms are served at /atoms/{slug}/index.html
    return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { margin: 0; overflow: hidden; background: #0a0a0a; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script>
    // EOE Preview Runtime Bridge
    // This script runs BEFORE the atom's own code
    window.__eoeControllers = ${JSON.stringify(controllers)};
    window.__eoeNodeId = '${config.nodeId}';

    // Listen for parameter updates from parent
    window.addEventListener('message', function(e) {
      if (!e.data || !e.data.type) return;

      if (e.data.type === 'eoe-param-update') {
        // Update controller values that the atom reads
        var params = e.data.params || {};
        for (var key in params) {
          window.__eoeControllers[key] = params[key];
        }
        // Dispatch custom event that atom code can listen to
        window.dispatchEvent(new CustomEvent('eoe:params-changed', {
          detail: params
        }));
      }

      if (e.data.type === 'eoe-play') {
        window.dispatchEvent(new CustomEvent('eoe:play'));
      }

      if (e.data.type === 'eoe-pause') {
        window.dispatchEvent(new CustomEvent('eoe:pause'));
      }

      if (e.data.type === 'eoe-stop') {
        window.dispatchEvent(new CustomEvent('eoe:stop'));
      }
    });

    // Report ready to parent
    window.parent.postMessage({ type: 'eoe-atom-ready', nodeId: window.__eoeNodeId }, '*');

    // Report errors to parent
    window.addEventListener('error', function(e) {
      window.parent.postMessage({
        type: 'eoe-atom-error',
        nodeId: window.__eoeNodeId,
        message: e.message || 'Runtime error'
      }, '*');
    });

    // Audio glitch detection: monitor for AudioContext state changes
    var _origAudioContext = window.AudioContext || window.webkitAudioContext;
    if (_origAudioContext) {
      var _origProto = _origAudioContext.prototype;
      var _origResume = _origProto.resume;
      _origProto.resume = function() {
        return _origResume.call(this).catch(function(err) {
          window.parent.postMessage({
            type: 'eoe-audio-glitch',
            nodeId: window.__eoeNodeId
          }, '*');
          throw err;
        });
      };
    }
  </script>

  <!-- Load atom from its served path -->
  <script type="module">
    // Fetch and execute the atom's sketch.js
    // The atom reads config from window.__eoeControllers instead of config.json
    try {
      const atomUrl = '/atoms/${config.atomSlug}/';
      // Load the atom's sketch dynamically
      const module = await import(atomUrl + 'sketch.js');
    } catch (err) {
      window.parent.postMessage({
        type: 'eoe-atom-error',
        nodeId: '${config.nodeId}',
        message: err.message || 'Failed to load atom'
      }, '*');
    }
  </script>
</body>
</html>`;
  }

  /**
   * Send parameter updates to the iframe.
   */
  updateParams(params: Record<string, number | string | boolean>): void {
    if (!this.iframe?.contentWindow || !this.ready) return;
    this.iframe.contentWindow.postMessage({
      type: 'eoe-param-update',
      params,
    }, '*');
  }

  /**
   * Send play command to iframe.
   */
  play(): void {
    if (!this.iframe?.contentWindow) return;
    this.iframe.contentWindow.postMessage({ type: 'eoe-play' }, '*');
  }

  /**
   * Send pause command to iframe.
   */
  pause(): void {
    if (!this.iframe?.contentWindow) return;
    this.iframe.contentWindow.postMessage({ type: 'eoe-pause' }, '*');
  }

  /**
   * Send stop command to iframe.
   */
  stop(): void {
    if (!this.iframe?.contentWindow) return;
    this.iframe.contentWindow.postMessage({ type: 'eoe-stop' }, '*');
  }

  /**
   * Clean up: remove iframe and event listeners.
   */
  dispose(): void {
    if (this.messageHandler) {
      window.removeEventListener('message', this.messageHandler);
      this.messageHandler = null;
    }
    if (this.iframe) {
      // Send stop before removing
      this.stop();
      // Give iframe time to clean up, then remove
      setTimeout(() => {
        this.iframe?.remove();
        this.iframe = null;
      }, 100);
    }
    this.ready = false;
  }

  isReady(): boolean {
    return this.ready;
  }

  getNodeId(): string {
    return this.nodeId;
  }
}
```

Key design decisions:
- Sandboxed iframes prevent atoms from interfering with each other or the parent page
- postMessage protocol for parameter injection (works cross-origin)
- Audio glitch detection via AudioContext.resume monkey-patch
- Each atom loads its sketch.js from the served /atoms/ path
- Parameters injected via `window.__eoeControllers` that atom code reads instead of config.json
- Error isolation: one atom crashing reports error but others continue
  </action>
  <verify>
1. portfolio/src/scripts/atom-runtime.ts exists
2. Exports AtomRuntime class and AtomRuntimeConfig interface
3. init() creates iframe with sandbox attribute
4. updateParams() sends postMessage to iframe
5. play/pause/stop methods send commands to iframe
6. dispose() removes iframe and cleans up event listeners
7. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
AtomRuntime class created for sandboxed atom execution via iframes with postMessage-based parameter control, error isolation, and audio glitch detection. Each atom runs independently and can receive real-time parameter updates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create PreviewEngine orchestrator</name>
  <files>
    portfolio/src/scripts/preview-engine.ts
  </files>
  <action>
Create the PreviewEngine class that orchestrates multi-atom preview with parameter routing.

**Create portfolio/src/scripts/preview-engine.ts:**

```typescript
/**
 * PreviewEngine: Orchestrates composition preview playback.
 *
 * Manages:
 * - Multiple AtomRuntime instances (one per atom in composition)
 * - Parameter routing: reads source param values and pushes to targets
 * - Playback modes: simultaneous (all at once) or sequential (one at a time)
 * - Route visualization: dispatches events for canvas edge highlighting
 * - Glitch handling: detects audio issues, notifies user
 *
 * Lifecycle:
 * 1. init(composition) - Create AtomRuntime for each atom
 * 2. play() - Start all atoms (simultaneous) or first atom (sequential)
 * 3. routing loop - Continuously apply parameter routes
 * 4. stop() - Clean up all runtimes
 */

import { AtomRuntime, type AtomRuntimeConfig } from './atom-runtime';
import type { Composition, PreviewState, ParameterRoute } from './composition-types';
import type { AtomMetadata } from './db';

export interface PreviewEngineCallbacks {
  onStateChange: (state: PreviewState) => void;
  onRouteActive: (routeId: string, value: unknown) => void;
  onAtomReady: (nodeId: string) => void;
  onAtomError: (nodeId: string, message: string) => void;
  onGlitch: (nodeId: string) => void;
}

export class PreviewEngine {
  private runtimes: Map<string, AtomRuntime> = new Map();
  private composition: Composition | null = null;
  private atomsMap: Map<string, AtomMetadata> = new Map();
  private state: PreviewState = 'stopped';
  private routingInterval: ReturnType<typeof setInterval> | null = null;
  private callbacks: PreviewEngineCallbacks;
  private previewContainer: HTMLElement | null = null;
  private sequentialIndex = 0;
  private readyCount = 0;
  private totalAtoms = 0;

  constructor(callbacks: PreviewEngineCallbacks) {
    this.callbacks = callbacks;
  }

  /**
   * Initialize preview for a composition.
   * Creates a hidden container for atom iframes and initializes runtimes.
   */
  async init(
    composition: Composition,
    atomsMap: Map<string, AtomMetadata>,
  ): Promise<void> {
    // Clean up any previous preview
    await this.cleanup();

    this.composition = composition;
    this.atomsMap = atomsMap;
    this.readyCount = 0;
    this.totalAtoms = composition.atoms.length;
    this.sequentialIndex = 0;

    // Create preview container (hidden iframes area)
    this.previewContainer = document.createElement('div');
    this.previewContainer.id = 'preview-container';
    this.previewContainer.style.cssText = `
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 0;
      overflow: hidden;
      pointer-events: none;
      z-index: -1;
    `;
    document.body.appendChild(this.previewContainer);

    // Create AtomRuntime for each atom
    for (const atom of composition.atoms) {
      const metadata = atomsMap.get(atom.atomSlug);
      if (!metadata) {
        this.callbacks.onAtomError(atom.nodeId, `Atom "${atom.atomSlug}" not found`);
        continue;
      }

      const config: AtomRuntimeConfig = {
        nodeId: atom.nodeId,
        atomSlug: atom.atomSlug,
        atomCode: metadata.code,
        atomHtml: '', // Using built-in template
        configJson: metadata.configJson,
        paramOverrides: atom.paramOverrides,
      };

      const runtime = new AtomRuntime(config, this.previewContainer, {
        onReady: (nodeId) => {
          this.readyCount++;
          this.callbacks.onAtomReady(nodeId);
        },
        onError: (nodeId, message) => {
          this.callbacks.onAtomError(nodeId, message);
        },
        onGlitch: (nodeId) => {
          this.callbacks.onGlitch(nodeId);
        },
      });

      await runtime.init(config);
      this.runtimes.set(atom.nodeId, runtime);
    }
  }

  /**
   * Start playback.
   * - Simultaneous: all atoms play at once
   * - Sequential: atoms play one at a time (first atom starts)
   */
  play(): void {
    if (!this.composition || this.runtimes.size === 0) return;

    const mode = this.composition.playbackMode || 'simultaneous';

    if (mode === 'simultaneous') {
      // Start all atoms
      for (const [, runtime] of this.runtimes) {
        runtime.play();
      }
    } else {
      // Sequential: start first atom only
      this.sequentialIndex = 0;
      this.playCurrentSequentialAtom();
    }

    // Start parameter routing loop
    this.startRoutingLoop();

    this.state = 'playing';
    this.callbacks.onStateChange('playing');
  }

  /**
   * Pause playback. Pauses all running atoms.
   */
  pause(): void {
    for (const [, runtime] of this.runtimes) {
      runtime.pause();
    }

    this.stopRoutingLoop();
    this.state = 'paused';
    this.callbacks.onStateChange('paused');
  }

  /**
   * Stop playback and clean up.
   */
  async stop(): Promise<void> {
    for (const [, runtime] of this.runtimes) {
      runtime.stop();
    }

    this.stopRoutingLoop();
    this.state = 'stopped';
    this.callbacks.onStateChange('stopped');
  }

  /**
   * Resume from paused state.
   */
  resume(): void {
    if (this.state !== 'paused') return;

    const mode = this.composition?.playbackMode || 'simultaneous';

    if (mode === 'simultaneous') {
      for (const [, runtime] of this.runtimes) {
        runtime.play();
      }
    } else {
      this.playCurrentSequentialAtom();
    }

    this.startRoutingLoop();
    this.state = 'playing';
    this.callbacks.onStateChange('playing');
  }

  /**
   * Advance to the next atom in sequential mode.
   */
  nextAtom(): void {
    if (!this.composition) return;
    const mode = this.composition.playbackMode || 'simultaneous';
    if (mode !== 'sequential') return;

    // Stop current atom
    const currentAtom = this.composition.atoms[this.sequentialIndex];
    if (currentAtom) {
      this.runtimes.get(currentAtom.nodeId)?.stop();
    }

    // Advance to next
    this.sequentialIndex = (this.sequentialIndex + 1) % this.composition.atoms.length;
    this.playCurrentSequentialAtom();
  }

  /**
   * Apply a parameter change during preview.
   * Changes are applied instantly (no queueing).
   */
  updateParam(nodeId: string, paramName: string, value: number | string | boolean): void {
    const runtime = this.runtimes.get(nodeId);
    if (runtime) {
      runtime.updateParams({ [paramName]: value });
    }
  }

  /**
   * Get current preview state.
   */
  getState(): PreviewState {
    return this.state;
  }

  /**
   * Full cleanup: dispose all runtimes, remove container.
   */
  async cleanup(): Promise<void> {
    this.stopRoutingLoop();

    for (const [, runtime] of this.runtimes) {
      runtime.dispose();
    }
    this.runtimes.clear();

    if (this.previewContainer) {
      // Wait for iframe disposal
      await new Promise(resolve => setTimeout(resolve, 150));
      this.previewContainer.remove();
      this.previewContainer = null;
    }

    this.composition = null;
    this.state = 'stopped';
    this.readyCount = 0;
    this.totalAtoms = 0;
  }

  // ---- Private helpers ----

  /**
   * Start the parameter routing loop.
   * Runs at 30fps: reads source param values and pushes to target atoms.
   * This is where routes come alive during preview.
   */
  private startRoutingLoop(): void {
    if (this.routingInterval) return;
    if (!this.composition) return;

    const routes = this.composition.routes;
    if (routes.length === 0) return;

    this.routingInterval = setInterval(() => {
      this.applyRoutes(routes);
    }, 33); // ~30fps
  }

  /**
   * Stop the routing loop.
   */
  private stopRoutingLoop(): void {
    if (this.routingInterval) {
      clearInterval(this.routingInterval);
      this.routingInterval = null;
    }
  }

  /**
   * Apply all parameter routes.
   * For each route: read source atom's current param value, send to target atom.
   *
   * Since atoms run in iframes, we use the composition's paramOverrides
   * and the routing graph to propagate values. The source value is taken
   * from the composition's atom config (initial + overrides), and any
   * runtime changes flow through the route.
   */
  private applyRoutes(routes: ParameterRoute[]): void {
    if (!this.composition) return;

    for (const route of routes) {
      // Find source atom and its current value for the source param
      const sourceAtom = this.composition.atoms.find(a => a.nodeId === route.sourceNodeId);
      if (!sourceAtom) continue;

      // Get the effective value: override > original config value
      const sourceMetadata = this.atomsMap.get(sourceAtom.atomSlug);
      if (!sourceMetadata) continue;

      let sourceValue: unknown;
      try {
        const config = JSON.parse(sourceMetadata.configJson);
        const controllers = config.controllers || {};
        // Check overrides first, then original
        sourceValue = sourceAtom.paramOverrides?.[route.sourceParam]
          ?? controllers[route.sourceParam];
      } catch {
        continue;
      }

      if (sourceValue === undefined) continue;

      // Send to target atom runtime
      const targetRuntime = this.runtimes.get(route.targetNodeId);
      if (targetRuntime) {
        targetRuntime.updateParams({
          [route.targetParam]: sourceValue as number | string | boolean,
        });
      }

      // Notify UI that this route is active (for edge highlighting)
      this.callbacks.onRouteActive(route.id, sourceValue);
    }
  }

  /**
   * Play the current atom in sequential mode.
   */
  private playCurrentSequentialAtom(): void {
    if (!this.composition) return;
    const atom = this.composition.atoms[this.sequentialIndex];
    if (!atom) return;

    const runtime = this.runtimes.get(atom.nodeId);
    if (runtime) {
      runtime.play();
    }
  }
}
```

Key design decisions:
- 30fps routing loop applies parameter values continuously during preview
- Simultaneous mode starts all atoms at once; sequential starts one at a time
- Route activity notifications enable edge highlighting on the canvas
- Each atom runs in its own iframe via AtomRuntime
- Parameter changes are instant (no queueing, per user decision)
- Cleanup is thorough: all iframes removed, all intervals cleared
  </action>
  <verify>
1. portfolio/src/scripts/preview-engine.ts exists
2. Exports PreviewEngine class and PreviewEngineCallbacks interface
3. init() creates AtomRuntime for each composition atom
4. play() supports both simultaneous and sequential modes
5. startRoutingLoop() runs at ~30fps, applies all routes
6. onRouteActive callback fires for each active route
7. cleanup() disposes all runtimes and removes container
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
PreviewEngine orchestrator created with multi-atom lifecycle management, dual playback modes (simultaneous/sequential), 30fps parameter routing loop, route activity notifications for visual feedback, and thorough cleanup. Integrates with AtomRuntime for sandboxed execution.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create PreviewControls UI component</name>
  <files>
    portfolio/src/components/PreviewControls.astro
    portfolio/src/styles/canvas.css
  </files>
  <action>
Create the preview controls UI with play/pause/stop buttons, playback mode toggle, and glitch warning display.

**Create portfolio/src/components/PreviewControls.astro:**

```astro
---
/**
 * PreviewControls: Play/Pause/Stop buttons and playback mode toggle.
 *
 * Shows:
 * - Play/Pause toggle button (large, centered)
 * - Stop button (stops and resets)
 * - Playback mode toggle (simultaneous / sequential)
 * - Glitch warning with Continue/Restart buttons
 *
 * Communicates via custom events:
 * - eoe:preview-play / eoe:preview-pause / eoe:preview-stop
 * - eoe:preview-mode-changed (detail: { mode: 'simultaneous' | 'sequential' })
 * - eoe:preview-state-changed (incoming, to update button states)
 * - eoe:preview-glitch (incoming, shows warning)
 */
---

<div id="preview-controls" class="preview-controls" style="display: none;">
  <div class="preview-controls-bar">
    <!-- Stop button -->
    <button id="preview-stop-btn" class="preview-btn preview-btn-stop" title="Stop">
      <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
        <rect x="4" y="4" width="12" height="12" rx="2"/>
      </svg>
    </button>

    <!-- Play/Pause toggle -->
    <button id="preview-play-btn" class="preview-btn preview-btn-play" title="Play">
      <svg id="play-icon" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M8 5v14l11-7z"/>
      </svg>
      <svg id="pause-icon" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="display: none;">
        <rect x="6" y="4" width="4" height="16" rx="1"/>
        <rect x="14" y="4" width="4" height="16" rx="1"/>
      </svg>
    </button>

    <!-- Mode toggle -->
    <button id="preview-mode-btn" class="preview-btn preview-btn-mode" title="Playback mode: simultaneous">
      <span id="mode-label" class="mode-label">ALL</span>
    </button>
  </div>

  <!-- Sequential: Next atom button (shown only in sequential mode) -->
  <button id="preview-next-btn" class="preview-btn preview-btn-next" style="display: none;" title="Next atom">
    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
      <path d="M6 4v12l8-6z"/>
      <rect x="14" y="4" width="2" height="12"/>
    </svg>
  </button>
</div>

<!-- Glitch warning overlay -->
<div id="glitch-warning" class="glitch-warning" style="display: none;">
  <div class="glitch-warning-content">
    <div class="glitch-warning-icon">!</div>
    <div class="glitch-warning-text">Audio glitch detected</div>
    <div class="glitch-warning-actions">
      <button id="glitch-continue-btn" class="glitch-btn glitch-btn-continue">Continue</button>
      <button id="glitch-restart-btn" class="glitch-btn glitch-btn-restart">Restart</button>
    </div>
  </div>
</div>

<script>
  let currentState: 'stopped' | 'playing' | 'paused' = 'stopped';
  let currentMode: 'simultaneous' | 'sequential' = 'simultaneous';

  const controls = document.getElementById('preview-controls')!;
  const playBtn = document.getElementById('preview-play-btn')!;
  const stopBtn = document.getElementById('preview-stop-btn')!;
  const modeBtn = document.getElementById('preview-mode-btn')!;
  const nextBtn = document.getElementById('preview-next-btn')!;
  const playIcon = document.getElementById('play-icon')!;
  const pauseIcon = document.getElementById('pause-icon')!;
  const modeLabel = document.getElementById('mode-label')!;
  const glitchWarning = document.getElementById('glitch-warning')!;

  // Play/Pause toggle
  playBtn.addEventListener('click', () => {
    if (currentState === 'stopped' || currentState === 'paused') {
      window.dispatchEvent(new CustomEvent('eoe:preview-play'));
    } else if (currentState === 'playing') {
      window.dispatchEvent(new CustomEvent('eoe:preview-pause'));
    }
  });

  // Stop
  stopBtn.addEventListener('click', () => {
    window.dispatchEvent(new CustomEvent('eoe:preview-stop'));
  });

  // Mode toggle
  modeBtn.addEventListener('click', () => {
    currentMode = currentMode === 'simultaneous' ? 'sequential' : 'simultaneous';
    updateModeUI();
    window.dispatchEvent(new CustomEvent('eoe:preview-mode-changed', {
      detail: { mode: currentMode }
    }));
  });

  // Next atom (sequential only)
  nextBtn.addEventListener('click', () => {
    window.dispatchEvent(new CustomEvent('eoe:preview-next'));
  });

  // Glitch: Continue
  document.getElementById('glitch-continue-btn')!.addEventListener('click', () => {
    glitchWarning.style.display = 'none';
  });

  // Glitch: Restart
  document.getElementById('glitch-restart-btn')!.addEventListener('click', () => {
    glitchWarning.style.display = 'none';
    window.dispatchEvent(new CustomEvent('eoe:preview-stop'));
    // Small delay then restart
    setTimeout(() => {
      window.dispatchEvent(new CustomEvent('eoe:preview-play'));
    }, 200);
  });

  // State change handler (from PreviewEngine via compose.astro)
  window.addEventListener('eoe:preview-state-changed', ((e: CustomEvent) => {
    currentState = e.detail.state;
    updatePlayButtonUI();
  }) as EventListener);

  // Show controls when composition has atoms
  window.addEventListener('eoe:show-preview-controls', ((e: CustomEvent) => {
    controls.style.display = e.detail?.show ? 'flex' : 'none';
  }) as EventListener);

  // Show glitch warning
  window.addEventListener('eoe:preview-glitch', () => {
    glitchWarning.style.display = 'flex';
  });

  // Set initial mode from composition
  window.addEventListener('eoe:preview-mode-init', ((e: CustomEvent) => {
    currentMode = e.detail?.mode || 'simultaneous';
    updateModeUI();
  }) as EventListener);

  function updatePlayButtonUI() {
    if (currentState === 'playing') {
      playIcon.style.display = 'none';
      pauseIcon.style.display = 'block';
      playBtn.title = 'Pause';
      playBtn.classList.add('active');
    } else {
      playIcon.style.display = 'block';
      pauseIcon.style.display = 'none';
      playBtn.title = 'Play';
      playBtn.classList.remove('active');
    }
  }

  function updateModeUI() {
    if (currentMode === 'simultaneous') {
      modeLabel.textContent = 'ALL';
      modeBtn.title = 'Playback mode: simultaneous';
      nextBtn.style.display = 'none';
    } else {
      modeLabel.textContent = 'SEQ';
      modeBtn.title = 'Playback mode: sequential';
      if (currentState === 'playing') {
        nextBtn.style.display = 'flex';
      }
    }
  }
</script>

<style>
  .preview-controls {
    position: fixed;
    bottom: calc(88px + env(safe-area-inset-bottom, 0));
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 8px;
    z-index: 60;
  }

  .preview-controls-bar {
    display: flex;
    align-items: center;
    gap: 6px;
    background: rgba(20, 20, 20, 0.95);
    border: 1px solid #333;
    border-radius: 28px;
    padding: 6px 12px;
    backdrop-filter: blur(8px);
  }

  .preview-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    color: #ccc;
    cursor: pointer;
    border-radius: 50%;
    min-width: 44px;
    min-height: 44px;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.15s, color 0.15s;
  }

  .preview-btn:active {
    background: rgba(255, 255, 255, 0.1);
  }

  .preview-btn-play {
    width: 52px;
    height: 52px;
    background: #6bb5ff;
    color: #0a0a0a;
  }

  .preview-btn-play:active {
    background: #5aa0e8;
  }

  .preview-btn-play.active {
    background: #ffb56b;
  }

  .preview-btn-mode {
    min-width: 44px;
  }

  .mode-label {
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 0.5px;
  }

  .preview-btn-next {
    position: fixed;
    bottom: calc(88px + env(safe-area-inset-bottom, 0));
    right: 24px;
    background: rgba(20, 20, 20, 0.95);
    border: 1px solid #333;
    border-radius: 50%;
    backdrop-filter: blur(8px);
  }

  /* Glitch warning */
  .glitch-warning {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.7);
    z-index: 200;
    backdrop-filter: blur(4px);
  }

  .glitch-warning-content {
    background: #1a1a1a;
    border: 1px solid #ff6b6b;
    border-radius: 12px;
    padding: 24px;
    text-align: center;
    max-width: 300px;
  }

  .glitch-warning-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #ff6b6b;
    color: #fff;
    font-size: 20px;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 12px;
  }

  .glitch-warning-text {
    color: #ff6b6b;
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 16px;
  }

  .glitch-warning-actions {
    display: flex;
    gap: 12px;
    justify-content: center;
  }

  .glitch-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    min-height: 44px;
    -webkit-tap-highlight-color: transparent;
  }

  .glitch-btn-continue {
    background: #333;
    color: #fff;
  }

  .glitch-btn-restart {
    background: #6bb5ff;
    color: #0a0a0a;
  }
</style>
```

**Update portfolio/src/styles/canvas.css:**

Add styles for active route visualization during preview. Append to the existing canvas.css:

```css
/* Active route during preview: pulsing animation */
.react-flow__edge.route-active .react-flow__edge-path {
  stroke: #6bff6b;
  stroke-width: 3;
  animation: route-pulse 1s ease-in-out infinite;
}

@keyframes route-pulse {
  0%, 100% { opacity: 0.7; stroke-width: 2; }
  50% { opacity: 1; stroke-width: 4; }
}

/* Preview playing state: subtle border glow on nodes */
.atom-node-playing {
  box-shadow: 0 0 12px rgba(107, 181, 255, 0.4);
}
```
  </action>
  <verify>
1. portfolio/src/components/PreviewControls.astro exists
2. Play/Pause toggle button works (dispatches eoe:preview-play / eoe:preview-pause)
3. Stop button dispatches eoe:preview-stop
4. Mode toggle switches between ALL/SEQ labels
5. Glitch warning shows Continue and Restart buttons
6. All buttons have min 44px touch targets
7. Route-active CSS animation added to canvas.css
8. `cd portfolio && npm run build` succeeds
  </verify>
  <done>
PreviewControls component created with play/pause/stop buttons, simultaneous/sequential mode toggle, sequential next-atom button, and glitch warning overlay with Continue/Restart options. Canvas CSS extended with active route pulse animation and node playing glow.
  </done>
</task>

<task type="auto">
  <name>Task 5: Integrate preview engine into compose page and canvas</name>
  <files>
    portfolio/src/pages/mobile/compose.astro
    portfolio/src/components/CompositionCanvas.astro
    portfolio/src/scripts/atom-node.tsx
  </files>
  <action>
Wire the PreviewEngine and PreviewControls into the compose page. Add route highlighting to the canvas during preview.

**Update portfolio/src/pages/mobile/compose.astro:**

Add PreviewControls import and PreviewEngine integration. Add after the existing imports:

```astro
---
import PreviewControls from '../../components/PreviewControls.astro';
---
```

Add `<PreviewControls />` component in the page body, after the NodeDetailSheet:

```html
<!-- Preview controls -->
<PreviewControls />
```

In the `<script>` section, add preview engine initialization and event handlers. Add these imports at the top of the script:

```typescript
import { PreviewEngine } from '../../scripts/preview-engine';
```

Add this after the `initComposition` function definition:

```typescript
// ---- Preview Engine ----
let previewEngine: PreviewEngine | null = null;

function initPreviewEngine() {
  previewEngine = new PreviewEngine({
    onStateChange: (state) => {
      window.dispatchEvent(new CustomEvent('eoe:preview-state-changed', {
        detail: { state }
      }));

      // Update edge classes for route visualization
      if (state === 'stopped') {
        document.querySelectorAll('.react-flow__edge.route-active').forEach(el => {
          el.classList.remove('route-active');
        });
      }
    },
    onRouteActive: (routeId, value) => {
      // Highlight the active edge on the canvas
      const edgeEl = document.querySelector(`[data-testid="rf__edge-${routeId}"]`);
      if (edgeEl && !edgeEl.classList.contains('route-active')) {
        edgeEl.classList.add('route-active');
      }
    },
    onAtomReady: (nodeId) => {
      console.log('[preview] Atom ready:', nodeId);
    },
    onAtomError: (nodeId, message) => {
      console.error('[preview] Atom error:', nodeId, message);
      showToast(`Atom error: ${message}`);
    },
    onGlitch: (nodeId) => {
      window.dispatchEvent(new CustomEvent('eoe:preview-glitch'));
    },
  });
}

// Preview play
window.addEventListener('eoe:preview-play', async () => {
  if (!previewEngine) initPreviewEngine();
  if (!previewEngine) return;

  if (previewEngine.getState() === 'paused') {
    previewEngine.resume();
  } else {
    // Initialize and play
    await previewEngine.init(currentComposition, atomsMap);
    previewEngine.play();
  }
});

// Preview pause
window.addEventListener('eoe:preview-pause', () => {
  previewEngine?.pause();
});

// Preview stop
window.addEventListener('eoe:preview-stop', async () => {
  if (previewEngine) {
    await previewEngine.stop();
    await previewEngine.cleanup();
  }
});

// Preview next (sequential mode)
window.addEventListener('eoe:preview-next', () => {
  previewEngine?.nextAtom();
});

// Playback mode changed
window.addEventListener('eoe:preview-mode-changed', ((e: CustomEvent) => {
  const mode = e.detail.mode as 'simultaneous' | 'sequential';
  const updated = {
    ...currentComposition,
    playbackMode: mode,
    updatedAt: new Date().toISOString(),
  };
  commitChange(updated);
}) as EventListener);
```

Update the `refreshCanvas` function to also show/hide preview controls:

After `updateFabState()` at the end of `refreshCanvas()`, add:

```typescript
// Show preview controls when atoms exist
window.dispatchEvent(new CustomEvent('eoe:show-preview-controls', {
  detail: { show: currentComposition.atoms.length > 0 }
}));

// Initialize mode from composition
window.dispatchEvent(new CustomEvent('eoe:preview-mode-init', {
  detail: { mode: currentComposition.playbackMode || 'simultaneous' }
}));
```

In the `initComposition` function, also show preview controls after `updateFabState()`:

```typescript
// Show preview controls if composition has atoms
window.dispatchEvent(new CustomEvent('eoe:show-preview-controls', {
  detail: { show: currentComposition.atoms.length > 0 }
}));
```

Add cleanup on page unload:

```typescript
// Clean up preview on navigation
window.addEventListener('beforeunload', async () => {
  if (previewEngine) {
    await previewEngine.cleanup();
  }
});
```

**Update portfolio/src/scripts/atom-node.tsx:**

Add a small preview-playing indicator to nodes during playback. In the AtomNodeComponent, add an event listener for a CSS class toggle. Since this is React, the simplest approach is to add a CSS class that the parent compose page can toggle. The existing node already has an outer div -- add a className that can be targeted:

In the main (non-missing) return path of AtomNodeComponent, add `className="atom-node"` to the outer div:

```tsx
<div className="atom-node" style={{
  background: '#1a1a1a',
  // ... existing styles
}}>
```

This gives compose.astro a CSS hook to add `.atom-node-playing` dynamically via DOM manipulation when preview is active.
  </action>
  <verify>
1. PreviewControls component is imported and rendered on compose page
2. PreviewEngine is initialized on first play
3. Play/pause/stop events wire through to PreviewEngine methods
4. Mode changes update composition and commit to history
5. Route highlighting applies CSS class to active edges
6. Preview controls show/hide based on atom count
7. Cleanup runs on page unload
8. atom-node CSS class added to AtomNode component
9. `cd portfolio && npm run build` succeeds
10. No regressions in existing compose page functionality
  </verify>
  <done>
Preview engine integrated into compose page. PreviewControls rendered with play/pause/stop. Event handlers wire preview-play/pause/stop/next/mode-changed. Route visualization highlights active edges. Playback mode persisted in composition. Preview cleanup on page unload. AtomNode gets CSS class hook for playing state.
  </done>
</task>

</tasks>

<verification>
1. `cd portfolio && npm run build` completes without errors
2. Composition type includes playbackMode field with 'simultaneous' default
3. AtomRuntime creates sandboxed iframe for atom execution
4. PreviewEngine manages multiple AtomRuntime instances
5. Simultaneous mode starts all atoms at once
6. Sequential mode starts one atom at a time with Next button
7. Parameter routing loop runs at ~30fps during preview
8. Active routes are highlighted with pulsing green animation on canvas edges
9. Play/Pause/Stop controls accessible from compose page
10. Mode toggle switches between ALL and SEQ with visual feedback
11. Audio glitch shows warning with Continue/Restart buttons (user decides)
12. Parameter changes apply instantly during playback
13. Preview cleanup removes all iframes and clears intervals
14. All touch targets are >= 44px (Apple HIG compliant)
15. No regressions in Phase 5 features (canvas, routing, autosave, undo/redo)
</verification>

<success_criteria>
- COMP-04: User can preview composition with real-time parameter routing
- Simultaneous and sequential playback modes available and user-configurable
- Active routes visualized with animation during playback
- Audio glitches show warning with user choice (Continue/Restart)
- Parameter changes apply instantly during preview
- Preview engine cleans up all resources when stopped
- Foundation for save/load (Plan 06-02) is backward-compatible with new Composition fields
</success_criteria>

<output>
After completion, create `.planning/phases/06-composition-preview-save-cloud-backup/06-01-SUMMARY.md`
</output>
